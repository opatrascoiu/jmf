Opening files...
Parsing specification from standard input...
Checking specification...
Warning: Terminal "BAD" was declared but never used
Building parse tables...
  Computing non-terminal nullability...
  Computing first sets...
  Building state machine...
  Filling in tables...
  Checking for non-reduced productions...
*** Production "enumLiteralExp ::= pathName " never reduced
Writing parser...
===== Terminals =====
[0]EOF [1]error [2]BAD [3]PACKAGE [4]ENDPACKAGE 
[5]CONTEXT [6]INIT [7]DERIVE [8]INV [9]DEF 
[10]PRE [11]POST [12]BODY [13]SET [14]BAG 
[15]SEQUENCE [16]COLLECTION [17]TUPLE [18]TUPLE_TYPE [19]ITERATE 
[20]IMPLIES [21]AND [22]OR [23]XOR [24]EQ 
[25]NE [26]LT [27]GT [28]LE [29]GE 
[30]PLUS [31]MINUS [32]UMINUS [33]TIMES [34]DIVIDE 
[35]NOT [36]LET [37]IN [38]IF [39]THEN 
[40]ELSE [41]ENDIF [42]COMMA [43]DOT [44]COLON 
[45]SEMICOLON [46]BAR [47]UP [48]AT [49]QUESTION 
[50]DOT_DOT [51]COLON_COLON [52]UP_UP [53]LEFT_PAR [54]LEFT_BRK 
[55]LEFT_BRA [56]RIGHT_PAR [57]RIGHT_BRK [58]RIGHT_BRA [59]MINUS_GT 
[60]INTEGER [61]REAL [62]STRING [63]TRUE [64]FALSE 
[65]SIMPLE_NAME 

===== Non terminals =====
[0]$START [1]packageDeclaration [2]contextDeclList [3]contextDeclaration [4]classifierContextDecl 
[5]invOrDef [6]defExpression [7]propertyContextDecl [8]initOrDerValue [9]operationContextDecl 
[10]operation [11]prePostOrBodyDecl [12]variableDeclarationList [13]variableDeclaration [14]type 
[15]collectionType [16]collectionKind [17]tupleType [18]oclExpression [19]arguments 
[20]argumentList [21]oclMessageArgumentList [22]oclMessageArgument [23]isMarkedPre [24]literalExp 
[25]enumLiteralExp [26]collectionLiteralExp [27]collectionLiteralParts [28]collectionLiteralPart [29]collectionRange 
[30]tupleLiteralExp [31]primitiveLiteralExp [32]pathName [33]simpleName 

===== Productions =====
[0] $START ::= packageDeclaration EOF 
[1] packageDeclaration ::= PACKAGE pathName contextDeclList ENDPACKAGE 
[2] packageDeclaration ::= contextDeclList 
[3] contextDeclList ::= 
[4] contextDeclList ::= contextDeclList contextDeclaration 
[5] contextDeclaration ::= propertyContextDecl 
[6] contextDeclaration ::= classifierContextDecl 
[7] contextDeclaration ::= operationContextDecl 
[8] propertyContextDecl ::= CONTEXT pathName simpleName COLON type initOrDerValue 
[9] initOrDerValue ::= INIT COLON oclExpression 
[10] initOrDerValue ::= DERIVE COLON oclExpression 
[11] initOrDerValue ::= initOrDerValue INIT COLON oclExpression 
[12] initOrDerValue ::= initOrDerValue DERIVE COLON oclExpression 
[13] classifierContextDecl ::= CONTEXT pathName invOrDef 
[14] invOrDef ::= INV simpleName COLON oclExpression 
[15] invOrDef ::= INV COLON oclExpression 
[16] invOrDef ::= DEF simpleName COLON defExpression 
[17] invOrDef ::= DEF COLON defExpression 
[18] invOrDef ::= invOrDef INV simpleName COLON oclExpression 
[19] invOrDef ::= invOrDef INV COLON oclExpression 
[20] invOrDef ::= invOrDef DEF simpleName COLON defExpression 
[21] invOrDef ::= invOrDef COLON defExpression 
[22] defExpression ::= variableDeclaration EQ oclExpression 
[23] defExpression ::= operation EQ oclExpression 
[24] operationContextDecl ::= CONTEXT operation prePostOrBodyDecl 
[25] prePostOrBodyDecl ::= PRE simpleName COLON oclExpression 
[26] prePostOrBodyDecl ::= PRE COLON oclExpression 
[27] prePostOrBodyDecl ::= POST simpleName COLON oclExpression 
[28] prePostOrBodyDecl ::= POST COLON oclExpression 
[29] prePostOrBodyDecl ::= BODY simpleName COLON oclExpression 
[30] prePostOrBodyDecl ::= BODY COLON oclExpression 
[31] prePostOrBodyDecl ::= prePostOrBodyDecl PRE simpleName COLON oclExpression 
[32] prePostOrBodyDecl ::= prePostOrBodyDecl PRE COLON oclExpression 
[33] prePostOrBodyDecl ::= prePostOrBodyDecl POST simpleName COLON oclExpression 
[34] prePostOrBodyDecl ::= prePostOrBodyDecl POST COLON oclExpression 
[35] prePostOrBodyDecl ::= prePostOrBodyDecl BODY simpleName COLON oclExpression 
[36] prePostOrBodyDecl ::= prePostOrBodyDecl BODY COLON oclExpression 
[37] operation ::= pathName COLON_COLON simpleName LEFT_PAR variableDeclarationList RIGHT_PAR COLON type 
[38] operation ::= pathName COLON_COLON simpleName LEFT_PAR variableDeclarationList RIGHT_PAR 
[39] operation ::= pathName COLON_COLON simpleName LEFT_PAR RIGHT_PAR COLON type 
[40] operation ::= pathName COLON_COLON simpleName LEFT_PAR RIGHT_PAR 
[41] operation ::= simpleName LEFT_PAR variableDeclarationList RIGHT_PAR COLON type 
[42] operation ::= simpleName LEFT_PAR variableDeclarationList RIGHT_PAR 
[43] operation ::= simpleName LEFT_PAR RIGHT_PAR COLON type 
[44] operation ::= simpleName LEFT_PAR RIGHT_PAR 
[45] variableDeclarationList ::= variableDeclaration 
[46] variableDeclarationList ::= variableDeclarationList COMMA variableDeclaration 
[47] variableDeclaration ::= simpleName COLON type EQ oclExpression 
[48] variableDeclaration ::= simpleName COLON type 
[49] variableDeclaration ::= simpleName EQ oclExpression 
[50] variableDeclaration ::= simpleName 
[51] type ::= pathName 
[52] type ::= collectionType 
[53] type ::= tupleType 
[54] collectionType ::= collectionKind LEFT_PAR type RIGHT_PAR 
[55] tupleType ::= TUPLE_TYPE LEFT_PAR variableDeclarationList RIGHT_PAR 
[56] oclExpression ::= literalExp 
[57] oclExpression ::= LEFT_PAR oclExpression RIGHT_PAR 
[58] oclExpression ::= pathName isMarkedPre 
[59] oclExpression ::= oclExpression DOT simpleName isMarkedPre 
[60] oclExpression ::= oclExpression LEFT_PAR arguments RIGHT_PAR 
[61] oclExpression ::= oclExpression LEFT_PAR variableDeclaration BAR oclExpression RIGHT_PAR 
[62] oclExpression ::= oclExpression LEFT_BRK argumentList RIGHT_BRK isMarkedPre 
[63] oclExpression ::= oclExpression MINUS_GT simpleName 
[64] oclExpression ::= oclExpression MINUS_GT ITERATE LEFT_PAR variableDeclaration SEMICOLON variableDeclaration BAR oclExpression RIGHT_PAR 
[65] oclExpression ::= oclExpression MINUS_GT ITERATE LEFT_PAR variableDeclaration BAR oclExpression RIGHT_PAR 
[66] oclExpression ::= NOT oclExpression 
[67] oclExpression ::= MINUS oclExpression 
[68] oclExpression ::= oclExpression TIMES oclExpression 
[69] oclExpression ::= oclExpression DIVIDE oclExpression 
[70] oclExpression ::= oclExpression PLUS oclExpression 
[71] oclExpression ::= oclExpression MINUS oclExpression 
[72] oclExpression ::= IF oclExpression THEN oclExpression ELSE oclExpression ENDIF 
[73] oclExpression ::= oclExpression LT oclExpression 
[74] oclExpression ::= oclExpression GT oclExpression 
[75] oclExpression ::= oclExpression LE oclExpression 
[76] oclExpression ::= oclExpression GE oclExpression 
[77] oclExpression ::= oclExpression EQ oclExpression 
[78] oclExpression ::= oclExpression NE oclExpression 
[79] oclExpression ::= oclExpression AND oclExpression 
[80] oclExpression ::= oclExpression OR oclExpression 
[81] oclExpression ::= oclExpression XOR oclExpression 
[82] oclExpression ::= oclExpression IMPLIES oclExpression 
[83] oclExpression ::= LET variableDeclarationList IN oclExpression 
[84] oclExpression ::= oclExpression UP_UP simpleName LEFT_PAR oclMessageArgumentList RIGHT_PAR 
[85] oclExpression ::= oclExpression UP_UP simpleName LEFT_PAR RIGHT_PAR 
[86] oclExpression ::= oclExpression UP simpleName LEFT_PAR oclMessageArgumentList RIGHT_PAR 
[87] oclExpression ::= oclExpression UP simpleName LEFT_PAR RIGHT_PAR 
[88] arguments ::= 
[89] arguments ::= argumentList 
[90] argumentList ::= oclExpression 
[91] argumentList ::= argumentList COMMA oclExpression 
[92] oclMessageArgumentList ::= oclMessageArgument 
[93] oclMessageArgumentList ::= oclMessageArgumentList COMMA oclMessageArgument 
[94] oclMessageArgument ::= QUESTION 
[95] oclMessageArgument ::= QUESTION COLON type 
[96] oclMessageArgument ::= oclExpression 
[97] isMarkedPre ::= 
[98] isMarkedPre ::= AT PRE 
[99] literalExp ::= collectionLiteralExp 
[100] literalExp ::= tupleLiteralExp 
[101] literalExp ::= primitiveLiteralExp 
[102] enumLiteralExp ::= pathName 
[103] collectionLiteralExp ::= collectionKind LEFT_BRA collectionLiteralParts RIGHT_BRA 
[104] collectionLiteralExp ::= collectionKind LEFT_BRA RIGHT_BRA 
[105] collectionKind ::= SET 
[106] collectionKind ::= BAG 
[107] collectionKind ::= SEQUENCE 
[108] collectionKind ::= COLLECTION 
[109] collectionLiteralParts ::= collectionLiteralPart 
[110] collectionLiteralParts ::= collectionLiteralParts COMMA collectionLiteralPart 
[111] collectionLiteralPart ::= oclExpression 
[112] collectionLiteralPart ::= collectionRange 
[113] collectionRange ::= oclExpression DOT_DOT oclExpression 
[114] tupleLiteralExp ::= TUPLE LEFT_BRA variableDeclarationList RIGHT_BRA 
[115] primitiveLiteralExp ::= INTEGER 
[116] primitiveLiteralExp ::= REAL 
[117] primitiveLiteralExp ::= STRING 
[118] primitiveLiteralExp ::= TRUE 
[119] primitiveLiteralExp ::= FALSE 
[120] pathName ::= simpleName 
[121] pathName ::= pathName COLON_COLON simpleName 
[122] simpleName ::= SIMPLE_NAME 

===== Viable Prefix Recognizer =====
START lalr_state [0]: {
  [packageDeclaration ::= (*) contextDeclList , {EOF }]
  [contextDeclList ::= (*) contextDeclList contextDeclaration , {EOF CONTEXT }]
  [packageDeclaration ::= (*) PACKAGE pathName contextDeclList ENDPACKAGE , {EOF }]
  [contextDeclList ::= (*) , {EOF CONTEXT }]
  [$START ::= (*) packageDeclaration EOF , {EOF }]
}
transition on contextDeclList to state [3]
transition on PACKAGE to state [2]
transition on packageDeclaration to state [1]

-------------------
lalr_state [1]: {
  [$START ::= packageDeclaration (*) EOF , {EOF }]
}
transition on EOF to state [274]

-------------------
lalr_state [2]: {
  [pathName ::= (*) simpleName , {ENDPACKAGE CONTEXT COLON_COLON }]
  [packageDeclaration ::= PACKAGE (*) pathName contextDeclList ENDPACKAGE , {EOF }]
  [simpleName ::= (*) SIMPLE_NAME , {ENDPACKAGE CONTEXT COLON_COLON }]
  [pathName ::= (*) pathName COLON_COLON simpleName , {ENDPACKAGE CONTEXT COLON_COLON }]
}
transition on SIMPLE_NAME to state [12]
transition on simpleName to state [26]
transition on pathName to state [271]

-------------------
lalr_state [3]: {
  [propertyContextDecl ::= (*) CONTEXT pathName simpleName COLON type initOrDerValue , {EOF CONTEXT }]
  [contextDeclaration ::= (*) propertyContextDecl , {EOF CONTEXT }]
  [packageDeclaration ::= contextDeclList (*) , {EOF }]
  [classifierContextDecl ::= (*) CONTEXT pathName invOrDef , {EOF CONTEXT }]
  [operationContextDecl ::= (*) CONTEXT operation prePostOrBodyDecl , {EOF CONTEXT }]
  [contextDeclaration ::= (*) operationContextDecl , {EOF CONTEXT }]
  [contextDeclList ::= contextDeclList (*) contextDeclaration , {EOF CONTEXT }]
  [contextDeclaration ::= (*) classifierContextDecl , {EOF CONTEXT }]
}
transition on CONTEXT to state [8]
transition on operationContextDecl to state [7]
transition on classifierContextDecl to state [6]
transition on propertyContextDecl to state [5]
transition on contextDeclaration to state [4]

-------------------
lalr_state [4]: {
  [contextDeclList ::= contextDeclList contextDeclaration (*) , {EOF ENDPACKAGE CONTEXT }]
}

-------------------
lalr_state [5]: {
  [contextDeclaration ::= propertyContextDecl (*) , {EOF ENDPACKAGE CONTEXT }]
}

-------------------
lalr_state [6]: {
  [contextDeclaration ::= classifierContextDecl (*) , {EOF ENDPACKAGE CONTEXT }]
}

-------------------
lalr_state [7]: {
  [contextDeclaration ::= operationContextDecl (*) , {EOF ENDPACKAGE CONTEXT }]
}

-------------------
lalr_state [8]: {
  [operation ::= (*) simpleName LEFT_PAR RIGHT_PAR COLON type , {PRE POST BODY }]
  [operation ::= (*) pathName COLON_COLON simpleName LEFT_PAR RIGHT_PAR , {PRE POST BODY }]
  [operation ::= (*) pathName COLON_COLON simpleName LEFT_PAR variableDeclarationList RIGHT_PAR COLON type , {PRE POST BODY }]
  [propertyContextDecl ::= CONTEXT (*) pathName simpleName COLON type initOrDerValue , {EOF ENDPACKAGE CONTEXT }]
  [pathName ::= (*) simpleName , {INV DEF COLON_COLON SIMPLE_NAME }]
  [operation ::= (*) simpleName LEFT_PAR variableDeclarationList RIGHT_PAR , {PRE POST BODY }]
  [operation ::= (*) pathName COLON_COLON simpleName LEFT_PAR RIGHT_PAR COLON type , {PRE POST BODY }]
  [classifierContextDecl ::= CONTEXT (*) pathName invOrDef , {EOF ENDPACKAGE CONTEXT }]
  [simpleName ::= (*) SIMPLE_NAME , {INV DEF COLON_COLON LEFT_PAR SIMPLE_NAME }]
  [operationContextDecl ::= CONTEXT (*) operation prePostOrBodyDecl , {EOF ENDPACKAGE CONTEXT }]
  [operation ::= (*) simpleName LEFT_PAR RIGHT_PAR , {PRE POST BODY }]
  [operation ::= (*) simpleName LEFT_PAR variableDeclarationList RIGHT_PAR COLON type , {PRE POST BODY }]
  [operation ::= (*) pathName COLON_COLON simpleName LEFT_PAR variableDeclarationList RIGHT_PAR , {PRE POST BODY }]
  [pathName ::= (*) pathName COLON_COLON simpleName , {INV DEF COLON_COLON SIMPLE_NAME }]
}
transition on SIMPLE_NAME to state [12]
transition on simpleName to state [11]
transition on pathName to state [10]
transition on operation to state [9]

-------------------
lalr_state [9]: {
  [prePostOrBodyDecl ::= (*) prePostOrBodyDecl POST COLON oclExpression , {EOF ENDPACKAGE CONTEXT PRE POST BODY }]
  [prePostOrBodyDecl ::= (*) prePostOrBodyDecl PRE simpleName COLON oclExpression , {EOF ENDPACKAGE CONTEXT PRE POST BODY }]
  [prePostOrBodyDecl ::= (*) POST COLON oclExpression , {EOF ENDPACKAGE CONTEXT PRE POST BODY }]
  [prePostOrBodyDecl ::= (*) PRE simpleName COLON oclExpression , {EOF ENDPACKAGE CONTEXT PRE POST BODY }]
  [prePostOrBodyDecl ::= (*) prePostOrBodyDecl BODY COLON oclExpression , {EOF ENDPACKAGE CONTEXT PRE POST BODY }]
  [prePostOrBodyDecl ::= (*) prePostOrBodyDecl POST simpleName COLON oclExpression , {EOF ENDPACKAGE CONTEXT PRE POST BODY }]
  [operationContextDecl ::= CONTEXT operation (*) prePostOrBodyDecl , {EOF ENDPACKAGE CONTEXT }]
  [prePostOrBodyDecl ::= (*) BODY COLON oclExpression , {EOF ENDPACKAGE CONTEXT PRE POST BODY }]
  [prePostOrBodyDecl ::= (*) POST simpleName COLON oclExpression , {EOF ENDPACKAGE CONTEXT PRE POST BODY }]
  [prePostOrBodyDecl ::= (*) prePostOrBodyDecl BODY simpleName COLON oclExpression , {EOF ENDPACKAGE CONTEXT PRE POST BODY }]
  [prePostOrBodyDecl ::= (*) prePostOrBodyDecl PRE COLON oclExpression , {EOF ENDPACKAGE CONTEXT PRE POST BODY }]
  [prePostOrBodyDecl ::= (*) BODY simpleName COLON oclExpression , {EOF ENDPACKAGE CONTEXT PRE POST BODY }]
  [prePostOrBodyDecl ::= (*) PRE COLON oclExpression , {EOF ENDPACKAGE CONTEXT PRE POST BODY }]
}
transition on POST to state [237]
transition on prePostOrBodyDecl to state [236]
transition on PRE to state [235]
transition on BODY to state [234]

-------------------
lalr_state [10]: {
  [invOrDef ::= (*) invOrDef DEF simpleName COLON defExpression , {EOF ENDPACKAGE CONTEXT INV DEF COLON }]
  [operation ::= pathName (*) COLON_COLON simpleName LEFT_PAR RIGHT_PAR , {PRE POST BODY }]
  [invOrDef ::= (*) DEF COLON defExpression , {EOF ENDPACKAGE CONTEXT INV DEF COLON }]
  [operation ::= pathName (*) COLON_COLON simpleName LEFT_PAR variableDeclarationList RIGHT_PAR COLON type , {PRE POST BODY }]
  [invOrDef ::= (*) INV simpleName COLON oclExpression , {EOF ENDPACKAGE CONTEXT INV DEF COLON }]
  [propertyContextDecl ::= CONTEXT pathName (*) simpleName COLON type initOrDerValue , {EOF ENDPACKAGE CONTEXT }]
  [invOrDef ::= (*) invOrDef INV COLON oclExpression , {EOF ENDPACKAGE CONTEXT INV DEF COLON }]
  [operation ::= pathName (*) COLON_COLON simpleName LEFT_PAR RIGHT_PAR COLON type , {PRE POST BODY }]
  [classifierContextDecl ::= CONTEXT pathName (*) invOrDef , {EOF ENDPACKAGE CONTEXT }]
  [invOrDef ::= (*) DEF simpleName COLON defExpression , {EOF ENDPACKAGE CONTEXT INV DEF COLON }]
  [simpleName ::= (*) SIMPLE_NAME , {COLON }]
  [invOrDef ::= (*) invOrDef COLON defExpression , {EOF ENDPACKAGE CONTEXT INV DEF COLON }]
  [invOrDef ::= (*) invOrDef INV simpleName COLON oclExpression , {EOF ENDPACKAGE CONTEXT INV DEF COLON }]
  [operation ::= pathName (*) COLON_COLON simpleName LEFT_PAR variableDeclarationList RIGHT_PAR , {PRE POST BODY }]
  [invOrDef ::= (*) INV COLON oclExpression , {EOF ENDPACKAGE CONTEXT INV DEF COLON }]
  [pathName ::= pathName (*) COLON_COLON simpleName , {INV DEF COLON_COLON SIMPLE_NAME }]
}
transition on SIMPLE_NAME to state [12]
transition on COLON_COLON to state [179]
transition on INV to state [178]
transition on simpleName to state [177]
transition on invOrDef to state [176]
transition on DEF to state [175]

-------------------
lalr_state [11]: {
  [pathName ::= simpleName (*) , {INV DEF COLON_COLON SIMPLE_NAME }]
  [operation ::= simpleName (*) LEFT_PAR RIGHT_PAR COLON type , {PRE POST BODY }]
  [operation ::= simpleName (*) LEFT_PAR variableDeclarationList RIGHT_PAR , {PRE POST BODY }]
  [operation ::= simpleName (*) LEFT_PAR RIGHT_PAR , {PRE POST BODY }]
  [operation ::= simpleName (*) LEFT_PAR variableDeclarationList RIGHT_PAR COLON type , {PRE POST BODY }]
}
transition on LEFT_PAR to state [13]

-------------------
lalr_state [12]: {
  [simpleName ::= SIMPLE_NAME (*) , {EOF ENDPACKAGE CONTEXT INIT DERIVE INV DEF PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE IN THEN ELSE ENDIF COMMA DOT COLON SEMICOLON BAR UP AT DOT_DOT COLON_COLON UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR RIGHT_BRK RIGHT_BRA MINUS_GT SIMPLE_NAME }]
}

-------------------
lalr_state [13]: {
  [operation ::= simpleName LEFT_PAR (*) variableDeclarationList RIGHT_PAR , {PRE POST BODY EQ }]
  [variableDeclaration ::= (*) simpleName COLON type , {COMMA RIGHT_PAR }]
  [variableDeclarationList ::= (*) variableDeclaration , {COMMA RIGHT_PAR }]
  [simpleName ::= (*) SIMPLE_NAME , {EQ COMMA COLON RIGHT_PAR }]
  [variableDeclaration ::= (*) simpleName , {COMMA RIGHT_PAR }]
  [operation ::= simpleName LEFT_PAR (*) RIGHT_PAR , {PRE POST BODY EQ }]
  [variableDeclaration ::= (*) simpleName COLON type EQ oclExpression , {COMMA RIGHT_PAR }]
  [operation ::= simpleName LEFT_PAR (*) variableDeclarationList RIGHT_PAR COLON type , {PRE POST BODY EQ }]
  [operation ::= simpleName LEFT_PAR (*) RIGHT_PAR COLON type , {PRE POST BODY EQ }]
  [variableDeclaration ::= (*) simpleName EQ oclExpression , {COMMA RIGHT_PAR }]
  [variableDeclarationList ::= (*) variableDeclarationList COMMA variableDeclaration , {COMMA RIGHT_PAR }]
}
transition on SIMPLE_NAME to state [12]
transition on variableDeclaration to state [17]
transition on simpleName to state [16]
transition on RIGHT_PAR to state [15]
transition on variableDeclarationList to state [14]

-------------------
lalr_state [14]: {
  [variableDeclarationList ::= variableDeclarationList (*) COMMA variableDeclaration , {COMMA RIGHT_PAR }]
  [operation ::= simpleName LEFT_PAR variableDeclarationList (*) RIGHT_PAR , {PRE POST BODY EQ }]
  [operation ::= simpleName LEFT_PAR variableDeclarationList (*) RIGHT_PAR COLON type , {PRE POST BODY EQ }]
}
transition on RIGHT_PAR to state [172]
transition on COMMA to state [33]

-------------------
lalr_state [15]: {
  [operation ::= simpleName LEFT_PAR RIGHT_PAR (*) COLON type , {PRE POST BODY EQ }]
  [operation ::= simpleName LEFT_PAR RIGHT_PAR (*) , {PRE POST BODY EQ }]
}
transition on COLON to state [170]

-------------------
lalr_state [16]: {
  [variableDeclaration ::= simpleName (*) EQ oclExpression , {IN COMMA SEMICOLON BAR RIGHT_PAR RIGHT_BRA }]
  [variableDeclaration ::= simpleName (*) COLON type , {IN COMMA SEMICOLON BAR RIGHT_PAR RIGHT_BRA }]
  [variableDeclaration ::= simpleName (*) , {IN COMMA SEMICOLON BAR RIGHT_PAR RIGHT_BRA }]
  [variableDeclaration ::= simpleName (*) COLON type EQ oclExpression , {IN COMMA SEMICOLON BAR RIGHT_PAR RIGHT_BRA }]
}
transition on COLON to state [19]
transition on EQ to state [18]

-------------------
lalr_state [17]: {
  [variableDeclarationList ::= variableDeclaration (*) , {IN COMMA RIGHT_PAR RIGHT_BRA }]
}

-------------------
lalr_state [18]: {
  [oclExpression ::= (*) oclExpression UP simpleName LEFT_PAR oclMessageArgumentList RIGHT_PAR , {IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE IN COMMA DOT SEMICOLON BAR UP UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR RIGHT_BRA MINUS_GT }]
  [oclExpression ::= (*) oclExpression EQ oclExpression , {IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE IN COMMA DOT SEMICOLON BAR UP UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR RIGHT_BRA MINUS_GT }]
  [oclExpression ::= (*) oclExpression TIMES oclExpression , {IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE IN COMMA DOT SEMICOLON BAR UP UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR RIGHT_BRA MINUS_GT }]
  [oclExpression ::= (*) oclExpression DOT simpleName isMarkedPre , {IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE IN COMMA DOT SEMICOLON BAR UP UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR RIGHT_BRA MINUS_GT }]
  [primitiveLiteralExp ::= (*) TRUE , {IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE IN COMMA DOT SEMICOLON BAR UP UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR RIGHT_BRA MINUS_GT }]
  [literalExp ::= (*) tupleLiteralExp , {IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE IN COMMA DOT SEMICOLON BAR UP UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR RIGHT_BRA MINUS_GT }]
  [oclExpression ::= (*) oclExpression IMPLIES oclExpression , {IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE IN COMMA DOT SEMICOLON BAR UP UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR RIGHT_BRA MINUS_GT }]
  [oclExpression ::= (*) oclExpression LT oclExpression , {IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE IN COMMA DOT SEMICOLON BAR UP UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR RIGHT_BRA MINUS_GT }]
  [oclExpression ::= (*) oclExpression MINUS_GT ITERATE LEFT_PAR variableDeclaration SEMICOLON variableDeclaration BAR oclExpression RIGHT_PAR , {IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE IN COMMA DOT SEMICOLON BAR UP UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR RIGHT_BRA MINUS_GT }]
  [tupleLiteralExp ::= (*) TUPLE LEFT_BRA variableDeclarationList RIGHT_BRA , {IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE IN COMMA DOT SEMICOLON BAR UP UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR RIGHT_BRA MINUS_GT }]
  [collectionKind ::= (*) SET , {LEFT_BRA }]
  [oclExpression ::= (*) oclExpression UP simpleName LEFT_PAR RIGHT_PAR , {IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE IN COMMA DOT SEMICOLON BAR UP UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR RIGHT_BRA MINUS_GT }]
  [oclExpression ::= (*) oclExpression NE oclExpression , {IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE IN COMMA DOT SEMICOLON BAR UP UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR RIGHT_BRA MINUS_GT }]
  [oclExpression ::= (*) oclExpression DIVIDE oclExpression , {IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE IN COMMA DOT SEMICOLON BAR UP UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR RIGHT_BRA MINUS_GT }]
  [oclExpression ::= (*) oclExpression LEFT_PAR arguments RIGHT_PAR , {IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE IN COMMA DOT SEMICOLON BAR UP UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR RIGHT_BRA MINUS_GT }]
  [primitiveLiteralExp ::= (*) FALSE , {IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE IN COMMA DOT SEMICOLON BAR UP UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR RIGHT_BRA MINUS_GT }]
  [literalExp ::= (*) primitiveLiteralExp , {IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE IN COMMA DOT SEMICOLON BAR UP UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR RIGHT_BRA MINUS_GT }]
  [oclExpression ::= (*) LET variableDeclarationList IN oclExpression , {IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE IN COMMA DOT SEMICOLON BAR UP UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR RIGHT_BRA MINUS_GT }]
  [oclExpression ::= (*) oclExpression GT oclExpression , {IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE IN COMMA DOT SEMICOLON BAR UP UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR RIGHT_BRA MINUS_GT }]
  [oclExpression ::= (*) oclExpression MINUS_GT ITERATE LEFT_PAR variableDeclaration BAR oclExpression RIGHT_PAR , {IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE IN COMMA DOT SEMICOLON BAR UP UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR RIGHT_BRA MINUS_GT }]
  [oclExpression ::= (*) literalExp , {IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE IN COMMA DOT SEMICOLON BAR UP UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR RIGHT_BRA MINUS_GT }]
  [primitiveLiteralExp ::= (*) INTEGER , {IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE IN COMMA DOT SEMICOLON BAR UP UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR RIGHT_BRA MINUS_GT }]
  [collectionKind ::= (*) BAG , {LEFT_BRA }]
  [oclExpression ::= (*) oclExpression AND oclExpression , {IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE IN COMMA DOT SEMICOLON BAR UP UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR RIGHT_BRA MINUS_GT }]
  [oclExpression ::= (*) oclExpression PLUS oclExpression , {IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE IN COMMA DOT SEMICOLON BAR UP UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR RIGHT_BRA MINUS_GT }]
  [oclExpression ::= (*) oclExpression LEFT_PAR variableDeclaration BAR oclExpression RIGHT_PAR , {IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE IN COMMA DOT SEMICOLON BAR UP UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR RIGHT_BRA MINUS_GT }]
  [pathName ::= (*) simpleName , {IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE IN COMMA DOT SEMICOLON BAR UP AT COLON_COLON UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR RIGHT_BRA MINUS_GT }]
  [oclExpression ::= (*) oclExpression UP_UP simpleName LEFT_PAR oclMessageArgumentList RIGHT_PAR , {IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE IN COMMA DOT SEMICOLON BAR UP UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR RIGHT_BRA MINUS_GT }]
  [oclExpression ::= (*) oclExpression LE oclExpression , {IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE IN COMMA DOT SEMICOLON BAR UP UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR RIGHT_BRA MINUS_GT }]
  [oclExpression ::= (*) NOT oclExpression , {IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE IN COMMA DOT SEMICOLON BAR UP UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR RIGHT_BRA MINUS_GT }]
  [oclExpression ::= (*) LEFT_PAR oclExpression RIGHT_PAR , {IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE IN COMMA DOT SEMICOLON BAR UP UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR RIGHT_BRA MINUS_GT }]
  [primitiveLiteralExp ::= (*) REAL , {IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE IN COMMA DOT SEMICOLON BAR UP UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR RIGHT_BRA MINUS_GT }]
  [collectionKind ::= (*) SEQUENCE , {LEFT_BRA }]
  [oclExpression ::= (*) oclExpression OR oclExpression , {IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE IN COMMA DOT SEMICOLON BAR UP UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR RIGHT_BRA MINUS_GT }]
  [oclExpression ::= (*) oclExpression MINUS oclExpression , {IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE IN COMMA DOT SEMICOLON BAR UP UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR RIGHT_BRA MINUS_GT }]
  [oclExpression ::= (*) oclExpression LEFT_BRK argumentList RIGHT_BRK isMarkedPre , {IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE IN COMMA DOT SEMICOLON BAR UP UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR RIGHT_BRA MINUS_GT }]
  [pathName ::= (*) pathName COLON_COLON simpleName , {IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE IN COMMA DOT SEMICOLON BAR UP AT COLON_COLON UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR RIGHT_BRA MINUS_GT }]
  [collectionLiteralExp ::= (*) collectionKind LEFT_BRA collectionLiteralParts RIGHT_BRA , {IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE IN COMMA DOT SEMICOLON BAR UP UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR RIGHT_BRA MINUS_GT }]
  [oclExpression ::= (*) oclExpression UP_UP simpleName LEFT_PAR RIGHT_PAR , {IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE IN COMMA DOT SEMICOLON BAR UP UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR RIGHT_BRA MINUS_GT }]
  [oclExpression ::= (*) oclExpression GE oclExpression , {IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE IN COMMA DOT SEMICOLON BAR UP UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR RIGHT_BRA MINUS_GT }]
  [variableDeclaration ::= simpleName EQ (*) oclExpression , {EQ IN COMMA SEMICOLON BAR RIGHT_PAR RIGHT_BRA }]
  [oclExpression ::= (*) MINUS oclExpression , {IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE IN COMMA DOT SEMICOLON BAR UP UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR RIGHT_BRA MINUS_GT }]
  [oclExpression ::= (*) pathName isMarkedPre , {IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE IN COMMA DOT SEMICOLON BAR UP UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR RIGHT_BRA MINUS_GT }]
  [primitiveLiteralExp ::= (*) STRING , {IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE IN COMMA DOT SEMICOLON BAR UP UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR RIGHT_BRA MINUS_GT }]
  [collectionKind ::= (*) COLLECTION , {LEFT_BRA }]
  [literalExp ::= (*) collectionLiteralExp , {IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE IN COMMA DOT SEMICOLON BAR UP UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR RIGHT_BRA MINUS_GT }]
  [oclExpression ::= (*) oclExpression XOR oclExpression , {IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE IN COMMA DOT SEMICOLON BAR UP UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR RIGHT_BRA MINUS_GT }]
  [oclExpression ::= (*) IF oclExpression THEN oclExpression ELSE oclExpression ENDIF , {IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE IN COMMA DOT SEMICOLON BAR UP UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR RIGHT_BRA MINUS_GT }]
  [oclExpression ::= (*) oclExpression MINUS_GT simpleName , {IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE IN COMMA DOT SEMICOLON BAR UP UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR RIGHT_BRA MINUS_GT }]
  [simpleName ::= (*) SIMPLE_NAME , {IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE IN COMMA DOT SEMICOLON BAR UP AT COLON_COLON UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR RIGHT_BRA MINUS_GT }]
  [collectionLiteralExp ::= (*) collectionKind LEFT_BRA RIGHT_BRA , {IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE IN COMMA DOT SEMICOLON BAR UP UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR RIGHT_BRA MINUS_GT }]
}
transition on tupleLiteralExp to state [54]
transition on oclExpression to state [169]
transition on REAL to state [52]
transition on INTEGER to state [51]
transition on pathName to state [50]
transition on SIMPLE_NAME to state [12]
transition on LET to state [49]
transition on FALSE to state [48]
transition on MINUS to state [47]
transition on COLLECTION to state [28]
transition on SET to state [20]
transition on simpleName to state [26]
transition on collectionLiteralExp to state [46]
transition on LEFT_PAR to state [45]
transition on STRING to state [44]
transition on IF to state [43]
transition on TRUE to state [42]
transition on collectionKind to state [41]
transition on NOT to state [40]
transition on primitiveLiteralExp to state [39]
transition on TUPLE to state [38]
transition on literalExp to state [37]
transition on BAG to state [25]
transition on SEQUENCE to state [22]

-------------------
lalr_state [19]: {
  [collectionKind ::= (*) BAG , {LEFT_PAR }]
  [variableDeclaration ::= simpleName COLON (*) type , {EQ IN COMMA SEMICOLON BAR RIGHT_PAR RIGHT_BRA }]
  [collectionType ::= (*) collectionKind LEFT_PAR type RIGHT_PAR , {EQ IN COMMA SEMICOLON BAR RIGHT_PAR RIGHT_BRA }]
  [pathName ::= (*) simpleName , {EQ IN COMMA SEMICOLON BAR COLON_COLON RIGHT_PAR RIGHT_BRA }]
  [type ::= (*) pathName , {EQ IN COMMA SEMICOLON BAR RIGHT_PAR RIGHT_BRA }]
  [collectionKind ::= (*) COLLECTION , {LEFT_PAR }]
  [collectionKind ::= (*) SET , {LEFT_PAR }]
  [simpleName ::= (*) SIMPLE_NAME , {EQ IN COMMA SEMICOLON BAR COLON_COLON RIGHT_PAR RIGHT_BRA }]
  [variableDeclaration ::= simpleName COLON (*) type EQ oclExpression , {EQ IN COMMA SEMICOLON BAR RIGHT_PAR RIGHT_BRA }]
  [type ::= (*) tupleType , {EQ IN COMMA SEMICOLON BAR RIGHT_PAR RIGHT_BRA }]
  [collectionKind ::= (*) SEQUENCE , {LEFT_PAR }]
  [tupleType ::= (*) TUPLE_TYPE LEFT_PAR variableDeclarationList RIGHT_PAR , {EQ IN COMMA SEMICOLON BAR RIGHT_PAR RIGHT_BRA }]
  [pathName ::= (*) pathName COLON_COLON simpleName , {EQ IN COMMA SEMICOLON BAR COLON_COLON RIGHT_PAR RIGHT_BRA }]
  [type ::= (*) collectionType , {EQ IN COMMA SEMICOLON BAR RIGHT_PAR RIGHT_BRA }]
}
transition on collectionType to state [30]
transition on TUPLE_TYPE to state [29]
transition on COLLECTION to state [28]
transition on type to state [27]
transition on simpleName to state [26]
transition on BAG to state [25]
transition on collectionKind to state [24]
transition on pathName to state [23]
transition on SEQUENCE to state [22]
transition on tupleType to state [21]
transition on SET to state [20]
transition on SIMPLE_NAME to state [12]

-------------------
lalr_state [20]: {
  [collectionKind ::= SET (*) , {LEFT_PAR LEFT_BRA }]
}

-------------------
lalr_state [21]: {
  [type ::= tupleType (*) , {INIT DERIVE PRE POST BODY EQ IN COMMA SEMICOLON BAR RIGHT_PAR RIGHT_BRA }]
}

-------------------
lalr_state [22]: {
  [collectionKind ::= SEQUENCE (*) , {LEFT_PAR LEFT_BRA }]
}

-------------------
lalr_state [23]: {
  [type ::= pathName (*) , {INIT DERIVE PRE POST BODY EQ IN COMMA SEMICOLON BAR RIGHT_PAR RIGHT_BRA }]
  [pathName ::= pathName (*) COLON_COLON simpleName , {INIT DERIVE PRE POST BODY EQ IN COMMA SEMICOLON BAR COLON_COLON RIGHT_PAR RIGHT_BRA }]
}
transition on COLON_COLON to state [137]

-------------------
lalr_state [24]: {
  [collectionType ::= collectionKind (*) LEFT_PAR type RIGHT_PAR , {INIT DERIVE PRE POST BODY EQ IN COMMA SEMICOLON BAR RIGHT_PAR RIGHT_BRA }]
}
transition on LEFT_PAR to state [166]

-------------------
lalr_state [25]: {
  [collectionKind ::= BAG (*) , {LEFT_PAR LEFT_BRA }]
}

-------------------
lalr_state [26]: {
  [pathName ::= simpleName (*) , {EOF ENDPACKAGE CONTEXT INIT DERIVE INV DEF PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE IN THEN ELSE ENDIF COMMA DOT COLON SEMICOLON BAR UP AT DOT_DOT COLON_COLON UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR RIGHT_BRK RIGHT_BRA MINUS_GT }]
}

-------------------
lalr_state [27]: {
  [variableDeclaration ::= simpleName COLON type (*) , {EQ IN COMMA SEMICOLON BAR RIGHT_PAR RIGHT_BRA }]
  [variableDeclaration ::= simpleName COLON type (*) EQ oclExpression , {EQ IN COMMA SEMICOLON BAR RIGHT_PAR RIGHT_BRA }]
}
transition on EQ to state [36]

-------------------
lalr_state [28]: {
  [collectionKind ::= COLLECTION (*) , {LEFT_PAR LEFT_BRA }]
}

-------------------
lalr_state [29]: {
  [tupleType ::= TUPLE_TYPE (*) LEFT_PAR variableDeclarationList RIGHT_PAR , {INIT DERIVE PRE POST BODY EQ IN COMMA SEMICOLON BAR RIGHT_PAR RIGHT_BRA }]
}
transition on LEFT_PAR to state [31]

-------------------
lalr_state [30]: {
  [type ::= collectionType (*) , {INIT DERIVE PRE POST BODY EQ IN COMMA SEMICOLON BAR RIGHT_PAR RIGHT_BRA }]
}

-------------------
lalr_state [31]: {
  [variableDeclaration ::= (*) simpleName EQ oclExpression , {COMMA RIGHT_PAR }]
  [variableDeclarationList ::= (*) variableDeclarationList COMMA variableDeclaration , {COMMA RIGHT_PAR }]
  [variableDeclaration ::= (*) simpleName COLON type , {COMMA RIGHT_PAR }]
  [simpleName ::= (*) SIMPLE_NAME , {EQ COMMA COLON RIGHT_PAR }]
  [variableDeclarationList ::= (*) variableDeclaration , {COMMA RIGHT_PAR }]
  [variableDeclaration ::= (*) simpleName , {COMMA RIGHT_PAR }]
  [tupleType ::= TUPLE_TYPE LEFT_PAR (*) variableDeclarationList RIGHT_PAR , {INIT DERIVE PRE POST BODY EQ IN COMMA SEMICOLON BAR RIGHT_PAR RIGHT_BRA }]
  [variableDeclaration ::= (*) simpleName COLON type EQ oclExpression , {COMMA RIGHT_PAR }]
}
transition on SIMPLE_NAME to state [12]
transition on variableDeclaration to state [17]
transition on simpleName to state [16]
transition on variableDeclarationList to state [32]

-------------------
lalr_state [32]: {
  [variableDeclarationList ::= variableDeclarationList (*) COMMA variableDeclaration , {COMMA RIGHT_PAR }]
  [tupleType ::= TUPLE_TYPE LEFT_PAR variableDeclarationList (*) RIGHT_PAR , {INIT DERIVE PRE POST BODY EQ IN COMMA SEMICOLON BAR RIGHT_PAR RIGHT_BRA }]
}
transition on RIGHT_PAR to state [34]
transition on COMMA to state [33]

-------------------
lalr_state [33]: {
  [variableDeclarationList ::= variableDeclarationList COMMA (*) variableDeclaration , {IN COMMA RIGHT_PAR RIGHT_BRA }]
  [variableDeclaration ::= (*) simpleName EQ oclExpression , {IN COMMA RIGHT_PAR RIGHT_BRA }]
  [variableDeclaration ::= (*) simpleName COLON type , {IN COMMA RIGHT_PAR RIGHT_BRA }]
  [simpleName ::= (*) SIMPLE_NAME , {EQ IN COMMA COLON RIGHT_PAR RIGHT_BRA }]
  [variableDeclaration ::= (*) simpleName , {IN COMMA RIGHT_PAR RIGHT_BRA }]
  [variableDeclaration ::= (*) simpleName COLON type EQ oclExpression , {IN COMMA RIGHT_PAR RIGHT_BRA }]
}
transition on SIMPLE_NAME to state [12]
transition on variableDeclaration to state [35]
transition on simpleName to state [16]

-------------------
lalr_state [34]: {
  [tupleType ::= TUPLE_TYPE LEFT_PAR variableDeclarationList RIGHT_PAR (*) , {INIT DERIVE PRE POST BODY EQ IN COMMA SEMICOLON BAR RIGHT_PAR RIGHT_BRA }]
}

-------------------
lalr_state [35]: {
  [variableDeclarationList ::= variableDeclarationList COMMA variableDeclaration (*) , {IN COMMA RIGHT_PAR RIGHT_BRA }]
}

-------------------
lalr_state [36]: {
  [oclExpression ::= (*) oclExpression UP simpleName LEFT_PAR oclMessageArgumentList RIGHT_PAR , {IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE IN COMMA DOT SEMICOLON BAR UP UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR RIGHT_BRA MINUS_GT }]
  [oclExpression ::= (*) oclExpression EQ oclExpression , {IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE IN COMMA DOT SEMICOLON BAR UP UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR RIGHT_BRA MINUS_GT }]
  [oclExpression ::= (*) oclExpression TIMES oclExpression , {IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE IN COMMA DOT SEMICOLON BAR UP UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR RIGHT_BRA MINUS_GT }]
  [oclExpression ::= (*) oclExpression DOT simpleName isMarkedPre , {IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE IN COMMA DOT SEMICOLON BAR UP UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR RIGHT_BRA MINUS_GT }]
  [primitiveLiteralExp ::= (*) TRUE , {IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE IN COMMA DOT SEMICOLON BAR UP UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR RIGHT_BRA MINUS_GT }]
  [literalExp ::= (*) tupleLiteralExp , {IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE IN COMMA DOT SEMICOLON BAR UP UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR RIGHT_BRA MINUS_GT }]
  [oclExpression ::= (*) oclExpression IMPLIES oclExpression , {IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE IN COMMA DOT SEMICOLON BAR UP UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR RIGHT_BRA MINUS_GT }]
  [oclExpression ::= (*) oclExpression LT oclExpression , {IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE IN COMMA DOT SEMICOLON BAR UP UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR RIGHT_BRA MINUS_GT }]
  [oclExpression ::= (*) oclExpression MINUS_GT ITERATE LEFT_PAR variableDeclaration SEMICOLON variableDeclaration BAR oclExpression RIGHT_PAR , {IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE IN COMMA DOT SEMICOLON BAR UP UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR RIGHT_BRA MINUS_GT }]
  [tupleLiteralExp ::= (*) TUPLE LEFT_BRA variableDeclarationList RIGHT_BRA , {IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE IN COMMA DOT SEMICOLON BAR UP UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR RIGHT_BRA MINUS_GT }]
  [collectionKind ::= (*) SET , {LEFT_BRA }]
  [oclExpression ::= (*) oclExpression UP simpleName LEFT_PAR RIGHT_PAR , {IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE IN COMMA DOT SEMICOLON BAR UP UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR RIGHT_BRA MINUS_GT }]
  [oclExpression ::= (*) oclExpression NE oclExpression , {IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE IN COMMA DOT SEMICOLON BAR UP UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR RIGHT_BRA MINUS_GT }]
  [oclExpression ::= (*) oclExpression DIVIDE oclExpression , {IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE IN COMMA DOT SEMICOLON BAR UP UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR RIGHT_BRA MINUS_GT }]
  [oclExpression ::= (*) oclExpression LEFT_PAR arguments RIGHT_PAR , {IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE IN COMMA DOT SEMICOLON BAR UP UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR RIGHT_BRA MINUS_GT }]
  [primitiveLiteralExp ::= (*) FALSE , {IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE IN COMMA DOT SEMICOLON BAR UP UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR RIGHT_BRA MINUS_GT }]
  [literalExp ::= (*) primitiveLiteralExp , {IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE IN COMMA DOT SEMICOLON BAR UP UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR RIGHT_BRA MINUS_GT }]
  [variableDeclaration ::= simpleName COLON type EQ (*) oclExpression , {EQ IN COMMA SEMICOLON BAR RIGHT_PAR RIGHT_BRA }]
  [oclExpression ::= (*) LET variableDeclarationList IN oclExpression , {IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE IN COMMA DOT SEMICOLON BAR UP UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR RIGHT_BRA MINUS_GT }]
  [oclExpression ::= (*) oclExpression GT oclExpression , {IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE IN COMMA DOT SEMICOLON BAR UP UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR RIGHT_BRA MINUS_GT }]
  [oclExpression ::= (*) oclExpression MINUS_GT ITERATE LEFT_PAR variableDeclaration BAR oclExpression RIGHT_PAR , {IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE IN COMMA DOT SEMICOLON BAR UP UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR RIGHT_BRA MINUS_GT }]
  [oclExpression ::= (*) literalExp , {IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE IN COMMA DOT SEMICOLON BAR UP UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR RIGHT_BRA MINUS_GT }]
  [primitiveLiteralExp ::= (*) INTEGER , {IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE IN COMMA DOT SEMICOLON BAR UP UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR RIGHT_BRA MINUS_GT }]
  [collectionKind ::= (*) BAG , {LEFT_BRA }]
  [oclExpression ::= (*) oclExpression AND oclExpression , {IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE IN COMMA DOT SEMICOLON BAR UP UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR RIGHT_BRA MINUS_GT }]
  [oclExpression ::= (*) oclExpression PLUS oclExpression , {IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE IN COMMA DOT SEMICOLON BAR UP UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR RIGHT_BRA MINUS_GT }]
  [oclExpression ::= (*) oclExpression LEFT_PAR variableDeclaration BAR oclExpression RIGHT_PAR , {IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE IN COMMA DOT SEMICOLON BAR UP UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR RIGHT_BRA MINUS_GT }]
  [pathName ::= (*) simpleName , {IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE IN COMMA DOT SEMICOLON BAR UP AT COLON_COLON UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR RIGHT_BRA MINUS_GT }]
  [oclExpression ::= (*) oclExpression UP_UP simpleName LEFT_PAR oclMessageArgumentList RIGHT_PAR , {IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE IN COMMA DOT SEMICOLON BAR UP UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR RIGHT_BRA MINUS_GT }]
  [oclExpression ::= (*) oclExpression LE oclExpression , {IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE IN COMMA DOT SEMICOLON BAR UP UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR RIGHT_BRA MINUS_GT }]
  [oclExpression ::= (*) NOT oclExpression , {IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE IN COMMA DOT SEMICOLON BAR UP UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR RIGHT_BRA MINUS_GT }]
  [oclExpression ::= (*) LEFT_PAR oclExpression RIGHT_PAR , {IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE IN COMMA DOT SEMICOLON BAR UP UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR RIGHT_BRA MINUS_GT }]
  [primitiveLiteralExp ::= (*) REAL , {IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE IN COMMA DOT SEMICOLON BAR UP UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR RIGHT_BRA MINUS_GT }]
  [collectionKind ::= (*) SEQUENCE , {LEFT_BRA }]
  [oclExpression ::= (*) oclExpression OR oclExpression , {IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE IN COMMA DOT SEMICOLON BAR UP UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR RIGHT_BRA MINUS_GT }]
  [oclExpression ::= (*) oclExpression MINUS oclExpression , {IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE IN COMMA DOT SEMICOLON BAR UP UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR RIGHT_BRA MINUS_GT }]
  [oclExpression ::= (*) oclExpression LEFT_BRK argumentList RIGHT_BRK isMarkedPre , {IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE IN COMMA DOT SEMICOLON BAR UP UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR RIGHT_BRA MINUS_GT }]
  [pathName ::= (*) pathName COLON_COLON simpleName , {IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE IN COMMA DOT SEMICOLON BAR UP AT COLON_COLON UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR RIGHT_BRA MINUS_GT }]
  [collectionLiteralExp ::= (*) collectionKind LEFT_BRA collectionLiteralParts RIGHT_BRA , {IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE IN COMMA DOT SEMICOLON BAR UP UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR RIGHT_BRA MINUS_GT }]
  [oclExpression ::= (*) oclExpression UP_UP simpleName LEFT_PAR RIGHT_PAR , {IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE IN COMMA DOT SEMICOLON BAR UP UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR RIGHT_BRA MINUS_GT }]
  [oclExpression ::= (*) oclExpression GE oclExpression , {IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE IN COMMA DOT SEMICOLON BAR UP UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR RIGHT_BRA MINUS_GT }]
  [oclExpression ::= (*) MINUS oclExpression , {IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE IN COMMA DOT SEMICOLON BAR UP UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR RIGHT_BRA MINUS_GT }]
  [oclExpression ::= (*) pathName isMarkedPre , {IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE IN COMMA DOT SEMICOLON BAR UP UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR RIGHT_BRA MINUS_GT }]
  [primitiveLiteralExp ::= (*) STRING , {IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE IN COMMA DOT SEMICOLON BAR UP UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR RIGHT_BRA MINUS_GT }]
  [collectionKind ::= (*) COLLECTION , {LEFT_BRA }]
  [literalExp ::= (*) collectionLiteralExp , {IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE IN COMMA DOT SEMICOLON BAR UP UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR RIGHT_BRA MINUS_GT }]
  [oclExpression ::= (*) oclExpression XOR oclExpression , {IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE IN COMMA DOT SEMICOLON BAR UP UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR RIGHT_BRA MINUS_GT }]
  [oclExpression ::= (*) IF oclExpression THEN oclExpression ELSE oclExpression ENDIF , {IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE IN COMMA DOT SEMICOLON BAR UP UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR RIGHT_BRA MINUS_GT }]
  [oclExpression ::= (*) oclExpression MINUS_GT simpleName , {IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE IN COMMA DOT SEMICOLON BAR UP UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR RIGHT_BRA MINUS_GT }]
  [simpleName ::= (*) SIMPLE_NAME , {IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE IN COMMA DOT SEMICOLON BAR UP AT COLON_COLON UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR RIGHT_BRA MINUS_GT }]
  [collectionLiteralExp ::= (*) collectionKind LEFT_BRA RIGHT_BRA , {IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE IN COMMA DOT SEMICOLON BAR UP UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR RIGHT_BRA MINUS_GT }]
}
transition on tupleLiteralExp to state [54]
transition on oclExpression to state [53]
transition on REAL to state [52]
transition on INTEGER to state [51]
transition on pathName to state [50]
transition on SIMPLE_NAME to state [12]
transition on LET to state [49]
transition on FALSE to state [48]
transition on MINUS to state [47]
transition on COLLECTION to state [28]
transition on SET to state [20]
transition on simpleName to state [26]
transition on collectionLiteralExp to state [46]
transition on LEFT_PAR to state [45]
transition on STRING to state [44]
transition on IF to state [43]
transition on TRUE to state [42]
transition on collectionKind to state [41]
transition on NOT to state [40]
transition on primitiveLiteralExp to state [39]
transition on TUPLE to state [38]
transition on literalExp to state [37]
transition on BAG to state [25]
transition on SEQUENCE to state [22]

-------------------
lalr_state [37]: {
  [oclExpression ::= literalExp (*) , {EOF ENDPACKAGE CONTEXT INIT DERIVE INV DEF PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE IN THEN ELSE ENDIF COMMA DOT COLON SEMICOLON BAR UP DOT_DOT UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR RIGHT_BRK RIGHT_BRA MINUS_GT }]
}

-------------------
lalr_state [38]: {
  [tupleLiteralExp ::= TUPLE (*) LEFT_BRA variableDeclarationList RIGHT_BRA , {EOF ENDPACKAGE CONTEXT INIT DERIVE INV DEF PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE IN THEN ELSE ENDIF COMMA DOT COLON SEMICOLON BAR UP DOT_DOT UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR RIGHT_BRK RIGHT_BRA MINUS_GT }]
}
transition on LEFT_BRA to state [163]

-------------------
lalr_state [39]: {
  [literalExp ::= primitiveLiteralExp (*) , {EOF ENDPACKAGE CONTEXT INIT DERIVE INV DEF PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE IN THEN ELSE ENDIF COMMA DOT COLON SEMICOLON BAR UP DOT_DOT UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR RIGHT_BRK RIGHT_BRA MINUS_GT }]
}

-------------------
lalr_state [40]: {
  [oclExpression ::= (*) oclExpression UP simpleName LEFT_PAR oclMessageArgumentList RIGHT_PAR , {EOF ENDPACKAGE CONTEXT INIT DERIVE INV DEF PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE IN THEN ELSE ENDIF COMMA DOT COLON SEMICOLON BAR UP DOT_DOT UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR RIGHT_BRK RIGHT_BRA MINUS_GT }]
  [oclExpression ::= (*) oclExpression EQ oclExpression , {EOF ENDPACKAGE CONTEXT INIT DERIVE INV DEF PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE IN THEN ELSE ENDIF COMMA DOT COLON SEMICOLON BAR UP DOT_DOT UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR RIGHT_BRK RIGHT_BRA MINUS_GT }]
  [oclExpression ::= (*) oclExpression TIMES oclExpression , {EOF ENDPACKAGE CONTEXT INIT DERIVE INV DEF PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE IN THEN ELSE ENDIF COMMA DOT COLON SEMICOLON BAR UP DOT_DOT UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR RIGHT_BRK RIGHT_BRA MINUS_GT }]
  [oclExpression ::= (*) oclExpression DOT simpleName isMarkedPre , {EOF ENDPACKAGE CONTEXT INIT DERIVE INV DEF PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE IN THEN ELSE ENDIF COMMA DOT COLON SEMICOLON BAR UP DOT_DOT UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR RIGHT_BRK RIGHT_BRA MINUS_GT }]
  [primitiveLiteralExp ::= (*) TRUE , {EOF ENDPACKAGE CONTEXT INIT DERIVE INV DEF PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE IN THEN ELSE ENDIF COMMA DOT COLON SEMICOLON BAR UP DOT_DOT UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR RIGHT_BRK RIGHT_BRA MINUS_GT }]
  [literalExp ::= (*) tupleLiteralExp , {EOF ENDPACKAGE CONTEXT INIT DERIVE INV DEF PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE IN THEN ELSE ENDIF COMMA DOT COLON SEMICOLON BAR UP DOT_DOT UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR RIGHT_BRK RIGHT_BRA MINUS_GT }]
  [oclExpression ::= (*) oclExpression IMPLIES oclExpression , {EOF ENDPACKAGE CONTEXT INIT DERIVE INV DEF PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE IN THEN ELSE ENDIF COMMA DOT COLON SEMICOLON BAR UP DOT_DOT UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR RIGHT_BRK RIGHT_BRA MINUS_GT }]
  [oclExpression ::= (*) oclExpression LT oclExpression , {EOF ENDPACKAGE CONTEXT INIT DERIVE INV DEF PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE IN THEN ELSE ENDIF COMMA DOT COLON SEMICOLON BAR UP DOT_DOT UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR RIGHT_BRK RIGHT_BRA MINUS_GT }]
  [oclExpression ::= (*) oclExpression MINUS_GT ITERATE LEFT_PAR variableDeclaration SEMICOLON variableDeclaration BAR oclExpression RIGHT_PAR , {EOF ENDPACKAGE CONTEXT INIT DERIVE INV DEF PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE IN THEN ELSE ENDIF COMMA DOT COLON SEMICOLON BAR UP DOT_DOT UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR RIGHT_BRK RIGHT_BRA MINUS_GT }]
  [tupleLiteralExp ::= (*) TUPLE LEFT_BRA variableDeclarationList RIGHT_BRA , {EOF ENDPACKAGE CONTEXT INIT DERIVE INV DEF PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE IN THEN ELSE ENDIF COMMA DOT COLON SEMICOLON BAR UP DOT_DOT UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR RIGHT_BRK RIGHT_BRA MINUS_GT }]
  [collectionKind ::= (*) SET , {LEFT_BRA }]
  [oclExpression ::= (*) oclExpression UP simpleName LEFT_PAR RIGHT_PAR , {EOF ENDPACKAGE CONTEXT INIT DERIVE INV DEF PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE IN THEN ELSE ENDIF COMMA DOT COLON SEMICOLON BAR UP DOT_DOT UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR RIGHT_BRK RIGHT_BRA MINUS_GT }]
  [oclExpression ::= (*) oclExpression NE oclExpression , {EOF ENDPACKAGE CONTEXT INIT DERIVE INV DEF PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE IN THEN ELSE ENDIF COMMA DOT COLON SEMICOLON BAR UP DOT_DOT UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR RIGHT_BRK RIGHT_BRA MINUS_GT }]
  [oclExpression ::= (*) oclExpression DIVIDE oclExpression , {EOF ENDPACKAGE CONTEXT INIT DERIVE INV DEF PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE IN THEN ELSE ENDIF COMMA DOT COLON SEMICOLON BAR UP DOT_DOT UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR RIGHT_BRK RIGHT_BRA MINUS_GT }]
  [oclExpression ::= (*) oclExpression LEFT_PAR arguments RIGHT_PAR , {EOF ENDPACKAGE CONTEXT INIT DERIVE INV DEF PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE IN THEN ELSE ENDIF COMMA DOT COLON SEMICOLON BAR UP DOT_DOT UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR RIGHT_BRK RIGHT_BRA MINUS_GT }]
  [primitiveLiteralExp ::= (*) FALSE , {EOF ENDPACKAGE CONTEXT INIT DERIVE INV DEF PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE IN THEN ELSE ENDIF COMMA DOT COLON SEMICOLON BAR UP DOT_DOT UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR RIGHT_BRK RIGHT_BRA MINUS_GT }]
  [literalExp ::= (*) primitiveLiteralExp , {EOF ENDPACKAGE CONTEXT INIT DERIVE INV DEF PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE IN THEN ELSE ENDIF COMMA DOT COLON SEMICOLON BAR UP DOT_DOT UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR RIGHT_BRK RIGHT_BRA MINUS_GT }]
  [oclExpression ::= (*) LET variableDeclarationList IN oclExpression , {EOF ENDPACKAGE CONTEXT INIT DERIVE INV DEF PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE IN THEN ELSE ENDIF COMMA DOT COLON SEMICOLON BAR UP DOT_DOT UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR RIGHT_BRK RIGHT_BRA MINUS_GT }]
  [oclExpression ::= (*) oclExpression GT oclExpression , {EOF ENDPACKAGE CONTEXT INIT DERIVE INV DEF PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE IN THEN ELSE ENDIF COMMA DOT COLON SEMICOLON BAR UP DOT_DOT UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR RIGHT_BRK RIGHT_BRA MINUS_GT }]
  [oclExpression ::= (*) oclExpression MINUS_GT ITERATE LEFT_PAR variableDeclaration BAR oclExpression RIGHT_PAR , {EOF ENDPACKAGE CONTEXT INIT DERIVE INV DEF PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE IN THEN ELSE ENDIF COMMA DOT COLON SEMICOLON BAR UP DOT_DOT UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR RIGHT_BRK RIGHT_BRA MINUS_GT }]
  [oclExpression ::= (*) literalExp , {EOF ENDPACKAGE CONTEXT INIT DERIVE INV DEF PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE IN THEN ELSE ENDIF COMMA DOT COLON SEMICOLON BAR UP DOT_DOT UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR RIGHT_BRK RIGHT_BRA MINUS_GT }]
  [primitiveLiteralExp ::= (*) INTEGER , {EOF ENDPACKAGE CONTEXT INIT DERIVE INV DEF PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE IN THEN ELSE ENDIF COMMA DOT COLON SEMICOLON BAR UP DOT_DOT UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR RIGHT_BRK RIGHT_BRA MINUS_GT }]
  [collectionKind ::= (*) BAG , {LEFT_BRA }]
  [oclExpression ::= (*) oclExpression AND oclExpression , {EOF ENDPACKAGE CONTEXT INIT DERIVE INV DEF PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE IN THEN ELSE ENDIF COMMA DOT COLON SEMICOLON BAR UP DOT_DOT UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR RIGHT_BRK RIGHT_BRA MINUS_GT }]
  [oclExpression ::= (*) oclExpression PLUS oclExpression , {EOF ENDPACKAGE CONTEXT INIT DERIVE INV DEF PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE IN THEN ELSE ENDIF COMMA DOT COLON SEMICOLON BAR UP DOT_DOT UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR RIGHT_BRK RIGHT_BRA MINUS_GT }]
  [oclExpression ::= (*) oclExpression LEFT_PAR variableDeclaration BAR oclExpression RIGHT_PAR , {EOF ENDPACKAGE CONTEXT INIT DERIVE INV DEF PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE IN THEN ELSE ENDIF COMMA DOT COLON SEMICOLON BAR UP DOT_DOT UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR RIGHT_BRK RIGHT_BRA MINUS_GT }]
  [pathName ::= (*) simpleName , {EOF ENDPACKAGE CONTEXT INIT DERIVE INV DEF PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE IN THEN ELSE ENDIF COMMA DOT COLON SEMICOLON BAR UP AT DOT_DOT COLON_COLON UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR RIGHT_BRK RIGHT_BRA MINUS_GT }]
  [oclExpression ::= (*) oclExpression UP_UP simpleName LEFT_PAR oclMessageArgumentList RIGHT_PAR , {EOF ENDPACKAGE CONTEXT INIT DERIVE INV DEF PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE IN THEN ELSE ENDIF COMMA DOT COLON SEMICOLON BAR UP DOT_DOT UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR RIGHT_BRK RIGHT_BRA MINUS_GT }]
  [oclExpression ::= NOT (*) oclExpression , {EOF ENDPACKAGE CONTEXT INIT DERIVE INV DEF PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE IN THEN ELSE ENDIF COMMA DOT COLON SEMICOLON BAR UP DOT_DOT UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR RIGHT_BRK RIGHT_BRA MINUS_GT }]
  [oclExpression ::= (*) oclExpression LE oclExpression , {EOF ENDPACKAGE CONTEXT INIT DERIVE INV DEF PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE IN THEN ELSE ENDIF COMMA DOT COLON SEMICOLON BAR UP DOT_DOT UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR RIGHT_BRK RIGHT_BRA MINUS_GT }]
  [oclExpression ::= (*) NOT oclExpression , {EOF ENDPACKAGE CONTEXT INIT DERIVE INV DEF PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE IN THEN ELSE ENDIF COMMA DOT COLON SEMICOLON BAR UP DOT_DOT UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR RIGHT_BRK RIGHT_BRA MINUS_GT }]
  [oclExpression ::= (*) LEFT_PAR oclExpression RIGHT_PAR , {EOF ENDPACKAGE CONTEXT INIT DERIVE INV DEF PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE IN THEN ELSE ENDIF COMMA DOT COLON SEMICOLON BAR UP DOT_DOT UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR RIGHT_BRK RIGHT_BRA MINUS_GT }]
  [primitiveLiteralExp ::= (*) REAL , {EOF ENDPACKAGE CONTEXT INIT DERIVE INV DEF PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE IN THEN ELSE ENDIF COMMA DOT COLON SEMICOLON BAR UP DOT_DOT UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR RIGHT_BRK RIGHT_BRA MINUS_GT }]
  [collectionKind ::= (*) SEQUENCE , {LEFT_BRA }]
  [oclExpression ::= (*) oclExpression OR oclExpression , {EOF ENDPACKAGE CONTEXT INIT DERIVE INV DEF PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE IN THEN ELSE ENDIF COMMA DOT COLON SEMICOLON BAR UP DOT_DOT UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR RIGHT_BRK RIGHT_BRA MINUS_GT }]
  [oclExpression ::= (*) oclExpression MINUS oclExpression , {EOF ENDPACKAGE CONTEXT INIT DERIVE INV DEF PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE IN THEN ELSE ENDIF COMMA DOT COLON SEMICOLON BAR UP DOT_DOT UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR RIGHT_BRK RIGHT_BRA MINUS_GT }]
  [oclExpression ::= (*) oclExpression LEFT_BRK argumentList RIGHT_BRK isMarkedPre , {EOF ENDPACKAGE CONTEXT INIT DERIVE INV DEF PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE IN THEN ELSE ENDIF COMMA DOT COLON SEMICOLON BAR UP DOT_DOT UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR RIGHT_BRK RIGHT_BRA MINUS_GT }]
  [pathName ::= (*) pathName COLON_COLON simpleName , {EOF ENDPACKAGE CONTEXT INIT DERIVE INV DEF PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE IN THEN ELSE ENDIF COMMA DOT COLON SEMICOLON BAR UP AT DOT_DOT COLON_COLON UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR RIGHT_BRK RIGHT_BRA MINUS_GT }]
  [collectionLiteralExp ::= (*) collectionKind LEFT_BRA collectionLiteralParts RIGHT_BRA , {EOF ENDPACKAGE CONTEXT INIT DERIVE INV DEF PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE IN THEN ELSE ENDIF COMMA DOT COLON SEMICOLON BAR UP DOT_DOT UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR RIGHT_BRK RIGHT_BRA MINUS_GT }]
  [oclExpression ::= (*) oclExpression UP_UP simpleName LEFT_PAR RIGHT_PAR , {EOF ENDPACKAGE CONTEXT INIT DERIVE INV DEF PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE IN THEN ELSE ENDIF COMMA DOT COLON SEMICOLON BAR UP DOT_DOT UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR RIGHT_BRK RIGHT_BRA MINUS_GT }]
  [oclExpression ::= (*) oclExpression GE oclExpression , {EOF ENDPACKAGE CONTEXT INIT DERIVE INV DEF PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE IN THEN ELSE ENDIF COMMA DOT COLON SEMICOLON BAR UP DOT_DOT UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR RIGHT_BRK RIGHT_BRA MINUS_GT }]
  [oclExpression ::= (*) MINUS oclExpression , {EOF ENDPACKAGE CONTEXT INIT DERIVE INV DEF PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE IN THEN ELSE ENDIF COMMA DOT COLON SEMICOLON BAR UP DOT_DOT UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR RIGHT_BRK RIGHT_BRA MINUS_GT }]
  [oclExpression ::= (*) pathName isMarkedPre , {EOF ENDPACKAGE CONTEXT INIT DERIVE INV DEF PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE IN THEN ELSE ENDIF COMMA DOT COLON SEMICOLON BAR UP DOT_DOT UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR RIGHT_BRK RIGHT_BRA MINUS_GT }]
  [primitiveLiteralExp ::= (*) STRING , {EOF ENDPACKAGE CONTEXT INIT DERIVE INV DEF PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE IN THEN ELSE ENDIF COMMA DOT COLON SEMICOLON BAR UP DOT_DOT UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR RIGHT_BRK RIGHT_BRA MINUS_GT }]
  [collectionKind ::= (*) COLLECTION , {LEFT_BRA }]
  [literalExp ::= (*) collectionLiteralExp , {EOF ENDPACKAGE CONTEXT INIT DERIVE INV DEF PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE IN THEN ELSE ENDIF COMMA DOT COLON SEMICOLON BAR UP DOT_DOT UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR RIGHT_BRK RIGHT_BRA MINUS_GT }]
  [oclExpression ::= (*) oclExpression XOR oclExpression , {EOF ENDPACKAGE CONTEXT INIT DERIVE INV DEF PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE IN THEN ELSE ENDIF COMMA DOT COLON SEMICOLON BAR UP DOT_DOT UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR RIGHT_BRK RIGHT_BRA MINUS_GT }]
  [oclExpression ::= (*) IF oclExpression THEN oclExpression ELSE oclExpression ENDIF , {EOF ENDPACKAGE CONTEXT INIT DERIVE INV DEF PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE IN THEN ELSE ENDIF COMMA DOT COLON SEMICOLON BAR UP DOT_DOT UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR RIGHT_BRK RIGHT_BRA MINUS_GT }]
  [oclExpression ::= (*) oclExpression MINUS_GT simpleName , {EOF ENDPACKAGE CONTEXT INIT DERIVE INV DEF PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE IN THEN ELSE ENDIF COMMA DOT COLON SEMICOLON BAR UP DOT_DOT UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR RIGHT_BRK RIGHT_BRA MINUS_GT }]
  [simpleName ::= (*) SIMPLE_NAME , {EOF ENDPACKAGE CONTEXT INIT DERIVE INV DEF PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE IN THEN ELSE ENDIF COMMA DOT COLON SEMICOLON BAR UP AT DOT_DOT COLON_COLON UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR RIGHT_BRK RIGHT_BRA MINUS_GT }]
  [collectionLiteralExp ::= (*) collectionKind LEFT_BRA RIGHT_BRA , {EOF ENDPACKAGE CONTEXT INIT DERIVE INV DEF PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE IN THEN ELSE ENDIF COMMA DOT COLON SEMICOLON BAR UP DOT_DOT UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR RIGHT_BRK RIGHT_BRA MINUS_GT }]
}
transition on tupleLiteralExp to state [54]
transition on oclExpression to state [162]
transition on REAL to state [52]
transition on INTEGER to state [51]
transition on pathName to state [50]
transition on SIMPLE_NAME to state [12]
transition on LET to state [49]
transition on FALSE to state [48]
transition on MINUS to state [47]
transition on COLLECTION to state [28]
transition on SET to state [20]
transition on simpleName to state [26]
transition on collectionLiteralExp to state [46]
transition on LEFT_PAR to state [45]
transition on STRING to state [44]
transition on IF to state [43]
transition on TRUE to state [42]
transition on collectionKind to state [41]
transition on NOT to state [40]
transition on primitiveLiteralExp to state [39]
transition on TUPLE to state [38]
transition on literalExp to state [37]
transition on BAG to state [25]
transition on SEQUENCE to state [22]

-------------------
lalr_state [41]: {
  [collectionLiteralExp ::= collectionKind (*) LEFT_BRA RIGHT_BRA , {EOF ENDPACKAGE CONTEXT INIT DERIVE INV DEF PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE IN THEN ELSE ENDIF COMMA DOT COLON SEMICOLON BAR UP DOT_DOT UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR RIGHT_BRK RIGHT_BRA MINUS_GT }]
  [collectionLiteralExp ::= collectionKind (*) LEFT_BRA collectionLiteralParts RIGHT_BRA , {EOF ENDPACKAGE CONTEXT INIT DERIVE INV DEF PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE IN THEN ELSE ENDIF COMMA DOT COLON SEMICOLON BAR UP DOT_DOT UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR RIGHT_BRK RIGHT_BRA MINUS_GT }]
}
transition on LEFT_BRA to state [151]

-------------------
lalr_state [42]: {
  [primitiveLiteralExp ::= TRUE (*) , {EOF ENDPACKAGE CONTEXT INIT DERIVE INV DEF PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE IN THEN ELSE ENDIF COMMA DOT COLON SEMICOLON BAR UP DOT_DOT UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR RIGHT_BRK RIGHT_BRA MINUS_GT }]
}

-------------------
lalr_state [43]: {
  [oclExpression ::= (*) oclExpression UP simpleName LEFT_PAR oclMessageArgumentList RIGHT_PAR , {IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE THEN DOT UP UP_UP LEFT_PAR LEFT_BRK MINUS_GT }]
  [oclExpression ::= (*) oclExpression EQ oclExpression , {IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE THEN DOT UP UP_UP LEFT_PAR LEFT_BRK MINUS_GT }]
  [oclExpression ::= (*) oclExpression TIMES oclExpression , {IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE THEN DOT UP UP_UP LEFT_PAR LEFT_BRK MINUS_GT }]
  [oclExpression ::= (*) oclExpression DOT simpleName isMarkedPre , {IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE THEN DOT UP UP_UP LEFT_PAR LEFT_BRK MINUS_GT }]
  [primitiveLiteralExp ::= (*) TRUE , {IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE THEN DOT UP UP_UP LEFT_PAR LEFT_BRK MINUS_GT }]
  [literalExp ::= (*) tupleLiteralExp , {IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE THEN DOT UP UP_UP LEFT_PAR LEFT_BRK MINUS_GT }]
  [oclExpression ::= (*) oclExpression IMPLIES oclExpression , {IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE THEN DOT UP UP_UP LEFT_PAR LEFT_BRK MINUS_GT }]
  [oclExpression ::= (*) oclExpression LT oclExpression , {IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE THEN DOT UP UP_UP LEFT_PAR LEFT_BRK MINUS_GT }]
  [oclExpression ::= (*) oclExpression MINUS_GT ITERATE LEFT_PAR variableDeclaration SEMICOLON variableDeclaration BAR oclExpression RIGHT_PAR , {IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE THEN DOT UP UP_UP LEFT_PAR LEFT_BRK MINUS_GT }]
  [tupleLiteralExp ::= (*) TUPLE LEFT_BRA variableDeclarationList RIGHT_BRA , {IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE THEN DOT UP UP_UP LEFT_PAR LEFT_BRK MINUS_GT }]
  [collectionKind ::= (*) SET , {LEFT_BRA }]
  [oclExpression ::= (*) oclExpression UP simpleName LEFT_PAR RIGHT_PAR , {IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE THEN DOT UP UP_UP LEFT_PAR LEFT_BRK MINUS_GT }]
  [oclExpression ::= (*) oclExpression NE oclExpression , {IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE THEN DOT UP UP_UP LEFT_PAR LEFT_BRK MINUS_GT }]
  [oclExpression ::= (*) oclExpression DIVIDE oclExpression , {IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE THEN DOT UP UP_UP LEFT_PAR LEFT_BRK MINUS_GT }]
  [oclExpression ::= (*) oclExpression LEFT_PAR arguments RIGHT_PAR , {IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE THEN DOT UP UP_UP LEFT_PAR LEFT_BRK MINUS_GT }]
  [primitiveLiteralExp ::= (*) FALSE , {IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE THEN DOT UP UP_UP LEFT_PAR LEFT_BRK MINUS_GT }]
  [literalExp ::= (*) primitiveLiteralExp , {IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE THEN DOT UP UP_UP LEFT_PAR LEFT_BRK MINUS_GT }]
  [oclExpression ::= (*) LET variableDeclarationList IN oclExpression , {IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE THEN DOT UP UP_UP LEFT_PAR LEFT_BRK MINUS_GT }]
  [oclExpression ::= (*) oclExpression GT oclExpression , {IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE THEN DOT UP UP_UP LEFT_PAR LEFT_BRK MINUS_GT }]
  [oclExpression ::= (*) oclExpression MINUS_GT ITERATE LEFT_PAR variableDeclaration BAR oclExpression RIGHT_PAR , {IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE THEN DOT UP UP_UP LEFT_PAR LEFT_BRK MINUS_GT }]
  [oclExpression ::= (*) literalExp , {IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE THEN DOT UP UP_UP LEFT_PAR LEFT_BRK MINUS_GT }]
  [primitiveLiteralExp ::= (*) INTEGER , {IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE THEN DOT UP UP_UP LEFT_PAR LEFT_BRK MINUS_GT }]
  [collectionKind ::= (*) BAG , {LEFT_BRA }]
  [oclExpression ::= (*) oclExpression AND oclExpression , {IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE THEN DOT UP UP_UP LEFT_PAR LEFT_BRK MINUS_GT }]
  [oclExpression ::= (*) oclExpression PLUS oclExpression , {IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE THEN DOT UP UP_UP LEFT_PAR LEFT_BRK MINUS_GT }]
  [oclExpression ::= (*) oclExpression LEFT_PAR variableDeclaration BAR oclExpression RIGHT_PAR , {IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE THEN DOT UP UP_UP LEFT_PAR LEFT_BRK MINUS_GT }]
  [pathName ::= (*) simpleName , {IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE THEN DOT UP AT COLON_COLON UP_UP LEFT_PAR LEFT_BRK MINUS_GT }]
  [oclExpression ::= (*) oclExpression UP_UP simpleName LEFT_PAR oclMessageArgumentList RIGHT_PAR , {IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE THEN DOT UP UP_UP LEFT_PAR LEFT_BRK MINUS_GT }]
  [oclExpression ::= (*) oclExpression LE oclExpression , {IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE THEN DOT UP UP_UP LEFT_PAR LEFT_BRK MINUS_GT }]
  [oclExpression ::= (*) NOT oclExpression , {IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE THEN DOT UP UP_UP LEFT_PAR LEFT_BRK MINUS_GT }]
  [oclExpression ::= (*) LEFT_PAR oclExpression RIGHT_PAR , {IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE THEN DOT UP UP_UP LEFT_PAR LEFT_BRK MINUS_GT }]
  [primitiveLiteralExp ::= (*) REAL , {IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE THEN DOT UP UP_UP LEFT_PAR LEFT_BRK MINUS_GT }]
  [collectionKind ::= (*) SEQUENCE , {LEFT_BRA }]
  [oclExpression ::= (*) oclExpression OR oclExpression , {IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE THEN DOT UP UP_UP LEFT_PAR LEFT_BRK MINUS_GT }]
  [oclExpression ::= (*) oclExpression MINUS oclExpression , {IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE THEN DOT UP UP_UP LEFT_PAR LEFT_BRK MINUS_GT }]
  [oclExpression ::= (*) oclExpression LEFT_BRK argumentList RIGHT_BRK isMarkedPre , {IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE THEN DOT UP UP_UP LEFT_PAR LEFT_BRK MINUS_GT }]
  [pathName ::= (*) pathName COLON_COLON simpleName , {IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE THEN DOT UP AT COLON_COLON UP_UP LEFT_PAR LEFT_BRK MINUS_GT }]
  [collectionLiteralExp ::= (*) collectionKind LEFT_BRA collectionLiteralParts RIGHT_BRA , {IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE THEN DOT UP UP_UP LEFT_PAR LEFT_BRK MINUS_GT }]
  [oclExpression ::= (*) oclExpression UP_UP simpleName LEFT_PAR RIGHT_PAR , {IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE THEN DOT UP UP_UP LEFT_PAR LEFT_BRK MINUS_GT }]
  [oclExpression ::= (*) oclExpression GE oclExpression , {IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE THEN DOT UP UP_UP LEFT_PAR LEFT_BRK MINUS_GT }]
  [oclExpression ::= (*) MINUS oclExpression , {IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE THEN DOT UP UP_UP LEFT_PAR LEFT_BRK MINUS_GT }]
  [oclExpression ::= (*) pathName isMarkedPre , {IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE THEN DOT UP UP_UP LEFT_PAR LEFT_BRK MINUS_GT }]
  [primitiveLiteralExp ::= (*) STRING , {IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE THEN DOT UP UP_UP LEFT_PAR LEFT_BRK MINUS_GT }]
  [collectionKind ::= (*) COLLECTION , {LEFT_BRA }]
  [literalExp ::= (*) collectionLiteralExp , {IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE THEN DOT UP UP_UP LEFT_PAR LEFT_BRK MINUS_GT }]
  [oclExpression ::= (*) oclExpression XOR oclExpression , {IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE THEN DOT UP UP_UP LEFT_PAR LEFT_BRK MINUS_GT }]
  [oclExpression ::= IF (*) oclExpression THEN oclExpression ELSE oclExpression ENDIF , {EOF ENDPACKAGE CONTEXT INIT DERIVE INV DEF PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE IN THEN ELSE ENDIF COMMA DOT COLON SEMICOLON BAR UP DOT_DOT UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR RIGHT_BRK RIGHT_BRA MINUS_GT }]
  [oclExpression ::= (*) IF oclExpression THEN oclExpression ELSE oclExpression ENDIF , {IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE THEN DOT UP UP_UP LEFT_PAR LEFT_BRK MINUS_GT }]
  [oclExpression ::= (*) oclExpression MINUS_GT simpleName , {IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE THEN DOT UP UP_UP LEFT_PAR LEFT_BRK MINUS_GT }]
  [simpleName ::= (*) SIMPLE_NAME , {IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE THEN DOT UP AT COLON_COLON UP_UP LEFT_PAR LEFT_BRK MINUS_GT }]
  [collectionLiteralExp ::= (*) collectionKind LEFT_BRA RIGHT_BRA , {IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE THEN DOT UP UP_UP LEFT_PAR LEFT_BRK MINUS_GT }]
}
transition on tupleLiteralExp to state [54]
transition on oclExpression to state [145]
transition on REAL to state [52]
transition on INTEGER to state [51]
transition on pathName to state [50]
transition on SIMPLE_NAME to state [12]
transition on LET to state [49]
transition on FALSE to state [48]
transition on MINUS to state [47]
transition on COLLECTION to state [28]
transition on SET to state [20]
transition on simpleName to state [26]
transition on collectionLiteralExp to state [46]
transition on LEFT_PAR to state [45]
transition on STRING to state [44]
transition on IF to state [43]
transition on TRUE to state [42]
transition on collectionKind to state [41]
transition on NOT to state [40]
transition on primitiveLiteralExp to state [39]
transition on TUPLE to state [38]
transition on literalExp to state [37]
transition on BAG to state [25]
transition on SEQUENCE to state [22]

-------------------
lalr_state [44]: {
  [primitiveLiteralExp ::= STRING (*) , {EOF ENDPACKAGE CONTEXT INIT DERIVE INV DEF PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE IN THEN ELSE ENDIF COMMA DOT COLON SEMICOLON BAR UP DOT_DOT UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR RIGHT_BRK RIGHT_BRA MINUS_GT }]
}

-------------------
lalr_state [45]: {
  [oclExpression ::= (*) oclExpression UP simpleName LEFT_PAR oclMessageArgumentList RIGHT_PAR , {IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE DOT UP UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR MINUS_GT }]
  [oclExpression ::= (*) oclExpression EQ oclExpression , {IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE DOT UP UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR MINUS_GT }]
  [oclExpression ::= (*) oclExpression TIMES oclExpression , {IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE DOT UP UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR MINUS_GT }]
  [oclExpression ::= (*) oclExpression DOT simpleName isMarkedPre , {IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE DOT UP UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR MINUS_GT }]
  [primitiveLiteralExp ::= (*) TRUE , {IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE DOT UP UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR MINUS_GT }]
  [literalExp ::= (*) tupleLiteralExp , {IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE DOT UP UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR MINUS_GT }]
  [oclExpression ::= (*) oclExpression IMPLIES oclExpression , {IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE DOT UP UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR MINUS_GT }]
  [oclExpression ::= (*) oclExpression LT oclExpression , {IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE DOT UP UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR MINUS_GT }]
  [oclExpression ::= (*) oclExpression MINUS_GT ITERATE LEFT_PAR variableDeclaration SEMICOLON variableDeclaration BAR oclExpression RIGHT_PAR , {IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE DOT UP UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR MINUS_GT }]
  [tupleLiteralExp ::= (*) TUPLE LEFT_BRA variableDeclarationList RIGHT_BRA , {IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE DOT UP UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR MINUS_GT }]
  [collectionKind ::= (*) SET , {LEFT_BRA }]
  [oclExpression ::= (*) oclExpression UP simpleName LEFT_PAR RIGHT_PAR , {IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE DOT UP UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR MINUS_GT }]
  [oclExpression ::= (*) oclExpression NE oclExpression , {IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE DOT UP UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR MINUS_GT }]
  [oclExpression ::= (*) oclExpression DIVIDE oclExpression , {IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE DOT UP UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR MINUS_GT }]
  [oclExpression ::= (*) oclExpression LEFT_PAR arguments RIGHT_PAR , {IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE DOT UP UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR MINUS_GT }]
  [primitiveLiteralExp ::= (*) FALSE , {IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE DOT UP UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR MINUS_GT }]
  [literalExp ::= (*) primitiveLiteralExp , {IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE DOT UP UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR MINUS_GT }]
  [oclExpression ::= (*) LET variableDeclarationList IN oclExpression , {IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE DOT UP UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR MINUS_GT }]
  [oclExpression ::= (*) oclExpression GT oclExpression , {IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE DOT UP UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR MINUS_GT }]
  [oclExpression ::= (*) oclExpression MINUS_GT ITERATE LEFT_PAR variableDeclaration BAR oclExpression RIGHT_PAR , {IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE DOT UP UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR MINUS_GT }]
  [oclExpression ::= (*) literalExp , {IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE DOT UP UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR MINUS_GT }]
  [primitiveLiteralExp ::= (*) INTEGER , {IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE DOT UP UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR MINUS_GT }]
  [collectionKind ::= (*) BAG , {LEFT_BRA }]
  [oclExpression ::= (*) oclExpression AND oclExpression , {IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE DOT UP UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR MINUS_GT }]
  [oclExpression ::= (*) oclExpression PLUS oclExpression , {IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE DOT UP UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR MINUS_GT }]
  [oclExpression ::= (*) oclExpression LEFT_PAR variableDeclaration BAR oclExpression RIGHT_PAR , {IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE DOT UP UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR MINUS_GT }]
  [pathName ::= (*) simpleName , {IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE DOT UP AT COLON_COLON UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR MINUS_GT }]
  [oclExpression ::= (*) oclExpression UP_UP simpleName LEFT_PAR oclMessageArgumentList RIGHT_PAR , {IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE DOT UP UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR MINUS_GT }]
  [oclExpression ::= (*) oclExpression LE oclExpression , {IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE DOT UP UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR MINUS_GT }]
  [oclExpression ::= (*) NOT oclExpression , {IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE DOT UP UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR MINUS_GT }]
  [oclExpression ::= LEFT_PAR (*) oclExpression RIGHT_PAR , {EOF ENDPACKAGE CONTEXT INIT DERIVE INV DEF PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE IN THEN ELSE ENDIF COMMA DOT COLON SEMICOLON BAR UP DOT_DOT UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR RIGHT_BRK RIGHT_BRA MINUS_GT }]
  [oclExpression ::= (*) LEFT_PAR oclExpression RIGHT_PAR , {IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE DOT UP UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR MINUS_GT }]
  [primitiveLiteralExp ::= (*) REAL , {IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE DOT UP UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR MINUS_GT }]
  [collectionKind ::= (*) SEQUENCE , {LEFT_BRA }]
  [oclExpression ::= (*) oclExpression OR oclExpression , {IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE DOT UP UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR MINUS_GT }]
  [oclExpression ::= (*) oclExpression MINUS oclExpression , {IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE DOT UP UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR MINUS_GT }]
  [oclExpression ::= (*) oclExpression LEFT_BRK argumentList RIGHT_BRK isMarkedPre , {IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE DOT UP UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR MINUS_GT }]
  [pathName ::= (*) pathName COLON_COLON simpleName , {IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE DOT UP AT COLON_COLON UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR MINUS_GT }]
  [collectionLiteralExp ::= (*) collectionKind LEFT_BRA collectionLiteralParts RIGHT_BRA , {IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE DOT UP UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR MINUS_GT }]
  [oclExpression ::= (*) oclExpression UP_UP simpleName LEFT_PAR RIGHT_PAR , {IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE DOT UP UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR MINUS_GT }]
  [oclExpression ::= (*) oclExpression GE oclExpression , {IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE DOT UP UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR MINUS_GT }]
  [oclExpression ::= (*) MINUS oclExpression , {IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE DOT UP UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR MINUS_GT }]
  [oclExpression ::= (*) pathName isMarkedPre , {IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE DOT UP UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR MINUS_GT }]
  [primitiveLiteralExp ::= (*) STRING , {IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE DOT UP UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR MINUS_GT }]
  [collectionKind ::= (*) COLLECTION , {LEFT_BRA }]
  [literalExp ::= (*) collectionLiteralExp , {IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE DOT UP UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR MINUS_GT }]
  [oclExpression ::= (*) oclExpression XOR oclExpression , {IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE DOT UP UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR MINUS_GT }]
  [oclExpression ::= (*) IF oclExpression THEN oclExpression ELSE oclExpression ENDIF , {IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE DOT UP UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR MINUS_GT }]
  [oclExpression ::= (*) oclExpression MINUS_GT simpleName , {IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE DOT UP UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR MINUS_GT }]
  [simpleName ::= (*) SIMPLE_NAME , {IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE DOT UP AT COLON_COLON UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR MINUS_GT }]
  [collectionLiteralExp ::= (*) collectionKind LEFT_BRA RIGHT_BRA , {IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE DOT UP UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR MINUS_GT }]
}
transition on tupleLiteralExp to state [54]
transition on oclExpression to state [143]
transition on REAL to state [52]
transition on INTEGER to state [51]
transition on pathName to state [50]
transition on SIMPLE_NAME to state [12]
transition on LET to state [49]
transition on FALSE to state [48]
transition on MINUS to state [47]
transition on COLLECTION to state [28]
transition on SET to state [20]
transition on simpleName to state [26]
transition on collectionLiteralExp to state [46]
transition on LEFT_PAR to state [45]
transition on STRING to state [44]
transition on IF to state [43]
transition on TRUE to state [42]
transition on collectionKind to state [41]
transition on NOT to state [40]
transition on primitiveLiteralExp to state [39]
transition on TUPLE to state [38]
transition on literalExp to state [37]
transition on BAG to state [25]
transition on SEQUENCE to state [22]

-------------------
lalr_state [46]: {
  [literalExp ::= collectionLiteralExp (*) , {EOF ENDPACKAGE CONTEXT INIT DERIVE INV DEF PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE IN THEN ELSE ENDIF COMMA DOT COLON SEMICOLON BAR UP DOT_DOT UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR RIGHT_BRK RIGHT_BRA MINUS_GT }]
}

-------------------
lalr_state [47]: {
  [oclExpression ::= (*) oclExpression UP simpleName LEFT_PAR oclMessageArgumentList RIGHT_PAR , {EOF ENDPACKAGE CONTEXT INIT DERIVE INV DEF PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE IN THEN ELSE ENDIF COMMA DOT COLON SEMICOLON BAR UP DOT_DOT UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR RIGHT_BRK RIGHT_BRA MINUS_GT }]
  [oclExpression ::= (*) oclExpression EQ oclExpression , {EOF ENDPACKAGE CONTEXT INIT DERIVE INV DEF PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE IN THEN ELSE ENDIF COMMA DOT COLON SEMICOLON BAR UP DOT_DOT UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR RIGHT_BRK RIGHT_BRA MINUS_GT }]
  [oclExpression ::= (*) oclExpression TIMES oclExpression , {EOF ENDPACKAGE CONTEXT INIT DERIVE INV DEF PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE IN THEN ELSE ENDIF COMMA DOT COLON SEMICOLON BAR UP DOT_DOT UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR RIGHT_BRK RIGHT_BRA MINUS_GT }]
  [oclExpression ::= (*) oclExpression DOT simpleName isMarkedPre , {EOF ENDPACKAGE CONTEXT INIT DERIVE INV DEF PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE IN THEN ELSE ENDIF COMMA DOT COLON SEMICOLON BAR UP DOT_DOT UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR RIGHT_BRK RIGHT_BRA MINUS_GT }]
  [primitiveLiteralExp ::= (*) TRUE , {EOF ENDPACKAGE CONTEXT INIT DERIVE INV DEF PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE IN THEN ELSE ENDIF COMMA DOT COLON SEMICOLON BAR UP DOT_DOT UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR RIGHT_BRK RIGHT_BRA MINUS_GT }]
  [literalExp ::= (*) tupleLiteralExp , {EOF ENDPACKAGE CONTEXT INIT DERIVE INV DEF PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE IN THEN ELSE ENDIF COMMA DOT COLON SEMICOLON BAR UP DOT_DOT UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR RIGHT_BRK RIGHT_BRA MINUS_GT }]
  [oclExpression ::= (*) oclExpression IMPLIES oclExpression , {EOF ENDPACKAGE CONTEXT INIT DERIVE INV DEF PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE IN THEN ELSE ENDIF COMMA DOT COLON SEMICOLON BAR UP DOT_DOT UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR RIGHT_BRK RIGHT_BRA MINUS_GT }]
  [oclExpression ::= (*) oclExpression LT oclExpression , {EOF ENDPACKAGE CONTEXT INIT DERIVE INV DEF PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE IN THEN ELSE ENDIF COMMA DOT COLON SEMICOLON BAR UP DOT_DOT UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR RIGHT_BRK RIGHT_BRA MINUS_GT }]
  [oclExpression ::= (*) oclExpression MINUS_GT ITERATE LEFT_PAR variableDeclaration SEMICOLON variableDeclaration BAR oclExpression RIGHT_PAR , {EOF ENDPACKAGE CONTEXT INIT DERIVE INV DEF PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE IN THEN ELSE ENDIF COMMA DOT COLON SEMICOLON BAR UP DOT_DOT UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR RIGHT_BRK RIGHT_BRA MINUS_GT }]
  [tupleLiteralExp ::= (*) TUPLE LEFT_BRA variableDeclarationList RIGHT_BRA , {EOF ENDPACKAGE CONTEXT INIT DERIVE INV DEF PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE IN THEN ELSE ENDIF COMMA DOT COLON SEMICOLON BAR UP DOT_DOT UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR RIGHT_BRK RIGHT_BRA MINUS_GT }]
  [collectionKind ::= (*) SET , {LEFT_BRA }]
  [oclExpression ::= (*) oclExpression UP simpleName LEFT_PAR RIGHT_PAR , {EOF ENDPACKAGE CONTEXT INIT DERIVE INV DEF PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE IN THEN ELSE ENDIF COMMA DOT COLON SEMICOLON BAR UP DOT_DOT UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR RIGHT_BRK RIGHT_BRA MINUS_GT }]
  [oclExpression ::= (*) oclExpression NE oclExpression , {EOF ENDPACKAGE CONTEXT INIT DERIVE INV DEF PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE IN THEN ELSE ENDIF COMMA DOT COLON SEMICOLON BAR UP DOT_DOT UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR RIGHT_BRK RIGHT_BRA MINUS_GT }]
  [oclExpression ::= (*) oclExpression DIVIDE oclExpression , {EOF ENDPACKAGE CONTEXT INIT DERIVE INV DEF PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE IN THEN ELSE ENDIF COMMA DOT COLON SEMICOLON BAR UP DOT_DOT UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR RIGHT_BRK RIGHT_BRA MINUS_GT }]
  [oclExpression ::= (*) oclExpression LEFT_PAR arguments RIGHT_PAR , {EOF ENDPACKAGE CONTEXT INIT DERIVE INV DEF PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE IN THEN ELSE ENDIF COMMA DOT COLON SEMICOLON BAR UP DOT_DOT UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR RIGHT_BRK RIGHT_BRA MINUS_GT }]
  [primitiveLiteralExp ::= (*) FALSE , {EOF ENDPACKAGE CONTEXT INIT DERIVE INV DEF PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE IN THEN ELSE ENDIF COMMA DOT COLON SEMICOLON BAR UP DOT_DOT UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR RIGHT_BRK RIGHT_BRA MINUS_GT }]
  [literalExp ::= (*) primitiveLiteralExp , {EOF ENDPACKAGE CONTEXT INIT DERIVE INV DEF PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE IN THEN ELSE ENDIF COMMA DOT COLON SEMICOLON BAR UP DOT_DOT UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR RIGHT_BRK RIGHT_BRA MINUS_GT }]
  [oclExpression ::= (*) LET variableDeclarationList IN oclExpression , {EOF ENDPACKAGE CONTEXT INIT DERIVE INV DEF PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE IN THEN ELSE ENDIF COMMA DOT COLON SEMICOLON BAR UP DOT_DOT UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR RIGHT_BRK RIGHT_BRA MINUS_GT }]
  [oclExpression ::= (*) oclExpression GT oclExpression , {EOF ENDPACKAGE CONTEXT INIT DERIVE INV DEF PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE IN THEN ELSE ENDIF COMMA DOT COLON SEMICOLON BAR UP DOT_DOT UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR RIGHT_BRK RIGHT_BRA MINUS_GT }]
  [oclExpression ::= (*) oclExpression MINUS_GT ITERATE LEFT_PAR variableDeclaration BAR oclExpression RIGHT_PAR , {EOF ENDPACKAGE CONTEXT INIT DERIVE INV DEF PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE IN THEN ELSE ENDIF COMMA DOT COLON SEMICOLON BAR UP DOT_DOT UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR RIGHT_BRK RIGHT_BRA MINUS_GT }]
  [oclExpression ::= (*) literalExp , {EOF ENDPACKAGE CONTEXT INIT DERIVE INV DEF PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE IN THEN ELSE ENDIF COMMA DOT COLON SEMICOLON BAR UP DOT_DOT UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR RIGHT_BRK RIGHT_BRA MINUS_GT }]
  [primitiveLiteralExp ::= (*) INTEGER , {EOF ENDPACKAGE CONTEXT INIT DERIVE INV DEF PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE IN THEN ELSE ENDIF COMMA DOT COLON SEMICOLON BAR UP DOT_DOT UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR RIGHT_BRK RIGHT_BRA MINUS_GT }]
  [collectionKind ::= (*) BAG , {LEFT_BRA }]
  [oclExpression ::= (*) oclExpression AND oclExpression , {EOF ENDPACKAGE CONTEXT INIT DERIVE INV DEF PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE IN THEN ELSE ENDIF COMMA DOT COLON SEMICOLON BAR UP DOT_DOT UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR RIGHT_BRK RIGHT_BRA MINUS_GT }]
  [oclExpression ::= (*) oclExpression PLUS oclExpression , {EOF ENDPACKAGE CONTEXT INIT DERIVE INV DEF PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE IN THEN ELSE ENDIF COMMA DOT COLON SEMICOLON BAR UP DOT_DOT UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR RIGHT_BRK RIGHT_BRA MINUS_GT }]
  [oclExpression ::= (*) oclExpression LEFT_PAR variableDeclaration BAR oclExpression RIGHT_PAR , {EOF ENDPACKAGE CONTEXT INIT DERIVE INV DEF PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE IN THEN ELSE ENDIF COMMA DOT COLON SEMICOLON BAR UP DOT_DOT UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR RIGHT_BRK RIGHT_BRA MINUS_GT }]
  [pathName ::= (*) simpleName , {EOF ENDPACKAGE CONTEXT INIT DERIVE INV DEF PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE IN THEN ELSE ENDIF COMMA DOT COLON SEMICOLON BAR UP AT DOT_DOT COLON_COLON UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR RIGHT_BRK RIGHT_BRA MINUS_GT }]
  [oclExpression ::= (*) oclExpression UP_UP simpleName LEFT_PAR oclMessageArgumentList RIGHT_PAR , {EOF ENDPACKAGE CONTEXT INIT DERIVE INV DEF PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE IN THEN ELSE ENDIF COMMA DOT COLON SEMICOLON BAR UP DOT_DOT UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR RIGHT_BRK RIGHT_BRA MINUS_GT }]
  [oclExpression ::= (*) oclExpression LE oclExpression , {EOF ENDPACKAGE CONTEXT INIT DERIVE INV DEF PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE IN THEN ELSE ENDIF COMMA DOT COLON SEMICOLON BAR UP DOT_DOT UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR RIGHT_BRK RIGHT_BRA MINUS_GT }]
  [oclExpression ::= (*) NOT oclExpression , {EOF ENDPACKAGE CONTEXT INIT DERIVE INV DEF PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE IN THEN ELSE ENDIF COMMA DOT COLON SEMICOLON BAR UP DOT_DOT UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR RIGHT_BRK RIGHT_BRA MINUS_GT }]
  [oclExpression ::= (*) LEFT_PAR oclExpression RIGHT_PAR , {EOF ENDPACKAGE CONTEXT INIT DERIVE INV DEF PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE IN THEN ELSE ENDIF COMMA DOT COLON SEMICOLON BAR UP DOT_DOT UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR RIGHT_BRK RIGHT_BRA MINUS_GT }]
  [primitiveLiteralExp ::= (*) REAL , {EOF ENDPACKAGE CONTEXT INIT DERIVE INV DEF PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE IN THEN ELSE ENDIF COMMA DOT COLON SEMICOLON BAR UP DOT_DOT UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR RIGHT_BRK RIGHT_BRA MINUS_GT }]
  [collectionKind ::= (*) SEQUENCE , {LEFT_BRA }]
  [oclExpression ::= (*) oclExpression OR oclExpression , {EOF ENDPACKAGE CONTEXT INIT DERIVE INV DEF PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE IN THEN ELSE ENDIF COMMA DOT COLON SEMICOLON BAR UP DOT_DOT UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR RIGHT_BRK RIGHT_BRA MINUS_GT }]
  [oclExpression ::= (*) oclExpression MINUS oclExpression , {EOF ENDPACKAGE CONTEXT INIT DERIVE INV DEF PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE IN THEN ELSE ENDIF COMMA DOT COLON SEMICOLON BAR UP DOT_DOT UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR RIGHT_BRK RIGHT_BRA MINUS_GT }]
  [oclExpression ::= (*) oclExpression LEFT_BRK argumentList RIGHT_BRK isMarkedPre , {EOF ENDPACKAGE CONTEXT INIT DERIVE INV DEF PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE IN THEN ELSE ENDIF COMMA DOT COLON SEMICOLON BAR UP DOT_DOT UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR RIGHT_BRK RIGHT_BRA MINUS_GT }]
  [pathName ::= (*) pathName COLON_COLON simpleName , {EOF ENDPACKAGE CONTEXT INIT DERIVE INV DEF PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE IN THEN ELSE ENDIF COMMA DOT COLON SEMICOLON BAR UP AT DOT_DOT COLON_COLON UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR RIGHT_BRK RIGHT_BRA MINUS_GT }]
  [collectionLiteralExp ::= (*) collectionKind LEFT_BRA collectionLiteralParts RIGHT_BRA , {EOF ENDPACKAGE CONTEXT INIT DERIVE INV DEF PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE IN THEN ELSE ENDIF COMMA DOT COLON SEMICOLON BAR UP DOT_DOT UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR RIGHT_BRK RIGHT_BRA MINUS_GT }]
  [oclExpression ::= (*) oclExpression UP_UP simpleName LEFT_PAR RIGHT_PAR , {EOF ENDPACKAGE CONTEXT INIT DERIVE INV DEF PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE IN THEN ELSE ENDIF COMMA DOT COLON SEMICOLON BAR UP DOT_DOT UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR RIGHT_BRK RIGHT_BRA MINUS_GT }]
  [oclExpression ::= (*) oclExpression GE oclExpression , {EOF ENDPACKAGE CONTEXT INIT DERIVE INV DEF PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE IN THEN ELSE ENDIF COMMA DOT COLON SEMICOLON BAR UP DOT_DOT UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR RIGHT_BRK RIGHT_BRA MINUS_GT }]
  [oclExpression ::= MINUS (*) oclExpression , {EOF ENDPACKAGE CONTEXT INIT DERIVE INV DEF PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE IN THEN ELSE ENDIF COMMA DOT COLON SEMICOLON BAR UP DOT_DOT UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR RIGHT_BRK RIGHT_BRA MINUS_GT }]
  [oclExpression ::= (*) MINUS oclExpression , {EOF ENDPACKAGE CONTEXT INIT DERIVE INV DEF PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE IN THEN ELSE ENDIF COMMA DOT COLON SEMICOLON BAR UP DOT_DOT UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR RIGHT_BRK RIGHT_BRA MINUS_GT }]
  [oclExpression ::= (*) pathName isMarkedPre , {EOF ENDPACKAGE CONTEXT INIT DERIVE INV DEF PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE IN THEN ELSE ENDIF COMMA DOT COLON SEMICOLON BAR UP DOT_DOT UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR RIGHT_BRK RIGHT_BRA MINUS_GT }]
  [primitiveLiteralExp ::= (*) STRING , {EOF ENDPACKAGE CONTEXT INIT DERIVE INV DEF PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE IN THEN ELSE ENDIF COMMA DOT COLON SEMICOLON BAR UP DOT_DOT UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR RIGHT_BRK RIGHT_BRA MINUS_GT }]
  [collectionKind ::= (*) COLLECTION , {LEFT_BRA }]
  [literalExp ::= (*) collectionLiteralExp , {EOF ENDPACKAGE CONTEXT INIT DERIVE INV DEF PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE IN THEN ELSE ENDIF COMMA DOT COLON SEMICOLON BAR UP DOT_DOT UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR RIGHT_BRK RIGHT_BRA MINUS_GT }]
  [oclExpression ::= (*) oclExpression XOR oclExpression , {EOF ENDPACKAGE CONTEXT INIT DERIVE INV DEF PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE IN THEN ELSE ENDIF COMMA DOT COLON SEMICOLON BAR UP DOT_DOT UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR RIGHT_BRK RIGHT_BRA MINUS_GT }]
  [oclExpression ::= (*) IF oclExpression THEN oclExpression ELSE oclExpression ENDIF , {EOF ENDPACKAGE CONTEXT INIT DERIVE INV DEF PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE IN THEN ELSE ENDIF COMMA DOT COLON SEMICOLON BAR UP DOT_DOT UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR RIGHT_BRK RIGHT_BRA MINUS_GT }]
  [oclExpression ::= (*) oclExpression MINUS_GT simpleName , {EOF ENDPACKAGE CONTEXT INIT DERIVE INV DEF PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE IN THEN ELSE ENDIF COMMA DOT COLON SEMICOLON BAR UP DOT_DOT UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR RIGHT_BRK RIGHT_BRA MINUS_GT }]
  [simpleName ::= (*) SIMPLE_NAME , {EOF ENDPACKAGE CONTEXT INIT DERIVE INV DEF PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE IN THEN ELSE ENDIF COMMA DOT COLON SEMICOLON BAR UP AT DOT_DOT COLON_COLON UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR RIGHT_BRK RIGHT_BRA MINUS_GT }]
  [collectionLiteralExp ::= (*) collectionKind LEFT_BRA RIGHT_BRA , {EOF ENDPACKAGE CONTEXT INIT DERIVE INV DEF PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE IN THEN ELSE ENDIF COMMA DOT COLON SEMICOLON BAR UP DOT_DOT UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR RIGHT_BRK RIGHT_BRA MINUS_GT }]
}
transition on tupleLiteralExp to state [54]
transition on oclExpression to state [142]
transition on REAL to state [52]
transition on INTEGER to state [51]
transition on pathName to state [50]
transition on SIMPLE_NAME to state [12]
transition on LET to state [49]
transition on FALSE to state [48]
transition on MINUS to state [47]
transition on COLLECTION to state [28]
transition on SET to state [20]
transition on simpleName to state [26]
transition on collectionLiteralExp to state [46]
transition on LEFT_PAR to state [45]
transition on STRING to state [44]
transition on IF to state [43]
transition on TRUE to state [42]
transition on collectionKind to state [41]
transition on NOT to state [40]
transition on primitiveLiteralExp to state [39]
transition on TUPLE to state [38]
transition on literalExp to state [37]
transition on BAG to state [25]
transition on SEQUENCE to state [22]

-------------------
lalr_state [48]: {
  [primitiveLiteralExp ::= FALSE (*) , {EOF ENDPACKAGE CONTEXT INIT DERIVE INV DEF PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE IN THEN ELSE ENDIF COMMA DOT COLON SEMICOLON BAR UP DOT_DOT UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR RIGHT_BRK RIGHT_BRA MINUS_GT }]
}

-------------------
lalr_state [49]: {
  [variableDeclaration ::= (*) simpleName EQ oclExpression , {IN COMMA }]
  [variableDeclarationList ::= (*) variableDeclarationList COMMA variableDeclaration , {IN COMMA }]
  [variableDeclaration ::= (*) simpleName COLON type , {IN COMMA }]
  [simpleName ::= (*) SIMPLE_NAME , {EQ IN COMMA COLON }]
  [variableDeclarationList ::= (*) variableDeclaration , {IN COMMA }]
  [oclExpression ::= LET (*) variableDeclarationList IN oclExpression , {EOF ENDPACKAGE CONTEXT INIT DERIVE INV DEF PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE IN THEN ELSE ENDIF COMMA DOT COLON SEMICOLON BAR UP DOT_DOT UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR RIGHT_BRK RIGHT_BRA MINUS_GT }]
  [variableDeclaration ::= (*) simpleName , {IN COMMA }]
  [variableDeclaration ::= (*) simpleName COLON type EQ oclExpression , {IN COMMA }]
}
transition on SIMPLE_NAME to state [12]
transition on variableDeclaration to state [17]
transition on simpleName to state [16]
transition on variableDeclarationList to state [139]

-------------------
lalr_state [50]: {
  [isMarkedPre ::= (*) AT PRE , {EOF ENDPACKAGE CONTEXT INIT DERIVE INV DEF PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE IN THEN ELSE ENDIF COMMA DOT COLON SEMICOLON BAR UP DOT_DOT UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR RIGHT_BRK RIGHT_BRA MINUS_GT }]
  [isMarkedPre ::= (*) , {EOF ENDPACKAGE CONTEXT INIT DERIVE INV DEF PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE IN THEN ELSE ENDIF COMMA DOT COLON SEMICOLON BAR UP DOT_DOT UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR RIGHT_BRK RIGHT_BRA MINUS_GT }]
  [oclExpression ::= pathName (*) isMarkedPre , {EOF ENDPACKAGE CONTEXT INIT DERIVE INV DEF PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE IN THEN ELSE ENDIF COMMA DOT COLON SEMICOLON BAR UP DOT_DOT UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR RIGHT_BRK RIGHT_BRA MINUS_GT }]
  [pathName ::= pathName (*) COLON_COLON simpleName , {EOF ENDPACKAGE CONTEXT INIT DERIVE INV DEF PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE IN THEN ELSE ENDIF COMMA DOT COLON SEMICOLON BAR UP AT DOT_DOT COLON_COLON UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR RIGHT_BRK RIGHT_BRA MINUS_GT }]
}
transition on COLON_COLON to state [137]
transition on isMarkedPre to state [136]
transition on AT to state [78]

-------------------
lalr_state [51]: {
  [primitiveLiteralExp ::= INTEGER (*) , {EOF ENDPACKAGE CONTEXT INIT DERIVE INV DEF PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE IN THEN ELSE ENDIF COMMA DOT COLON SEMICOLON BAR UP DOT_DOT UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR RIGHT_BRK RIGHT_BRA MINUS_GT }]
}

-------------------
lalr_state [52]: {
  [primitiveLiteralExp ::= REAL (*) , {EOF ENDPACKAGE CONTEXT INIT DERIVE INV DEF PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE IN THEN ELSE ENDIF COMMA DOT COLON SEMICOLON BAR UP DOT_DOT UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR RIGHT_BRK RIGHT_BRA MINUS_GT }]
}

-------------------
lalr_state [53]: {
  [oclExpression ::= oclExpression (*) LEFT_BRK argumentList RIGHT_BRK isMarkedPre , {IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE IN COMMA DOT SEMICOLON BAR UP UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR RIGHT_BRA MINUS_GT }]
  [oclExpression ::= oclExpression (*) EQ oclExpression , {IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE IN COMMA DOT SEMICOLON BAR UP UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR RIGHT_BRA MINUS_GT }]
  [oclExpression ::= oclExpression (*) IMPLIES oclExpression , {IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE IN COMMA DOT SEMICOLON BAR UP UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR RIGHT_BRA MINUS_GT }]
  [oclExpression ::= oclExpression (*) UP simpleName LEFT_PAR RIGHT_PAR , {IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE IN COMMA DOT SEMICOLON BAR UP UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR RIGHT_BRA MINUS_GT }]
  [oclExpression ::= oclExpression (*) LEFT_PAR arguments RIGHT_PAR , {IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE IN COMMA DOT SEMICOLON BAR UP UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR RIGHT_BRA MINUS_GT }]
  [oclExpression ::= oclExpression (*) MINUS_GT ITERATE LEFT_PAR variableDeclaration BAR oclExpression RIGHT_PAR , {IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE IN COMMA DOT SEMICOLON BAR UP UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR RIGHT_BRA MINUS_GT }]
  [oclExpression ::= oclExpression (*) PLUS oclExpression , {IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE IN COMMA DOT SEMICOLON BAR UP UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR RIGHT_BRA MINUS_GT }]
  [oclExpression ::= oclExpression (*) LE oclExpression , {IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE IN COMMA DOT SEMICOLON BAR UP UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR RIGHT_BRA MINUS_GT }]
  [oclExpression ::= oclExpression (*) OR oclExpression , {IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE IN COMMA DOT SEMICOLON BAR UP UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR RIGHT_BRA MINUS_GT }]
  [oclExpression ::= oclExpression (*) UP_UP simpleName LEFT_PAR RIGHT_PAR , {IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE IN COMMA DOT SEMICOLON BAR UP UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR RIGHT_BRA MINUS_GT }]
  [oclExpression ::= oclExpression (*) MINUS_GT simpleName , {IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE IN COMMA DOT SEMICOLON BAR UP UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR RIGHT_BRA MINUS_GT }]
  [oclExpression ::= oclExpression (*) TIMES oclExpression , {IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE IN COMMA DOT SEMICOLON BAR UP UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR RIGHT_BRA MINUS_GT }]
  [oclExpression ::= oclExpression (*) LT oclExpression , {IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE IN COMMA DOT SEMICOLON BAR UP UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR RIGHT_BRA MINUS_GT }]
  [oclExpression ::= oclExpression (*) NE oclExpression , {IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE IN COMMA DOT SEMICOLON BAR UP UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR RIGHT_BRA MINUS_GT }]
  [oclExpression ::= oclExpression (*) LEFT_PAR variableDeclaration BAR oclExpression RIGHT_PAR , {IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE IN COMMA DOT SEMICOLON BAR UP UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR RIGHT_BRA MINUS_GT }]
  [oclExpression ::= oclExpression (*) MINUS oclExpression , {IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE IN COMMA DOT SEMICOLON BAR UP UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR RIGHT_BRA MINUS_GT }]
  [oclExpression ::= oclExpression (*) GE oclExpression , {IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE IN COMMA DOT SEMICOLON BAR UP UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR RIGHT_BRA MINUS_GT }]
  [oclExpression ::= oclExpression (*) XOR oclExpression , {IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE IN COMMA DOT SEMICOLON BAR UP UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR RIGHT_BRA MINUS_GT }]
  [oclExpression ::= oclExpression (*) UP simpleName LEFT_PAR oclMessageArgumentList RIGHT_PAR , {IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE IN COMMA DOT SEMICOLON BAR UP UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR RIGHT_BRA MINUS_GT }]
  [oclExpression ::= oclExpression (*) DOT simpleName isMarkedPre , {IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE IN COMMA DOT SEMICOLON BAR UP UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR RIGHT_BRA MINUS_GT }]
  [oclExpression ::= oclExpression (*) MINUS_GT ITERATE LEFT_PAR variableDeclaration SEMICOLON variableDeclaration BAR oclExpression RIGHT_PAR , {IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE IN COMMA DOT SEMICOLON BAR UP UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR RIGHT_BRA MINUS_GT }]
  [oclExpression ::= oclExpression (*) DIVIDE oclExpression , {IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE IN COMMA DOT SEMICOLON BAR UP UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR RIGHT_BRA MINUS_GT }]
  [variableDeclaration ::= simpleName COLON type EQ oclExpression (*) , {EQ IN COMMA SEMICOLON BAR RIGHT_PAR RIGHT_BRA }]
  [oclExpression ::= oclExpression (*) GT oclExpression , {IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE IN COMMA DOT SEMICOLON BAR UP UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR RIGHT_BRA MINUS_GT }]
  [oclExpression ::= oclExpression (*) AND oclExpression , {IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE IN COMMA DOT SEMICOLON BAR UP UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR RIGHT_BRA MINUS_GT }]
  [oclExpression ::= oclExpression (*) UP_UP simpleName LEFT_PAR oclMessageArgumentList RIGHT_PAR , {IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE IN COMMA DOT SEMICOLON BAR UP UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR RIGHT_BRA MINUS_GT }]
}
transition on XOR to state [74]
transition on EQ to state [73]
transition on DOT to state [72]
transition on MINUS to state [71]
transition on GE to state [70]
transition on LEFT_BRK to state [69]
transition on DIVIDE to state [68]
transition on LEFT_PAR to state [67]
transition on MINUS_GT to state [66]
transition on LE to state [65]
transition on GT to state [64]
transition on IMPLIES to state [63]
transition on UP to state [62]
transition on UP_UP to state [61]
transition on OR to state [60]
transition on PLUS to state [59]
transition on NE to state [58]
transition on LT to state [57]
transition on AND to state [56]
transition on TIMES to state [55]

-------------------
lalr_state [54]: {
  [literalExp ::= tupleLiteralExp (*) , {EOF ENDPACKAGE CONTEXT INIT DERIVE INV DEF PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE IN THEN ELSE ENDIF COMMA DOT COLON SEMICOLON BAR UP DOT_DOT UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR RIGHT_BRK RIGHT_BRA MINUS_GT }]
}

-------------------
lalr_state [55]: {
  [oclExpression ::= (*) oclExpression UP simpleName LEFT_PAR oclMessageArgumentList RIGHT_PAR , {EOF ENDPACKAGE CONTEXT INIT DERIVE INV DEF PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE IN THEN ELSE ENDIF COMMA DOT COLON SEMICOLON BAR UP DOT_DOT UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR RIGHT_BRK RIGHT_BRA MINUS_GT }]
  [oclExpression ::= oclExpression TIMES (*) oclExpression , {EOF ENDPACKAGE CONTEXT INIT DERIVE INV DEF PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE IN THEN ELSE ENDIF COMMA DOT COLON SEMICOLON BAR UP DOT_DOT UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR RIGHT_BRK RIGHT_BRA MINUS_GT }]
  [oclExpression ::= (*) oclExpression EQ oclExpression , {EOF ENDPACKAGE CONTEXT INIT DERIVE INV DEF PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE IN THEN ELSE ENDIF COMMA DOT COLON SEMICOLON BAR UP DOT_DOT UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR RIGHT_BRK RIGHT_BRA MINUS_GT }]
  [oclExpression ::= (*) oclExpression TIMES oclExpression , {EOF ENDPACKAGE CONTEXT INIT DERIVE INV DEF PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE IN THEN ELSE ENDIF COMMA DOT COLON SEMICOLON BAR UP DOT_DOT UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR RIGHT_BRK RIGHT_BRA MINUS_GT }]
  [oclExpression ::= (*) oclExpression DOT simpleName isMarkedPre , {EOF ENDPACKAGE CONTEXT INIT DERIVE INV DEF PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE IN THEN ELSE ENDIF COMMA DOT COLON SEMICOLON BAR UP DOT_DOT UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR RIGHT_BRK RIGHT_BRA MINUS_GT }]
  [primitiveLiteralExp ::= (*) TRUE , {EOF ENDPACKAGE CONTEXT INIT DERIVE INV DEF PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE IN THEN ELSE ENDIF COMMA DOT COLON SEMICOLON BAR UP DOT_DOT UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR RIGHT_BRK RIGHT_BRA MINUS_GT }]
  [literalExp ::= (*) tupleLiteralExp , {EOF ENDPACKAGE CONTEXT INIT DERIVE INV DEF PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE IN THEN ELSE ENDIF COMMA DOT COLON SEMICOLON BAR UP DOT_DOT UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR RIGHT_BRK RIGHT_BRA MINUS_GT }]
  [oclExpression ::= (*) oclExpression IMPLIES oclExpression , {EOF ENDPACKAGE CONTEXT INIT DERIVE INV DEF PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE IN THEN ELSE ENDIF COMMA DOT COLON SEMICOLON BAR UP DOT_DOT UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR RIGHT_BRK RIGHT_BRA MINUS_GT }]
  [oclExpression ::= (*) oclExpression LT oclExpression , {EOF ENDPACKAGE CONTEXT INIT DERIVE INV DEF PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE IN THEN ELSE ENDIF COMMA DOT COLON SEMICOLON BAR UP DOT_DOT UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR RIGHT_BRK RIGHT_BRA MINUS_GT }]
  [oclExpression ::= (*) oclExpression MINUS_GT ITERATE LEFT_PAR variableDeclaration SEMICOLON variableDeclaration BAR oclExpression RIGHT_PAR , {EOF ENDPACKAGE CONTEXT INIT DERIVE INV DEF PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE IN THEN ELSE ENDIF COMMA DOT COLON SEMICOLON BAR UP DOT_DOT UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR RIGHT_BRK RIGHT_BRA MINUS_GT }]
  [tupleLiteralExp ::= (*) TUPLE LEFT_BRA variableDeclarationList RIGHT_BRA , {EOF ENDPACKAGE CONTEXT INIT DERIVE INV DEF PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE IN THEN ELSE ENDIF COMMA DOT COLON SEMICOLON BAR UP DOT_DOT UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR RIGHT_BRK RIGHT_BRA MINUS_GT }]
  [collectionKind ::= (*) SET , {LEFT_BRA }]
  [oclExpression ::= (*) oclExpression UP simpleName LEFT_PAR RIGHT_PAR , {EOF ENDPACKAGE CONTEXT INIT DERIVE INV DEF PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE IN THEN ELSE ENDIF COMMA DOT COLON SEMICOLON BAR UP DOT_DOT UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR RIGHT_BRK RIGHT_BRA MINUS_GT }]
  [oclExpression ::= (*) oclExpression NE oclExpression , {EOF ENDPACKAGE CONTEXT INIT DERIVE INV DEF PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE IN THEN ELSE ENDIF COMMA DOT COLON SEMICOLON BAR UP DOT_DOT UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR RIGHT_BRK RIGHT_BRA MINUS_GT }]
  [oclExpression ::= (*) oclExpression DIVIDE oclExpression , {EOF ENDPACKAGE CONTEXT INIT DERIVE INV DEF PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE IN THEN ELSE ENDIF COMMA DOT COLON SEMICOLON BAR UP DOT_DOT UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR RIGHT_BRK RIGHT_BRA MINUS_GT }]
  [oclExpression ::= (*) oclExpression LEFT_PAR arguments RIGHT_PAR , {EOF ENDPACKAGE CONTEXT INIT DERIVE INV DEF PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE IN THEN ELSE ENDIF COMMA DOT COLON SEMICOLON BAR UP DOT_DOT UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR RIGHT_BRK RIGHT_BRA MINUS_GT }]
  [primitiveLiteralExp ::= (*) FALSE , {EOF ENDPACKAGE CONTEXT INIT DERIVE INV DEF PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE IN THEN ELSE ENDIF COMMA DOT COLON SEMICOLON BAR UP DOT_DOT UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR RIGHT_BRK RIGHT_BRA MINUS_GT }]
  [literalExp ::= (*) primitiveLiteralExp , {EOF ENDPACKAGE CONTEXT INIT DERIVE INV DEF PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE IN THEN ELSE ENDIF COMMA DOT COLON SEMICOLON BAR UP DOT_DOT UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR RIGHT_BRK RIGHT_BRA MINUS_GT }]
  [oclExpression ::= (*) LET variableDeclarationList IN oclExpression , {EOF ENDPACKAGE CONTEXT INIT DERIVE INV DEF PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE IN THEN ELSE ENDIF COMMA DOT COLON SEMICOLON BAR UP DOT_DOT UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR RIGHT_BRK RIGHT_BRA MINUS_GT }]
  [oclExpression ::= (*) oclExpression GT oclExpression , {EOF ENDPACKAGE CONTEXT INIT DERIVE INV DEF PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE IN THEN ELSE ENDIF COMMA DOT COLON SEMICOLON BAR UP DOT_DOT UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR RIGHT_BRK RIGHT_BRA MINUS_GT }]
  [oclExpression ::= (*) oclExpression MINUS_GT ITERATE LEFT_PAR variableDeclaration BAR oclExpression RIGHT_PAR , {EOF ENDPACKAGE CONTEXT INIT DERIVE INV DEF PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE IN THEN ELSE ENDIF COMMA DOT COLON SEMICOLON BAR UP DOT_DOT UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR RIGHT_BRK RIGHT_BRA MINUS_GT }]
  [oclExpression ::= (*) literalExp , {EOF ENDPACKAGE CONTEXT INIT DERIVE INV DEF PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE IN THEN ELSE ENDIF COMMA DOT COLON SEMICOLON BAR UP DOT_DOT UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR RIGHT_BRK RIGHT_BRA MINUS_GT }]
  [primitiveLiteralExp ::= (*) INTEGER , {EOF ENDPACKAGE CONTEXT INIT DERIVE INV DEF PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE IN THEN ELSE ENDIF COMMA DOT COLON SEMICOLON BAR UP DOT_DOT UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR RIGHT_BRK RIGHT_BRA MINUS_GT }]
  [collectionKind ::= (*) BAG , {LEFT_BRA }]
  [oclExpression ::= (*) oclExpression AND oclExpression , {EOF ENDPACKAGE CONTEXT INIT DERIVE INV DEF PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE IN THEN ELSE ENDIF COMMA DOT COLON SEMICOLON BAR UP DOT_DOT UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR RIGHT_BRK RIGHT_BRA MINUS_GT }]
  [oclExpression ::= (*) oclExpression PLUS oclExpression , {EOF ENDPACKAGE CONTEXT INIT DERIVE INV DEF PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE IN THEN ELSE ENDIF COMMA DOT COLON SEMICOLON BAR UP DOT_DOT UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR RIGHT_BRK RIGHT_BRA MINUS_GT }]
  [oclExpression ::= (*) oclExpression LEFT_PAR variableDeclaration BAR oclExpression RIGHT_PAR , {EOF ENDPACKAGE CONTEXT INIT DERIVE INV DEF PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE IN THEN ELSE ENDIF COMMA DOT COLON SEMICOLON BAR UP DOT_DOT UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR RIGHT_BRK RIGHT_BRA MINUS_GT }]
  [pathName ::= (*) simpleName , {EOF ENDPACKAGE CONTEXT INIT DERIVE INV DEF PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE IN THEN ELSE ENDIF COMMA DOT COLON SEMICOLON BAR UP AT DOT_DOT COLON_COLON UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR RIGHT_BRK RIGHT_BRA MINUS_GT }]
  [oclExpression ::= (*) oclExpression UP_UP simpleName LEFT_PAR oclMessageArgumentList RIGHT_PAR , {EOF ENDPACKAGE CONTEXT INIT DERIVE INV DEF PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE IN THEN ELSE ENDIF COMMA DOT COLON SEMICOLON BAR UP DOT_DOT UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR RIGHT_BRK RIGHT_BRA MINUS_GT }]
  [oclExpression ::= (*) oclExpression LE oclExpression , {EOF ENDPACKAGE CONTEXT INIT DERIVE INV DEF PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE IN THEN ELSE ENDIF COMMA DOT COLON SEMICOLON BAR UP DOT_DOT UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR RIGHT_BRK RIGHT_BRA MINUS_GT }]
  [oclExpression ::= (*) NOT oclExpression , {EOF ENDPACKAGE CONTEXT INIT DERIVE INV DEF PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE IN THEN ELSE ENDIF COMMA DOT COLON SEMICOLON BAR UP DOT_DOT UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR RIGHT_BRK RIGHT_BRA MINUS_GT }]
  [oclExpression ::= (*) LEFT_PAR oclExpression RIGHT_PAR , {EOF ENDPACKAGE CONTEXT INIT DERIVE INV DEF PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE IN THEN ELSE ENDIF COMMA DOT COLON SEMICOLON BAR UP DOT_DOT UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR RIGHT_BRK RIGHT_BRA MINUS_GT }]
  [primitiveLiteralExp ::= (*) REAL , {EOF ENDPACKAGE CONTEXT INIT DERIVE INV DEF PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE IN THEN ELSE ENDIF COMMA DOT COLON SEMICOLON BAR UP DOT_DOT UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR RIGHT_BRK RIGHT_BRA MINUS_GT }]
  [collectionKind ::= (*) SEQUENCE , {LEFT_BRA }]
  [oclExpression ::= (*) oclExpression OR oclExpression , {EOF ENDPACKAGE CONTEXT INIT DERIVE INV DEF PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE IN THEN ELSE ENDIF COMMA DOT COLON SEMICOLON BAR UP DOT_DOT UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR RIGHT_BRK RIGHT_BRA MINUS_GT }]
  [oclExpression ::= (*) oclExpression MINUS oclExpression , {EOF ENDPACKAGE CONTEXT INIT DERIVE INV DEF PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE IN THEN ELSE ENDIF COMMA DOT COLON SEMICOLON BAR UP DOT_DOT UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR RIGHT_BRK RIGHT_BRA MINUS_GT }]
  [oclExpression ::= (*) oclExpression LEFT_BRK argumentList RIGHT_BRK isMarkedPre , {EOF ENDPACKAGE CONTEXT INIT DERIVE INV DEF PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE IN THEN ELSE ENDIF COMMA DOT COLON SEMICOLON BAR UP DOT_DOT UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR RIGHT_BRK RIGHT_BRA MINUS_GT }]
  [pathName ::= (*) pathName COLON_COLON simpleName , {EOF ENDPACKAGE CONTEXT INIT DERIVE INV DEF PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE IN THEN ELSE ENDIF COMMA DOT COLON SEMICOLON BAR UP AT DOT_DOT COLON_COLON UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR RIGHT_BRK RIGHT_BRA MINUS_GT }]
  [collectionLiteralExp ::= (*) collectionKind LEFT_BRA collectionLiteralParts RIGHT_BRA , {EOF ENDPACKAGE CONTEXT INIT DERIVE INV DEF PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE IN THEN ELSE ENDIF COMMA DOT COLON SEMICOLON BAR UP DOT_DOT UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR RIGHT_BRK RIGHT_BRA MINUS_GT }]
  [oclExpression ::= (*) oclExpression UP_UP simpleName LEFT_PAR RIGHT_PAR , {EOF ENDPACKAGE CONTEXT INIT DERIVE INV DEF PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE IN THEN ELSE ENDIF COMMA DOT COLON SEMICOLON BAR UP DOT_DOT UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR RIGHT_BRK RIGHT_BRA MINUS_GT }]
  [oclExpression ::= (*) oclExpression GE oclExpression , {EOF ENDPACKAGE CONTEXT INIT DERIVE INV DEF PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE IN THEN ELSE ENDIF COMMA DOT COLON SEMICOLON BAR UP DOT_DOT UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR RIGHT_BRK RIGHT_BRA MINUS_GT }]
  [oclExpression ::= (*) MINUS oclExpression , {EOF ENDPACKAGE CONTEXT INIT DERIVE INV DEF PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE IN THEN ELSE ENDIF COMMA DOT COLON SEMICOLON BAR UP DOT_DOT UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR RIGHT_BRK RIGHT_BRA MINUS_GT }]
  [oclExpression ::= (*) pathName isMarkedPre , {EOF ENDPACKAGE CONTEXT INIT DERIVE INV DEF PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE IN THEN ELSE ENDIF COMMA DOT COLON SEMICOLON BAR UP DOT_DOT UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR RIGHT_BRK RIGHT_BRA MINUS_GT }]
  [primitiveLiteralExp ::= (*) STRING , {EOF ENDPACKAGE CONTEXT INIT DERIVE INV DEF PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE IN THEN ELSE ENDIF COMMA DOT COLON SEMICOLON BAR UP DOT_DOT UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR RIGHT_BRK RIGHT_BRA MINUS_GT }]
  [collectionKind ::= (*) COLLECTION , {LEFT_BRA }]
  [literalExp ::= (*) collectionLiteralExp , {EOF ENDPACKAGE CONTEXT INIT DERIVE INV DEF PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE IN THEN ELSE ENDIF COMMA DOT COLON SEMICOLON BAR UP DOT_DOT UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR RIGHT_BRK RIGHT_BRA MINUS_GT }]
  [oclExpression ::= (*) oclExpression XOR oclExpression , {EOF ENDPACKAGE CONTEXT INIT DERIVE INV DEF PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE IN THEN ELSE ENDIF COMMA DOT COLON SEMICOLON BAR UP DOT_DOT UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR RIGHT_BRK RIGHT_BRA MINUS_GT }]
  [oclExpression ::= (*) IF oclExpression THEN oclExpression ELSE oclExpression ENDIF , {EOF ENDPACKAGE CONTEXT INIT DERIVE INV DEF PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE IN THEN ELSE ENDIF COMMA DOT COLON SEMICOLON BAR UP DOT_DOT UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR RIGHT_BRK RIGHT_BRA MINUS_GT }]
  [oclExpression ::= (*) oclExpression MINUS_GT simpleName , {EOF ENDPACKAGE CONTEXT INIT DERIVE INV DEF PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE IN THEN ELSE ENDIF COMMA DOT COLON SEMICOLON BAR UP DOT_DOT UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR RIGHT_BRK RIGHT_BRA MINUS_GT }]
  [simpleName ::= (*) SIMPLE_NAME , {EOF ENDPACKAGE CONTEXT INIT DERIVE INV DEF PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE IN THEN ELSE ENDIF COMMA DOT COLON SEMICOLON BAR UP AT DOT_DOT COLON_COLON UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR RIGHT_BRK RIGHT_BRA MINUS_GT }]
  [collectionLiteralExp ::= (*) collectionKind LEFT_BRA RIGHT_BRA , {EOF ENDPACKAGE CONTEXT INIT DERIVE INV DEF PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE IN THEN ELSE ENDIF COMMA DOT COLON SEMICOLON BAR UP DOT_DOT UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR RIGHT_BRK RIGHT_BRA MINUS_GT }]
}
transition on tupleLiteralExp to state [54]
transition on oclExpression to state [135]
transition on REAL to state [52]
transition on INTEGER to state [51]
transition on pathName to state [50]
transition on SIMPLE_NAME to state [12]
transition on LET to state [49]
transition on FALSE to state [48]
transition on MINUS to state [47]
transition on COLLECTION to state [28]
transition on SET to state [20]
transition on simpleName to state [26]
transition on collectionLiteralExp to state [46]
transition on LEFT_PAR to state [45]
transition on STRING to state [44]
transition on IF to state [43]
transition on TRUE to state [42]
transition on collectionKind to state [41]
transition on NOT to state [40]
transition on primitiveLiteralExp to state [39]
transition on TUPLE to state [38]
transition on literalExp to state [37]
transition on BAG to state [25]
transition on SEQUENCE to state [22]

-------------------
lalr_state [56]: {
  [oclExpression ::= (*) oclExpression UP simpleName LEFT_PAR oclMessageArgumentList RIGHT_PAR , {EOF ENDPACKAGE CONTEXT INIT DERIVE INV DEF PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE IN THEN ELSE ENDIF COMMA DOT COLON SEMICOLON BAR UP DOT_DOT UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR RIGHT_BRK RIGHT_BRA MINUS_GT }]
  [oclExpression ::= (*) oclExpression EQ oclExpression , {EOF ENDPACKAGE CONTEXT INIT DERIVE INV DEF PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE IN THEN ELSE ENDIF COMMA DOT COLON SEMICOLON BAR UP DOT_DOT UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR RIGHT_BRK RIGHT_BRA MINUS_GT }]
  [oclExpression ::= (*) oclExpression TIMES oclExpression , {EOF ENDPACKAGE CONTEXT INIT DERIVE INV DEF PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE IN THEN ELSE ENDIF COMMA DOT COLON SEMICOLON BAR UP DOT_DOT UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR RIGHT_BRK RIGHT_BRA MINUS_GT }]
  [oclExpression ::= (*) oclExpression DOT simpleName isMarkedPre , {EOF ENDPACKAGE CONTEXT INIT DERIVE INV DEF PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE IN THEN ELSE ENDIF COMMA DOT COLON SEMICOLON BAR UP DOT_DOT UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR RIGHT_BRK RIGHT_BRA MINUS_GT }]
  [primitiveLiteralExp ::= (*) TRUE , {EOF ENDPACKAGE CONTEXT INIT DERIVE INV DEF PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE IN THEN ELSE ENDIF COMMA DOT COLON SEMICOLON BAR UP DOT_DOT UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR RIGHT_BRK RIGHT_BRA MINUS_GT }]
  [literalExp ::= (*) tupleLiteralExp , {EOF ENDPACKAGE CONTEXT INIT DERIVE INV DEF PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE IN THEN ELSE ENDIF COMMA DOT COLON SEMICOLON BAR UP DOT_DOT UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR RIGHT_BRK RIGHT_BRA MINUS_GT }]
  [oclExpression ::= (*) oclExpression IMPLIES oclExpression , {EOF ENDPACKAGE CONTEXT INIT DERIVE INV DEF PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE IN THEN ELSE ENDIF COMMA DOT COLON SEMICOLON BAR UP DOT_DOT UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR RIGHT_BRK RIGHT_BRA MINUS_GT }]
  [oclExpression ::= (*) oclExpression LT oclExpression , {EOF ENDPACKAGE CONTEXT INIT DERIVE INV DEF PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE IN THEN ELSE ENDIF COMMA DOT COLON SEMICOLON BAR UP DOT_DOT UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR RIGHT_BRK RIGHT_BRA MINUS_GT }]
  [oclExpression ::= (*) oclExpression MINUS_GT ITERATE LEFT_PAR variableDeclaration SEMICOLON variableDeclaration BAR oclExpression RIGHT_PAR , {EOF ENDPACKAGE CONTEXT INIT DERIVE INV DEF PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE IN THEN ELSE ENDIF COMMA DOT COLON SEMICOLON BAR UP DOT_DOT UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR RIGHT_BRK RIGHT_BRA MINUS_GT }]
  [tupleLiteralExp ::= (*) TUPLE LEFT_BRA variableDeclarationList RIGHT_BRA , {EOF ENDPACKAGE CONTEXT INIT DERIVE INV DEF PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE IN THEN ELSE ENDIF COMMA DOT COLON SEMICOLON BAR UP DOT_DOT UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR RIGHT_BRK RIGHT_BRA MINUS_GT }]
  [collectionKind ::= (*) SET , {LEFT_BRA }]
  [oclExpression ::= (*) oclExpression UP simpleName LEFT_PAR RIGHT_PAR , {EOF ENDPACKAGE CONTEXT INIT DERIVE INV DEF PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE IN THEN ELSE ENDIF COMMA DOT COLON SEMICOLON BAR UP DOT_DOT UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR RIGHT_BRK RIGHT_BRA MINUS_GT }]
  [oclExpression ::= (*) oclExpression NE oclExpression , {EOF ENDPACKAGE CONTEXT INIT DERIVE INV DEF PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE IN THEN ELSE ENDIF COMMA DOT COLON SEMICOLON BAR UP DOT_DOT UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR RIGHT_BRK RIGHT_BRA MINUS_GT }]
  [oclExpression ::= (*) oclExpression DIVIDE oclExpression , {EOF ENDPACKAGE CONTEXT INIT DERIVE INV DEF PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE IN THEN ELSE ENDIF COMMA DOT COLON SEMICOLON BAR UP DOT_DOT UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR RIGHT_BRK RIGHT_BRA MINUS_GT }]
  [oclExpression ::= (*) oclExpression LEFT_PAR arguments RIGHT_PAR , {EOF ENDPACKAGE CONTEXT INIT DERIVE INV DEF PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE IN THEN ELSE ENDIF COMMA DOT COLON SEMICOLON BAR UP DOT_DOT UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR RIGHT_BRK RIGHT_BRA MINUS_GT }]
  [primitiveLiteralExp ::= (*) FALSE , {EOF ENDPACKAGE CONTEXT INIT DERIVE INV DEF PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE IN THEN ELSE ENDIF COMMA DOT COLON SEMICOLON BAR UP DOT_DOT UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR RIGHT_BRK RIGHT_BRA MINUS_GT }]
  [literalExp ::= (*) primitiveLiteralExp , {EOF ENDPACKAGE CONTEXT INIT DERIVE INV DEF PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE IN THEN ELSE ENDIF COMMA DOT COLON SEMICOLON BAR UP DOT_DOT UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR RIGHT_BRK RIGHT_BRA MINUS_GT }]
  [oclExpression ::= (*) LET variableDeclarationList IN oclExpression , {EOF ENDPACKAGE CONTEXT INIT DERIVE INV DEF PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE IN THEN ELSE ENDIF COMMA DOT COLON SEMICOLON BAR UP DOT_DOT UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR RIGHT_BRK RIGHT_BRA MINUS_GT }]
  [oclExpression ::= (*) oclExpression GT oclExpression , {EOF ENDPACKAGE CONTEXT INIT DERIVE INV DEF PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE IN THEN ELSE ENDIF COMMA DOT COLON SEMICOLON BAR UP DOT_DOT UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR RIGHT_BRK RIGHT_BRA MINUS_GT }]
  [oclExpression ::= (*) oclExpression MINUS_GT ITERATE LEFT_PAR variableDeclaration BAR oclExpression RIGHT_PAR , {EOF ENDPACKAGE CONTEXT INIT DERIVE INV DEF PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE IN THEN ELSE ENDIF COMMA DOT COLON SEMICOLON BAR UP DOT_DOT UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR RIGHT_BRK RIGHT_BRA MINUS_GT }]
  [oclExpression ::= (*) literalExp , {EOF ENDPACKAGE CONTEXT INIT DERIVE INV DEF PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE IN THEN ELSE ENDIF COMMA DOT COLON SEMICOLON BAR UP DOT_DOT UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR RIGHT_BRK RIGHT_BRA MINUS_GT }]
  [primitiveLiteralExp ::= (*) INTEGER , {EOF ENDPACKAGE CONTEXT INIT DERIVE INV DEF PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE IN THEN ELSE ENDIF COMMA DOT COLON SEMICOLON BAR UP DOT_DOT UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR RIGHT_BRK RIGHT_BRA MINUS_GT }]
  [collectionKind ::= (*) BAG , {LEFT_BRA }]
  [oclExpression ::= oclExpression AND (*) oclExpression , {EOF ENDPACKAGE CONTEXT INIT DERIVE INV DEF PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE IN THEN ELSE ENDIF COMMA DOT COLON SEMICOLON BAR UP DOT_DOT UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR RIGHT_BRK RIGHT_BRA MINUS_GT }]
  [oclExpression ::= (*) oclExpression AND oclExpression , {EOF ENDPACKAGE CONTEXT INIT DERIVE INV DEF PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE IN THEN ELSE ENDIF COMMA DOT COLON SEMICOLON BAR UP DOT_DOT UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR RIGHT_BRK RIGHT_BRA MINUS_GT }]
  [oclExpression ::= (*) oclExpression PLUS oclExpression , {EOF ENDPACKAGE CONTEXT INIT DERIVE INV DEF PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE IN THEN ELSE ENDIF COMMA DOT COLON SEMICOLON BAR UP DOT_DOT UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR RIGHT_BRK RIGHT_BRA MINUS_GT }]
  [oclExpression ::= (*) oclExpression LEFT_PAR variableDeclaration BAR oclExpression RIGHT_PAR , {EOF ENDPACKAGE CONTEXT INIT DERIVE INV DEF PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE IN THEN ELSE ENDIF COMMA DOT COLON SEMICOLON BAR UP DOT_DOT UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR RIGHT_BRK RIGHT_BRA MINUS_GT }]
  [pathName ::= (*) simpleName , {EOF ENDPACKAGE CONTEXT INIT DERIVE INV DEF PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE IN THEN ELSE ENDIF COMMA DOT COLON SEMICOLON BAR UP AT DOT_DOT COLON_COLON UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR RIGHT_BRK RIGHT_BRA MINUS_GT }]
  [oclExpression ::= (*) oclExpression UP_UP simpleName LEFT_PAR oclMessageArgumentList RIGHT_PAR , {EOF ENDPACKAGE CONTEXT INIT DERIVE INV DEF PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE IN THEN ELSE ENDIF COMMA DOT COLON SEMICOLON BAR UP DOT_DOT UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR RIGHT_BRK RIGHT_BRA MINUS_GT }]
  [oclExpression ::= (*) oclExpression LE oclExpression , {EOF ENDPACKAGE CONTEXT INIT DERIVE INV DEF PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE IN THEN ELSE ENDIF COMMA DOT COLON SEMICOLON BAR UP DOT_DOT UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR RIGHT_BRK RIGHT_BRA MINUS_GT }]
  [oclExpression ::= (*) NOT oclExpression , {EOF ENDPACKAGE CONTEXT INIT DERIVE INV DEF PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE IN THEN ELSE ENDIF COMMA DOT COLON SEMICOLON BAR UP DOT_DOT UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR RIGHT_BRK RIGHT_BRA MINUS_GT }]
  [oclExpression ::= (*) LEFT_PAR oclExpression RIGHT_PAR , {EOF ENDPACKAGE CONTEXT INIT DERIVE INV DEF PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE IN THEN ELSE ENDIF COMMA DOT COLON SEMICOLON BAR UP DOT_DOT UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR RIGHT_BRK RIGHT_BRA MINUS_GT }]
  [primitiveLiteralExp ::= (*) REAL , {EOF ENDPACKAGE CONTEXT INIT DERIVE INV DEF PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE IN THEN ELSE ENDIF COMMA DOT COLON SEMICOLON BAR UP DOT_DOT UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR RIGHT_BRK RIGHT_BRA MINUS_GT }]
  [collectionKind ::= (*) SEQUENCE , {LEFT_BRA }]
  [oclExpression ::= (*) oclExpression OR oclExpression , {EOF ENDPACKAGE CONTEXT INIT DERIVE INV DEF PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE IN THEN ELSE ENDIF COMMA DOT COLON SEMICOLON BAR UP DOT_DOT UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR RIGHT_BRK RIGHT_BRA MINUS_GT }]
  [oclExpression ::= (*) oclExpression MINUS oclExpression , {EOF ENDPACKAGE CONTEXT INIT DERIVE INV DEF PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE IN THEN ELSE ENDIF COMMA DOT COLON SEMICOLON BAR UP DOT_DOT UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR RIGHT_BRK RIGHT_BRA MINUS_GT }]
  [oclExpression ::= (*) oclExpression LEFT_BRK argumentList RIGHT_BRK isMarkedPre , {EOF ENDPACKAGE CONTEXT INIT DERIVE INV DEF PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE IN THEN ELSE ENDIF COMMA DOT COLON SEMICOLON BAR UP DOT_DOT UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR RIGHT_BRK RIGHT_BRA MINUS_GT }]
  [pathName ::= (*) pathName COLON_COLON simpleName , {EOF ENDPACKAGE CONTEXT INIT DERIVE INV DEF PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE IN THEN ELSE ENDIF COMMA DOT COLON SEMICOLON BAR UP AT DOT_DOT COLON_COLON UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR RIGHT_BRK RIGHT_BRA MINUS_GT }]
  [collectionLiteralExp ::= (*) collectionKind LEFT_BRA collectionLiteralParts RIGHT_BRA , {EOF ENDPACKAGE CONTEXT INIT DERIVE INV DEF PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE IN THEN ELSE ENDIF COMMA DOT COLON SEMICOLON BAR UP DOT_DOT UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR RIGHT_BRK RIGHT_BRA MINUS_GT }]
  [oclExpression ::= (*) oclExpression UP_UP simpleName LEFT_PAR RIGHT_PAR , {EOF ENDPACKAGE CONTEXT INIT DERIVE INV DEF PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE IN THEN ELSE ENDIF COMMA DOT COLON SEMICOLON BAR UP DOT_DOT UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR RIGHT_BRK RIGHT_BRA MINUS_GT }]
  [oclExpression ::= (*) oclExpression GE oclExpression , {EOF ENDPACKAGE CONTEXT INIT DERIVE INV DEF PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE IN THEN ELSE ENDIF COMMA DOT COLON SEMICOLON BAR UP DOT_DOT UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR RIGHT_BRK RIGHT_BRA MINUS_GT }]
  [oclExpression ::= (*) MINUS oclExpression , {EOF ENDPACKAGE CONTEXT INIT DERIVE INV DEF PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE IN THEN ELSE ENDIF COMMA DOT COLON SEMICOLON BAR UP DOT_DOT UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR RIGHT_BRK RIGHT_BRA MINUS_GT }]
  [oclExpression ::= (*) pathName isMarkedPre , {EOF ENDPACKAGE CONTEXT INIT DERIVE INV DEF PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE IN THEN ELSE ENDIF COMMA DOT COLON SEMICOLON BAR UP DOT_DOT UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR RIGHT_BRK RIGHT_BRA MINUS_GT }]
  [primitiveLiteralExp ::= (*) STRING , {EOF ENDPACKAGE CONTEXT INIT DERIVE INV DEF PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE IN THEN ELSE ENDIF COMMA DOT COLON SEMICOLON BAR UP DOT_DOT UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR RIGHT_BRK RIGHT_BRA MINUS_GT }]
  [collectionKind ::= (*) COLLECTION , {LEFT_BRA }]
  [literalExp ::= (*) collectionLiteralExp , {EOF ENDPACKAGE CONTEXT INIT DERIVE INV DEF PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE IN THEN ELSE ENDIF COMMA DOT COLON SEMICOLON BAR UP DOT_DOT UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR RIGHT_BRK RIGHT_BRA MINUS_GT }]
  [oclExpression ::= (*) oclExpression XOR oclExpression , {EOF ENDPACKAGE CONTEXT INIT DERIVE INV DEF PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE IN THEN ELSE ENDIF COMMA DOT COLON SEMICOLON BAR UP DOT_DOT UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR RIGHT_BRK RIGHT_BRA MINUS_GT }]
  [oclExpression ::= (*) IF oclExpression THEN oclExpression ELSE oclExpression ENDIF , {EOF ENDPACKAGE CONTEXT INIT DERIVE INV DEF PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE IN THEN ELSE ENDIF COMMA DOT COLON SEMICOLON BAR UP DOT_DOT UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR RIGHT_BRK RIGHT_BRA MINUS_GT }]
  [oclExpression ::= (*) oclExpression MINUS_GT simpleName , {EOF ENDPACKAGE CONTEXT INIT DERIVE INV DEF PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE IN THEN ELSE ENDIF COMMA DOT COLON SEMICOLON BAR UP DOT_DOT UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR RIGHT_BRK RIGHT_BRA MINUS_GT }]
  [simpleName ::= (*) SIMPLE_NAME , {EOF ENDPACKAGE CONTEXT INIT DERIVE INV DEF PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE IN THEN ELSE ENDIF COMMA DOT COLON SEMICOLON BAR UP AT DOT_DOT COLON_COLON UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR RIGHT_BRK RIGHT_BRA MINUS_GT }]
  [collectionLiteralExp ::= (*) collectionKind LEFT_BRA RIGHT_BRA , {EOF ENDPACKAGE CONTEXT INIT DERIVE INV DEF PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE IN THEN ELSE ENDIF COMMA DOT COLON SEMICOLON BAR UP DOT_DOT UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR RIGHT_BRK RIGHT_BRA MINUS_GT }]
}
transition on tupleLiteralExp to state [54]
transition on oclExpression to state [134]
transition on REAL to state [52]
transition on INTEGER to state [51]
transition on pathName to state [50]
transition on SIMPLE_NAME to state [12]
transition on LET to state [49]
transition on FALSE to state [48]
transition on MINUS to state [47]
transition on COLLECTION to state [28]
transition on SET to state [20]
transition on simpleName to state [26]
transition on collectionLiteralExp to state [46]
transition on LEFT_PAR to state [45]
transition on STRING to state [44]
transition on IF to state [43]
transition on TRUE to state [42]
transition on collectionKind to state [41]
transition on NOT to state [40]
transition on primitiveLiteralExp to state [39]
transition on TUPLE to state [38]
transition on literalExp to state [37]
transition on BAG to state [25]
transition on SEQUENCE to state [22]

-------------------
lalr_state [57]: {
  [oclExpression ::= (*) oclExpression UP simpleName LEFT_PAR oclMessageArgumentList RIGHT_PAR , {EOF ENDPACKAGE CONTEXT INIT DERIVE INV DEF PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE IN THEN ELSE ENDIF COMMA DOT COLON SEMICOLON BAR UP DOT_DOT UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR RIGHT_BRK RIGHT_BRA MINUS_GT }]
  [oclExpression ::= (*) oclExpression EQ oclExpression , {EOF ENDPACKAGE CONTEXT INIT DERIVE INV DEF PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE IN THEN ELSE ENDIF COMMA DOT COLON SEMICOLON BAR UP DOT_DOT UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR RIGHT_BRK RIGHT_BRA MINUS_GT }]
  [oclExpression ::= (*) oclExpression TIMES oclExpression , {EOF ENDPACKAGE CONTEXT INIT DERIVE INV DEF PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE IN THEN ELSE ENDIF COMMA DOT COLON SEMICOLON BAR UP DOT_DOT UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR RIGHT_BRK RIGHT_BRA MINUS_GT }]
  [oclExpression ::= (*) oclExpression DOT simpleName isMarkedPre , {EOF ENDPACKAGE CONTEXT INIT DERIVE INV DEF PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE IN THEN ELSE ENDIF COMMA DOT COLON SEMICOLON BAR UP DOT_DOT UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR RIGHT_BRK RIGHT_BRA MINUS_GT }]
  [primitiveLiteralExp ::= (*) TRUE , {EOF ENDPACKAGE CONTEXT INIT DERIVE INV DEF PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE IN THEN ELSE ENDIF COMMA DOT COLON SEMICOLON BAR UP DOT_DOT UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR RIGHT_BRK RIGHT_BRA MINUS_GT }]
  [literalExp ::= (*) tupleLiteralExp , {EOF ENDPACKAGE CONTEXT INIT DERIVE INV DEF PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE IN THEN ELSE ENDIF COMMA DOT COLON SEMICOLON BAR UP DOT_DOT UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR RIGHT_BRK RIGHT_BRA MINUS_GT }]
  [oclExpression ::= oclExpression LT (*) oclExpression , {EOF ENDPACKAGE CONTEXT INIT DERIVE INV DEF PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE IN THEN ELSE ENDIF COMMA DOT COLON SEMICOLON BAR UP DOT_DOT UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR RIGHT_BRK RIGHT_BRA MINUS_GT }]
  [oclExpression ::= (*) oclExpression IMPLIES oclExpression , {EOF ENDPACKAGE CONTEXT INIT DERIVE INV DEF PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE IN THEN ELSE ENDIF COMMA DOT COLON SEMICOLON BAR UP DOT_DOT UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR RIGHT_BRK RIGHT_BRA MINUS_GT }]
  [oclExpression ::= (*) oclExpression LT oclExpression , {EOF ENDPACKAGE CONTEXT INIT DERIVE INV DEF PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE IN THEN ELSE ENDIF COMMA DOT COLON SEMICOLON BAR UP DOT_DOT UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR RIGHT_BRK RIGHT_BRA MINUS_GT }]
  [oclExpression ::= (*) oclExpression MINUS_GT ITERATE LEFT_PAR variableDeclaration SEMICOLON variableDeclaration BAR oclExpression RIGHT_PAR , {EOF ENDPACKAGE CONTEXT INIT DERIVE INV DEF PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE IN THEN ELSE ENDIF COMMA DOT COLON SEMICOLON BAR UP DOT_DOT UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR RIGHT_BRK RIGHT_BRA MINUS_GT }]
  [tupleLiteralExp ::= (*) TUPLE LEFT_BRA variableDeclarationList RIGHT_BRA , {EOF ENDPACKAGE CONTEXT INIT DERIVE INV DEF PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE IN THEN ELSE ENDIF COMMA DOT COLON SEMICOLON BAR UP DOT_DOT UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR RIGHT_BRK RIGHT_BRA MINUS_GT }]
  [collectionKind ::= (*) SET , {LEFT_BRA }]
  [oclExpression ::= (*) oclExpression UP simpleName LEFT_PAR RIGHT_PAR , {EOF ENDPACKAGE CONTEXT INIT DERIVE INV DEF PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE IN THEN ELSE ENDIF COMMA DOT COLON SEMICOLON BAR UP DOT_DOT UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR RIGHT_BRK RIGHT_BRA MINUS_GT }]
  [oclExpression ::= (*) oclExpression NE oclExpression , {EOF ENDPACKAGE CONTEXT INIT DERIVE INV DEF PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE IN THEN ELSE ENDIF COMMA DOT COLON SEMICOLON BAR UP DOT_DOT UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR RIGHT_BRK RIGHT_BRA MINUS_GT }]
  [oclExpression ::= (*) oclExpression DIVIDE oclExpression , {EOF ENDPACKAGE CONTEXT INIT DERIVE INV DEF PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE IN THEN ELSE ENDIF COMMA DOT COLON SEMICOLON BAR UP DOT_DOT UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR RIGHT_BRK RIGHT_BRA MINUS_GT }]
  [oclExpression ::= (*) oclExpression LEFT_PAR arguments RIGHT_PAR , {EOF ENDPACKAGE CONTEXT INIT DERIVE INV DEF PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE IN THEN ELSE ENDIF COMMA DOT COLON SEMICOLON BAR UP DOT_DOT UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR RIGHT_BRK RIGHT_BRA MINUS_GT }]
  [primitiveLiteralExp ::= (*) FALSE , {EOF ENDPACKAGE CONTEXT INIT DERIVE INV DEF PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE IN THEN ELSE ENDIF COMMA DOT COLON SEMICOLON BAR UP DOT_DOT UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR RIGHT_BRK RIGHT_BRA MINUS_GT }]
  [literalExp ::= (*) primitiveLiteralExp , {EOF ENDPACKAGE CONTEXT INIT DERIVE INV DEF PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE IN THEN ELSE ENDIF COMMA DOT COLON SEMICOLON BAR UP DOT_DOT UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR RIGHT_BRK RIGHT_BRA MINUS_GT }]
  [oclExpression ::= (*) LET variableDeclarationList IN oclExpression , {EOF ENDPACKAGE CONTEXT INIT DERIVE INV DEF PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE IN THEN ELSE ENDIF COMMA DOT COLON SEMICOLON BAR UP DOT_DOT UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR RIGHT_BRK RIGHT_BRA MINUS_GT }]
  [oclExpression ::= (*) oclExpression GT oclExpression , {EOF ENDPACKAGE CONTEXT INIT DERIVE INV DEF PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE IN THEN ELSE ENDIF COMMA DOT COLON SEMICOLON BAR UP DOT_DOT UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR RIGHT_BRK RIGHT_BRA MINUS_GT }]
  [oclExpression ::= (*) oclExpression MINUS_GT ITERATE LEFT_PAR variableDeclaration BAR oclExpression RIGHT_PAR , {EOF ENDPACKAGE CONTEXT INIT DERIVE INV DEF PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE IN THEN ELSE ENDIF COMMA DOT COLON SEMICOLON BAR UP DOT_DOT UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR RIGHT_BRK RIGHT_BRA MINUS_GT }]
  [oclExpression ::= (*) literalExp , {EOF ENDPACKAGE CONTEXT INIT DERIVE INV DEF PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE IN THEN ELSE ENDIF COMMA DOT COLON SEMICOLON BAR UP DOT_DOT UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR RIGHT_BRK RIGHT_BRA MINUS_GT }]
  [primitiveLiteralExp ::= (*) INTEGER , {EOF ENDPACKAGE CONTEXT INIT DERIVE INV DEF PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE IN THEN ELSE ENDIF COMMA DOT COLON SEMICOLON BAR UP DOT_DOT UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR RIGHT_BRK RIGHT_BRA MINUS_GT }]
  [collectionKind ::= (*) BAG , {LEFT_BRA }]
  [oclExpression ::= (*) oclExpression AND oclExpression , {EOF ENDPACKAGE CONTEXT INIT DERIVE INV DEF PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE IN THEN ELSE ENDIF COMMA DOT COLON SEMICOLON BAR UP DOT_DOT UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR RIGHT_BRK RIGHT_BRA MINUS_GT }]
  [oclExpression ::= (*) oclExpression PLUS oclExpression , {EOF ENDPACKAGE CONTEXT INIT DERIVE INV DEF PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE IN THEN ELSE ENDIF COMMA DOT COLON SEMICOLON BAR UP DOT_DOT UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR RIGHT_BRK RIGHT_BRA MINUS_GT }]
  [oclExpression ::= (*) oclExpression LEFT_PAR variableDeclaration BAR oclExpression RIGHT_PAR , {EOF ENDPACKAGE CONTEXT INIT DERIVE INV DEF PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE IN THEN ELSE ENDIF COMMA DOT COLON SEMICOLON BAR UP DOT_DOT UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR RIGHT_BRK RIGHT_BRA MINUS_GT }]
  [pathName ::= (*) simpleName , {EOF ENDPACKAGE CONTEXT INIT DERIVE INV DEF PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE IN THEN ELSE ENDIF COMMA DOT COLON SEMICOLON BAR UP AT DOT_DOT COLON_COLON UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR RIGHT_BRK RIGHT_BRA MINUS_GT }]
  [oclExpression ::= (*) oclExpression UP_UP simpleName LEFT_PAR oclMessageArgumentList RIGHT_PAR , {EOF ENDPACKAGE CONTEXT INIT DERIVE INV DEF PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE IN THEN ELSE ENDIF COMMA DOT COLON SEMICOLON BAR UP DOT_DOT UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR RIGHT_BRK RIGHT_BRA MINUS_GT }]
  [oclExpression ::= (*) oclExpression LE oclExpression , {EOF ENDPACKAGE CONTEXT INIT DERIVE INV DEF PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE IN THEN ELSE ENDIF COMMA DOT COLON SEMICOLON BAR UP DOT_DOT UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR RIGHT_BRK RIGHT_BRA MINUS_GT }]
  [oclExpression ::= (*) NOT oclExpression , {EOF ENDPACKAGE CONTEXT INIT DERIVE INV DEF PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE IN THEN ELSE ENDIF COMMA DOT COLON SEMICOLON BAR UP DOT_DOT UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR RIGHT_BRK RIGHT_BRA MINUS_GT }]
  [oclExpression ::= (*) LEFT_PAR oclExpression RIGHT_PAR , {EOF ENDPACKAGE CONTEXT INIT DERIVE INV DEF PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE IN THEN ELSE ENDIF COMMA DOT COLON SEMICOLON BAR UP DOT_DOT UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR RIGHT_BRK RIGHT_BRA MINUS_GT }]
  [primitiveLiteralExp ::= (*) REAL , {EOF ENDPACKAGE CONTEXT INIT DERIVE INV DEF PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE IN THEN ELSE ENDIF COMMA DOT COLON SEMICOLON BAR UP DOT_DOT UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR RIGHT_BRK RIGHT_BRA MINUS_GT }]
  [collectionKind ::= (*) SEQUENCE , {LEFT_BRA }]
  [oclExpression ::= (*) oclExpression OR oclExpression , {EOF ENDPACKAGE CONTEXT INIT DERIVE INV DEF PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE IN THEN ELSE ENDIF COMMA DOT COLON SEMICOLON BAR UP DOT_DOT UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR RIGHT_BRK RIGHT_BRA MINUS_GT }]
  [oclExpression ::= (*) oclExpression MINUS oclExpression , {EOF ENDPACKAGE CONTEXT INIT DERIVE INV DEF PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE IN THEN ELSE ENDIF COMMA DOT COLON SEMICOLON BAR UP DOT_DOT UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR RIGHT_BRK RIGHT_BRA MINUS_GT }]
  [oclExpression ::= (*) oclExpression LEFT_BRK argumentList RIGHT_BRK isMarkedPre , {EOF ENDPACKAGE CONTEXT INIT DERIVE INV DEF PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE IN THEN ELSE ENDIF COMMA DOT COLON SEMICOLON BAR UP DOT_DOT UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR RIGHT_BRK RIGHT_BRA MINUS_GT }]
  [pathName ::= (*) pathName COLON_COLON simpleName , {EOF ENDPACKAGE CONTEXT INIT DERIVE INV DEF PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE IN THEN ELSE ENDIF COMMA DOT COLON SEMICOLON BAR UP AT DOT_DOT COLON_COLON UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR RIGHT_BRK RIGHT_BRA MINUS_GT }]
  [collectionLiteralExp ::= (*) collectionKind LEFT_BRA collectionLiteralParts RIGHT_BRA , {EOF ENDPACKAGE CONTEXT INIT DERIVE INV DEF PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE IN THEN ELSE ENDIF COMMA DOT COLON SEMICOLON BAR UP DOT_DOT UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR RIGHT_BRK RIGHT_BRA MINUS_GT }]
  [oclExpression ::= (*) oclExpression UP_UP simpleName LEFT_PAR RIGHT_PAR , {EOF ENDPACKAGE CONTEXT INIT DERIVE INV DEF PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE IN THEN ELSE ENDIF COMMA DOT COLON SEMICOLON BAR UP DOT_DOT UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR RIGHT_BRK RIGHT_BRA MINUS_GT }]
  [oclExpression ::= (*) oclExpression GE oclExpression , {EOF ENDPACKAGE CONTEXT INIT DERIVE INV DEF PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE IN THEN ELSE ENDIF COMMA DOT COLON SEMICOLON BAR UP DOT_DOT UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR RIGHT_BRK RIGHT_BRA MINUS_GT }]
  [oclExpression ::= (*) MINUS oclExpression , {EOF ENDPACKAGE CONTEXT INIT DERIVE INV DEF PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE IN THEN ELSE ENDIF COMMA DOT COLON SEMICOLON BAR UP DOT_DOT UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR RIGHT_BRK RIGHT_BRA MINUS_GT }]
  [oclExpression ::= (*) pathName isMarkedPre , {EOF ENDPACKAGE CONTEXT INIT DERIVE INV DEF PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE IN THEN ELSE ENDIF COMMA DOT COLON SEMICOLON BAR UP DOT_DOT UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR RIGHT_BRK RIGHT_BRA MINUS_GT }]
  [primitiveLiteralExp ::= (*) STRING , {EOF ENDPACKAGE CONTEXT INIT DERIVE INV DEF PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE IN THEN ELSE ENDIF COMMA DOT COLON SEMICOLON BAR UP DOT_DOT UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR RIGHT_BRK RIGHT_BRA MINUS_GT }]
  [collectionKind ::= (*) COLLECTION , {LEFT_BRA }]
  [literalExp ::= (*) collectionLiteralExp , {EOF ENDPACKAGE CONTEXT INIT DERIVE INV DEF PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE IN THEN ELSE ENDIF COMMA DOT COLON SEMICOLON BAR UP DOT_DOT UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR RIGHT_BRK RIGHT_BRA MINUS_GT }]
  [oclExpression ::= (*) oclExpression XOR oclExpression , {EOF ENDPACKAGE CONTEXT INIT DERIVE INV DEF PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE IN THEN ELSE ENDIF COMMA DOT COLON SEMICOLON BAR UP DOT_DOT UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR RIGHT_BRK RIGHT_BRA MINUS_GT }]
  [oclExpression ::= (*) IF oclExpression THEN oclExpression ELSE oclExpression ENDIF , {EOF ENDPACKAGE CONTEXT INIT DERIVE INV DEF PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE IN THEN ELSE ENDIF COMMA DOT COLON SEMICOLON BAR UP DOT_DOT UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR RIGHT_BRK RIGHT_BRA MINUS_GT }]
  [oclExpression ::= (*) oclExpression MINUS_GT simpleName , {EOF ENDPACKAGE CONTEXT INIT DERIVE INV DEF PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE IN THEN ELSE ENDIF COMMA DOT COLON SEMICOLON BAR UP DOT_DOT UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR RIGHT_BRK RIGHT_BRA MINUS_GT }]
  [simpleName ::= (*) SIMPLE_NAME , {EOF ENDPACKAGE CONTEXT INIT DERIVE INV DEF PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE IN THEN ELSE ENDIF COMMA DOT COLON SEMICOLON BAR UP AT DOT_DOT COLON_COLON UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR RIGHT_BRK RIGHT_BRA MINUS_GT }]
  [collectionLiteralExp ::= (*) collectionKind LEFT_BRA RIGHT_BRA , {EOF ENDPACKAGE CONTEXT INIT DERIVE INV DEF PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE IN THEN ELSE ENDIF COMMA DOT COLON SEMICOLON BAR UP DOT_DOT UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR RIGHT_BRK RIGHT_BRA MINUS_GT }]
}
transition on tupleLiteralExp to state [54]
transition on oclExpression to state [133]
transition on REAL to state [52]
transition on INTEGER to state [51]
transition on pathName to state [50]
transition on SIMPLE_NAME to state [12]
transition on LET to state [49]
transition on FALSE to state [48]
transition on MINUS to state [47]
transition on COLLECTION to state [28]
transition on SET to state [20]
transition on simpleName to state [26]
transition on collectionLiteralExp to state [46]
transition on LEFT_PAR to state [45]
transition on STRING to state [44]
transition on IF to state [43]
transition on TRUE to state [42]
transition on collectionKind to state [41]
transition on NOT to state [40]
transition on primitiveLiteralExp to state [39]
transition on TUPLE to state [38]
transition on literalExp to state [37]
transition on BAG to state [25]
transition on SEQUENCE to state [22]

-------------------
lalr_state [58]: {
  [oclExpression ::= (*) oclExpression UP simpleName LEFT_PAR oclMessageArgumentList RIGHT_PAR , {EOF ENDPACKAGE CONTEXT INIT DERIVE INV DEF PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE IN THEN ELSE ENDIF COMMA DOT COLON SEMICOLON BAR UP DOT_DOT UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR RIGHT_BRK RIGHT_BRA MINUS_GT }]
  [oclExpression ::= (*) oclExpression EQ oclExpression , {EOF ENDPACKAGE CONTEXT INIT DERIVE INV DEF PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE IN THEN ELSE ENDIF COMMA DOT COLON SEMICOLON BAR UP DOT_DOT UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR RIGHT_BRK RIGHT_BRA MINUS_GT }]
  [oclExpression ::= (*) oclExpression TIMES oclExpression , {EOF ENDPACKAGE CONTEXT INIT DERIVE INV DEF PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE IN THEN ELSE ENDIF COMMA DOT COLON SEMICOLON BAR UP DOT_DOT UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR RIGHT_BRK RIGHT_BRA MINUS_GT }]
  [oclExpression ::= (*) oclExpression DOT simpleName isMarkedPre , {EOF ENDPACKAGE CONTEXT INIT DERIVE INV DEF PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE IN THEN ELSE ENDIF COMMA DOT COLON SEMICOLON BAR UP DOT_DOT UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR RIGHT_BRK RIGHT_BRA MINUS_GT }]
  [primitiveLiteralExp ::= (*) TRUE , {EOF ENDPACKAGE CONTEXT INIT DERIVE INV DEF PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE IN THEN ELSE ENDIF COMMA DOT COLON SEMICOLON BAR UP DOT_DOT UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR RIGHT_BRK RIGHT_BRA MINUS_GT }]
  [literalExp ::= (*) tupleLiteralExp , {EOF ENDPACKAGE CONTEXT INIT DERIVE INV DEF PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE IN THEN ELSE ENDIF COMMA DOT COLON SEMICOLON BAR UP DOT_DOT UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR RIGHT_BRK RIGHT_BRA MINUS_GT }]
  [oclExpression ::= (*) oclExpression IMPLIES oclExpression , {EOF ENDPACKAGE CONTEXT INIT DERIVE INV DEF PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE IN THEN ELSE ENDIF COMMA DOT COLON SEMICOLON BAR UP DOT_DOT UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR RIGHT_BRK RIGHT_BRA MINUS_GT }]
  [oclExpression ::= (*) oclExpression LT oclExpression , {EOF ENDPACKAGE CONTEXT INIT DERIVE INV DEF PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE IN THEN ELSE ENDIF COMMA DOT COLON SEMICOLON BAR UP DOT_DOT UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR RIGHT_BRK RIGHT_BRA MINUS_GT }]
  [oclExpression ::= (*) oclExpression MINUS_GT ITERATE LEFT_PAR variableDeclaration SEMICOLON variableDeclaration BAR oclExpression RIGHT_PAR , {EOF ENDPACKAGE CONTEXT INIT DERIVE INV DEF PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE IN THEN ELSE ENDIF COMMA DOT COLON SEMICOLON BAR UP DOT_DOT UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR RIGHT_BRK RIGHT_BRA MINUS_GT }]
  [tupleLiteralExp ::= (*) TUPLE LEFT_BRA variableDeclarationList RIGHT_BRA , {EOF ENDPACKAGE CONTEXT INIT DERIVE INV DEF PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE IN THEN ELSE ENDIF COMMA DOT COLON SEMICOLON BAR UP DOT_DOT UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR RIGHT_BRK RIGHT_BRA MINUS_GT }]
  [collectionKind ::= (*) SET , {LEFT_BRA }]
  [oclExpression ::= oclExpression NE (*) oclExpression , {EOF ENDPACKAGE CONTEXT INIT DERIVE INV DEF PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE IN THEN ELSE ENDIF COMMA DOT COLON SEMICOLON BAR UP DOT_DOT UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR RIGHT_BRK RIGHT_BRA MINUS_GT }]
  [oclExpression ::= (*) oclExpression UP simpleName LEFT_PAR RIGHT_PAR , {EOF ENDPACKAGE CONTEXT INIT DERIVE INV DEF PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE IN THEN ELSE ENDIF COMMA DOT COLON SEMICOLON BAR UP DOT_DOT UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR RIGHT_BRK RIGHT_BRA MINUS_GT }]
  [oclExpression ::= (*) oclExpression NE oclExpression , {EOF ENDPACKAGE CONTEXT INIT DERIVE INV DEF PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE IN THEN ELSE ENDIF COMMA DOT COLON SEMICOLON BAR UP DOT_DOT UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR RIGHT_BRK RIGHT_BRA MINUS_GT }]
  [oclExpression ::= (*) oclExpression DIVIDE oclExpression , {EOF ENDPACKAGE CONTEXT INIT DERIVE INV DEF PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE IN THEN ELSE ENDIF COMMA DOT COLON SEMICOLON BAR UP DOT_DOT UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR RIGHT_BRK RIGHT_BRA MINUS_GT }]
  [oclExpression ::= (*) oclExpression LEFT_PAR arguments RIGHT_PAR , {EOF ENDPACKAGE CONTEXT INIT DERIVE INV DEF PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE IN THEN ELSE ENDIF COMMA DOT COLON SEMICOLON BAR UP DOT_DOT UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR RIGHT_BRK RIGHT_BRA MINUS_GT }]
  [primitiveLiteralExp ::= (*) FALSE , {EOF ENDPACKAGE CONTEXT INIT DERIVE INV DEF PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE IN THEN ELSE ENDIF COMMA DOT COLON SEMICOLON BAR UP DOT_DOT UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR RIGHT_BRK RIGHT_BRA MINUS_GT }]
  [literalExp ::= (*) primitiveLiteralExp , {EOF ENDPACKAGE CONTEXT INIT DERIVE INV DEF PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE IN THEN ELSE ENDIF COMMA DOT COLON SEMICOLON BAR UP DOT_DOT UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR RIGHT_BRK RIGHT_BRA MINUS_GT }]
  [oclExpression ::= (*) LET variableDeclarationList IN oclExpression , {EOF ENDPACKAGE CONTEXT INIT DERIVE INV DEF PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE IN THEN ELSE ENDIF COMMA DOT COLON SEMICOLON BAR UP DOT_DOT UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR RIGHT_BRK RIGHT_BRA MINUS_GT }]
  [oclExpression ::= (*) oclExpression GT oclExpression , {EOF ENDPACKAGE CONTEXT INIT DERIVE INV DEF PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE IN THEN ELSE ENDIF COMMA DOT COLON SEMICOLON BAR UP DOT_DOT UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR RIGHT_BRK RIGHT_BRA MINUS_GT }]
  [oclExpression ::= (*) oclExpression MINUS_GT ITERATE LEFT_PAR variableDeclaration BAR oclExpression RIGHT_PAR , {EOF ENDPACKAGE CONTEXT INIT DERIVE INV DEF PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE IN THEN ELSE ENDIF COMMA DOT COLON SEMICOLON BAR UP DOT_DOT UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR RIGHT_BRK RIGHT_BRA MINUS_GT }]
  [oclExpression ::= (*) literalExp , {EOF ENDPACKAGE CONTEXT INIT DERIVE INV DEF PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE IN THEN ELSE ENDIF COMMA DOT COLON SEMICOLON BAR UP DOT_DOT UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR RIGHT_BRK RIGHT_BRA MINUS_GT }]
  [primitiveLiteralExp ::= (*) INTEGER , {EOF ENDPACKAGE CONTEXT INIT DERIVE INV DEF PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE IN THEN ELSE ENDIF COMMA DOT COLON SEMICOLON BAR UP DOT_DOT UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR RIGHT_BRK RIGHT_BRA MINUS_GT }]
  [collectionKind ::= (*) BAG , {LEFT_BRA }]
  [oclExpression ::= (*) oclExpression AND oclExpression , {EOF ENDPACKAGE CONTEXT INIT DERIVE INV DEF PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE IN THEN ELSE ENDIF COMMA DOT COLON SEMICOLON BAR UP DOT_DOT UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR RIGHT_BRK RIGHT_BRA MINUS_GT }]
  [oclExpression ::= (*) oclExpression PLUS oclExpression , {EOF ENDPACKAGE CONTEXT INIT DERIVE INV DEF PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE IN THEN ELSE ENDIF COMMA DOT COLON SEMICOLON BAR UP DOT_DOT UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR RIGHT_BRK RIGHT_BRA MINUS_GT }]
  [oclExpression ::= (*) oclExpression LEFT_PAR variableDeclaration BAR oclExpression RIGHT_PAR , {EOF ENDPACKAGE CONTEXT INIT DERIVE INV DEF PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE IN THEN ELSE ENDIF COMMA DOT COLON SEMICOLON BAR UP DOT_DOT UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR RIGHT_BRK RIGHT_BRA MINUS_GT }]
  [pathName ::= (*) simpleName , {EOF ENDPACKAGE CONTEXT INIT DERIVE INV DEF PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE IN THEN ELSE ENDIF COMMA DOT COLON SEMICOLON BAR UP AT DOT_DOT COLON_COLON UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR RIGHT_BRK RIGHT_BRA MINUS_GT }]
  [oclExpression ::= (*) oclExpression UP_UP simpleName LEFT_PAR oclMessageArgumentList RIGHT_PAR , {EOF ENDPACKAGE CONTEXT INIT DERIVE INV DEF PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE IN THEN ELSE ENDIF COMMA DOT COLON SEMICOLON BAR UP DOT_DOT UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR RIGHT_BRK RIGHT_BRA MINUS_GT }]
  [oclExpression ::= (*) oclExpression LE oclExpression , {EOF ENDPACKAGE CONTEXT INIT DERIVE INV DEF PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE IN THEN ELSE ENDIF COMMA DOT COLON SEMICOLON BAR UP DOT_DOT UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR RIGHT_BRK RIGHT_BRA MINUS_GT }]
  [oclExpression ::= (*) NOT oclExpression , {EOF ENDPACKAGE CONTEXT INIT DERIVE INV DEF PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE IN THEN ELSE ENDIF COMMA DOT COLON SEMICOLON BAR UP DOT_DOT UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR RIGHT_BRK RIGHT_BRA MINUS_GT }]
  [oclExpression ::= (*) LEFT_PAR oclExpression RIGHT_PAR , {EOF ENDPACKAGE CONTEXT INIT DERIVE INV DEF PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE IN THEN ELSE ENDIF COMMA DOT COLON SEMICOLON BAR UP DOT_DOT UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR RIGHT_BRK RIGHT_BRA MINUS_GT }]
  [primitiveLiteralExp ::= (*) REAL , {EOF ENDPACKAGE CONTEXT INIT DERIVE INV DEF PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE IN THEN ELSE ENDIF COMMA DOT COLON SEMICOLON BAR UP DOT_DOT UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR RIGHT_BRK RIGHT_BRA MINUS_GT }]
  [collectionKind ::= (*) SEQUENCE , {LEFT_BRA }]
  [oclExpression ::= (*) oclExpression OR oclExpression , {EOF ENDPACKAGE CONTEXT INIT DERIVE INV DEF PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE IN THEN ELSE ENDIF COMMA DOT COLON SEMICOLON BAR UP DOT_DOT UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR RIGHT_BRK RIGHT_BRA MINUS_GT }]
  [oclExpression ::= (*) oclExpression MINUS oclExpression , {EOF ENDPACKAGE CONTEXT INIT DERIVE INV DEF PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE IN THEN ELSE ENDIF COMMA DOT COLON SEMICOLON BAR UP DOT_DOT UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR RIGHT_BRK RIGHT_BRA MINUS_GT }]
  [oclExpression ::= (*) oclExpression LEFT_BRK argumentList RIGHT_BRK isMarkedPre , {EOF ENDPACKAGE CONTEXT INIT DERIVE INV DEF PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE IN THEN ELSE ENDIF COMMA DOT COLON SEMICOLON BAR UP DOT_DOT UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR RIGHT_BRK RIGHT_BRA MINUS_GT }]
  [pathName ::= (*) pathName COLON_COLON simpleName , {EOF ENDPACKAGE CONTEXT INIT DERIVE INV DEF PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE IN THEN ELSE ENDIF COMMA DOT COLON SEMICOLON BAR UP AT DOT_DOT COLON_COLON UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR RIGHT_BRK RIGHT_BRA MINUS_GT }]
  [collectionLiteralExp ::= (*) collectionKind LEFT_BRA collectionLiteralParts RIGHT_BRA , {EOF ENDPACKAGE CONTEXT INIT DERIVE INV DEF PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE IN THEN ELSE ENDIF COMMA DOT COLON SEMICOLON BAR UP DOT_DOT UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR RIGHT_BRK RIGHT_BRA MINUS_GT }]
  [oclExpression ::= (*) oclExpression UP_UP simpleName LEFT_PAR RIGHT_PAR , {EOF ENDPACKAGE CONTEXT INIT DERIVE INV DEF PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE IN THEN ELSE ENDIF COMMA DOT COLON SEMICOLON BAR UP DOT_DOT UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR RIGHT_BRK RIGHT_BRA MINUS_GT }]
  [oclExpression ::= (*) oclExpression GE oclExpression , {EOF ENDPACKAGE CONTEXT INIT DERIVE INV DEF PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE IN THEN ELSE ENDIF COMMA DOT COLON SEMICOLON BAR UP DOT_DOT UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR RIGHT_BRK RIGHT_BRA MINUS_GT }]
  [oclExpression ::= (*) MINUS oclExpression , {EOF ENDPACKAGE CONTEXT INIT DERIVE INV DEF PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE IN THEN ELSE ENDIF COMMA DOT COLON SEMICOLON BAR UP DOT_DOT UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR RIGHT_BRK RIGHT_BRA MINUS_GT }]
  [oclExpression ::= (*) pathName isMarkedPre , {EOF ENDPACKAGE CONTEXT INIT DERIVE INV DEF PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE IN THEN ELSE ENDIF COMMA DOT COLON SEMICOLON BAR UP DOT_DOT UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR RIGHT_BRK RIGHT_BRA MINUS_GT }]
  [primitiveLiteralExp ::= (*) STRING , {EOF ENDPACKAGE CONTEXT INIT DERIVE INV DEF PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE IN THEN ELSE ENDIF COMMA DOT COLON SEMICOLON BAR UP DOT_DOT UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR RIGHT_BRK RIGHT_BRA MINUS_GT }]
  [collectionKind ::= (*) COLLECTION , {LEFT_BRA }]
  [literalExp ::= (*) collectionLiteralExp , {EOF ENDPACKAGE CONTEXT INIT DERIVE INV DEF PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE IN THEN ELSE ENDIF COMMA DOT COLON SEMICOLON BAR UP DOT_DOT UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR RIGHT_BRK RIGHT_BRA MINUS_GT }]
  [oclExpression ::= (*) oclExpression XOR oclExpression , {EOF ENDPACKAGE CONTEXT INIT DERIVE INV DEF PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE IN THEN ELSE ENDIF COMMA DOT COLON SEMICOLON BAR UP DOT_DOT UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR RIGHT_BRK RIGHT_BRA MINUS_GT }]
  [oclExpression ::= (*) IF oclExpression THEN oclExpression ELSE oclExpression ENDIF , {EOF ENDPACKAGE CONTEXT INIT DERIVE INV DEF PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE IN THEN ELSE ENDIF COMMA DOT COLON SEMICOLON BAR UP DOT_DOT UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR RIGHT_BRK RIGHT_BRA MINUS_GT }]
  [oclExpression ::= (*) oclExpression MINUS_GT simpleName , {EOF ENDPACKAGE CONTEXT INIT DERIVE INV DEF PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE IN THEN ELSE ENDIF COMMA DOT COLON SEMICOLON BAR UP DOT_DOT UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR RIGHT_BRK RIGHT_BRA MINUS_GT }]
  [simpleName ::= (*) SIMPLE_NAME , {EOF ENDPACKAGE CONTEXT INIT DERIVE INV DEF PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE IN THEN ELSE ENDIF COMMA DOT COLON SEMICOLON BAR UP AT DOT_DOT COLON_COLON UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR RIGHT_BRK RIGHT_BRA MINUS_GT }]
  [collectionLiteralExp ::= (*) collectionKind LEFT_BRA RIGHT_BRA , {EOF ENDPACKAGE CONTEXT INIT DERIVE INV DEF PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE IN THEN ELSE ENDIF COMMA DOT COLON SEMICOLON BAR UP DOT_DOT UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR RIGHT_BRK RIGHT_BRA MINUS_GT }]
}
transition on tupleLiteralExp to state [54]
transition on oclExpression to state [132]
transition on REAL to state [52]
transition on INTEGER to state [51]
transition on pathName to state [50]
transition on SIMPLE_NAME to state [12]
transition on LET to state [49]
transition on FALSE to state [48]
transition on MINUS to state [47]
transition on COLLECTION to state [28]
transition on SET to state [20]
transition on simpleName to state [26]
transition on collectionLiteralExp to state [46]
transition on LEFT_PAR to state [45]
transition on STRING to state [44]
transition on IF to state [43]
transition on TRUE to state [42]
transition on collectionKind to state [41]
transition on NOT to state [40]
transition on primitiveLiteralExp to state [39]
transition on TUPLE to state [38]
transition on literalExp to state [37]
transition on BAG to state [25]
transition on SEQUENCE to state [22]

-------------------
lalr_state [59]: {
  [oclExpression ::= (*) oclExpression UP simpleName LEFT_PAR oclMessageArgumentList RIGHT_PAR , {EOF ENDPACKAGE CONTEXT INIT DERIVE INV DEF PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE IN THEN ELSE ENDIF COMMA DOT COLON SEMICOLON BAR UP DOT_DOT UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR RIGHT_BRK RIGHT_BRA MINUS_GT }]
  [oclExpression ::= (*) oclExpression EQ oclExpression , {EOF ENDPACKAGE CONTEXT INIT DERIVE INV DEF PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE IN THEN ELSE ENDIF COMMA DOT COLON SEMICOLON BAR UP DOT_DOT UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR RIGHT_BRK RIGHT_BRA MINUS_GT }]
  [oclExpression ::= (*) oclExpression TIMES oclExpression , {EOF ENDPACKAGE CONTEXT INIT DERIVE INV DEF PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE IN THEN ELSE ENDIF COMMA DOT COLON SEMICOLON BAR UP DOT_DOT UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR RIGHT_BRK RIGHT_BRA MINUS_GT }]
  [oclExpression ::= (*) oclExpression DOT simpleName isMarkedPre , {EOF ENDPACKAGE CONTEXT INIT DERIVE INV DEF PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE IN THEN ELSE ENDIF COMMA DOT COLON SEMICOLON BAR UP DOT_DOT UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR RIGHT_BRK RIGHT_BRA MINUS_GT }]
  [primitiveLiteralExp ::= (*) TRUE , {EOF ENDPACKAGE CONTEXT INIT DERIVE INV DEF PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE IN THEN ELSE ENDIF COMMA DOT COLON SEMICOLON BAR UP DOT_DOT UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR RIGHT_BRK RIGHT_BRA MINUS_GT }]
  [literalExp ::= (*) tupleLiteralExp , {EOF ENDPACKAGE CONTEXT INIT DERIVE INV DEF PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE IN THEN ELSE ENDIF COMMA DOT COLON SEMICOLON BAR UP DOT_DOT UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR RIGHT_BRK RIGHT_BRA MINUS_GT }]
  [oclExpression ::= (*) oclExpression IMPLIES oclExpression , {EOF ENDPACKAGE CONTEXT INIT DERIVE INV DEF PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE IN THEN ELSE ENDIF COMMA DOT COLON SEMICOLON BAR UP DOT_DOT UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR RIGHT_BRK RIGHT_BRA MINUS_GT }]
  [oclExpression ::= (*) oclExpression LT oclExpression , {EOF ENDPACKAGE CONTEXT INIT DERIVE INV DEF PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE IN THEN ELSE ENDIF COMMA DOT COLON SEMICOLON BAR UP DOT_DOT UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR RIGHT_BRK RIGHT_BRA MINUS_GT }]
  [oclExpression ::= (*) oclExpression MINUS_GT ITERATE LEFT_PAR variableDeclaration SEMICOLON variableDeclaration BAR oclExpression RIGHT_PAR , {EOF ENDPACKAGE CONTEXT INIT DERIVE INV DEF PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE IN THEN ELSE ENDIF COMMA DOT COLON SEMICOLON BAR UP DOT_DOT UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR RIGHT_BRK RIGHT_BRA MINUS_GT }]
  [tupleLiteralExp ::= (*) TUPLE LEFT_BRA variableDeclarationList RIGHT_BRA , {EOF ENDPACKAGE CONTEXT INIT DERIVE INV DEF PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE IN THEN ELSE ENDIF COMMA DOT COLON SEMICOLON BAR UP DOT_DOT UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR RIGHT_BRK RIGHT_BRA MINUS_GT }]
  [collectionKind ::= (*) SET , {LEFT_BRA }]
  [oclExpression ::= (*) oclExpression UP simpleName LEFT_PAR RIGHT_PAR , {EOF ENDPACKAGE CONTEXT INIT DERIVE INV DEF PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE IN THEN ELSE ENDIF COMMA DOT COLON SEMICOLON BAR UP DOT_DOT UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR RIGHT_BRK RIGHT_BRA MINUS_GT }]
  [oclExpression ::= (*) oclExpression NE oclExpression , {EOF ENDPACKAGE CONTEXT INIT DERIVE INV DEF PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE IN THEN ELSE ENDIF COMMA DOT COLON SEMICOLON BAR UP DOT_DOT UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR RIGHT_BRK RIGHT_BRA MINUS_GT }]
  [oclExpression ::= (*) oclExpression DIVIDE oclExpression , {EOF ENDPACKAGE CONTEXT INIT DERIVE INV DEF PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE IN THEN ELSE ENDIF COMMA DOT COLON SEMICOLON BAR UP DOT_DOT UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR RIGHT_BRK RIGHT_BRA MINUS_GT }]
  [oclExpression ::= (*) oclExpression LEFT_PAR arguments RIGHT_PAR , {EOF ENDPACKAGE CONTEXT INIT DERIVE INV DEF PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE IN THEN ELSE ENDIF COMMA DOT COLON SEMICOLON BAR UP DOT_DOT UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR RIGHT_BRK RIGHT_BRA MINUS_GT }]
  [primitiveLiteralExp ::= (*) FALSE , {EOF ENDPACKAGE CONTEXT INIT DERIVE INV DEF PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE IN THEN ELSE ENDIF COMMA DOT COLON SEMICOLON BAR UP DOT_DOT UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR RIGHT_BRK RIGHT_BRA MINUS_GT }]
  [literalExp ::= (*) primitiveLiteralExp , {EOF ENDPACKAGE CONTEXT INIT DERIVE INV DEF PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE IN THEN ELSE ENDIF COMMA DOT COLON SEMICOLON BAR UP DOT_DOT UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR RIGHT_BRK RIGHT_BRA MINUS_GT }]
  [oclExpression ::= (*) LET variableDeclarationList IN oclExpression , {EOF ENDPACKAGE CONTEXT INIT DERIVE INV DEF PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE IN THEN ELSE ENDIF COMMA DOT COLON SEMICOLON BAR UP DOT_DOT UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR RIGHT_BRK RIGHT_BRA MINUS_GT }]
  [oclExpression ::= (*) oclExpression GT oclExpression , {EOF ENDPACKAGE CONTEXT INIT DERIVE INV DEF PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE IN THEN ELSE ENDIF COMMA DOT COLON SEMICOLON BAR UP DOT_DOT UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR RIGHT_BRK RIGHT_BRA MINUS_GT }]
  [oclExpression ::= (*) oclExpression MINUS_GT ITERATE LEFT_PAR variableDeclaration BAR oclExpression RIGHT_PAR , {EOF ENDPACKAGE CONTEXT INIT DERIVE INV DEF PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE IN THEN ELSE ENDIF COMMA DOT COLON SEMICOLON BAR UP DOT_DOT UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR RIGHT_BRK RIGHT_BRA MINUS_GT }]
  [oclExpression ::= (*) literalExp , {EOF ENDPACKAGE CONTEXT INIT DERIVE INV DEF PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE IN THEN ELSE ENDIF COMMA DOT COLON SEMICOLON BAR UP DOT_DOT UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR RIGHT_BRK RIGHT_BRA MINUS_GT }]
  [primitiveLiteralExp ::= (*) INTEGER , {EOF ENDPACKAGE CONTEXT INIT DERIVE INV DEF PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE IN THEN ELSE ENDIF COMMA DOT COLON SEMICOLON BAR UP DOT_DOT UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR RIGHT_BRK RIGHT_BRA MINUS_GT }]
  [collectionKind ::= (*) BAG , {LEFT_BRA }]
  [oclExpression ::= oclExpression PLUS (*) oclExpression , {EOF ENDPACKAGE CONTEXT INIT DERIVE INV DEF PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE IN THEN ELSE ENDIF COMMA DOT COLON SEMICOLON BAR UP DOT_DOT UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR RIGHT_BRK RIGHT_BRA MINUS_GT }]
  [oclExpression ::= (*) oclExpression AND oclExpression , {EOF ENDPACKAGE CONTEXT INIT DERIVE INV DEF PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE IN THEN ELSE ENDIF COMMA DOT COLON SEMICOLON BAR UP DOT_DOT UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR RIGHT_BRK RIGHT_BRA MINUS_GT }]
  [oclExpression ::= (*) oclExpression PLUS oclExpression , {EOF ENDPACKAGE CONTEXT INIT DERIVE INV DEF PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE IN THEN ELSE ENDIF COMMA DOT COLON SEMICOLON BAR UP DOT_DOT UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR RIGHT_BRK RIGHT_BRA MINUS_GT }]
  [oclExpression ::= (*) oclExpression LEFT_PAR variableDeclaration BAR oclExpression RIGHT_PAR , {EOF ENDPACKAGE CONTEXT INIT DERIVE INV DEF PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE IN THEN ELSE ENDIF COMMA DOT COLON SEMICOLON BAR UP DOT_DOT UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR RIGHT_BRK RIGHT_BRA MINUS_GT }]
  [pathName ::= (*) simpleName , {EOF ENDPACKAGE CONTEXT INIT DERIVE INV DEF PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE IN THEN ELSE ENDIF COMMA DOT COLON SEMICOLON BAR UP AT DOT_DOT COLON_COLON UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR RIGHT_BRK RIGHT_BRA MINUS_GT }]
  [oclExpression ::= (*) oclExpression UP_UP simpleName LEFT_PAR oclMessageArgumentList RIGHT_PAR , {EOF ENDPACKAGE CONTEXT INIT DERIVE INV DEF PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE IN THEN ELSE ENDIF COMMA DOT COLON SEMICOLON BAR UP DOT_DOT UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR RIGHT_BRK RIGHT_BRA MINUS_GT }]
  [oclExpression ::= (*) oclExpression LE oclExpression , {EOF ENDPACKAGE CONTEXT INIT DERIVE INV DEF PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE IN THEN ELSE ENDIF COMMA DOT COLON SEMICOLON BAR UP DOT_DOT UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR RIGHT_BRK RIGHT_BRA MINUS_GT }]
  [oclExpression ::= (*) NOT oclExpression , {EOF ENDPACKAGE CONTEXT INIT DERIVE INV DEF PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE IN THEN ELSE ENDIF COMMA DOT COLON SEMICOLON BAR UP DOT_DOT UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR RIGHT_BRK RIGHT_BRA MINUS_GT }]
  [oclExpression ::= (*) LEFT_PAR oclExpression RIGHT_PAR , {EOF ENDPACKAGE CONTEXT INIT DERIVE INV DEF PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE IN THEN ELSE ENDIF COMMA DOT COLON SEMICOLON BAR UP DOT_DOT UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR RIGHT_BRK RIGHT_BRA MINUS_GT }]
  [primitiveLiteralExp ::= (*) REAL , {EOF ENDPACKAGE CONTEXT INIT DERIVE INV DEF PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE IN THEN ELSE ENDIF COMMA DOT COLON SEMICOLON BAR UP DOT_DOT UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR RIGHT_BRK RIGHT_BRA MINUS_GT }]
  [collectionKind ::= (*) SEQUENCE , {LEFT_BRA }]
  [oclExpression ::= (*) oclExpression OR oclExpression , {EOF ENDPACKAGE CONTEXT INIT DERIVE INV DEF PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE IN THEN ELSE ENDIF COMMA DOT COLON SEMICOLON BAR UP DOT_DOT UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR RIGHT_BRK RIGHT_BRA MINUS_GT }]
  [oclExpression ::= (*) oclExpression MINUS oclExpression , {EOF ENDPACKAGE CONTEXT INIT DERIVE INV DEF PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE IN THEN ELSE ENDIF COMMA DOT COLON SEMICOLON BAR UP DOT_DOT UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR RIGHT_BRK RIGHT_BRA MINUS_GT }]
  [oclExpression ::= (*) oclExpression LEFT_BRK argumentList RIGHT_BRK isMarkedPre , {EOF ENDPACKAGE CONTEXT INIT DERIVE INV DEF PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE IN THEN ELSE ENDIF COMMA DOT COLON SEMICOLON BAR UP DOT_DOT UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR RIGHT_BRK RIGHT_BRA MINUS_GT }]
  [pathName ::= (*) pathName COLON_COLON simpleName , {EOF ENDPACKAGE CONTEXT INIT DERIVE INV DEF PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE IN THEN ELSE ENDIF COMMA DOT COLON SEMICOLON BAR UP AT DOT_DOT COLON_COLON UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR RIGHT_BRK RIGHT_BRA MINUS_GT }]
  [collectionLiteralExp ::= (*) collectionKind LEFT_BRA collectionLiteralParts RIGHT_BRA , {EOF ENDPACKAGE CONTEXT INIT DERIVE INV DEF PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE IN THEN ELSE ENDIF COMMA DOT COLON SEMICOLON BAR UP DOT_DOT UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR RIGHT_BRK RIGHT_BRA MINUS_GT }]
  [oclExpression ::= (*) oclExpression UP_UP simpleName LEFT_PAR RIGHT_PAR , {EOF ENDPACKAGE CONTEXT INIT DERIVE INV DEF PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE IN THEN ELSE ENDIF COMMA DOT COLON SEMICOLON BAR UP DOT_DOT UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR RIGHT_BRK RIGHT_BRA MINUS_GT }]
  [oclExpression ::= (*) oclExpression GE oclExpression , {EOF ENDPACKAGE CONTEXT INIT DERIVE INV DEF PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE IN THEN ELSE ENDIF COMMA DOT COLON SEMICOLON BAR UP DOT_DOT UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR RIGHT_BRK RIGHT_BRA MINUS_GT }]
  [oclExpression ::= (*) MINUS oclExpression , {EOF ENDPACKAGE CONTEXT INIT DERIVE INV DEF PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE IN THEN ELSE ENDIF COMMA DOT COLON SEMICOLON BAR UP DOT_DOT UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR RIGHT_BRK RIGHT_BRA MINUS_GT }]
  [oclExpression ::= (*) pathName isMarkedPre , {EOF ENDPACKAGE CONTEXT INIT DERIVE INV DEF PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE IN THEN ELSE ENDIF COMMA DOT COLON SEMICOLON BAR UP DOT_DOT UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR RIGHT_BRK RIGHT_BRA MINUS_GT }]
  [primitiveLiteralExp ::= (*) STRING , {EOF ENDPACKAGE CONTEXT INIT DERIVE INV DEF PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE IN THEN ELSE ENDIF COMMA DOT COLON SEMICOLON BAR UP DOT_DOT UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR RIGHT_BRK RIGHT_BRA MINUS_GT }]
  [collectionKind ::= (*) COLLECTION , {LEFT_BRA }]
  [literalExp ::= (*) collectionLiteralExp , {EOF ENDPACKAGE CONTEXT INIT DERIVE INV DEF PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE IN THEN ELSE ENDIF COMMA DOT COLON SEMICOLON BAR UP DOT_DOT UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR RIGHT_BRK RIGHT_BRA MINUS_GT }]
  [oclExpression ::= (*) oclExpression XOR oclExpression , {EOF ENDPACKAGE CONTEXT INIT DERIVE INV DEF PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE IN THEN ELSE ENDIF COMMA DOT COLON SEMICOLON BAR UP DOT_DOT UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR RIGHT_BRK RIGHT_BRA MINUS_GT }]
  [oclExpression ::= (*) IF oclExpression THEN oclExpression ELSE oclExpression ENDIF , {EOF ENDPACKAGE CONTEXT INIT DERIVE INV DEF PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE IN THEN ELSE ENDIF COMMA DOT COLON SEMICOLON BAR UP DOT_DOT UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR RIGHT_BRK RIGHT_BRA MINUS_GT }]
  [oclExpression ::= (*) oclExpression MINUS_GT simpleName , {EOF ENDPACKAGE CONTEXT INIT DERIVE INV DEF PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE IN THEN ELSE ENDIF COMMA DOT COLON SEMICOLON BAR UP DOT_DOT UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR RIGHT_BRK RIGHT_BRA MINUS_GT }]
  [simpleName ::= (*) SIMPLE_NAME , {EOF ENDPACKAGE CONTEXT INIT DERIVE INV DEF PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE IN THEN ELSE ENDIF COMMA DOT COLON SEMICOLON BAR UP AT DOT_DOT COLON_COLON UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR RIGHT_BRK RIGHT_BRA MINUS_GT }]
  [collectionLiteralExp ::= (*) collectionKind LEFT_BRA RIGHT_BRA , {EOF ENDPACKAGE CONTEXT INIT DERIVE INV DEF PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE IN THEN ELSE ENDIF COMMA DOT COLON SEMICOLON BAR UP DOT_DOT UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR RIGHT_BRK RIGHT_BRA MINUS_GT }]
}
transition on tupleLiteralExp to state [54]
transition on oclExpression to state [131]
transition on REAL to state [52]
transition on INTEGER to state [51]
transition on pathName to state [50]
transition on SIMPLE_NAME to state [12]
transition on LET to state [49]
transition on FALSE to state [48]
transition on MINUS to state [47]
transition on COLLECTION to state [28]
transition on SET to state [20]
transition on simpleName to state [26]
transition on collectionLiteralExp to state [46]
transition on LEFT_PAR to state [45]
transition on STRING to state [44]
transition on IF to state [43]
transition on TRUE to state [42]
transition on collectionKind to state [41]
transition on NOT to state [40]
transition on primitiveLiteralExp to state [39]
transition on TUPLE to state [38]
transition on literalExp to state [37]
transition on BAG to state [25]
transition on SEQUENCE to state [22]

-------------------
lalr_state [60]: {
  [oclExpression ::= (*) oclExpression UP simpleName LEFT_PAR oclMessageArgumentList RIGHT_PAR , {EOF ENDPACKAGE CONTEXT INIT DERIVE INV DEF PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE IN THEN ELSE ENDIF COMMA DOT COLON SEMICOLON BAR UP DOT_DOT UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR RIGHT_BRK RIGHT_BRA MINUS_GT }]
  [oclExpression ::= (*) oclExpression EQ oclExpression , {EOF ENDPACKAGE CONTEXT INIT DERIVE INV DEF PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE IN THEN ELSE ENDIF COMMA DOT COLON SEMICOLON BAR UP DOT_DOT UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR RIGHT_BRK RIGHT_BRA MINUS_GT }]
  [oclExpression ::= (*) oclExpression TIMES oclExpression , {EOF ENDPACKAGE CONTEXT INIT DERIVE INV DEF PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE IN THEN ELSE ENDIF COMMA DOT COLON SEMICOLON BAR UP DOT_DOT UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR RIGHT_BRK RIGHT_BRA MINUS_GT }]
  [oclExpression ::= (*) oclExpression DOT simpleName isMarkedPre , {EOF ENDPACKAGE CONTEXT INIT DERIVE INV DEF PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE IN THEN ELSE ENDIF COMMA DOT COLON SEMICOLON BAR UP DOT_DOT UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR RIGHT_BRK RIGHT_BRA MINUS_GT }]
  [primitiveLiteralExp ::= (*) TRUE , {EOF ENDPACKAGE CONTEXT INIT DERIVE INV DEF PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE IN THEN ELSE ENDIF COMMA DOT COLON SEMICOLON BAR UP DOT_DOT UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR RIGHT_BRK RIGHT_BRA MINUS_GT }]
  [literalExp ::= (*) tupleLiteralExp , {EOF ENDPACKAGE CONTEXT INIT DERIVE INV DEF PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE IN THEN ELSE ENDIF COMMA DOT COLON SEMICOLON BAR UP DOT_DOT UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR RIGHT_BRK RIGHT_BRA MINUS_GT }]
  [oclExpression ::= (*) oclExpression IMPLIES oclExpression , {EOF ENDPACKAGE CONTEXT INIT DERIVE INV DEF PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE IN THEN ELSE ENDIF COMMA DOT COLON SEMICOLON BAR UP DOT_DOT UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR RIGHT_BRK RIGHT_BRA MINUS_GT }]
  [oclExpression ::= (*) oclExpression LT oclExpression , {EOF ENDPACKAGE CONTEXT INIT DERIVE INV DEF PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE IN THEN ELSE ENDIF COMMA DOT COLON SEMICOLON BAR UP DOT_DOT UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR RIGHT_BRK RIGHT_BRA MINUS_GT }]
  [oclExpression ::= (*) oclExpression MINUS_GT ITERATE LEFT_PAR variableDeclaration SEMICOLON variableDeclaration BAR oclExpression RIGHT_PAR , {EOF ENDPACKAGE CONTEXT INIT DERIVE INV DEF PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE IN THEN ELSE ENDIF COMMA DOT COLON SEMICOLON BAR UP DOT_DOT UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR RIGHT_BRK RIGHT_BRA MINUS_GT }]
  [tupleLiteralExp ::= (*) TUPLE LEFT_BRA variableDeclarationList RIGHT_BRA , {EOF ENDPACKAGE CONTEXT INIT DERIVE INV DEF PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE IN THEN ELSE ENDIF COMMA DOT COLON SEMICOLON BAR UP DOT_DOT UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR RIGHT_BRK RIGHT_BRA MINUS_GT }]
  [collectionKind ::= (*) SET , {LEFT_BRA }]
  [oclExpression ::= (*) oclExpression UP simpleName LEFT_PAR RIGHT_PAR , {EOF ENDPACKAGE CONTEXT INIT DERIVE INV DEF PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE IN THEN ELSE ENDIF COMMA DOT COLON SEMICOLON BAR UP DOT_DOT UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR RIGHT_BRK RIGHT_BRA MINUS_GT }]
  [oclExpression ::= (*) oclExpression NE oclExpression , {EOF ENDPACKAGE CONTEXT INIT DERIVE INV DEF PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE IN THEN ELSE ENDIF COMMA DOT COLON SEMICOLON BAR UP DOT_DOT UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR RIGHT_BRK RIGHT_BRA MINUS_GT }]
  [oclExpression ::= (*) oclExpression DIVIDE oclExpression , {EOF ENDPACKAGE CONTEXT INIT DERIVE INV DEF PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE IN THEN ELSE ENDIF COMMA DOT COLON SEMICOLON BAR UP DOT_DOT UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR RIGHT_BRK RIGHT_BRA MINUS_GT }]
  [oclExpression ::= (*) oclExpression LEFT_PAR arguments RIGHT_PAR , {EOF ENDPACKAGE CONTEXT INIT DERIVE INV DEF PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE IN THEN ELSE ENDIF COMMA DOT COLON SEMICOLON BAR UP DOT_DOT UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR RIGHT_BRK RIGHT_BRA MINUS_GT }]
  [primitiveLiteralExp ::= (*) FALSE , {EOF ENDPACKAGE CONTEXT INIT DERIVE INV DEF PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE IN THEN ELSE ENDIF COMMA DOT COLON SEMICOLON BAR UP DOT_DOT UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR RIGHT_BRK RIGHT_BRA MINUS_GT }]
  [literalExp ::= (*) primitiveLiteralExp , {EOF ENDPACKAGE CONTEXT INIT DERIVE INV DEF PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE IN THEN ELSE ENDIF COMMA DOT COLON SEMICOLON BAR UP DOT_DOT UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR RIGHT_BRK RIGHT_BRA MINUS_GT }]
  [oclExpression ::= (*) LET variableDeclarationList IN oclExpression , {EOF ENDPACKAGE CONTEXT INIT DERIVE INV DEF PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE IN THEN ELSE ENDIF COMMA DOT COLON SEMICOLON BAR UP DOT_DOT UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR RIGHT_BRK RIGHT_BRA MINUS_GT }]
  [oclExpression ::= (*) oclExpression GT oclExpression , {EOF ENDPACKAGE CONTEXT INIT DERIVE INV DEF PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE IN THEN ELSE ENDIF COMMA DOT COLON SEMICOLON BAR UP DOT_DOT UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR RIGHT_BRK RIGHT_BRA MINUS_GT }]
  [oclExpression ::= (*) oclExpression MINUS_GT ITERATE LEFT_PAR variableDeclaration BAR oclExpression RIGHT_PAR , {EOF ENDPACKAGE CONTEXT INIT DERIVE INV DEF PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE IN THEN ELSE ENDIF COMMA DOT COLON SEMICOLON BAR UP DOT_DOT UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR RIGHT_BRK RIGHT_BRA MINUS_GT }]
  [oclExpression ::= (*) literalExp , {EOF ENDPACKAGE CONTEXT INIT DERIVE INV DEF PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE IN THEN ELSE ENDIF COMMA DOT COLON SEMICOLON BAR UP DOT_DOT UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR RIGHT_BRK RIGHT_BRA MINUS_GT }]
  [primitiveLiteralExp ::= (*) INTEGER , {EOF ENDPACKAGE CONTEXT INIT DERIVE INV DEF PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE IN THEN ELSE ENDIF COMMA DOT COLON SEMICOLON BAR UP DOT_DOT UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR RIGHT_BRK RIGHT_BRA MINUS_GT }]
  [collectionKind ::= (*) BAG , {LEFT_BRA }]
  [oclExpression ::= (*) oclExpression AND oclExpression , {EOF ENDPACKAGE CONTEXT INIT DERIVE INV DEF PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE IN THEN ELSE ENDIF COMMA DOT COLON SEMICOLON BAR UP DOT_DOT UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR RIGHT_BRK RIGHT_BRA MINUS_GT }]
  [oclExpression ::= (*) oclExpression PLUS oclExpression , {EOF ENDPACKAGE CONTEXT INIT DERIVE INV DEF PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE IN THEN ELSE ENDIF COMMA DOT COLON SEMICOLON BAR UP DOT_DOT UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR RIGHT_BRK RIGHT_BRA MINUS_GT }]
  [oclExpression ::= (*) oclExpression LEFT_PAR variableDeclaration BAR oclExpression RIGHT_PAR , {EOF ENDPACKAGE CONTEXT INIT DERIVE INV DEF PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE IN THEN ELSE ENDIF COMMA DOT COLON SEMICOLON BAR UP DOT_DOT UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR RIGHT_BRK RIGHT_BRA MINUS_GT }]
  [pathName ::= (*) simpleName , {EOF ENDPACKAGE CONTEXT INIT DERIVE INV DEF PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE IN THEN ELSE ENDIF COMMA DOT COLON SEMICOLON BAR UP AT DOT_DOT COLON_COLON UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR RIGHT_BRK RIGHT_BRA MINUS_GT }]
  [oclExpression ::= (*) oclExpression UP_UP simpleName LEFT_PAR oclMessageArgumentList RIGHT_PAR , {EOF ENDPACKAGE CONTEXT INIT DERIVE INV DEF PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE IN THEN ELSE ENDIF COMMA DOT COLON SEMICOLON BAR UP DOT_DOT UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR RIGHT_BRK RIGHT_BRA MINUS_GT }]
  [oclExpression ::= (*) oclExpression LE oclExpression , {EOF ENDPACKAGE CONTEXT INIT DERIVE INV DEF PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE IN THEN ELSE ENDIF COMMA DOT COLON SEMICOLON BAR UP DOT_DOT UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR RIGHT_BRK RIGHT_BRA MINUS_GT }]
  [oclExpression ::= (*) NOT oclExpression , {EOF ENDPACKAGE CONTEXT INIT DERIVE INV DEF PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE IN THEN ELSE ENDIF COMMA DOT COLON SEMICOLON BAR UP DOT_DOT UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR RIGHT_BRK RIGHT_BRA MINUS_GT }]
  [oclExpression ::= (*) LEFT_PAR oclExpression RIGHT_PAR , {EOF ENDPACKAGE CONTEXT INIT DERIVE INV DEF PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE IN THEN ELSE ENDIF COMMA DOT COLON SEMICOLON BAR UP DOT_DOT UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR RIGHT_BRK RIGHT_BRA MINUS_GT }]
  [primitiveLiteralExp ::= (*) REAL , {EOF ENDPACKAGE CONTEXT INIT DERIVE INV DEF PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE IN THEN ELSE ENDIF COMMA DOT COLON SEMICOLON BAR UP DOT_DOT UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR RIGHT_BRK RIGHT_BRA MINUS_GT }]
  [collectionKind ::= (*) SEQUENCE , {LEFT_BRA }]
  [oclExpression ::= oclExpression OR (*) oclExpression , {EOF ENDPACKAGE CONTEXT INIT DERIVE INV DEF PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE IN THEN ELSE ENDIF COMMA DOT COLON SEMICOLON BAR UP DOT_DOT UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR RIGHT_BRK RIGHT_BRA MINUS_GT }]
  [oclExpression ::= (*) oclExpression OR oclExpression , {EOF ENDPACKAGE CONTEXT INIT DERIVE INV DEF PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE IN THEN ELSE ENDIF COMMA DOT COLON SEMICOLON BAR UP DOT_DOT UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR RIGHT_BRK RIGHT_BRA MINUS_GT }]
  [oclExpression ::= (*) oclExpression MINUS oclExpression , {EOF ENDPACKAGE CONTEXT INIT DERIVE INV DEF PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE IN THEN ELSE ENDIF COMMA DOT COLON SEMICOLON BAR UP DOT_DOT UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR RIGHT_BRK RIGHT_BRA MINUS_GT }]
  [oclExpression ::= (*) oclExpression LEFT_BRK argumentList RIGHT_BRK isMarkedPre , {EOF ENDPACKAGE CONTEXT INIT DERIVE INV DEF PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE IN THEN ELSE ENDIF COMMA DOT COLON SEMICOLON BAR UP DOT_DOT UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR RIGHT_BRK RIGHT_BRA MINUS_GT }]
  [pathName ::= (*) pathName COLON_COLON simpleName , {EOF ENDPACKAGE CONTEXT INIT DERIVE INV DEF PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE IN THEN ELSE ENDIF COMMA DOT COLON SEMICOLON BAR UP AT DOT_DOT COLON_COLON UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR RIGHT_BRK RIGHT_BRA MINUS_GT }]
  [collectionLiteralExp ::= (*) collectionKind LEFT_BRA collectionLiteralParts RIGHT_BRA , {EOF ENDPACKAGE CONTEXT INIT DERIVE INV DEF PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE IN THEN ELSE ENDIF COMMA DOT COLON SEMICOLON BAR UP DOT_DOT UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR RIGHT_BRK RIGHT_BRA MINUS_GT }]
  [oclExpression ::= (*) oclExpression UP_UP simpleName LEFT_PAR RIGHT_PAR , {EOF ENDPACKAGE CONTEXT INIT DERIVE INV DEF PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE IN THEN ELSE ENDIF COMMA DOT COLON SEMICOLON BAR UP DOT_DOT UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR RIGHT_BRK RIGHT_BRA MINUS_GT }]
  [oclExpression ::= (*) oclExpression GE oclExpression , {EOF ENDPACKAGE CONTEXT INIT DERIVE INV DEF PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE IN THEN ELSE ENDIF COMMA DOT COLON SEMICOLON BAR UP DOT_DOT UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR RIGHT_BRK RIGHT_BRA MINUS_GT }]
  [oclExpression ::= (*) MINUS oclExpression , {EOF ENDPACKAGE CONTEXT INIT DERIVE INV DEF PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE IN THEN ELSE ENDIF COMMA DOT COLON SEMICOLON BAR UP DOT_DOT UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR RIGHT_BRK RIGHT_BRA MINUS_GT }]
  [oclExpression ::= (*) pathName isMarkedPre , {EOF ENDPACKAGE CONTEXT INIT DERIVE INV DEF PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE IN THEN ELSE ENDIF COMMA DOT COLON SEMICOLON BAR UP DOT_DOT UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR RIGHT_BRK RIGHT_BRA MINUS_GT }]
  [primitiveLiteralExp ::= (*) STRING , {EOF ENDPACKAGE CONTEXT INIT DERIVE INV DEF PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE IN THEN ELSE ENDIF COMMA DOT COLON SEMICOLON BAR UP DOT_DOT UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR RIGHT_BRK RIGHT_BRA MINUS_GT }]
  [collectionKind ::= (*) COLLECTION , {LEFT_BRA }]
  [literalExp ::= (*) collectionLiteralExp , {EOF ENDPACKAGE CONTEXT INIT DERIVE INV DEF PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE IN THEN ELSE ENDIF COMMA DOT COLON SEMICOLON BAR UP DOT_DOT UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR RIGHT_BRK RIGHT_BRA MINUS_GT }]
  [oclExpression ::= (*) oclExpression XOR oclExpression , {EOF ENDPACKAGE CONTEXT INIT DERIVE INV DEF PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE IN THEN ELSE ENDIF COMMA DOT COLON SEMICOLON BAR UP DOT_DOT UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR RIGHT_BRK RIGHT_BRA MINUS_GT }]
  [oclExpression ::= (*) IF oclExpression THEN oclExpression ELSE oclExpression ENDIF , {EOF ENDPACKAGE CONTEXT INIT DERIVE INV DEF PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE IN THEN ELSE ENDIF COMMA DOT COLON SEMICOLON BAR UP DOT_DOT UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR RIGHT_BRK RIGHT_BRA MINUS_GT }]
  [oclExpression ::= (*) oclExpression MINUS_GT simpleName , {EOF ENDPACKAGE CONTEXT INIT DERIVE INV DEF PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE IN THEN ELSE ENDIF COMMA DOT COLON SEMICOLON BAR UP DOT_DOT UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR RIGHT_BRK RIGHT_BRA MINUS_GT }]
  [simpleName ::= (*) SIMPLE_NAME , {EOF ENDPACKAGE CONTEXT INIT DERIVE INV DEF PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE IN THEN ELSE ENDIF COMMA DOT COLON SEMICOLON BAR UP AT DOT_DOT COLON_COLON UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR RIGHT_BRK RIGHT_BRA MINUS_GT }]
  [collectionLiteralExp ::= (*) collectionKind LEFT_BRA RIGHT_BRA , {EOF ENDPACKAGE CONTEXT INIT DERIVE INV DEF PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE IN THEN ELSE ENDIF COMMA DOT COLON SEMICOLON BAR UP DOT_DOT UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR RIGHT_BRK RIGHT_BRA MINUS_GT }]
}
transition on tupleLiteralExp to state [54]
transition on oclExpression to state [130]
transition on REAL to state [52]
transition on INTEGER to state [51]
transition on pathName to state [50]
transition on SIMPLE_NAME to state [12]
transition on LET to state [49]
transition on FALSE to state [48]
transition on MINUS to state [47]
transition on COLLECTION to state [28]
transition on SET to state [20]
transition on simpleName to state [26]
transition on collectionLiteralExp to state [46]
transition on LEFT_PAR to state [45]
transition on STRING to state [44]
transition on IF to state [43]
transition on TRUE to state [42]
transition on collectionKind to state [41]
transition on NOT to state [40]
transition on primitiveLiteralExp to state [39]
transition on TUPLE to state [38]
transition on literalExp to state [37]
transition on BAG to state [25]
transition on SEQUENCE to state [22]

-------------------
lalr_state [61]: {
  [oclExpression ::= oclExpression UP_UP (*) simpleName LEFT_PAR oclMessageArgumentList RIGHT_PAR , {EOF ENDPACKAGE CONTEXT INIT DERIVE INV DEF PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE IN THEN ELSE ENDIF COMMA DOT COLON SEMICOLON BAR UP DOT_DOT UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR RIGHT_BRK RIGHT_BRA MINUS_GT }]
  [simpleName ::= (*) SIMPLE_NAME , {LEFT_PAR }]
  [oclExpression ::= oclExpression UP_UP (*) simpleName LEFT_PAR RIGHT_PAR , {EOF ENDPACKAGE CONTEXT INIT DERIVE INV DEF PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE IN THEN ELSE ENDIF COMMA DOT COLON SEMICOLON BAR UP DOT_DOT UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR RIGHT_BRK RIGHT_BRA MINUS_GT }]
}
transition on SIMPLE_NAME to state [12]
transition on simpleName to state [125]

-------------------
lalr_state [62]: {
  [oclExpression ::= oclExpression UP (*) simpleName LEFT_PAR RIGHT_PAR , {EOF ENDPACKAGE CONTEXT INIT DERIVE INV DEF PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE IN THEN ELSE ENDIF COMMA DOT COLON SEMICOLON BAR UP DOT_DOT UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR RIGHT_BRK RIGHT_BRA MINUS_GT }]
  [oclExpression ::= oclExpression UP (*) simpleName LEFT_PAR oclMessageArgumentList RIGHT_PAR , {EOF ENDPACKAGE CONTEXT INIT DERIVE INV DEF PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE IN THEN ELSE ENDIF COMMA DOT COLON SEMICOLON BAR UP DOT_DOT UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR RIGHT_BRK RIGHT_BRA MINUS_GT }]
  [simpleName ::= (*) SIMPLE_NAME , {LEFT_PAR }]
}
transition on SIMPLE_NAME to state [12]
transition on simpleName to state [113]

-------------------
lalr_state [63]: {
  [oclExpression ::= (*) oclExpression UP simpleName LEFT_PAR oclMessageArgumentList RIGHT_PAR , {EOF ENDPACKAGE CONTEXT INIT DERIVE INV DEF PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE IN THEN ELSE ENDIF COMMA DOT COLON SEMICOLON BAR UP DOT_DOT UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR RIGHT_BRK RIGHT_BRA MINUS_GT }]
  [oclExpression ::= (*) oclExpression EQ oclExpression , {EOF ENDPACKAGE CONTEXT INIT DERIVE INV DEF PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE IN THEN ELSE ENDIF COMMA DOT COLON SEMICOLON BAR UP DOT_DOT UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR RIGHT_BRK RIGHT_BRA MINUS_GT }]
  [oclExpression ::= (*) oclExpression TIMES oclExpression , {EOF ENDPACKAGE CONTEXT INIT DERIVE INV DEF PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE IN THEN ELSE ENDIF COMMA DOT COLON SEMICOLON BAR UP DOT_DOT UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR RIGHT_BRK RIGHT_BRA MINUS_GT }]
  [oclExpression ::= (*) oclExpression DOT simpleName isMarkedPre , {EOF ENDPACKAGE CONTEXT INIT DERIVE INV DEF PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE IN THEN ELSE ENDIF COMMA DOT COLON SEMICOLON BAR UP DOT_DOT UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR RIGHT_BRK RIGHT_BRA MINUS_GT }]
  [primitiveLiteralExp ::= (*) TRUE , {EOF ENDPACKAGE CONTEXT INIT DERIVE INV DEF PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE IN THEN ELSE ENDIF COMMA DOT COLON SEMICOLON BAR UP DOT_DOT UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR RIGHT_BRK RIGHT_BRA MINUS_GT }]
  [literalExp ::= (*) tupleLiteralExp , {EOF ENDPACKAGE CONTEXT INIT DERIVE INV DEF PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE IN THEN ELSE ENDIF COMMA DOT COLON SEMICOLON BAR UP DOT_DOT UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR RIGHT_BRK RIGHT_BRA MINUS_GT }]
  [oclExpression ::= oclExpression IMPLIES (*) oclExpression , {EOF ENDPACKAGE CONTEXT INIT DERIVE INV DEF PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE IN THEN ELSE ENDIF COMMA DOT COLON SEMICOLON BAR UP DOT_DOT UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR RIGHT_BRK RIGHT_BRA MINUS_GT }]
  [oclExpression ::= (*) oclExpression IMPLIES oclExpression , {EOF ENDPACKAGE CONTEXT INIT DERIVE INV DEF PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE IN THEN ELSE ENDIF COMMA DOT COLON SEMICOLON BAR UP DOT_DOT UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR RIGHT_BRK RIGHT_BRA MINUS_GT }]
  [oclExpression ::= (*) oclExpression LT oclExpression , {EOF ENDPACKAGE CONTEXT INIT DERIVE INV DEF PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE IN THEN ELSE ENDIF COMMA DOT COLON SEMICOLON BAR UP DOT_DOT UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR RIGHT_BRK RIGHT_BRA MINUS_GT }]
  [oclExpression ::= (*) oclExpression MINUS_GT ITERATE LEFT_PAR variableDeclaration SEMICOLON variableDeclaration BAR oclExpression RIGHT_PAR , {EOF ENDPACKAGE CONTEXT INIT DERIVE INV DEF PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE IN THEN ELSE ENDIF COMMA DOT COLON SEMICOLON BAR UP DOT_DOT UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR RIGHT_BRK RIGHT_BRA MINUS_GT }]
  [tupleLiteralExp ::= (*) TUPLE LEFT_BRA variableDeclarationList RIGHT_BRA , {EOF ENDPACKAGE CONTEXT INIT DERIVE INV DEF PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE IN THEN ELSE ENDIF COMMA DOT COLON SEMICOLON BAR UP DOT_DOT UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR RIGHT_BRK RIGHT_BRA MINUS_GT }]
  [collectionKind ::= (*) SET , {LEFT_BRA }]
  [oclExpression ::= (*) oclExpression UP simpleName LEFT_PAR RIGHT_PAR , {EOF ENDPACKAGE CONTEXT INIT DERIVE INV DEF PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE IN THEN ELSE ENDIF COMMA DOT COLON SEMICOLON BAR UP DOT_DOT UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR RIGHT_BRK RIGHT_BRA MINUS_GT }]
  [oclExpression ::= (*) oclExpression NE oclExpression , {EOF ENDPACKAGE CONTEXT INIT DERIVE INV DEF PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE IN THEN ELSE ENDIF COMMA DOT COLON SEMICOLON BAR UP DOT_DOT UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR RIGHT_BRK RIGHT_BRA MINUS_GT }]
  [oclExpression ::= (*) oclExpression DIVIDE oclExpression , {EOF ENDPACKAGE CONTEXT INIT DERIVE INV DEF PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE IN THEN ELSE ENDIF COMMA DOT COLON SEMICOLON BAR UP DOT_DOT UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR RIGHT_BRK RIGHT_BRA MINUS_GT }]
  [oclExpression ::= (*) oclExpression LEFT_PAR arguments RIGHT_PAR , {EOF ENDPACKAGE CONTEXT INIT DERIVE INV DEF PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE IN THEN ELSE ENDIF COMMA DOT COLON SEMICOLON BAR UP DOT_DOT UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR RIGHT_BRK RIGHT_BRA MINUS_GT }]
  [primitiveLiteralExp ::= (*) FALSE , {EOF ENDPACKAGE CONTEXT INIT DERIVE INV DEF PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE IN THEN ELSE ENDIF COMMA DOT COLON SEMICOLON BAR UP DOT_DOT UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR RIGHT_BRK RIGHT_BRA MINUS_GT }]
  [literalExp ::= (*) primitiveLiteralExp , {EOF ENDPACKAGE CONTEXT INIT DERIVE INV DEF PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE IN THEN ELSE ENDIF COMMA DOT COLON SEMICOLON BAR UP DOT_DOT UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR RIGHT_BRK RIGHT_BRA MINUS_GT }]
  [oclExpression ::= (*) LET variableDeclarationList IN oclExpression , {EOF ENDPACKAGE CONTEXT INIT DERIVE INV DEF PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE IN THEN ELSE ENDIF COMMA DOT COLON SEMICOLON BAR UP DOT_DOT UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR RIGHT_BRK RIGHT_BRA MINUS_GT }]
  [oclExpression ::= (*) oclExpression GT oclExpression , {EOF ENDPACKAGE CONTEXT INIT DERIVE INV DEF PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE IN THEN ELSE ENDIF COMMA DOT COLON SEMICOLON BAR UP DOT_DOT UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR RIGHT_BRK RIGHT_BRA MINUS_GT }]
  [oclExpression ::= (*) oclExpression MINUS_GT ITERATE LEFT_PAR variableDeclaration BAR oclExpression RIGHT_PAR , {EOF ENDPACKAGE CONTEXT INIT DERIVE INV DEF PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE IN THEN ELSE ENDIF COMMA DOT COLON SEMICOLON BAR UP DOT_DOT UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR RIGHT_BRK RIGHT_BRA MINUS_GT }]
  [oclExpression ::= (*) literalExp , {EOF ENDPACKAGE CONTEXT INIT DERIVE INV DEF PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE IN THEN ELSE ENDIF COMMA DOT COLON SEMICOLON BAR UP DOT_DOT UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR RIGHT_BRK RIGHT_BRA MINUS_GT }]
  [primitiveLiteralExp ::= (*) INTEGER , {EOF ENDPACKAGE CONTEXT INIT DERIVE INV DEF PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE IN THEN ELSE ENDIF COMMA DOT COLON SEMICOLON BAR UP DOT_DOT UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR RIGHT_BRK RIGHT_BRA MINUS_GT }]
  [collectionKind ::= (*) BAG , {LEFT_BRA }]
  [oclExpression ::= (*) oclExpression AND oclExpression , {EOF ENDPACKAGE CONTEXT INIT DERIVE INV DEF PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE IN THEN ELSE ENDIF COMMA DOT COLON SEMICOLON BAR UP DOT_DOT UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR RIGHT_BRK RIGHT_BRA MINUS_GT }]
  [oclExpression ::= (*) oclExpression PLUS oclExpression , {EOF ENDPACKAGE CONTEXT INIT DERIVE INV DEF PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE IN THEN ELSE ENDIF COMMA DOT COLON SEMICOLON BAR UP DOT_DOT UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR RIGHT_BRK RIGHT_BRA MINUS_GT }]
  [oclExpression ::= (*) oclExpression LEFT_PAR variableDeclaration BAR oclExpression RIGHT_PAR , {EOF ENDPACKAGE CONTEXT INIT DERIVE INV DEF PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE IN THEN ELSE ENDIF COMMA DOT COLON SEMICOLON BAR UP DOT_DOT UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR RIGHT_BRK RIGHT_BRA MINUS_GT }]
  [pathName ::= (*) simpleName , {EOF ENDPACKAGE CONTEXT INIT DERIVE INV DEF PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE IN THEN ELSE ENDIF COMMA DOT COLON SEMICOLON BAR UP AT DOT_DOT COLON_COLON UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR RIGHT_BRK RIGHT_BRA MINUS_GT }]
  [oclExpression ::= (*) oclExpression UP_UP simpleName LEFT_PAR oclMessageArgumentList RIGHT_PAR , {EOF ENDPACKAGE CONTEXT INIT DERIVE INV DEF PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE IN THEN ELSE ENDIF COMMA DOT COLON SEMICOLON BAR UP DOT_DOT UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR RIGHT_BRK RIGHT_BRA MINUS_GT }]
  [oclExpression ::= (*) oclExpression LE oclExpression , {EOF ENDPACKAGE CONTEXT INIT DERIVE INV DEF PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE IN THEN ELSE ENDIF COMMA DOT COLON SEMICOLON BAR UP DOT_DOT UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR RIGHT_BRK RIGHT_BRA MINUS_GT }]
  [oclExpression ::= (*) NOT oclExpression , {EOF ENDPACKAGE CONTEXT INIT DERIVE INV DEF PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE IN THEN ELSE ENDIF COMMA DOT COLON SEMICOLON BAR UP DOT_DOT UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR RIGHT_BRK RIGHT_BRA MINUS_GT }]
  [oclExpression ::= (*) LEFT_PAR oclExpression RIGHT_PAR , {EOF ENDPACKAGE CONTEXT INIT DERIVE INV DEF PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE IN THEN ELSE ENDIF COMMA DOT COLON SEMICOLON BAR UP DOT_DOT UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR RIGHT_BRK RIGHT_BRA MINUS_GT }]
  [primitiveLiteralExp ::= (*) REAL , {EOF ENDPACKAGE CONTEXT INIT DERIVE INV DEF PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE IN THEN ELSE ENDIF COMMA DOT COLON SEMICOLON BAR UP DOT_DOT UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR RIGHT_BRK RIGHT_BRA MINUS_GT }]
  [collectionKind ::= (*) SEQUENCE , {LEFT_BRA }]
  [oclExpression ::= (*) oclExpression OR oclExpression , {EOF ENDPACKAGE CONTEXT INIT DERIVE INV DEF PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE IN THEN ELSE ENDIF COMMA DOT COLON SEMICOLON BAR UP DOT_DOT UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR RIGHT_BRK RIGHT_BRA MINUS_GT }]
  [oclExpression ::= (*) oclExpression MINUS oclExpression , {EOF ENDPACKAGE CONTEXT INIT DERIVE INV DEF PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE IN THEN ELSE ENDIF COMMA DOT COLON SEMICOLON BAR UP DOT_DOT UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR RIGHT_BRK RIGHT_BRA MINUS_GT }]
  [oclExpression ::= (*) oclExpression LEFT_BRK argumentList RIGHT_BRK isMarkedPre , {EOF ENDPACKAGE CONTEXT INIT DERIVE INV DEF PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE IN THEN ELSE ENDIF COMMA DOT COLON SEMICOLON BAR UP DOT_DOT UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR RIGHT_BRK RIGHT_BRA MINUS_GT }]
  [pathName ::= (*) pathName COLON_COLON simpleName , {EOF ENDPACKAGE CONTEXT INIT DERIVE INV DEF PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE IN THEN ELSE ENDIF COMMA DOT COLON SEMICOLON BAR UP AT DOT_DOT COLON_COLON UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR RIGHT_BRK RIGHT_BRA MINUS_GT }]
  [collectionLiteralExp ::= (*) collectionKind LEFT_BRA collectionLiteralParts RIGHT_BRA , {EOF ENDPACKAGE CONTEXT INIT DERIVE INV DEF PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE IN THEN ELSE ENDIF COMMA DOT COLON SEMICOLON BAR UP DOT_DOT UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR RIGHT_BRK RIGHT_BRA MINUS_GT }]
  [oclExpression ::= (*) oclExpression UP_UP simpleName LEFT_PAR RIGHT_PAR , {EOF ENDPACKAGE CONTEXT INIT DERIVE INV DEF PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE IN THEN ELSE ENDIF COMMA DOT COLON SEMICOLON BAR UP DOT_DOT UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR RIGHT_BRK RIGHT_BRA MINUS_GT }]
  [oclExpression ::= (*) oclExpression GE oclExpression , {EOF ENDPACKAGE CONTEXT INIT DERIVE INV DEF PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE IN THEN ELSE ENDIF COMMA DOT COLON SEMICOLON BAR UP DOT_DOT UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR RIGHT_BRK RIGHT_BRA MINUS_GT }]
  [oclExpression ::= (*) MINUS oclExpression , {EOF ENDPACKAGE CONTEXT INIT DERIVE INV DEF PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE IN THEN ELSE ENDIF COMMA DOT COLON SEMICOLON BAR UP DOT_DOT UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR RIGHT_BRK RIGHT_BRA MINUS_GT }]
  [oclExpression ::= (*) pathName isMarkedPre , {EOF ENDPACKAGE CONTEXT INIT DERIVE INV DEF PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE IN THEN ELSE ENDIF COMMA DOT COLON SEMICOLON BAR UP DOT_DOT UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR RIGHT_BRK RIGHT_BRA MINUS_GT }]
  [primitiveLiteralExp ::= (*) STRING , {EOF ENDPACKAGE CONTEXT INIT DERIVE INV DEF PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE IN THEN ELSE ENDIF COMMA DOT COLON SEMICOLON BAR UP DOT_DOT UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR RIGHT_BRK RIGHT_BRA MINUS_GT }]
  [collectionKind ::= (*) COLLECTION , {LEFT_BRA }]
  [literalExp ::= (*) collectionLiteralExp , {EOF ENDPACKAGE CONTEXT INIT DERIVE INV DEF PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE IN THEN ELSE ENDIF COMMA DOT COLON SEMICOLON BAR UP DOT_DOT UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR RIGHT_BRK RIGHT_BRA MINUS_GT }]
  [oclExpression ::= (*) oclExpression XOR oclExpression , {EOF ENDPACKAGE CONTEXT INIT DERIVE INV DEF PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE IN THEN ELSE ENDIF COMMA DOT COLON SEMICOLON BAR UP DOT_DOT UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR RIGHT_BRK RIGHT_BRA MINUS_GT }]
  [oclExpression ::= (*) IF oclExpression THEN oclExpression ELSE oclExpression ENDIF , {EOF ENDPACKAGE CONTEXT INIT DERIVE INV DEF PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE IN THEN ELSE ENDIF COMMA DOT COLON SEMICOLON BAR UP DOT_DOT UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR RIGHT_BRK RIGHT_BRA MINUS_GT }]
  [oclExpression ::= (*) oclExpression MINUS_GT simpleName , {EOF ENDPACKAGE CONTEXT INIT DERIVE INV DEF PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE IN THEN ELSE ENDIF COMMA DOT COLON SEMICOLON BAR UP DOT_DOT UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR RIGHT_BRK RIGHT_BRA MINUS_GT }]
  [simpleName ::= (*) SIMPLE_NAME , {EOF ENDPACKAGE CONTEXT INIT DERIVE INV DEF PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE IN THEN ELSE ENDIF COMMA DOT COLON SEMICOLON BAR UP AT DOT_DOT COLON_COLON UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR RIGHT_BRK RIGHT_BRA MINUS_GT }]
  [collectionLiteralExp ::= (*) collectionKind LEFT_BRA RIGHT_BRA , {EOF ENDPACKAGE CONTEXT INIT DERIVE INV DEF PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE IN THEN ELSE ENDIF COMMA DOT COLON SEMICOLON BAR UP DOT_DOT UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR RIGHT_BRK RIGHT_BRA MINUS_GT }]
}
transition on tupleLiteralExp to state [54]
transition on oclExpression to state [112]
transition on REAL to state [52]
transition on INTEGER to state [51]
transition on pathName to state [50]
transition on SIMPLE_NAME to state [12]
transition on LET to state [49]
transition on FALSE to state [48]
transition on MINUS to state [47]
transition on COLLECTION to state [28]
transition on SET to state [20]
transition on simpleName to state [26]
transition on collectionLiteralExp to state [46]
transition on LEFT_PAR to state [45]
transition on STRING to state [44]
transition on IF to state [43]
transition on TRUE to state [42]
transition on collectionKind to state [41]
transition on NOT to state [40]
transition on primitiveLiteralExp to state [39]
transition on TUPLE to state [38]
transition on literalExp to state [37]
transition on BAG to state [25]
transition on SEQUENCE to state [22]

-------------------
lalr_state [64]: {
  [oclExpression ::= (*) oclExpression UP simpleName LEFT_PAR oclMessageArgumentList RIGHT_PAR , {EOF ENDPACKAGE CONTEXT INIT DERIVE INV DEF PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE IN THEN ELSE ENDIF COMMA DOT COLON SEMICOLON BAR UP DOT_DOT UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR RIGHT_BRK RIGHT_BRA MINUS_GT }]
  [oclExpression ::= (*) oclExpression EQ oclExpression , {EOF ENDPACKAGE CONTEXT INIT DERIVE INV DEF PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE IN THEN ELSE ENDIF COMMA DOT COLON SEMICOLON BAR UP DOT_DOT UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR RIGHT_BRK RIGHT_BRA MINUS_GT }]
  [oclExpression ::= (*) oclExpression TIMES oclExpression , {EOF ENDPACKAGE CONTEXT INIT DERIVE INV DEF PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE IN THEN ELSE ENDIF COMMA DOT COLON SEMICOLON BAR UP DOT_DOT UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR RIGHT_BRK RIGHT_BRA MINUS_GT }]
  [oclExpression ::= (*) oclExpression DOT simpleName isMarkedPre , {EOF ENDPACKAGE CONTEXT INIT DERIVE INV DEF PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE IN THEN ELSE ENDIF COMMA DOT COLON SEMICOLON BAR UP DOT_DOT UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR RIGHT_BRK RIGHT_BRA MINUS_GT }]
  [primitiveLiteralExp ::= (*) TRUE , {EOF ENDPACKAGE CONTEXT INIT DERIVE INV DEF PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE IN THEN ELSE ENDIF COMMA DOT COLON SEMICOLON BAR UP DOT_DOT UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR RIGHT_BRK RIGHT_BRA MINUS_GT }]
  [literalExp ::= (*) tupleLiteralExp , {EOF ENDPACKAGE CONTEXT INIT DERIVE INV DEF PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE IN THEN ELSE ENDIF COMMA DOT COLON SEMICOLON BAR UP DOT_DOT UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR RIGHT_BRK RIGHT_BRA MINUS_GT }]
  [oclExpression ::= (*) oclExpression IMPLIES oclExpression , {EOF ENDPACKAGE CONTEXT INIT DERIVE INV DEF PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE IN THEN ELSE ENDIF COMMA DOT COLON SEMICOLON BAR UP DOT_DOT UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR RIGHT_BRK RIGHT_BRA MINUS_GT }]
  [oclExpression ::= (*) oclExpression LT oclExpression , {EOF ENDPACKAGE CONTEXT INIT DERIVE INV DEF PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE IN THEN ELSE ENDIF COMMA DOT COLON SEMICOLON BAR UP DOT_DOT UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR RIGHT_BRK RIGHT_BRA MINUS_GT }]
  [oclExpression ::= (*) oclExpression MINUS_GT ITERATE LEFT_PAR variableDeclaration SEMICOLON variableDeclaration BAR oclExpression RIGHT_PAR , {EOF ENDPACKAGE CONTEXT INIT DERIVE INV DEF PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE IN THEN ELSE ENDIF COMMA DOT COLON SEMICOLON BAR UP DOT_DOT UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR RIGHT_BRK RIGHT_BRA MINUS_GT }]
  [tupleLiteralExp ::= (*) TUPLE LEFT_BRA variableDeclarationList RIGHT_BRA , {EOF ENDPACKAGE CONTEXT INIT DERIVE INV DEF PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE IN THEN ELSE ENDIF COMMA DOT COLON SEMICOLON BAR UP DOT_DOT UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR RIGHT_BRK RIGHT_BRA MINUS_GT }]
  [collectionKind ::= (*) SET , {LEFT_BRA }]
  [oclExpression ::= (*) oclExpression UP simpleName LEFT_PAR RIGHT_PAR , {EOF ENDPACKAGE CONTEXT INIT DERIVE INV DEF PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE IN THEN ELSE ENDIF COMMA DOT COLON SEMICOLON BAR UP DOT_DOT UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR RIGHT_BRK RIGHT_BRA MINUS_GT }]
  [oclExpression ::= (*) oclExpression NE oclExpression , {EOF ENDPACKAGE CONTEXT INIT DERIVE INV DEF PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE IN THEN ELSE ENDIF COMMA DOT COLON SEMICOLON BAR UP DOT_DOT UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR RIGHT_BRK RIGHT_BRA MINUS_GT }]
  [oclExpression ::= (*) oclExpression DIVIDE oclExpression , {EOF ENDPACKAGE CONTEXT INIT DERIVE INV DEF PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE IN THEN ELSE ENDIF COMMA DOT COLON SEMICOLON BAR UP DOT_DOT UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR RIGHT_BRK RIGHT_BRA MINUS_GT }]
  [oclExpression ::= (*) oclExpression LEFT_PAR arguments RIGHT_PAR , {EOF ENDPACKAGE CONTEXT INIT DERIVE INV DEF PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE IN THEN ELSE ENDIF COMMA DOT COLON SEMICOLON BAR UP DOT_DOT UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR RIGHT_BRK RIGHT_BRA MINUS_GT }]
  [primitiveLiteralExp ::= (*) FALSE , {EOF ENDPACKAGE CONTEXT INIT DERIVE INV DEF PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE IN THEN ELSE ENDIF COMMA DOT COLON SEMICOLON BAR UP DOT_DOT UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR RIGHT_BRK RIGHT_BRA MINUS_GT }]
  [literalExp ::= (*) primitiveLiteralExp , {EOF ENDPACKAGE CONTEXT INIT DERIVE INV DEF PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE IN THEN ELSE ENDIF COMMA DOT COLON SEMICOLON BAR UP DOT_DOT UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR RIGHT_BRK RIGHT_BRA MINUS_GT }]
  [oclExpression ::= oclExpression GT (*) oclExpression , {EOF ENDPACKAGE CONTEXT INIT DERIVE INV DEF PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE IN THEN ELSE ENDIF COMMA DOT COLON SEMICOLON BAR UP DOT_DOT UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR RIGHT_BRK RIGHT_BRA MINUS_GT }]
  [oclExpression ::= (*) LET variableDeclarationList IN oclExpression , {EOF ENDPACKAGE CONTEXT INIT DERIVE INV DEF PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE IN THEN ELSE ENDIF COMMA DOT COLON SEMICOLON BAR UP DOT_DOT UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR RIGHT_BRK RIGHT_BRA MINUS_GT }]
  [oclExpression ::= (*) oclExpression GT oclExpression , {EOF ENDPACKAGE CONTEXT INIT DERIVE INV DEF PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE IN THEN ELSE ENDIF COMMA DOT COLON SEMICOLON BAR UP DOT_DOT UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR RIGHT_BRK RIGHT_BRA MINUS_GT }]
  [oclExpression ::= (*) oclExpression MINUS_GT ITERATE LEFT_PAR variableDeclaration BAR oclExpression RIGHT_PAR , {EOF ENDPACKAGE CONTEXT INIT DERIVE INV DEF PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE IN THEN ELSE ENDIF COMMA DOT COLON SEMICOLON BAR UP DOT_DOT UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR RIGHT_BRK RIGHT_BRA MINUS_GT }]
  [oclExpression ::= (*) literalExp , {EOF ENDPACKAGE CONTEXT INIT DERIVE INV DEF PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE IN THEN ELSE ENDIF COMMA DOT COLON SEMICOLON BAR UP DOT_DOT UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR RIGHT_BRK RIGHT_BRA MINUS_GT }]
  [primitiveLiteralExp ::= (*) INTEGER , {EOF ENDPACKAGE CONTEXT INIT DERIVE INV DEF PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE IN THEN ELSE ENDIF COMMA DOT COLON SEMICOLON BAR UP DOT_DOT UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR RIGHT_BRK RIGHT_BRA MINUS_GT }]
  [collectionKind ::= (*) BAG , {LEFT_BRA }]
  [oclExpression ::= (*) oclExpression AND oclExpression , {EOF ENDPACKAGE CONTEXT INIT DERIVE INV DEF PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE IN THEN ELSE ENDIF COMMA DOT COLON SEMICOLON BAR UP DOT_DOT UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR RIGHT_BRK RIGHT_BRA MINUS_GT }]
  [oclExpression ::= (*) oclExpression PLUS oclExpression , {EOF ENDPACKAGE CONTEXT INIT DERIVE INV DEF PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE IN THEN ELSE ENDIF COMMA DOT COLON SEMICOLON BAR UP DOT_DOT UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR RIGHT_BRK RIGHT_BRA MINUS_GT }]
  [oclExpression ::= (*) oclExpression LEFT_PAR variableDeclaration BAR oclExpression RIGHT_PAR , {EOF ENDPACKAGE CONTEXT INIT DERIVE INV DEF PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE IN THEN ELSE ENDIF COMMA DOT COLON SEMICOLON BAR UP DOT_DOT UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR RIGHT_BRK RIGHT_BRA MINUS_GT }]
  [pathName ::= (*) simpleName , {EOF ENDPACKAGE CONTEXT INIT DERIVE INV DEF PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE IN THEN ELSE ENDIF COMMA DOT COLON SEMICOLON BAR UP AT DOT_DOT COLON_COLON UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR RIGHT_BRK RIGHT_BRA MINUS_GT }]
  [oclExpression ::= (*) oclExpression UP_UP simpleName LEFT_PAR oclMessageArgumentList RIGHT_PAR , {EOF ENDPACKAGE CONTEXT INIT DERIVE INV DEF PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE IN THEN ELSE ENDIF COMMA DOT COLON SEMICOLON BAR UP DOT_DOT UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR RIGHT_BRK RIGHT_BRA MINUS_GT }]
  [oclExpression ::= (*) oclExpression LE oclExpression , {EOF ENDPACKAGE CONTEXT INIT DERIVE INV DEF PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE IN THEN ELSE ENDIF COMMA DOT COLON SEMICOLON BAR UP DOT_DOT UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR RIGHT_BRK RIGHT_BRA MINUS_GT }]
  [oclExpression ::= (*) NOT oclExpression , {EOF ENDPACKAGE CONTEXT INIT DERIVE INV DEF PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE IN THEN ELSE ENDIF COMMA DOT COLON SEMICOLON BAR UP DOT_DOT UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR RIGHT_BRK RIGHT_BRA MINUS_GT }]
  [oclExpression ::= (*) LEFT_PAR oclExpression RIGHT_PAR , {EOF ENDPACKAGE CONTEXT INIT DERIVE INV DEF PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE IN THEN ELSE ENDIF COMMA DOT COLON SEMICOLON BAR UP DOT_DOT UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR RIGHT_BRK RIGHT_BRA MINUS_GT }]
  [primitiveLiteralExp ::= (*) REAL , {EOF ENDPACKAGE CONTEXT INIT DERIVE INV DEF PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE IN THEN ELSE ENDIF COMMA DOT COLON SEMICOLON BAR UP DOT_DOT UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR RIGHT_BRK RIGHT_BRA MINUS_GT }]
  [collectionKind ::= (*) SEQUENCE , {LEFT_BRA }]
  [oclExpression ::= (*) oclExpression OR oclExpression , {EOF ENDPACKAGE CONTEXT INIT DERIVE INV DEF PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE IN THEN ELSE ENDIF COMMA DOT COLON SEMICOLON BAR UP DOT_DOT UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR RIGHT_BRK RIGHT_BRA MINUS_GT }]
  [oclExpression ::= (*) oclExpression MINUS oclExpression , {EOF ENDPACKAGE CONTEXT INIT DERIVE INV DEF PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE IN THEN ELSE ENDIF COMMA DOT COLON SEMICOLON BAR UP DOT_DOT UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR RIGHT_BRK RIGHT_BRA MINUS_GT }]
  [oclExpression ::= (*) oclExpression LEFT_BRK argumentList RIGHT_BRK isMarkedPre , {EOF ENDPACKAGE CONTEXT INIT DERIVE INV DEF PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE IN THEN ELSE ENDIF COMMA DOT COLON SEMICOLON BAR UP DOT_DOT UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR RIGHT_BRK RIGHT_BRA MINUS_GT }]
  [pathName ::= (*) pathName COLON_COLON simpleName , {EOF ENDPACKAGE CONTEXT INIT DERIVE INV DEF PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE IN THEN ELSE ENDIF COMMA DOT COLON SEMICOLON BAR UP AT DOT_DOT COLON_COLON UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR RIGHT_BRK RIGHT_BRA MINUS_GT }]
  [collectionLiteralExp ::= (*) collectionKind LEFT_BRA collectionLiteralParts RIGHT_BRA , {EOF ENDPACKAGE CONTEXT INIT DERIVE INV DEF PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE IN THEN ELSE ENDIF COMMA DOT COLON SEMICOLON BAR UP DOT_DOT UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR RIGHT_BRK RIGHT_BRA MINUS_GT }]
  [oclExpression ::= (*) oclExpression UP_UP simpleName LEFT_PAR RIGHT_PAR , {EOF ENDPACKAGE CONTEXT INIT DERIVE INV DEF PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE IN THEN ELSE ENDIF COMMA DOT COLON SEMICOLON BAR UP DOT_DOT UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR RIGHT_BRK RIGHT_BRA MINUS_GT }]
  [oclExpression ::= (*) oclExpression GE oclExpression , {EOF ENDPACKAGE CONTEXT INIT DERIVE INV DEF PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE IN THEN ELSE ENDIF COMMA DOT COLON SEMICOLON BAR UP DOT_DOT UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR RIGHT_BRK RIGHT_BRA MINUS_GT }]
  [oclExpression ::= (*) MINUS oclExpression , {EOF ENDPACKAGE CONTEXT INIT DERIVE INV DEF PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE IN THEN ELSE ENDIF COMMA DOT COLON SEMICOLON BAR UP DOT_DOT UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR RIGHT_BRK RIGHT_BRA MINUS_GT }]
  [oclExpression ::= (*) pathName isMarkedPre , {EOF ENDPACKAGE CONTEXT INIT DERIVE INV DEF PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE IN THEN ELSE ENDIF COMMA DOT COLON SEMICOLON BAR UP DOT_DOT UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR RIGHT_BRK RIGHT_BRA MINUS_GT }]
  [primitiveLiteralExp ::= (*) STRING , {EOF ENDPACKAGE CONTEXT INIT DERIVE INV DEF PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE IN THEN ELSE ENDIF COMMA DOT COLON SEMICOLON BAR UP DOT_DOT UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR RIGHT_BRK RIGHT_BRA MINUS_GT }]
  [collectionKind ::= (*) COLLECTION , {LEFT_BRA }]
  [literalExp ::= (*) collectionLiteralExp , {EOF ENDPACKAGE CONTEXT INIT DERIVE INV DEF PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE IN THEN ELSE ENDIF COMMA DOT COLON SEMICOLON BAR UP DOT_DOT UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR RIGHT_BRK RIGHT_BRA MINUS_GT }]
  [oclExpression ::= (*) oclExpression XOR oclExpression , {EOF ENDPACKAGE CONTEXT INIT DERIVE INV DEF PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE IN THEN ELSE ENDIF COMMA DOT COLON SEMICOLON BAR UP DOT_DOT UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR RIGHT_BRK RIGHT_BRA MINUS_GT }]
  [oclExpression ::= (*) IF oclExpression THEN oclExpression ELSE oclExpression ENDIF , {EOF ENDPACKAGE CONTEXT INIT DERIVE INV DEF PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE IN THEN ELSE ENDIF COMMA DOT COLON SEMICOLON BAR UP DOT_DOT UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR RIGHT_BRK RIGHT_BRA MINUS_GT }]
  [oclExpression ::= (*) oclExpression MINUS_GT simpleName , {EOF ENDPACKAGE CONTEXT INIT DERIVE INV DEF PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE IN THEN ELSE ENDIF COMMA DOT COLON SEMICOLON BAR UP DOT_DOT UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR RIGHT_BRK RIGHT_BRA MINUS_GT }]
  [simpleName ::= (*) SIMPLE_NAME , {EOF ENDPACKAGE CONTEXT INIT DERIVE INV DEF PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE IN THEN ELSE ENDIF COMMA DOT COLON SEMICOLON BAR UP AT DOT_DOT COLON_COLON UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR RIGHT_BRK RIGHT_BRA MINUS_GT }]
  [collectionLiteralExp ::= (*) collectionKind LEFT_BRA RIGHT_BRA , {EOF ENDPACKAGE CONTEXT INIT DERIVE INV DEF PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE IN THEN ELSE ENDIF COMMA DOT COLON SEMICOLON BAR UP DOT_DOT UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR RIGHT_BRK RIGHT_BRA MINUS_GT }]
}
transition on tupleLiteralExp to state [54]
transition on oclExpression to state [111]
transition on REAL to state [52]
transition on INTEGER to state [51]
transition on pathName to state [50]
transition on SIMPLE_NAME to state [12]
transition on LET to state [49]
transition on FALSE to state [48]
transition on MINUS to state [47]
transition on COLLECTION to state [28]
transition on SET to state [20]
transition on simpleName to state [26]
transition on collectionLiteralExp to state [46]
transition on LEFT_PAR to state [45]
transition on STRING to state [44]
transition on IF to state [43]
transition on TRUE to state [42]
transition on collectionKind to state [41]
transition on NOT to state [40]
transition on primitiveLiteralExp to state [39]
transition on TUPLE to state [38]
transition on literalExp to state [37]
transition on BAG to state [25]
transition on SEQUENCE to state [22]

-------------------
lalr_state [65]: {
  [oclExpression ::= (*) oclExpression UP simpleName LEFT_PAR oclMessageArgumentList RIGHT_PAR , {EOF ENDPACKAGE CONTEXT INIT DERIVE INV DEF PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE IN THEN ELSE ENDIF COMMA DOT COLON SEMICOLON BAR UP DOT_DOT UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR RIGHT_BRK RIGHT_BRA MINUS_GT }]
  [oclExpression ::= (*) oclExpression EQ oclExpression , {EOF ENDPACKAGE CONTEXT INIT DERIVE INV DEF PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE IN THEN ELSE ENDIF COMMA DOT COLON SEMICOLON BAR UP DOT_DOT UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR RIGHT_BRK RIGHT_BRA MINUS_GT }]
  [oclExpression ::= (*) oclExpression TIMES oclExpression , {EOF ENDPACKAGE CONTEXT INIT DERIVE INV DEF PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE IN THEN ELSE ENDIF COMMA DOT COLON SEMICOLON BAR UP DOT_DOT UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR RIGHT_BRK RIGHT_BRA MINUS_GT }]
  [oclExpression ::= (*) oclExpression DOT simpleName isMarkedPre , {EOF ENDPACKAGE CONTEXT INIT DERIVE INV DEF PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE IN THEN ELSE ENDIF COMMA DOT COLON SEMICOLON BAR UP DOT_DOT UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR RIGHT_BRK RIGHT_BRA MINUS_GT }]
  [primitiveLiteralExp ::= (*) TRUE , {EOF ENDPACKAGE CONTEXT INIT DERIVE INV DEF PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE IN THEN ELSE ENDIF COMMA DOT COLON SEMICOLON BAR UP DOT_DOT UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR RIGHT_BRK RIGHT_BRA MINUS_GT }]
  [literalExp ::= (*) tupleLiteralExp , {EOF ENDPACKAGE CONTEXT INIT DERIVE INV DEF PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE IN THEN ELSE ENDIF COMMA DOT COLON SEMICOLON BAR UP DOT_DOT UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR RIGHT_BRK RIGHT_BRA MINUS_GT }]
  [oclExpression ::= (*) oclExpression IMPLIES oclExpression , {EOF ENDPACKAGE CONTEXT INIT DERIVE INV DEF PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE IN THEN ELSE ENDIF COMMA DOT COLON SEMICOLON BAR UP DOT_DOT UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR RIGHT_BRK RIGHT_BRA MINUS_GT }]
  [oclExpression ::= (*) oclExpression LT oclExpression , {EOF ENDPACKAGE CONTEXT INIT DERIVE INV DEF PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE IN THEN ELSE ENDIF COMMA DOT COLON SEMICOLON BAR UP DOT_DOT UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR RIGHT_BRK RIGHT_BRA MINUS_GT }]
  [oclExpression ::= (*) oclExpression MINUS_GT ITERATE LEFT_PAR variableDeclaration SEMICOLON variableDeclaration BAR oclExpression RIGHT_PAR , {EOF ENDPACKAGE CONTEXT INIT DERIVE INV DEF PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE IN THEN ELSE ENDIF COMMA DOT COLON SEMICOLON BAR UP DOT_DOT UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR RIGHT_BRK RIGHT_BRA MINUS_GT }]
  [tupleLiteralExp ::= (*) TUPLE LEFT_BRA variableDeclarationList RIGHT_BRA , {EOF ENDPACKAGE CONTEXT INIT DERIVE INV DEF PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE IN THEN ELSE ENDIF COMMA DOT COLON SEMICOLON BAR UP DOT_DOT UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR RIGHT_BRK RIGHT_BRA MINUS_GT }]
  [collectionKind ::= (*) SET , {LEFT_BRA }]
  [oclExpression ::= (*) oclExpression UP simpleName LEFT_PAR RIGHT_PAR , {EOF ENDPACKAGE CONTEXT INIT DERIVE INV DEF PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE IN THEN ELSE ENDIF COMMA DOT COLON SEMICOLON BAR UP DOT_DOT UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR RIGHT_BRK RIGHT_BRA MINUS_GT }]
  [oclExpression ::= (*) oclExpression NE oclExpression , {EOF ENDPACKAGE CONTEXT INIT DERIVE INV DEF PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE IN THEN ELSE ENDIF COMMA DOT COLON SEMICOLON BAR UP DOT_DOT UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR RIGHT_BRK RIGHT_BRA MINUS_GT }]
  [oclExpression ::= (*) oclExpression DIVIDE oclExpression , {EOF ENDPACKAGE CONTEXT INIT DERIVE INV DEF PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE IN THEN ELSE ENDIF COMMA DOT COLON SEMICOLON BAR UP DOT_DOT UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR RIGHT_BRK RIGHT_BRA MINUS_GT }]
  [oclExpression ::= (*) oclExpression LEFT_PAR arguments RIGHT_PAR , {EOF ENDPACKAGE CONTEXT INIT DERIVE INV DEF PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE IN THEN ELSE ENDIF COMMA DOT COLON SEMICOLON BAR UP DOT_DOT UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR RIGHT_BRK RIGHT_BRA MINUS_GT }]
  [primitiveLiteralExp ::= (*) FALSE , {EOF ENDPACKAGE CONTEXT INIT DERIVE INV DEF PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE IN THEN ELSE ENDIF COMMA DOT COLON SEMICOLON BAR UP DOT_DOT UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR RIGHT_BRK RIGHT_BRA MINUS_GT }]
  [literalExp ::= (*) primitiveLiteralExp , {EOF ENDPACKAGE CONTEXT INIT DERIVE INV DEF PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE IN THEN ELSE ENDIF COMMA DOT COLON SEMICOLON BAR UP DOT_DOT UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR RIGHT_BRK RIGHT_BRA MINUS_GT }]
  [oclExpression ::= (*) LET variableDeclarationList IN oclExpression , {EOF ENDPACKAGE CONTEXT INIT DERIVE INV DEF PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE IN THEN ELSE ENDIF COMMA DOT COLON SEMICOLON BAR UP DOT_DOT UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR RIGHT_BRK RIGHT_BRA MINUS_GT }]
  [oclExpression ::= (*) oclExpression GT oclExpression , {EOF ENDPACKAGE CONTEXT INIT DERIVE INV DEF PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE IN THEN ELSE ENDIF COMMA DOT COLON SEMICOLON BAR UP DOT_DOT UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR RIGHT_BRK RIGHT_BRA MINUS_GT }]
  [oclExpression ::= (*) oclExpression MINUS_GT ITERATE LEFT_PAR variableDeclaration BAR oclExpression RIGHT_PAR , {EOF ENDPACKAGE CONTEXT INIT DERIVE INV DEF PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE IN THEN ELSE ENDIF COMMA DOT COLON SEMICOLON BAR UP DOT_DOT UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR RIGHT_BRK RIGHT_BRA MINUS_GT }]
  [oclExpression ::= (*) literalExp , {EOF ENDPACKAGE CONTEXT INIT DERIVE INV DEF PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE IN THEN ELSE ENDIF COMMA DOT COLON SEMICOLON BAR UP DOT_DOT UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR RIGHT_BRK RIGHT_BRA MINUS_GT }]
  [primitiveLiteralExp ::= (*) INTEGER , {EOF ENDPACKAGE CONTEXT INIT DERIVE INV DEF PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE IN THEN ELSE ENDIF COMMA DOT COLON SEMICOLON BAR UP DOT_DOT UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR RIGHT_BRK RIGHT_BRA MINUS_GT }]
  [collectionKind ::= (*) BAG , {LEFT_BRA }]
  [oclExpression ::= (*) oclExpression AND oclExpression , {EOF ENDPACKAGE CONTEXT INIT DERIVE INV DEF PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE IN THEN ELSE ENDIF COMMA DOT COLON SEMICOLON BAR UP DOT_DOT UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR RIGHT_BRK RIGHT_BRA MINUS_GT }]
  [oclExpression ::= (*) oclExpression PLUS oclExpression , {EOF ENDPACKAGE CONTEXT INIT DERIVE INV DEF PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE IN THEN ELSE ENDIF COMMA DOT COLON SEMICOLON BAR UP DOT_DOT UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR RIGHT_BRK RIGHT_BRA MINUS_GT }]
  [oclExpression ::= (*) oclExpression LEFT_PAR variableDeclaration BAR oclExpression RIGHT_PAR , {EOF ENDPACKAGE CONTEXT INIT DERIVE INV DEF PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE IN THEN ELSE ENDIF COMMA DOT COLON SEMICOLON BAR UP DOT_DOT UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR RIGHT_BRK RIGHT_BRA MINUS_GT }]
  [pathName ::= (*) simpleName , {EOF ENDPACKAGE CONTEXT INIT DERIVE INV DEF PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE IN THEN ELSE ENDIF COMMA DOT COLON SEMICOLON BAR UP AT DOT_DOT COLON_COLON UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR RIGHT_BRK RIGHT_BRA MINUS_GT }]
  [oclExpression ::= oclExpression LE (*) oclExpression , {EOF ENDPACKAGE CONTEXT INIT DERIVE INV DEF PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE IN THEN ELSE ENDIF COMMA DOT COLON SEMICOLON BAR UP DOT_DOT UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR RIGHT_BRK RIGHT_BRA MINUS_GT }]
  [oclExpression ::= (*) oclExpression UP_UP simpleName LEFT_PAR oclMessageArgumentList RIGHT_PAR , {EOF ENDPACKAGE CONTEXT INIT DERIVE INV DEF PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE IN THEN ELSE ENDIF COMMA DOT COLON SEMICOLON BAR UP DOT_DOT UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR RIGHT_BRK RIGHT_BRA MINUS_GT }]
  [oclExpression ::= (*) oclExpression LE oclExpression , {EOF ENDPACKAGE CONTEXT INIT DERIVE INV DEF PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE IN THEN ELSE ENDIF COMMA DOT COLON SEMICOLON BAR UP DOT_DOT UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR RIGHT_BRK RIGHT_BRA MINUS_GT }]
  [oclExpression ::= (*) NOT oclExpression , {EOF ENDPACKAGE CONTEXT INIT DERIVE INV DEF PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE IN THEN ELSE ENDIF COMMA DOT COLON SEMICOLON BAR UP DOT_DOT UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR RIGHT_BRK RIGHT_BRA MINUS_GT }]
  [oclExpression ::= (*) LEFT_PAR oclExpression RIGHT_PAR , {EOF ENDPACKAGE CONTEXT INIT DERIVE INV DEF PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE IN THEN ELSE ENDIF COMMA DOT COLON SEMICOLON BAR UP DOT_DOT UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR RIGHT_BRK RIGHT_BRA MINUS_GT }]
  [primitiveLiteralExp ::= (*) REAL , {EOF ENDPACKAGE CONTEXT INIT DERIVE INV DEF PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE IN THEN ELSE ENDIF COMMA DOT COLON SEMICOLON BAR UP DOT_DOT UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR RIGHT_BRK RIGHT_BRA MINUS_GT }]
  [collectionKind ::= (*) SEQUENCE , {LEFT_BRA }]
  [oclExpression ::= (*) oclExpression OR oclExpression , {EOF ENDPACKAGE CONTEXT INIT DERIVE INV DEF PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE IN THEN ELSE ENDIF COMMA DOT COLON SEMICOLON BAR UP DOT_DOT UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR RIGHT_BRK RIGHT_BRA MINUS_GT }]
  [oclExpression ::= (*) oclExpression MINUS oclExpression , {EOF ENDPACKAGE CONTEXT INIT DERIVE INV DEF PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE IN THEN ELSE ENDIF COMMA DOT COLON SEMICOLON BAR UP DOT_DOT UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR RIGHT_BRK RIGHT_BRA MINUS_GT }]
  [oclExpression ::= (*) oclExpression LEFT_BRK argumentList RIGHT_BRK isMarkedPre , {EOF ENDPACKAGE CONTEXT INIT DERIVE INV DEF PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE IN THEN ELSE ENDIF COMMA DOT COLON SEMICOLON BAR UP DOT_DOT UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR RIGHT_BRK RIGHT_BRA MINUS_GT }]
  [pathName ::= (*) pathName COLON_COLON simpleName , {EOF ENDPACKAGE CONTEXT INIT DERIVE INV DEF PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE IN THEN ELSE ENDIF COMMA DOT COLON SEMICOLON BAR UP AT DOT_DOT COLON_COLON UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR RIGHT_BRK RIGHT_BRA MINUS_GT }]
  [collectionLiteralExp ::= (*) collectionKind LEFT_BRA collectionLiteralParts RIGHT_BRA , {EOF ENDPACKAGE CONTEXT INIT DERIVE INV DEF PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE IN THEN ELSE ENDIF COMMA DOT COLON SEMICOLON BAR UP DOT_DOT UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR RIGHT_BRK RIGHT_BRA MINUS_GT }]
  [oclExpression ::= (*) oclExpression UP_UP simpleName LEFT_PAR RIGHT_PAR , {EOF ENDPACKAGE CONTEXT INIT DERIVE INV DEF PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE IN THEN ELSE ENDIF COMMA DOT COLON SEMICOLON BAR UP DOT_DOT UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR RIGHT_BRK RIGHT_BRA MINUS_GT }]
  [oclExpression ::= (*) oclExpression GE oclExpression , {EOF ENDPACKAGE CONTEXT INIT DERIVE INV DEF PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE IN THEN ELSE ENDIF COMMA DOT COLON SEMICOLON BAR UP DOT_DOT UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR RIGHT_BRK RIGHT_BRA MINUS_GT }]
  [oclExpression ::= (*) MINUS oclExpression , {EOF ENDPACKAGE CONTEXT INIT DERIVE INV DEF PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE IN THEN ELSE ENDIF COMMA DOT COLON SEMICOLON BAR UP DOT_DOT UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR RIGHT_BRK RIGHT_BRA MINUS_GT }]
  [oclExpression ::= (*) pathName isMarkedPre , {EOF ENDPACKAGE CONTEXT INIT DERIVE INV DEF PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE IN THEN ELSE ENDIF COMMA DOT COLON SEMICOLON BAR UP DOT_DOT UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR RIGHT_BRK RIGHT_BRA MINUS_GT }]
  [primitiveLiteralExp ::= (*) STRING , {EOF ENDPACKAGE CONTEXT INIT DERIVE INV DEF PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE IN THEN ELSE ENDIF COMMA DOT COLON SEMICOLON BAR UP DOT_DOT UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR RIGHT_BRK RIGHT_BRA MINUS_GT }]
  [collectionKind ::= (*) COLLECTION , {LEFT_BRA }]
  [literalExp ::= (*) collectionLiteralExp , {EOF ENDPACKAGE CONTEXT INIT DERIVE INV DEF PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE IN THEN ELSE ENDIF COMMA DOT COLON SEMICOLON BAR UP DOT_DOT UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR RIGHT_BRK RIGHT_BRA MINUS_GT }]
  [oclExpression ::= (*) oclExpression XOR oclExpression , {EOF ENDPACKAGE CONTEXT INIT DERIVE INV DEF PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE IN THEN ELSE ENDIF COMMA DOT COLON SEMICOLON BAR UP DOT_DOT UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR RIGHT_BRK RIGHT_BRA MINUS_GT }]
  [oclExpression ::= (*) IF oclExpression THEN oclExpression ELSE oclExpression ENDIF , {EOF ENDPACKAGE CONTEXT INIT DERIVE INV DEF PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE IN THEN ELSE ENDIF COMMA DOT COLON SEMICOLON BAR UP DOT_DOT UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR RIGHT_BRK RIGHT_BRA MINUS_GT }]
  [oclExpression ::= (*) oclExpression MINUS_GT simpleName , {EOF ENDPACKAGE CONTEXT INIT DERIVE INV DEF PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE IN THEN ELSE ENDIF COMMA DOT COLON SEMICOLON BAR UP DOT_DOT UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR RIGHT_BRK RIGHT_BRA MINUS_GT }]
  [simpleName ::= (*) SIMPLE_NAME , {EOF ENDPACKAGE CONTEXT INIT DERIVE INV DEF PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE IN THEN ELSE ENDIF COMMA DOT COLON SEMICOLON BAR UP AT DOT_DOT COLON_COLON UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR RIGHT_BRK RIGHT_BRA MINUS_GT }]
  [collectionLiteralExp ::= (*) collectionKind LEFT_BRA RIGHT_BRA , {EOF ENDPACKAGE CONTEXT INIT DERIVE INV DEF PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE IN THEN ELSE ENDIF COMMA DOT COLON SEMICOLON BAR UP DOT_DOT UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR RIGHT_BRK RIGHT_BRA MINUS_GT }]
}
transition on tupleLiteralExp to state [54]
transition on oclExpression to state [110]
transition on REAL to state [52]
transition on INTEGER to state [51]
transition on pathName to state [50]
transition on SIMPLE_NAME to state [12]
transition on LET to state [49]
transition on FALSE to state [48]
transition on MINUS to state [47]
transition on COLLECTION to state [28]
transition on SET to state [20]
transition on simpleName to state [26]
transition on collectionLiteralExp to state [46]
transition on LEFT_PAR to state [45]
transition on STRING to state [44]
transition on IF to state [43]
transition on TRUE to state [42]
transition on collectionKind to state [41]
transition on NOT to state [40]
transition on primitiveLiteralExp to state [39]
transition on TUPLE to state [38]
transition on literalExp to state [37]
transition on BAG to state [25]
transition on SEQUENCE to state [22]

-------------------
lalr_state [66]: {
  [oclExpression ::= oclExpression MINUS_GT (*) ITERATE LEFT_PAR variableDeclaration BAR oclExpression RIGHT_PAR , {EOF ENDPACKAGE CONTEXT INIT DERIVE INV DEF PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE IN THEN ELSE ENDIF COMMA DOT COLON SEMICOLON BAR UP DOT_DOT UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR RIGHT_BRK RIGHT_BRA MINUS_GT }]
  [oclExpression ::= oclExpression MINUS_GT (*) ITERATE LEFT_PAR variableDeclaration SEMICOLON variableDeclaration BAR oclExpression RIGHT_PAR , {EOF ENDPACKAGE CONTEXT INIT DERIVE INV DEF PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE IN THEN ELSE ENDIF COMMA DOT COLON SEMICOLON BAR UP DOT_DOT UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR RIGHT_BRK RIGHT_BRA MINUS_GT }]
  [simpleName ::= (*) SIMPLE_NAME , {EOF ENDPACKAGE CONTEXT INIT DERIVE INV DEF PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE IN THEN ELSE ENDIF COMMA DOT COLON SEMICOLON BAR UP DOT_DOT UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR RIGHT_BRK RIGHT_BRA MINUS_GT }]
  [oclExpression ::= oclExpression MINUS_GT (*) simpleName , {EOF ENDPACKAGE CONTEXT INIT DERIVE INV DEF PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE IN THEN ELSE ENDIF COMMA DOT COLON SEMICOLON BAR UP DOT_DOT UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR RIGHT_BRK RIGHT_BRA MINUS_GT }]
}
transition on SIMPLE_NAME to state [12]
transition on ITERATE to state [99]
transition on simpleName to state [98]

-------------------
lalr_state [67]: {
  [oclExpression ::= (*) oclExpression UP simpleName LEFT_PAR oclMessageArgumentList RIGHT_PAR , {IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE COMMA DOT UP UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR MINUS_GT }]
  [oclExpression ::= (*) oclExpression EQ oclExpression , {IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE COMMA DOT UP UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR MINUS_GT }]
  [oclExpression ::= (*) oclExpression TIMES oclExpression , {IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE COMMA DOT UP UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR MINUS_GT }]
  [oclExpression ::= (*) oclExpression DOT simpleName isMarkedPre , {IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE COMMA DOT UP UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR MINUS_GT }]
  [variableDeclaration ::= (*) simpleName , {BAR }]
  [primitiveLiteralExp ::= (*) TRUE , {IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE COMMA DOT UP UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR MINUS_GT }]
  [literalExp ::= (*) tupleLiteralExp , {IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE COMMA DOT UP UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR MINUS_GT }]
  [argumentList ::= (*) argumentList COMMA oclExpression , {COMMA RIGHT_PAR }]
  [oclExpression ::= (*) oclExpression IMPLIES oclExpression , {IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE COMMA DOT UP UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR MINUS_GT }]
  [oclExpression ::= (*) oclExpression LT oclExpression , {IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE COMMA DOT UP UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR MINUS_GT }]
  [oclExpression ::= (*) oclExpression MINUS_GT ITERATE LEFT_PAR variableDeclaration SEMICOLON variableDeclaration BAR oclExpression RIGHT_PAR , {IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE COMMA DOT UP UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR MINUS_GT }]
  [tupleLiteralExp ::= (*) TUPLE LEFT_BRA variableDeclarationList RIGHT_BRA , {IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE COMMA DOT UP UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR MINUS_GT }]
  [collectionKind ::= (*) SET , {LEFT_BRA }]
  [oclExpression ::= (*) oclExpression UP simpleName LEFT_PAR RIGHT_PAR , {IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE COMMA DOT UP UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR MINUS_GT }]
  [oclExpression ::= (*) oclExpression NE oclExpression , {IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE COMMA DOT UP UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR MINUS_GT }]
  [oclExpression ::= oclExpression LEFT_PAR (*) arguments RIGHT_PAR , {EOF ENDPACKAGE CONTEXT INIT DERIVE INV DEF PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE IN THEN ELSE ENDIF COMMA DOT COLON SEMICOLON BAR UP DOT_DOT UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR RIGHT_BRK RIGHT_BRA MINUS_GT }]
  [oclExpression ::= (*) oclExpression DIVIDE oclExpression , {IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE COMMA DOT UP UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR MINUS_GT }]
  [oclExpression ::= (*) oclExpression LEFT_PAR arguments RIGHT_PAR , {IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE COMMA DOT UP UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR MINUS_GT }]
  [primitiveLiteralExp ::= (*) FALSE , {IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE COMMA DOT UP UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR MINUS_GT }]
  [literalExp ::= (*) primitiveLiteralExp , {IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE COMMA DOT UP UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR MINUS_GT }]
  [oclExpression ::= (*) LET variableDeclarationList IN oclExpression , {IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE COMMA DOT UP UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR MINUS_GT }]
  [oclExpression ::= (*) oclExpression GT oclExpression , {IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE COMMA DOT UP UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR MINUS_GT }]
  [oclExpression ::= (*) oclExpression MINUS_GT ITERATE LEFT_PAR variableDeclaration BAR oclExpression RIGHT_PAR , {IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE COMMA DOT UP UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR MINUS_GT }]
  [oclExpression ::= (*) literalExp , {IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE COMMA DOT UP UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR MINUS_GT }]
  [variableDeclaration ::= (*) simpleName COLON type EQ oclExpression , {BAR }]
  [primitiveLiteralExp ::= (*) INTEGER , {IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE COMMA DOT UP UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR MINUS_GT }]
  [collectionKind ::= (*) BAG , {LEFT_BRA }]
  [arguments ::= (*) , {RIGHT_PAR }]
  [oclExpression ::= (*) oclExpression AND oclExpression , {IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE COMMA DOT UP UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR MINUS_GT }]
  [oclExpression ::= oclExpression LEFT_PAR (*) variableDeclaration BAR oclExpression RIGHT_PAR , {EOF ENDPACKAGE CONTEXT INIT DERIVE INV DEF PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE IN THEN ELSE ENDIF COMMA DOT COLON SEMICOLON BAR UP DOT_DOT UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR RIGHT_BRK RIGHT_BRA MINUS_GT }]
  [oclExpression ::= (*) oclExpression PLUS oclExpression , {IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE COMMA DOT UP UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR MINUS_GT }]
  [oclExpression ::= (*) oclExpression LEFT_PAR variableDeclaration BAR oclExpression RIGHT_PAR , {IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE COMMA DOT UP UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR MINUS_GT }]
  [pathName ::= (*) simpleName , {IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE COMMA DOT UP AT COLON_COLON UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR MINUS_GT }]
  [oclExpression ::= (*) oclExpression UP_UP simpleName LEFT_PAR oclMessageArgumentList RIGHT_PAR , {IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE COMMA DOT UP UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR MINUS_GT }]
  [oclExpression ::= (*) oclExpression LE oclExpression , {IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE COMMA DOT UP UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR MINUS_GT }]
  [oclExpression ::= (*) NOT oclExpression , {IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE COMMA DOT UP UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR MINUS_GT }]
  [oclExpression ::= (*) LEFT_PAR oclExpression RIGHT_PAR , {IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE COMMA DOT UP UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR MINUS_GT }]
  [variableDeclaration ::= (*) simpleName COLON type , {BAR }]
  [primitiveLiteralExp ::= (*) REAL , {IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE COMMA DOT UP UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR MINUS_GT }]
  [collectionKind ::= (*) SEQUENCE , {LEFT_BRA }]
  [arguments ::= (*) argumentList , {RIGHT_PAR }]
  [oclExpression ::= (*) oclExpression OR oclExpression , {IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE COMMA DOT UP UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR MINUS_GT }]
  [oclExpression ::= (*) oclExpression MINUS oclExpression , {IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE COMMA DOT UP UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR MINUS_GT }]
  [oclExpression ::= (*) oclExpression LEFT_BRK argumentList RIGHT_BRK isMarkedPre , {IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE COMMA DOT UP UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR MINUS_GT }]
  [pathName ::= (*) pathName COLON_COLON simpleName , {IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE COMMA DOT UP AT COLON_COLON UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR MINUS_GT }]
  [collectionLiteralExp ::= (*) collectionKind LEFT_BRA collectionLiteralParts RIGHT_BRA , {IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE COMMA DOT UP UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR MINUS_GT }]
  [oclExpression ::= (*) oclExpression UP_UP simpleName LEFT_PAR RIGHT_PAR , {IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE COMMA DOT UP UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR MINUS_GT }]
  [oclExpression ::= (*) oclExpression GE oclExpression , {IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE COMMA DOT UP UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR MINUS_GT }]
  [oclExpression ::= (*) MINUS oclExpression , {IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE COMMA DOT UP UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR MINUS_GT }]
  [oclExpression ::= (*) pathName isMarkedPre , {IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE COMMA DOT UP UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR MINUS_GT }]
  [variableDeclaration ::= (*) simpleName EQ oclExpression , {BAR }]
  [primitiveLiteralExp ::= (*) STRING , {IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE COMMA DOT UP UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR MINUS_GT }]
  [collectionKind ::= (*) COLLECTION , {LEFT_BRA }]
  [literalExp ::= (*) collectionLiteralExp , {IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE COMMA DOT UP UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR MINUS_GT }]
  [argumentList ::= (*) oclExpression , {COMMA RIGHT_PAR }]
  [oclExpression ::= (*) oclExpression XOR oclExpression , {IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE COMMA DOT UP UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR MINUS_GT }]
  [oclExpression ::= (*) IF oclExpression THEN oclExpression ELSE oclExpression ENDIF , {IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE COMMA DOT UP UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR MINUS_GT }]
  [oclExpression ::= (*) oclExpression MINUS_GT simpleName , {IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE COMMA DOT UP UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR MINUS_GT }]
  [simpleName ::= (*) SIMPLE_NAME , {IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE COMMA DOT COLON BAR UP AT COLON_COLON UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR MINUS_GT }]
  [collectionLiteralExp ::= (*) collectionKind LEFT_BRA RIGHT_BRA , {IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE COMMA DOT UP UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR MINUS_GT }]
}
transition on argumentList to state [93]
transition on arguments to state [92]
transition on tupleLiteralExp to state [54]
transition on oclExpression to state [83]
transition on REAL to state [52]
transition on INTEGER to state [51]
transition on pathName to state [50]
transition on SIMPLE_NAME to state [12]
transition on LET to state [49]
transition on FALSE to state [48]
transition on MINUS to state [47]
transition on COLLECTION to state [28]
transition on SET to state [20]
transition on simpleName to state [91]
transition on collectionLiteralExp to state [46]
transition on LEFT_PAR to state [45]
transition on STRING to state [44]
transition on variableDeclaration to state [90]
transition on IF to state [43]
transition on TRUE to state [42]
transition on collectionKind to state [41]
transition on NOT to state [40]
transition on primitiveLiteralExp to state [39]
transition on TUPLE to state [38]
transition on literalExp to state [37]
transition on BAG to state [25]
transition on SEQUENCE to state [22]

-------------------
lalr_state [68]: {
  [oclExpression ::= (*) oclExpression UP simpleName LEFT_PAR oclMessageArgumentList RIGHT_PAR , {EOF ENDPACKAGE CONTEXT INIT DERIVE INV DEF PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE IN THEN ELSE ENDIF COMMA DOT COLON SEMICOLON BAR UP DOT_DOT UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR RIGHT_BRK RIGHT_BRA MINUS_GT }]
  [oclExpression ::= (*) oclExpression EQ oclExpression , {EOF ENDPACKAGE CONTEXT INIT DERIVE INV DEF PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE IN THEN ELSE ENDIF COMMA DOT COLON SEMICOLON BAR UP DOT_DOT UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR RIGHT_BRK RIGHT_BRA MINUS_GT }]
  [oclExpression ::= (*) oclExpression TIMES oclExpression , {EOF ENDPACKAGE CONTEXT INIT DERIVE INV DEF PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE IN THEN ELSE ENDIF COMMA DOT COLON SEMICOLON BAR UP DOT_DOT UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR RIGHT_BRK RIGHT_BRA MINUS_GT }]
  [oclExpression ::= (*) oclExpression DOT simpleName isMarkedPre , {EOF ENDPACKAGE CONTEXT INIT DERIVE INV DEF PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE IN THEN ELSE ENDIF COMMA DOT COLON SEMICOLON BAR UP DOT_DOT UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR RIGHT_BRK RIGHT_BRA MINUS_GT }]
  [primitiveLiteralExp ::= (*) TRUE , {EOF ENDPACKAGE CONTEXT INIT DERIVE INV DEF PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE IN THEN ELSE ENDIF COMMA DOT COLON SEMICOLON BAR UP DOT_DOT UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR RIGHT_BRK RIGHT_BRA MINUS_GT }]
  [literalExp ::= (*) tupleLiteralExp , {EOF ENDPACKAGE CONTEXT INIT DERIVE INV DEF PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE IN THEN ELSE ENDIF COMMA DOT COLON SEMICOLON BAR UP DOT_DOT UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR RIGHT_BRK RIGHT_BRA MINUS_GT }]
  [oclExpression ::= (*) oclExpression IMPLIES oclExpression , {EOF ENDPACKAGE CONTEXT INIT DERIVE INV DEF PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE IN THEN ELSE ENDIF COMMA DOT COLON SEMICOLON BAR UP DOT_DOT UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR RIGHT_BRK RIGHT_BRA MINUS_GT }]
  [oclExpression ::= (*) oclExpression LT oclExpression , {EOF ENDPACKAGE CONTEXT INIT DERIVE INV DEF PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE IN THEN ELSE ENDIF COMMA DOT COLON SEMICOLON BAR UP DOT_DOT UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR RIGHT_BRK RIGHT_BRA MINUS_GT }]
  [oclExpression ::= (*) oclExpression MINUS_GT ITERATE LEFT_PAR variableDeclaration SEMICOLON variableDeclaration BAR oclExpression RIGHT_PAR , {EOF ENDPACKAGE CONTEXT INIT DERIVE INV DEF PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE IN THEN ELSE ENDIF COMMA DOT COLON SEMICOLON BAR UP DOT_DOT UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR RIGHT_BRK RIGHT_BRA MINUS_GT }]
  [tupleLiteralExp ::= (*) TUPLE LEFT_BRA variableDeclarationList RIGHT_BRA , {EOF ENDPACKAGE CONTEXT INIT DERIVE INV DEF PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE IN THEN ELSE ENDIF COMMA DOT COLON SEMICOLON BAR UP DOT_DOT UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR RIGHT_BRK RIGHT_BRA MINUS_GT }]
  [collectionKind ::= (*) SET , {LEFT_BRA }]
  [oclExpression ::= oclExpression DIVIDE (*) oclExpression , {EOF ENDPACKAGE CONTEXT INIT DERIVE INV DEF PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE IN THEN ELSE ENDIF COMMA DOT COLON SEMICOLON BAR UP DOT_DOT UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR RIGHT_BRK RIGHT_BRA MINUS_GT }]
  [oclExpression ::= (*) oclExpression UP simpleName LEFT_PAR RIGHT_PAR , {EOF ENDPACKAGE CONTEXT INIT DERIVE INV DEF PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE IN THEN ELSE ENDIF COMMA DOT COLON SEMICOLON BAR UP DOT_DOT UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR RIGHT_BRK RIGHT_BRA MINUS_GT }]
  [oclExpression ::= (*) oclExpression NE oclExpression , {EOF ENDPACKAGE CONTEXT INIT DERIVE INV DEF PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE IN THEN ELSE ENDIF COMMA DOT COLON SEMICOLON BAR UP DOT_DOT UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR RIGHT_BRK RIGHT_BRA MINUS_GT }]
  [oclExpression ::= (*) oclExpression DIVIDE oclExpression , {EOF ENDPACKAGE CONTEXT INIT DERIVE INV DEF PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE IN THEN ELSE ENDIF COMMA DOT COLON SEMICOLON BAR UP DOT_DOT UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR RIGHT_BRK RIGHT_BRA MINUS_GT }]
  [oclExpression ::= (*) oclExpression LEFT_PAR arguments RIGHT_PAR , {EOF ENDPACKAGE CONTEXT INIT DERIVE INV DEF PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE IN THEN ELSE ENDIF COMMA DOT COLON SEMICOLON BAR UP DOT_DOT UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR RIGHT_BRK RIGHT_BRA MINUS_GT }]
  [primitiveLiteralExp ::= (*) FALSE , {EOF ENDPACKAGE CONTEXT INIT DERIVE INV DEF PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE IN THEN ELSE ENDIF COMMA DOT COLON SEMICOLON BAR UP DOT_DOT UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR RIGHT_BRK RIGHT_BRA MINUS_GT }]
  [literalExp ::= (*) primitiveLiteralExp , {EOF ENDPACKAGE CONTEXT INIT DERIVE INV DEF PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE IN THEN ELSE ENDIF COMMA DOT COLON SEMICOLON BAR UP DOT_DOT UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR RIGHT_BRK RIGHT_BRA MINUS_GT }]
  [oclExpression ::= (*) LET variableDeclarationList IN oclExpression , {EOF ENDPACKAGE CONTEXT INIT DERIVE INV DEF PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE IN THEN ELSE ENDIF COMMA DOT COLON SEMICOLON BAR UP DOT_DOT UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR RIGHT_BRK RIGHT_BRA MINUS_GT }]
  [oclExpression ::= (*) oclExpression GT oclExpression , {EOF ENDPACKAGE CONTEXT INIT DERIVE INV DEF PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE IN THEN ELSE ENDIF COMMA DOT COLON SEMICOLON BAR UP DOT_DOT UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR RIGHT_BRK RIGHT_BRA MINUS_GT }]
  [oclExpression ::= (*) oclExpression MINUS_GT ITERATE LEFT_PAR variableDeclaration BAR oclExpression RIGHT_PAR , {EOF ENDPACKAGE CONTEXT INIT DERIVE INV DEF PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE IN THEN ELSE ENDIF COMMA DOT COLON SEMICOLON BAR UP DOT_DOT UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR RIGHT_BRK RIGHT_BRA MINUS_GT }]
  [oclExpression ::= (*) literalExp , {EOF ENDPACKAGE CONTEXT INIT DERIVE INV DEF PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE IN THEN ELSE ENDIF COMMA DOT COLON SEMICOLON BAR UP DOT_DOT UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR RIGHT_BRK RIGHT_BRA MINUS_GT }]
  [primitiveLiteralExp ::= (*) INTEGER , {EOF ENDPACKAGE CONTEXT INIT DERIVE INV DEF PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE IN THEN ELSE ENDIF COMMA DOT COLON SEMICOLON BAR UP DOT_DOT UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR RIGHT_BRK RIGHT_BRA MINUS_GT }]
  [collectionKind ::= (*) BAG , {LEFT_BRA }]
  [oclExpression ::= (*) oclExpression AND oclExpression , {EOF ENDPACKAGE CONTEXT INIT DERIVE INV DEF PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE IN THEN ELSE ENDIF COMMA DOT COLON SEMICOLON BAR UP DOT_DOT UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR RIGHT_BRK RIGHT_BRA MINUS_GT }]
  [oclExpression ::= (*) oclExpression PLUS oclExpression , {EOF ENDPACKAGE CONTEXT INIT DERIVE INV DEF PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE IN THEN ELSE ENDIF COMMA DOT COLON SEMICOLON BAR UP DOT_DOT UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR RIGHT_BRK RIGHT_BRA MINUS_GT }]
  [oclExpression ::= (*) oclExpression LEFT_PAR variableDeclaration BAR oclExpression RIGHT_PAR , {EOF ENDPACKAGE CONTEXT INIT DERIVE INV DEF PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE IN THEN ELSE ENDIF COMMA DOT COLON SEMICOLON BAR UP DOT_DOT UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR RIGHT_BRK RIGHT_BRA MINUS_GT }]
  [pathName ::= (*) simpleName , {EOF ENDPACKAGE CONTEXT INIT DERIVE INV DEF PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE IN THEN ELSE ENDIF COMMA DOT COLON SEMICOLON BAR UP AT DOT_DOT COLON_COLON UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR RIGHT_BRK RIGHT_BRA MINUS_GT }]
  [oclExpression ::= (*) oclExpression UP_UP simpleName LEFT_PAR oclMessageArgumentList RIGHT_PAR , {EOF ENDPACKAGE CONTEXT INIT DERIVE INV DEF PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE IN THEN ELSE ENDIF COMMA DOT COLON SEMICOLON BAR UP DOT_DOT UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR RIGHT_BRK RIGHT_BRA MINUS_GT }]
  [oclExpression ::= (*) oclExpression LE oclExpression , {EOF ENDPACKAGE CONTEXT INIT DERIVE INV DEF PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE IN THEN ELSE ENDIF COMMA DOT COLON SEMICOLON BAR UP DOT_DOT UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR RIGHT_BRK RIGHT_BRA MINUS_GT }]
  [oclExpression ::= (*) NOT oclExpression , {EOF ENDPACKAGE CONTEXT INIT DERIVE INV DEF PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE IN THEN ELSE ENDIF COMMA DOT COLON SEMICOLON BAR UP DOT_DOT UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR RIGHT_BRK RIGHT_BRA MINUS_GT }]
  [oclExpression ::= (*) LEFT_PAR oclExpression RIGHT_PAR , {EOF ENDPACKAGE CONTEXT INIT DERIVE INV DEF PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE IN THEN ELSE ENDIF COMMA DOT COLON SEMICOLON BAR UP DOT_DOT UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR RIGHT_BRK RIGHT_BRA MINUS_GT }]
  [primitiveLiteralExp ::= (*) REAL , {EOF ENDPACKAGE CONTEXT INIT DERIVE INV DEF PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE IN THEN ELSE ENDIF COMMA DOT COLON SEMICOLON BAR UP DOT_DOT UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR RIGHT_BRK RIGHT_BRA MINUS_GT }]
  [collectionKind ::= (*) SEQUENCE , {LEFT_BRA }]
  [oclExpression ::= (*) oclExpression OR oclExpression , {EOF ENDPACKAGE CONTEXT INIT DERIVE INV DEF PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE IN THEN ELSE ENDIF COMMA DOT COLON SEMICOLON BAR UP DOT_DOT UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR RIGHT_BRK RIGHT_BRA MINUS_GT }]
  [oclExpression ::= (*) oclExpression MINUS oclExpression , {EOF ENDPACKAGE CONTEXT INIT DERIVE INV DEF PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE IN THEN ELSE ENDIF COMMA DOT COLON SEMICOLON BAR UP DOT_DOT UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR RIGHT_BRK RIGHT_BRA MINUS_GT }]
  [oclExpression ::= (*) oclExpression LEFT_BRK argumentList RIGHT_BRK isMarkedPre , {EOF ENDPACKAGE CONTEXT INIT DERIVE INV DEF PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE IN THEN ELSE ENDIF COMMA DOT COLON SEMICOLON BAR UP DOT_DOT UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR RIGHT_BRK RIGHT_BRA MINUS_GT }]
  [pathName ::= (*) pathName COLON_COLON simpleName , {EOF ENDPACKAGE CONTEXT INIT DERIVE INV DEF PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE IN THEN ELSE ENDIF COMMA DOT COLON SEMICOLON BAR UP AT DOT_DOT COLON_COLON UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR RIGHT_BRK RIGHT_BRA MINUS_GT }]
  [collectionLiteralExp ::= (*) collectionKind LEFT_BRA collectionLiteralParts RIGHT_BRA , {EOF ENDPACKAGE CONTEXT INIT DERIVE INV DEF PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE IN THEN ELSE ENDIF COMMA DOT COLON SEMICOLON BAR UP DOT_DOT UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR RIGHT_BRK RIGHT_BRA MINUS_GT }]
  [oclExpression ::= (*) oclExpression UP_UP simpleName LEFT_PAR RIGHT_PAR , {EOF ENDPACKAGE CONTEXT INIT DERIVE INV DEF PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE IN THEN ELSE ENDIF COMMA DOT COLON SEMICOLON BAR UP DOT_DOT UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR RIGHT_BRK RIGHT_BRA MINUS_GT }]
  [oclExpression ::= (*) oclExpression GE oclExpression , {EOF ENDPACKAGE CONTEXT INIT DERIVE INV DEF PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE IN THEN ELSE ENDIF COMMA DOT COLON SEMICOLON BAR UP DOT_DOT UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR RIGHT_BRK RIGHT_BRA MINUS_GT }]
  [oclExpression ::= (*) MINUS oclExpression , {EOF ENDPACKAGE CONTEXT INIT DERIVE INV DEF PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE IN THEN ELSE ENDIF COMMA DOT COLON SEMICOLON BAR UP DOT_DOT UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR RIGHT_BRK RIGHT_BRA MINUS_GT }]
  [oclExpression ::= (*) pathName isMarkedPre , {EOF ENDPACKAGE CONTEXT INIT DERIVE INV DEF PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE IN THEN ELSE ENDIF COMMA DOT COLON SEMICOLON BAR UP DOT_DOT UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR RIGHT_BRK RIGHT_BRA MINUS_GT }]
  [primitiveLiteralExp ::= (*) STRING , {EOF ENDPACKAGE CONTEXT INIT DERIVE INV DEF PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE IN THEN ELSE ENDIF COMMA DOT COLON SEMICOLON BAR UP DOT_DOT UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR RIGHT_BRK RIGHT_BRA MINUS_GT }]
  [collectionKind ::= (*) COLLECTION , {LEFT_BRA }]
  [literalExp ::= (*) collectionLiteralExp , {EOF ENDPACKAGE CONTEXT INIT DERIVE INV DEF PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE IN THEN ELSE ENDIF COMMA DOT COLON SEMICOLON BAR UP DOT_DOT UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR RIGHT_BRK RIGHT_BRA MINUS_GT }]
  [oclExpression ::= (*) oclExpression XOR oclExpression , {EOF ENDPACKAGE CONTEXT INIT DERIVE INV DEF PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE IN THEN ELSE ENDIF COMMA DOT COLON SEMICOLON BAR UP DOT_DOT UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR RIGHT_BRK RIGHT_BRA MINUS_GT }]
  [oclExpression ::= (*) IF oclExpression THEN oclExpression ELSE oclExpression ENDIF , {EOF ENDPACKAGE CONTEXT INIT DERIVE INV DEF PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE IN THEN ELSE ENDIF COMMA DOT COLON SEMICOLON BAR UP DOT_DOT UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR RIGHT_BRK RIGHT_BRA MINUS_GT }]
  [oclExpression ::= (*) oclExpression MINUS_GT simpleName , {EOF ENDPACKAGE CONTEXT INIT DERIVE INV DEF PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE IN THEN ELSE ENDIF COMMA DOT COLON SEMICOLON BAR UP DOT_DOT UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR RIGHT_BRK RIGHT_BRA MINUS_GT }]
  [simpleName ::= (*) SIMPLE_NAME , {EOF ENDPACKAGE CONTEXT INIT DERIVE INV DEF PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE IN THEN ELSE ENDIF COMMA DOT COLON SEMICOLON BAR UP AT DOT_DOT COLON_COLON UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR RIGHT_BRK RIGHT_BRA MINUS_GT }]
  [collectionLiteralExp ::= (*) collectionKind LEFT_BRA RIGHT_BRA , {EOF ENDPACKAGE CONTEXT INIT DERIVE INV DEF PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE IN THEN ELSE ENDIF COMMA DOT COLON SEMICOLON BAR UP DOT_DOT UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR RIGHT_BRK RIGHT_BRA MINUS_GT }]
}
transition on tupleLiteralExp to state [54]
transition on oclExpression to state [89]
transition on REAL to state [52]
transition on INTEGER to state [51]
transition on pathName to state [50]
transition on SIMPLE_NAME to state [12]
transition on LET to state [49]
transition on FALSE to state [48]
transition on MINUS to state [47]
transition on COLLECTION to state [28]
transition on SET to state [20]
transition on simpleName to state [26]
transition on collectionLiteralExp to state [46]
transition on LEFT_PAR to state [45]
transition on STRING to state [44]
transition on IF to state [43]
transition on TRUE to state [42]
transition on collectionKind to state [41]
transition on NOT to state [40]
transition on primitiveLiteralExp to state [39]
transition on TUPLE to state [38]
transition on literalExp to state [37]
transition on BAG to state [25]
transition on SEQUENCE to state [22]

-------------------
lalr_state [69]: {
  [oclExpression ::= (*) oclExpression UP simpleName LEFT_PAR oclMessageArgumentList RIGHT_PAR , {IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE COMMA DOT UP UP_UP LEFT_PAR LEFT_BRK RIGHT_BRK MINUS_GT }]
  [oclExpression ::= (*) oclExpression EQ oclExpression , {IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE COMMA DOT UP UP_UP LEFT_PAR LEFT_BRK RIGHT_BRK MINUS_GT }]
  [oclExpression ::= (*) oclExpression TIMES oclExpression , {IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE COMMA DOT UP UP_UP LEFT_PAR LEFT_BRK RIGHT_BRK MINUS_GT }]
  [oclExpression ::= (*) oclExpression DOT simpleName isMarkedPre , {IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE COMMA DOT UP UP_UP LEFT_PAR LEFT_BRK RIGHT_BRK MINUS_GT }]
  [primitiveLiteralExp ::= (*) TRUE , {IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE COMMA DOT UP UP_UP LEFT_PAR LEFT_BRK RIGHT_BRK MINUS_GT }]
  [literalExp ::= (*) tupleLiteralExp , {IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE COMMA DOT UP UP_UP LEFT_PAR LEFT_BRK RIGHT_BRK MINUS_GT }]
  [argumentList ::= (*) argumentList COMMA oclExpression , {COMMA RIGHT_BRK }]
  [oclExpression ::= (*) oclExpression IMPLIES oclExpression , {IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE COMMA DOT UP UP_UP LEFT_PAR LEFT_BRK RIGHT_BRK MINUS_GT }]
  [oclExpression ::= (*) oclExpression LT oclExpression , {IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE COMMA DOT UP UP_UP LEFT_PAR LEFT_BRK RIGHT_BRK MINUS_GT }]
  [oclExpression ::= (*) oclExpression MINUS_GT ITERATE LEFT_PAR variableDeclaration SEMICOLON variableDeclaration BAR oclExpression RIGHT_PAR , {IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE COMMA DOT UP UP_UP LEFT_PAR LEFT_BRK RIGHT_BRK MINUS_GT }]
  [tupleLiteralExp ::= (*) TUPLE LEFT_BRA variableDeclarationList RIGHT_BRA , {IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE COMMA DOT UP UP_UP LEFT_PAR LEFT_BRK RIGHT_BRK MINUS_GT }]
  [collectionKind ::= (*) SET , {LEFT_BRA }]
  [oclExpression ::= (*) oclExpression UP simpleName LEFT_PAR RIGHT_PAR , {IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE COMMA DOT UP UP_UP LEFT_PAR LEFT_BRK RIGHT_BRK MINUS_GT }]
  [oclExpression ::= (*) oclExpression NE oclExpression , {IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE COMMA DOT UP UP_UP LEFT_PAR LEFT_BRK RIGHT_BRK MINUS_GT }]
  [oclExpression ::= (*) oclExpression DIVIDE oclExpression , {IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE COMMA DOT UP UP_UP LEFT_PAR LEFT_BRK RIGHT_BRK MINUS_GT }]
  [oclExpression ::= (*) oclExpression LEFT_PAR arguments RIGHT_PAR , {IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE COMMA DOT UP UP_UP LEFT_PAR LEFT_BRK RIGHT_BRK MINUS_GT }]
  [primitiveLiteralExp ::= (*) FALSE , {IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE COMMA DOT UP UP_UP LEFT_PAR LEFT_BRK RIGHT_BRK MINUS_GT }]
  [literalExp ::= (*) primitiveLiteralExp , {IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE COMMA DOT UP UP_UP LEFT_PAR LEFT_BRK RIGHT_BRK MINUS_GT }]
  [oclExpression ::= (*) LET variableDeclarationList IN oclExpression , {IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE COMMA DOT UP UP_UP LEFT_PAR LEFT_BRK RIGHT_BRK MINUS_GT }]
  [oclExpression ::= (*) oclExpression GT oclExpression , {IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE COMMA DOT UP UP_UP LEFT_PAR LEFT_BRK RIGHT_BRK MINUS_GT }]
  [oclExpression ::= (*) oclExpression MINUS_GT ITERATE LEFT_PAR variableDeclaration BAR oclExpression RIGHT_PAR , {IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE COMMA DOT UP UP_UP LEFT_PAR LEFT_BRK RIGHT_BRK MINUS_GT }]
  [oclExpression ::= (*) literalExp , {IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE COMMA DOT UP UP_UP LEFT_PAR LEFT_BRK RIGHT_BRK MINUS_GT }]
  [primitiveLiteralExp ::= (*) INTEGER , {IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE COMMA DOT UP UP_UP LEFT_PAR LEFT_BRK RIGHT_BRK MINUS_GT }]
  [collectionKind ::= (*) BAG , {LEFT_BRA }]
  [oclExpression ::= (*) oclExpression AND oclExpression , {IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE COMMA DOT UP UP_UP LEFT_PAR LEFT_BRK RIGHT_BRK MINUS_GT }]
  [oclExpression ::= (*) oclExpression PLUS oclExpression , {IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE COMMA DOT UP UP_UP LEFT_PAR LEFT_BRK RIGHT_BRK MINUS_GT }]
  [oclExpression ::= (*) oclExpression LEFT_PAR variableDeclaration BAR oclExpression RIGHT_PAR , {IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE COMMA DOT UP UP_UP LEFT_PAR LEFT_BRK RIGHT_BRK MINUS_GT }]
  [pathName ::= (*) simpleName , {IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE COMMA DOT UP AT COLON_COLON UP_UP LEFT_PAR LEFT_BRK RIGHT_BRK MINUS_GT }]
  [oclExpression ::= (*) oclExpression UP_UP simpleName LEFT_PAR oclMessageArgumentList RIGHT_PAR , {IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE COMMA DOT UP UP_UP LEFT_PAR LEFT_BRK RIGHT_BRK MINUS_GT }]
  [oclExpression ::= (*) oclExpression LE oclExpression , {IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE COMMA DOT UP UP_UP LEFT_PAR LEFT_BRK RIGHT_BRK MINUS_GT }]
  [oclExpression ::= (*) NOT oclExpression , {IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE COMMA DOT UP UP_UP LEFT_PAR LEFT_BRK RIGHT_BRK MINUS_GT }]
  [oclExpression ::= (*) LEFT_PAR oclExpression RIGHT_PAR , {IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE COMMA DOT UP UP_UP LEFT_PAR LEFT_BRK RIGHT_BRK MINUS_GT }]
  [primitiveLiteralExp ::= (*) REAL , {IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE COMMA DOT UP UP_UP LEFT_PAR LEFT_BRK RIGHT_BRK MINUS_GT }]
  [collectionKind ::= (*) SEQUENCE , {LEFT_BRA }]
  [oclExpression ::= (*) oclExpression OR oclExpression , {IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE COMMA DOT UP UP_UP LEFT_PAR LEFT_BRK RIGHT_BRK MINUS_GT }]
  [oclExpression ::= oclExpression LEFT_BRK (*) argumentList RIGHT_BRK isMarkedPre , {EOF ENDPACKAGE CONTEXT INIT DERIVE INV DEF PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE IN THEN ELSE ENDIF COMMA DOT COLON SEMICOLON BAR UP DOT_DOT UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR RIGHT_BRK RIGHT_BRA MINUS_GT }]
  [oclExpression ::= (*) oclExpression MINUS oclExpression , {IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE COMMA DOT UP UP_UP LEFT_PAR LEFT_BRK RIGHT_BRK MINUS_GT }]
  [oclExpression ::= (*) oclExpression LEFT_BRK argumentList RIGHT_BRK isMarkedPre , {IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE COMMA DOT UP UP_UP LEFT_PAR LEFT_BRK RIGHT_BRK MINUS_GT }]
  [pathName ::= (*) pathName COLON_COLON simpleName , {IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE COMMA DOT UP AT COLON_COLON UP_UP LEFT_PAR LEFT_BRK RIGHT_BRK MINUS_GT }]
  [collectionLiteralExp ::= (*) collectionKind LEFT_BRA collectionLiteralParts RIGHT_BRA , {IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE COMMA DOT UP UP_UP LEFT_PAR LEFT_BRK RIGHT_BRK MINUS_GT }]
  [oclExpression ::= (*) oclExpression UP_UP simpleName LEFT_PAR RIGHT_PAR , {IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE COMMA DOT UP UP_UP LEFT_PAR LEFT_BRK RIGHT_BRK MINUS_GT }]
  [oclExpression ::= (*) oclExpression GE oclExpression , {IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE COMMA DOT UP UP_UP LEFT_PAR LEFT_BRK RIGHT_BRK MINUS_GT }]
  [oclExpression ::= (*) MINUS oclExpression , {IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE COMMA DOT UP UP_UP LEFT_PAR LEFT_BRK RIGHT_BRK MINUS_GT }]
  [oclExpression ::= (*) pathName isMarkedPre , {IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE COMMA DOT UP UP_UP LEFT_PAR LEFT_BRK RIGHT_BRK MINUS_GT }]
  [primitiveLiteralExp ::= (*) STRING , {IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE COMMA DOT UP UP_UP LEFT_PAR LEFT_BRK RIGHT_BRK MINUS_GT }]
  [collectionKind ::= (*) COLLECTION , {LEFT_BRA }]
  [literalExp ::= (*) collectionLiteralExp , {IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE COMMA DOT UP UP_UP LEFT_PAR LEFT_BRK RIGHT_BRK MINUS_GT }]
  [argumentList ::= (*) oclExpression , {COMMA RIGHT_BRK }]
  [oclExpression ::= (*) oclExpression XOR oclExpression , {IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE COMMA DOT UP UP_UP LEFT_PAR LEFT_BRK RIGHT_BRK MINUS_GT }]
  [oclExpression ::= (*) IF oclExpression THEN oclExpression ELSE oclExpression ENDIF , {IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE COMMA DOT UP UP_UP LEFT_PAR LEFT_BRK RIGHT_BRK MINUS_GT }]
  [oclExpression ::= (*) oclExpression MINUS_GT simpleName , {IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE COMMA DOT UP UP_UP LEFT_PAR LEFT_BRK RIGHT_BRK MINUS_GT }]
  [simpleName ::= (*) SIMPLE_NAME , {IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE COMMA DOT UP AT COLON_COLON UP_UP LEFT_PAR LEFT_BRK RIGHT_BRK MINUS_GT }]
  [collectionLiteralExp ::= (*) collectionKind LEFT_BRA RIGHT_BRA , {IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE COMMA DOT UP UP_UP LEFT_PAR LEFT_BRK RIGHT_BRK MINUS_GT }]
}
transition on argumentList to state [84]
transition on tupleLiteralExp to state [54]
transition on oclExpression to state [83]
transition on REAL to state [52]
transition on INTEGER to state [51]
transition on pathName to state [50]
transition on SIMPLE_NAME to state [12]
transition on LET to state [49]
transition on FALSE to state [48]
transition on MINUS to state [47]
transition on COLLECTION to state [28]
transition on SET to state [20]
transition on simpleName to state [26]
transition on collectionLiteralExp to state [46]
transition on LEFT_PAR to state [45]
transition on STRING to state [44]
transition on IF to state [43]
transition on TRUE to state [42]
transition on collectionKind to state [41]
transition on NOT to state [40]
transition on primitiveLiteralExp to state [39]
transition on TUPLE to state [38]
transition on literalExp to state [37]
transition on BAG to state [25]
transition on SEQUENCE to state [22]

-------------------
lalr_state [70]: {
  [oclExpression ::= (*) oclExpression UP simpleName LEFT_PAR oclMessageArgumentList RIGHT_PAR , {EOF ENDPACKAGE CONTEXT INIT DERIVE INV DEF PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE IN THEN ELSE ENDIF COMMA DOT COLON SEMICOLON BAR UP DOT_DOT UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR RIGHT_BRK RIGHT_BRA MINUS_GT }]
  [oclExpression ::= (*) oclExpression EQ oclExpression , {EOF ENDPACKAGE CONTEXT INIT DERIVE INV DEF PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE IN THEN ELSE ENDIF COMMA DOT COLON SEMICOLON BAR UP DOT_DOT UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR RIGHT_BRK RIGHT_BRA MINUS_GT }]
  [oclExpression ::= (*) oclExpression TIMES oclExpression , {EOF ENDPACKAGE CONTEXT INIT DERIVE INV DEF PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE IN THEN ELSE ENDIF COMMA DOT COLON SEMICOLON BAR UP DOT_DOT UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR RIGHT_BRK RIGHT_BRA MINUS_GT }]
  [oclExpression ::= (*) oclExpression DOT simpleName isMarkedPre , {EOF ENDPACKAGE CONTEXT INIT DERIVE INV DEF PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE IN THEN ELSE ENDIF COMMA DOT COLON SEMICOLON BAR UP DOT_DOT UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR RIGHT_BRK RIGHT_BRA MINUS_GT }]
  [primitiveLiteralExp ::= (*) TRUE , {EOF ENDPACKAGE CONTEXT INIT DERIVE INV DEF PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE IN THEN ELSE ENDIF COMMA DOT COLON SEMICOLON BAR UP DOT_DOT UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR RIGHT_BRK RIGHT_BRA MINUS_GT }]
  [literalExp ::= (*) tupleLiteralExp , {EOF ENDPACKAGE CONTEXT INIT DERIVE INV DEF PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE IN THEN ELSE ENDIF COMMA DOT COLON SEMICOLON BAR UP DOT_DOT UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR RIGHT_BRK RIGHT_BRA MINUS_GT }]
  [oclExpression ::= (*) oclExpression IMPLIES oclExpression , {EOF ENDPACKAGE CONTEXT INIT DERIVE INV DEF PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE IN THEN ELSE ENDIF COMMA DOT COLON SEMICOLON BAR UP DOT_DOT UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR RIGHT_BRK RIGHT_BRA MINUS_GT }]
  [oclExpression ::= (*) oclExpression LT oclExpression , {EOF ENDPACKAGE CONTEXT INIT DERIVE INV DEF PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE IN THEN ELSE ENDIF COMMA DOT COLON SEMICOLON BAR UP DOT_DOT UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR RIGHT_BRK RIGHT_BRA MINUS_GT }]
  [oclExpression ::= (*) oclExpression MINUS_GT ITERATE LEFT_PAR variableDeclaration SEMICOLON variableDeclaration BAR oclExpression RIGHT_PAR , {EOF ENDPACKAGE CONTEXT INIT DERIVE INV DEF PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE IN THEN ELSE ENDIF COMMA DOT COLON SEMICOLON BAR UP DOT_DOT UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR RIGHT_BRK RIGHT_BRA MINUS_GT }]
  [tupleLiteralExp ::= (*) TUPLE LEFT_BRA variableDeclarationList RIGHT_BRA , {EOF ENDPACKAGE CONTEXT INIT DERIVE INV DEF PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE IN THEN ELSE ENDIF COMMA DOT COLON SEMICOLON BAR UP DOT_DOT UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR RIGHT_BRK RIGHT_BRA MINUS_GT }]
  [collectionKind ::= (*) SET , {LEFT_BRA }]
  [oclExpression ::= (*) oclExpression UP simpleName LEFT_PAR RIGHT_PAR , {EOF ENDPACKAGE CONTEXT INIT DERIVE INV DEF PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE IN THEN ELSE ENDIF COMMA DOT COLON SEMICOLON BAR UP DOT_DOT UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR RIGHT_BRK RIGHT_BRA MINUS_GT }]
  [oclExpression ::= (*) oclExpression NE oclExpression , {EOF ENDPACKAGE CONTEXT INIT DERIVE INV DEF PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE IN THEN ELSE ENDIF COMMA DOT COLON SEMICOLON BAR UP DOT_DOT UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR RIGHT_BRK RIGHT_BRA MINUS_GT }]
  [oclExpression ::= (*) oclExpression DIVIDE oclExpression , {EOF ENDPACKAGE CONTEXT INIT DERIVE INV DEF PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE IN THEN ELSE ENDIF COMMA DOT COLON SEMICOLON BAR UP DOT_DOT UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR RIGHT_BRK RIGHT_BRA MINUS_GT }]
  [oclExpression ::= (*) oclExpression LEFT_PAR arguments RIGHT_PAR , {EOF ENDPACKAGE CONTEXT INIT DERIVE INV DEF PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE IN THEN ELSE ENDIF COMMA DOT COLON SEMICOLON BAR UP DOT_DOT UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR RIGHT_BRK RIGHT_BRA MINUS_GT }]
  [primitiveLiteralExp ::= (*) FALSE , {EOF ENDPACKAGE CONTEXT INIT DERIVE INV DEF PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE IN THEN ELSE ENDIF COMMA DOT COLON SEMICOLON BAR UP DOT_DOT UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR RIGHT_BRK RIGHT_BRA MINUS_GT }]
  [literalExp ::= (*) primitiveLiteralExp , {EOF ENDPACKAGE CONTEXT INIT DERIVE INV DEF PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE IN THEN ELSE ENDIF COMMA DOT COLON SEMICOLON BAR UP DOT_DOT UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR RIGHT_BRK RIGHT_BRA MINUS_GT }]
  [oclExpression ::= (*) LET variableDeclarationList IN oclExpression , {EOF ENDPACKAGE CONTEXT INIT DERIVE INV DEF PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE IN THEN ELSE ENDIF COMMA DOT COLON SEMICOLON BAR UP DOT_DOT UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR RIGHT_BRK RIGHT_BRA MINUS_GT }]
  [oclExpression ::= (*) oclExpression GT oclExpression , {EOF ENDPACKAGE CONTEXT INIT DERIVE INV DEF PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE IN THEN ELSE ENDIF COMMA DOT COLON SEMICOLON BAR UP DOT_DOT UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR RIGHT_BRK RIGHT_BRA MINUS_GT }]
  [oclExpression ::= (*) oclExpression MINUS_GT ITERATE LEFT_PAR variableDeclaration BAR oclExpression RIGHT_PAR , {EOF ENDPACKAGE CONTEXT INIT DERIVE INV DEF PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE IN THEN ELSE ENDIF COMMA DOT COLON SEMICOLON BAR UP DOT_DOT UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR RIGHT_BRK RIGHT_BRA MINUS_GT }]
  [oclExpression ::= (*) literalExp , {EOF ENDPACKAGE CONTEXT INIT DERIVE INV DEF PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE IN THEN ELSE ENDIF COMMA DOT COLON SEMICOLON BAR UP DOT_DOT UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR RIGHT_BRK RIGHT_BRA MINUS_GT }]
  [primitiveLiteralExp ::= (*) INTEGER , {EOF ENDPACKAGE CONTEXT INIT DERIVE INV DEF PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE IN THEN ELSE ENDIF COMMA DOT COLON SEMICOLON BAR UP DOT_DOT UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR RIGHT_BRK RIGHT_BRA MINUS_GT }]
  [collectionKind ::= (*) BAG , {LEFT_BRA }]
  [oclExpression ::= (*) oclExpression AND oclExpression , {EOF ENDPACKAGE CONTEXT INIT DERIVE INV DEF PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE IN THEN ELSE ENDIF COMMA DOT COLON SEMICOLON BAR UP DOT_DOT UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR RIGHT_BRK RIGHT_BRA MINUS_GT }]
  [oclExpression ::= (*) oclExpression PLUS oclExpression , {EOF ENDPACKAGE CONTEXT INIT DERIVE INV DEF PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE IN THEN ELSE ENDIF COMMA DOT COLON SEMICOLON BAR UP DOT_DOT UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR RIGHT_BRK RIGHT_BRA MINUS_GT }]
  [oclExpression ::= (*) oclExpression LEFT_PAR variableDeclaration BAR oclExpression RIGHT_PAR , {EOF ENDPACKAGE CONTEXT INIT DERIVE INV DEF PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE IN THEN ELSE ENDIF COMMA DOT COLON SEMICOLON BAR UP DOT_DOT UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR RIGHT_BRK RIGHT_BRA MINUS_GT }]
  [pathName ::= (*) simpleName , {EOF ENDPACKAGE CONTEXT INIT DERIVE INV DEF PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE IN THEN ELSE ENDIF COMMA DOT COLON SEMICOLON BAR UP AT DOT_DOT COLON_COLON UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR RIGHT_BRK RIGHT_BRA MINUS_GT }]
  [oclExpression ::= (*) oclExpression UP_UP simpleName LEFT_PAR oclMessageArgumentList RIGHT_PAR , {EOF ENDPACKAGE CONTEXT INIT DERIVE INV DEF PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE IN THEN ELSE ENDIF COMMA DOT COLON SEMICOLON BAR UP DOT_DOT UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR RIGHT_BRK RIGHT_BRA MINUS_GT }]
  [oclExpression ::= (*) oclExpression LE oclExpression , {EOF ENDPACKAGE CONTEXT INIT DERIVE INV DEF PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE IN THEN ELSE ENDIF COMMA DOT COLON SEMICOLON BAR UP DOT_DOT UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR RIGHT_BRK RIGHT_BRA MINUS_GT }]
  [oclExpression ::= (*) NOT oclExpression , {EOF ENDPACKAGE CONTEXT INIT DERIVE INV DEF PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE IN THEN ELSE ENDIF COMMA DOT COLON SEMICOLON BAR UP DOT_DOT UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR RIGHT_BRK RIGHT_BRA MINUS_GT }]
  [oclExpression ::= (*) LEFT_PAR oclExpression RIGHT_PAR , {EOF ENDPACKAGE CONTEXT INIT DERIVE INV DEF PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE IN THEN ELSE ENDIF COMMA DOT COLON SEMICOLON BAR UP DOT_DOT UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR RIGHT_BRK RIGHT_BRA MINUS_GT }]
  [primitiveLiteralExp ::= (*) REAL , {EOF ENDPACKAGE CONTEXT INIT DERIVE INV DEF PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE IN THEN ELSE ENDIF COMMA DOT COLON SEMICOLON BAR UP DOT_DOT UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR RIGHT_BRK RIGHT_BRA MINUS_GT }]
  [collectionKind ::= (*) SEQUENCE , {LEFT_BRA }]
  [oclExpression ::= (*) oclExpression OR oclExpression , {EOF ENDPACKAGE CONTEXT INIT DERIVE INV DEF PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE IN THEN ELSE ENDIF COMMA DOT COLON SEMICOLON BAR UP DOT_DOT UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR RIGHT_BRK RIGHT_BRA MINUS_GT }]
  [oclExpression ::= (*) oclExpression MINUS oclExpression , {EOF ENDPACKAGE CONTEXT INIT DERIVE INV DEF PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE IN THEN ELSE ENDIF COMMA DOT COLON SEMICOLON BAR UP DOT_DOT UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR RIGHT_BRK RIGHT_BRA MINUS_GT }]
  [oclExpression ::= (*) oclExpression LEFT_BRK argumentList RIGHT_BRK isMarkedPre , {EOF ENDPACKAGE CONTEXT INIT DERIVE INV DEF PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE IN THEN ELSE ENDIF COMMA DOT COLON SEMICOLON BAR UP DOT_DOT UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR RIGHT_BRK RIGHT_BRA MINUS_GT }]
  [pathName ::= (*) pathName COLON_COLON simpleName , {EOF ENDPACKAGE CONTEXT INIT DERIVE INV DEF PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE IN THEN ELSE ENDIF COMMA DOT COLON SEMICOLON BAR UP AT DOT_DOT COLON_COLON UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR RIGHT_BRK RIGHT_BRA MINUS_GT }]
  [collectionLiteralExp ::= (*) collectionKind LEFT_BRA collectionLiteralParts RIGHT_BRA , {EOF ENDPACKAGE CONTEXT INIT DERIVE INV DEF PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE IN THEN ELSE ENDIF COMMA DOT COLON SEMICOLON BAR UP DOT_DOT UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR RIGHT_BRK RIGHT_BRA MINUS_GT }]
  [oclExpression ::= oclExpression GE (*) oclExpression , {EOF ENDPACKAGE CONTEXT INIT DERIVE INV DEF PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE IN THEN ELSE ENDIF COMMA DOT COLON SEMICOLON BAR UP DOT_DOT UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR RIGHT_BRK RIGHT_BRA MINUS_GT }]
  [oclExpression ::= (*) oclExpression UP_UP simpleName LEFT_PAR RIGHT_PAR , {EOF ENDPACKAGE CONTEXT INIT DERIVE INV DEF PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE IN THEN ELSE ENDIF COMMA DOT COLON SEMICOLON BAR UP DOT_DOT UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR RIGHT_BRK RIGHT_BRA MINUS_GT }]
  [oclExpression ::= (*) oclExpression GE oclExpression , {EOF ENDPACKAGE CONTEXT INIT DERIVE INV DEF PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE IN THEN ELSE ENDIF COMMA DOT COLON SEMICOLON BAR UP DOT_DOT UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR RIGHT_BRK RIGHT_BRA MINUS_GT }]
  [oclExpression ::= (*) MINUS oclExpression , {EOF ENDPACKAGE CONTEXT INIT DERIVE INV DEF PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE IN THEN ELSE ENDIF COMMA DOT COLON SEMICOLON BAR UP DOT_DOT UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR RIGHT_BRK RIGHT_BRA MINUS_GT }]
  [oclExpression ::= (*) pathName isMarkedPre , {EOF ENDPACKAGE CONTEXT INIT DERIVE INV DEF PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE IN THEN ELSE ENDIF COMMA DOT COLON SEMICOLON BAR UP DOT_DOT UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR RIGHT_BRK RIGHT_BRA MINUS_GT }]
  [primitiveLiteralExp ::= (*) STRING , {EOF ENDPACKAGE CONTEXT INIT DERIVE INV DEF PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE IN THEN ELSE ENDIF COMMA DOT COLON SEMICOLON BAR UP DOT_DOT UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR RIGHT_BRK RIGHT_BRA MINUS_GT }]
  [collectionKind ::= (*) COLLECTION , {LEFT_BRA }]
  [literalExp ::= (*) collectionLiteralExp , {EOF ENDPACKAGE CONTEXT INIT DERIVE INV DEF PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE IN THEN ELSE ENDIF COMMA DOT COLON SEMICOLON BAR UP DOT_DOT UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR RIGHT_BRK RIGHT_BRA MINUS_GT }]
  [oclExpression ::= (*) oclExpression XOR oclExpression , {EOF ENDPACKAGE CONTEXT INIT DERIVE INV DEF PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE IN THEN ELSE ENDIF COMMA DOT COLON SEMICOLON BAR UP DOT_DOT UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR RIGHT_BRK RIGHT_BRA MINUS_GT }]
  [oclExpression ::= (*) IF oclExpression THEN oclExpression ELSE oclExpression ENDIF , {EOF ENDPACKAGE CONTEXT INIT DERIVE INV DEF PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE IN THEN ELSE ENDIF COMMA DOT COLON SEMICOLON BAR UP DOT_DOT UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR RIGHT_BRK RIGHT_BRA MINUS_GT }]
  [oclExpression ::= (*) oclExpression MINUS_GT simpleName , {EOF ENDPACKAGE CONTEXT INIT DERIVE INV DEF PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE IN THEN ELSE ENDIF COMMA DOT COLON SEMICOLON BAR UP DOT_DOT UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR RIGHT_BRK RIGHT_BRA MINUS_GT }]
  [simpleName ::= (*) SIMPLE_NAME , {EOF ENDPACKAGE CONTEXT INIT DERIVE INV DEF PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE IN THEN ELSE ENDIF COMMA DOT COLON SEMICOLON BAR UP AT DOT_DOT COLON_COLON UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR RIGHT_BRK RIGHT_BRA MINUS_GT }]
  [collectionLiteralExp ::= (*) collectionKind LEFT_BRA RIGHT_BRA , {EOF ENDPACKAGE CONTEXT INIT DERIVE INV DEF PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE IN THEN ELSE ENDIF COMMA DOT COLON SEMICOLON BAR UP DOT_DOT UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR RIGHT_BRK RIGHT_BRA MINUS_GT }]
}
transition on tupleLiteralExp to state [54]
transition on oclExpression to state [82]
transition on REAL to state [52]
transition on INTEGER to state [51]
transition on pathName to state [50]
transition on SIMPLE_NAME to state [12]
transition on LET to state [49]
transition on FALSE to state [48]
transition on MINUS to state [47]
transition on COLLECTION to state [28]
transition on SET to state [20]
transition on simpleName to state [26]
transition on collectionLiteralExp to state [46]
transition on LEFT_PAR to state [45]
transition on STRING to state [44]
transition on IF to state [43]
transition on TRUE to state [42]
transition on collectionKind to state [41]
transition on NOT to state [40]
transition on primitiveLiteralExp to state [39]
transition on TUPLE to state [38]
transition on literalExp to state [37]
transition on BAG to state [25]
transition on SEQUENCE to state [22]

-------------------
lalr_state [71]: {
  [oclExpression ::= (*) oclExpression UP simpleName LEFT_PAR oclMessageArgumentList RIGHT_PAR , {EOF ENDPACKAGE CONTEXT INIT DERIVE INV DEF PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE IN THEN ELSE ENDIF COMMA DOT COLON SEMICOLON BAR UP DOT_DOT UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR RIGHT_BRK RIGHT_BRA MINUS_GT }]
  [oclExpression ::= (*) oclExpression EQ oclExpression , {EOF ENDPACKAGE CONTEXT INIT DERIVE INV DEF PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE IN THEN ELSE ENDIF COMMA DOT COLON SEMICOLON BAR UP DOT_DOT UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR RIGHT_BRK RIGHT_BRA MINUS_GT }]
  [oclExpression ::= (*) oclExpression TIMES oclExpression , {EOF ENDPACKAGE CONTEXT INIT DERIVE INV DEF PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE IN THEN ELSE ENDIF COMMA DOT COLON SEMICOLON BAR UP DOT_DOT UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR RIGHT_BRK RIGHT_BRA MINUS_GT }]
  [oclExpression ::= (*) oclExpression DOT simpleName isMarkedPre , {EOF ENDPACKAGE CONTEXT INIT DERIVE INV DEF PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE IN THEN ELSE ENDIF COMMA DOT COLON SEMICOLON BAR UP DOT_DOT UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR RIGHT_BRK RIGHT_BRA MINUS_GT }]
  [primitiveLiteralExp ::= (*) TRUE , {EOF ENDPACKAGE CONTEXT INIT DERIVE INV DEF PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE IN THEN ELSE ENDIF COMMA DOT COLON SEMICOLON BAR UP DOT_DOT UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR RIGHT_BRK RIGHT_BRA MINUS_GT }]
  [literalExp ::= (*) tupleLiteralExp , {EOF ENDPACKAGE CONTEXT INIT DERIVE INV DEF PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE IN THEN ELSE ENDIF COMMA DOT COLON SEMICOLON BAR UP DOT_DOT UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR RIGHT_BRK RIGHT_BRA MINUS_GT }]
  [oclExpression ::= (*) oclExpression IMPLIES oclExpression , {EOF ENDPACKAGE CONTEXT INIT DERIVE INV DEF PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE IN THEN ELSE ENDIF COMMA DOT COLON SEMICOLON BAR UP DOT_DOT UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR RIGHT_BRK RIGHT_BRA MINUS_GT }]
  [oclExpression ::= (*) oclExpression LT oclExpression , {EOF ENDPACKAGE CONTEXT INIT DERIVE INV DEF PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE IN THEN ELSE ENDIF COMMA DOT COLON SEMICOLON BAR UP DOT_DOT UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR RIGHT_BRK RIGHT_BRA MINUS_GT }]
  [oclExpression ::= (*) oclExpression MINUS_GT ITERATE LEFT_PAR variableDeclaration SEMICOLON variableDeclaration BAR oclExpression RIGHT_PAR , {EOF ENDPACKAGE CONTEXT INIT DERIVE INV DEF PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE IN THEN ELSE ENDIF COMMA DOT COLON SEMICOLON BAR UP DOT_DOT UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR RIGHT_BRK RIGHT_BRA MINUS_GT }]
  [tupleLiteralExp ::= (*) TUPLE LEFT_BRA variableDeclarationList RIGHT_BRA , {EOF ENDPACKAGE CONTEXT INIT DERIVE INV DEF PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE IN THEN ELSE ENDIF COMMA DOT COLON SEMICOLON BAR UP DOT_DOT UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR RIGHT_BRK RIGHT_BRA MINUS_GT }]
  [collectionKind ::= (*) SET , {LEFT_BRA }]
  [oclExpression ::= (*) oclExpression UP simpleName LEFT_PAR RIGHT_PAR , {EOF ENDPACKAGE CONTEXT INIT DERIVE INV DEF PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE IN THEN ELSE ENDIF COMMA DOT COLON SEMICOLON BAR UP DOT_DOT UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR RIGHT_BRK RIGHT_BRA MINUS_GT }]
  [oclExpression ::= (*) oclExpression NE oclExpression , {EOF ENDPACKAGE CONTEXT INIT DERIVE INV DEF PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE IN THEN ELSE ENDIF COMMA DOT COLON SEMICOLON BAR UP DOT_DOT UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR RIGHT_BRK RIGHT_BRA MINUS_GT }]
  [oclExpression ::= (*) oclExpression DIVIDE oclExpression , {EOF ENDPACKAGE CONTEXT INIT DERIVE INV DEF PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE IN THEN ELSE ENDIF COMMA DOT COLON SEMICOLON BAR UP DOT_DOT UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR RIGHT_BRK RIGHT_BRA MINUS_GT }]
  [oclExpression ::= (*) oclExpression LEFT_PAR arguments RIGHT_PAR , {EOF ENDPACKAGE CONTEXT INIT DERIVE INV DEF PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE IN THEN ELSE ENDIF COMMA DOT COLON SEMICOLON BAR UP DOT_DOT UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR RIGHT_BRK RIGHT_BRA MINUS_GT }]
  [primitiveLiteralExp ::= (*) FALSE , {EOF ENDPACKAGE CONTEXT INIT DERIVE INV DEF PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE IN THEN ELSE ENDIF COMMA DOT COLON SEMICOLON BAR UP DOT_DOT UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR RIGHT_BRK RIGHT_BRA MINUS_GT }]
  [literalExp ::= (*) primitiveLiteralExp , {EOF ENDPACKAGE CONTEXT INIT DERIVE INV DEF PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE IN THEN ELSE ENDIF COMMA DOT COLON SEMICOLON BAR UP DOT_DOT UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR RIGHT_BRK RIGHT_BRA MINUS_GT }]
  [oclExpression ::= (*) LET variableDeclarationList IN oclExpression , {EOF ENDPACKAGE CONTEXT INIT DERIVE INV DEF PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE IN THEN ELSE ENDIF COMMA DOT COLON SEMICOLON BAR UP DOT_DOT UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR RIGHT_BRK RIGHT_BRA MINUS_GT }]
  [oclExpression ::= (*) oclExpression GT oclExpression , {EOF ENDPACKAGE CONTEXT INIT DERIVE INV DEF PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE IN THEN ELSE ENDIF COMMA DOT COLON SEMICOLON BAR UP DOT_DOT UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR RIGHT_BRK RIGHT_BRA MINUS_GT }]
  [oclExpression ::= (*) oclExpression MINUS_GT ITERATE LEFT_PAR variableDeclaration BAR oclExpression RIGHT_PAR , {EOF ENDPACKAGE CONTEXT INIT DERIVE INV DEF PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE IN THEN ELSE ENDIF COMMA DOT COLON SEMICOLON BAR UP DOT_DOT UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR RIGHT_BRK RIGHT_BRA MINUS_GT }]
  [oclExpression ::= (*) literalExp , {EOF ENDPACKAGE CONTEXT INIT DERIVE INV DEF PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE IN THEN ELSE ENDIF COMMA DOT COLON SEMICOLON BAR UP DOT_DOT UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR RIGHT_BRK RIGHT_BRA MINUS_GT }]
  [primitiveLiteralExp ::= (*) INTEGER , {EOF ENDPACKAGE CONTEXT INIT DERIVE INV DEF PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE IN THEN ELSE ENDIF COMMA DOT COLON SEMICOLON BAR UP DOT_DOT UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR RIGHT_BRK RIGHT_BRA MINUS_GT }]
  [collectionKind ::= (*) BAG , {LEFT_BRA }]
  [oclExpression ::= (*) oclExpression AND oclExpression , {EOF ENDPACKAGE CONTEXT INIT DERIVE INV DEF PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE IN THEN ELSE ENDIF COMMA DOT COLON SEMICOLON BAR UP DOT_DOT UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR RIGHT_BRK RIGHT_BRA MINUS_GT }]
  [oclExpression ::= (*) oclExpression PLUS oclExpression , {EOF ENDPACKAGE CONTEXT INIT DERIVE INV DEF PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE IN THEN ELSE ENDIF COMMA DOT COLON SEMICOLON BAR UP DOT_DOT UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR RIGHT_BRK RIGHT_BRA MINUS_GT }]
  [oclExpression ::= (*) oclExpression LEFT_PAR variableDeclaration BAR oclExpression RIGHT_PAR , {EOF ENDPACKAGE CONTEXT INIT DERIVE INV DEF PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE IN THEN ELSE ENDIF COMMA DOT COLON SEMICOLON BAR UP DOT_DOT UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR RIGHT_BRK RIGHT_BRA MINUS_GT }]
  [pathName ::= (*) simpleName , {EOF ENDPACKAGE CONTEXT INIT DERIVE INV DEF PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE IN THEN ELSE ENDIF COMMA DOT COLON SEMICOLON BAR UP AT DOT_DOT COLON_COLON UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR RIGHT_BRK RIGHT_BRA MINUS_GT }]
  [oclExpression ::= (*) oclExpression UP_UP simpleName LEFT_PAR oclMessageArgumentList RIGHT_PAR , {EOF ENDPACKAGE CONTEXT INIT DERIVE INV DEF PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE IN THEN ELSE ENDIF COMMA DOT COLON SEMICOLON BAR UP DOT_DOT UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR RIGHT_BRK RIGHT_BRA MINUS_GT }]
  [oclExpression ::= (*) oclExpression LE oclExpression , {EOF ENDPACKAGE CONTEXT INIT DERIVE INV DEF PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE IN THEN ELSE ENDIF COMMA DOT COLON SEMICOLON BAR UP DOT_DOT UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR RIGHT_BRK RIGHT_BRA MINUS_GT }]
  [oclExpression ::= (*) NOT oclExpression , {EOF ENDPACKAGE CONTEXT INIT DERIVE INV DEF PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE IN THEN ELSE ENDIF COMMA DOT COLON SEMICOLON BAR UP DOT_DOT UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR RIGHT_BRK RIGHT_BRA MINUS_GT }]
  [oclExpression ::= (*) LEFT_PAR oclExpression RIGHT_PAR , {EOF ENDPACKAGE CONTEXT INIT DERIVE INV DEF PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE IN THEN ELSE ENDIF COMMA DOT COLON SEMICOLON BAR UP DOT_DOT UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR RIGHT_BRK RIGHT_BRA MINUS_GT }]
  [primitiveLiteralExp ::= (*) REAL , {EOF ENDPACKAGE CONTEXT INIT DERIVE INV DEF PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE IN THEN ELSE ENDIF COMMA DOT COLON SEMICOLON BAR UP DOT_DOT UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR RIGHT_BRK RIGHT_BRA MINUS_GT }]
  [collectionKind ::= (*) SEQUENCE , {LEFT_BRA }]
  [oclExpression ::= oclExpression MINUS (*) oclExpression , {EOF ENDPACKAGE CONTEXT INIT DERIVE INV DEF PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE IN THEN ELSE ENDIF COMMA DOT COLON SEMICOLON BAR UP DOT_DOT UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR RIGHT_BRK RIGHT_BRA MINUS_GT }]
  [oclExpression ::= (*) oclExpression OR oclExpression , {EOF ENDPACKAGE CONTEXT INIT DERIVE INV DEF PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE IN THEN ELSE ENDIF COMMA DOT COLON SEMICOLON BAR UP DOT_DOT UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR RIGHT_BRK RIGHT_BRA MINUS_GT }]
  [oclExpression ::= (*) oclExpression MINUS oclExpression , {EOF ENDPACKAGE CONTEXT INIT DERIVE INV DEF PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE IN THEN ELSE ENDIF COMMA DOT COLON SEMICOLON BAR UP DOT_DOT UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR RIGHT_BRK RIGHT_BRA MINUS_GT }]
  [oclExpression ::= (*) oclExpression LEFT_BRK argumentList RIGHT_BRK isMarkedPre , {EOF ENDPACKAGE CONTEXT INIT DERIVE INV DEF PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE IN THEN ELSE ENDIF COMMA DOT COLON SEMICOLON BAR UP DOT_DOT UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR RIGHT_BRK RIGHT_BRA MINUS_GT }]
  [pathName ::= (*) pathName COLON_COLON simpleName , {EOF ENDPACKAGE CONTEXT INIT DERIVE INV DEF PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE IN THEN ELSE ENDIF COMMA DOT COLON SEMICOLON BAR UP AT DOT_DOT COLON_COLON UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR RIGHT_BRK RIGHT_BRA MINUS_GT }]
  [collectionLiteralExp ::= (*) collectionKind LEFT_BRA collectionLiteralParts RIGHT_BRA , {EOF ENDPACKAGE CONTEXT INIT DERIVE INV DEF PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE IN THEN ELSE ENDIF COMMA DOT COLON SEMICOLON BAR UP DOT_DOT UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR RIGHT_BRK RIGHT_BRA MINUS_GT }]
  [oclExpression ::= (*) oclExpression UP_UP simpleName LEFT_PAR RIGHT_PAR , {EOF ENDPACKAGE CONTEXT INIT DERIVE INV DEF PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE IN THEN ELSE ENDIF COMMA DOT COLON SEMICOLON BAR UP DOT_DOT UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR RIGHT_BRK RIGHT_BRA MINUS_GT }]
  [oclExpression ::= (*) oclExpression GE oclExpression , {EOF ENDPACKAGE CONTEXT INIT DERIVE INV DEF PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE IN THEN ELSE ENDIF COMMA DOT COLON SEMICOLON BAR UP DOT_DOT UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR RIGHT_BRK RIGHT_BRA MINUS_GT }]
  [oclExpression ::= (*) MINUS oclExpression , {EOF ENDPACKAGE CONTEXT INIT DERIVE INV DEF PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE IN THEN ELSE ENDIF COMMA DOT COLON SEMICOLON BAR UP DOT_DOT UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR RIGHT_BRK RIGHT_BRA MINUS_GT }]
  [oclExpression ::= (*) pathName isMarkedPre , {EOF ENDPACKAGE CONTEXT INIT DERIVE INV DEF PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE IN THEN ELSE ENDIF COMMA DOT COLON SEMICOLON BAR UP DOT_DOT UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR RIGHT_BRK RIGHT_BRA MINUS_GT }]
  [primitiveLiteralExp ::= (*) STRING , {EOF ENDPACKAGE CONTEXT INIT DERIVE INV DEF PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE IN THEN ELSE ENDIF COMMA DOT COLON SEMICOLON BAR UP DOT_DOT UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR RIGHT_BRK RIGHT_BRA MINUS_GT }]
  [collectionKind ::= (*) COLLECTION , {LEFT_BRA }]
  [literalExp ::= (*) collectionLiteralExp , {EOF ENDPACKAGE CONTEXT INIT DERIVE INV DEF PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE IN THEN ELSE ENDIF COMMA DOT COLON SEMICOLON BAR UP DOT_DOT UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR RIGHT_BRK RIGHT_BRA MINUS_GT }]
  [oclExpression ::= (*) oclExpression XOR oclExpression , {EOF ENDPACKAGE CONTEXT INIT DERIVE INV DEF PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE IN THEN ELSE ENDIF COMMA DOT COLON SEMICOLON BAR UP DOT_DOT UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR RIGHT_BRK RIGHT_BRA MINUS_GT }]
  [oclExpression ::= (*) IF oclExpression THEN oclExpression ELSE oclExpression ENDIF , {EOF ENDPACKAGE CONTEXT INIT DERIVE INV DEF PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE IN THEN ELSE ENDIF COMMA DOT COLON SEMICOLON BAR UP DOT_DOT UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR RIGHT_BRK RIGHT_BRA MINUS_GT }]
  [oclExpression ::= (*) oclExpression MINUS_GT simpleName , {EOF ENDPACKAGE CONTEXT INIT DERIVE INV DEF PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE IN THEN ELSE ENDIF COMMA DOT COLON SEMICOLON BAR UP DOT_DOT UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR RIGHT_BRK RIGHT_BRA MINUS_GT }]
  [simpleName ::= (*) SIMPLE_NAME , {EOF ENDPACKAGE CONTEXT INIT DERIVE INV DEF PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE IN THEN ELSE ENDIF COMMA DOT COLON SEMICOLON BAR UP AT DOT_DOT COLON_COLON UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR RIGHT_BRK RIGHT_BRA MINUS_GT }]
  [collectionLiteralExp ::= (*) collectionKind LEFT_BRA RIGHT_BRA , {EOF ENDPACKAGE CONTEXT INIT DERIVE INV DEF PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE IN THEN ELSE ENDIF COMMA DOT COLON SEMICOLON BAR UP DOT_DOT UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR RIGHT_BRK RIGHT_BRA MINUS_GT }]
}
transition on tupleLiteralExp to state [54]
transition on oclExpression to state [81]
transition on REAL to state [52]
transition on INTEGER to state [51]
transition on pathName to state [50]
transition on SIMPLE_NAME to state [12]
transition on LET to state [49]
transition on FALSE to state [48]
transition on MINUS to state [47]
transition on COLLECTION to state [28]
transition on SET to state [20]
transition on simpleName to state [26]
transition on collectionLiteralExp to state [46]
transition on LEFT_PAR to state [45]
transition on STRING to state [44]
transition on IF to state [43]
transition on TRUE to state [42]
transition on collectionKind to state [41]
transition on NOT to state [40]
transition on primitiveLiteralExp to state [39]
transition on TUPLE to state [38]
transition on literalExp to state [37]
transition on BAG to state [25]
transition on SEQUENCE to state [22]

-------------------
lalr_state [72]: {
  [oclExpression ::= oclExpression DOT (*) simpleName isMarkedPre , {EOF ENDPACKAGE CONTEXT INIT DERIVE INV DEF PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE IN THEN ELSE ENDIF COMMA DOT COLON SEMICOLON BAR UP DOT_DOT UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR RIGHT_BRK RIGHT_BRA MINUS_GT }]
  [simpleName ::= (*) SIMPLE_NAME , {EOF ENDPACKAGE CONTEXT INIT DERIVE INV DEF PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE IN THEN ELSE ENDIF COMMA DOT COLON SEMICOLON BAR UP AT DOT_DOT UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR RIGHT_BRK RIGHT_BRA MINUS_GT }]
}
transition on SIMPLE_NAME to state [12]
transition on simpleName to state [77]

-------------------
lalr_state [73]: {
  [oclExpression ::= (*) oclExpression UP simpleName LEFT_PAR oclMessageArgumentList RIGHT_PAR , {EOF ENDPACKAGE CONTEXT INIT DERIVE INV DEF PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE IN THEN ELSE ENDIF COMMA DOT COLON SEMICOLON BAR UP DOT_DOT UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR RIGHT_BRK RIGHT_BRA MINUS_GT }]
  [oclExpression ::= (*) oclExpression EQ oclExpression , {EOF ENDPACKAGE CONTEXT INIT DERIVE INV DEF PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE IN THEN ELSE ENDIF COMMA DOT COLON SEMICOLON BAR UP DOT_DOT UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR RIGHT_BRK RIGHT_BRA MINUS_GT }]
  [oclExpression ::= (*) oclExpression TIMES oclExpression , {EOF ENDPACKAGE CONTEXT INIT DERIVE INV DEF PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE IN THEN ELSE ENDIF COMMA DOT COLON SEMICOLON BAR UP DOT_DOT UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR RIGHT_BRK RIGHT_BRA MINUS_GT }]
  [oclExpression ::= (*) oclExpression DOT simpleName isMarkedPre , {EOF ENDPACKAGE CONTEXT INIT DERIVE INV DEF PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE IN THEN ELSE ENDIF COMMA DOT COLON SEMICOLON BAR UP DOT_DOT UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR RIGHT_BRK RIGHT_BRA MINUS_GT }]
  [primitiveLiteralExp ::= (*) TRUE , {EOF ENDPACKAGE CONTEXT INIT DERIVE INV DEF PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE IN THEN ELSE ENDIF COMMA DOT COLON SEMICOLON BAR UP DOT_DOT UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR RIGHT_BRK RIGHT_BRA MINUS_GT }]
  [literalExp ::= (*) tupleLiteralExp , {EOF ENDPACKAGE CONTEXT INIT DERIVE INV DEF PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE IN THEN ELSE ENDIF COMMA DOT COLON SEMICOLON BAR UP DOT_DOT UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR RIGHT_BRK RIGHT_BRA MINUS_GT }]
  [oclExpression ::= (*) oclExpression IMPLIES oclExpression , {EOF ENDPACKAGE CONTEXT INIT DERIVE INV DEF PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE IN THEN ELSE ENDIF COMMA DOT COLON SEMICOLON BAR UP DOT_DOT UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR RIGHT_BRK RIGHT_BRA MINUS_GT }]
  [oclExpression ::= (*) oclExpression LT oclExpression , {EOF ENDPACKAGE CONTEXT INIT DERIVE INV DEF PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE IN THEN ELSE ENDIF COMMA DOT COLON SEMICOLON BAR UP DOT_DOT UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR RIGHT_BRK RIGHT_BRA MINUS_GT }]
  [oclExpression ::= (*) oclExpression MINUS_GT ITERATE LEFT_PAR variableDeclaration SEMICOLON variableDeclaration BAR oclExpression RIGHT_PAR , {EOF ENDPACKAGE CONTEXT INIT DERIVE INV DEF PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE IN THEN ELSE ENDIF COMMA DOT COLON SEMICOLON BAR UP DOT_DOT UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR RIGHT_BRK RIGHT_BRA MINUS_GT }]
  [tupleLiteralExp ::= (*) TUPLE LEFT_BRA variableDeclarationList RIGHT_BRA , {EOF ENDPACKAGE CONTEXT INIT DERIVE INV DEF PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE IN THEN ELSE ENDIF COMMA DOT COLON SEMICOLON BAR UP DOT_DOT UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR RIGHT_BRK RIGHT_BRA MINUS_GT }]
  [collectionKind ::= (*) SET , {LEFT_BRA }]
  [oclExpression ::= (*) oclExpression UP simpleName LEFT_PAR RIGHT_PAR , {EOF ENDPACKAGE CONTEXT INIT DERIVE INV DEF PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE IN THEN ELSE ENDIF COMMA DOT COLON SEMICOLON BAR UP DOT_DOT UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR RIGHT_BRK RIGHT_BRA MINUS_GT }]
  [oclExpression ::= (*) oclExpression NE oclExpression , {EOF ENDPACKAGE CONTEXT INIT DERIVE INV DEF PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE IN THEN ELSE ENDIF COMMA DOT COLON SEMICOLON BAR UP DOT_DOT UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR RIGHT_BRK RIGHT_BRA MINUS_GT }]
  [oclExpression ::= (*) oclExpression DIVIDE oclExpression , {EOF ENDPACKAGE CONTEXT INIT DERIVE INV DEF PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE IN THEN ELSE ENDIF COMMA DOT COLON SEMICOLON BAR UP DOT_DOT UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR RIGHT_BRK RIGHT_BRA MINUS_GT }]
  [oclExpression ::= (*) oclExpression LEFT_PAR arguments RIGHT_PAR , {EOF ENDPACKAGE CONTEXT INIT DERIVE INV DEF PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE IN THEN ELSE ENDIF COMMA DOT COLON SEMICOLON BAR UP DOT_DOT UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR RIGHT_BRK RIGHT_BRA MINUS_GT }]
  [primitiveLiteralExp ::= (*) FALSE , {EOF ENDPACKAGE CONTEXT INIT DERIVE INV DEF PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE IN THEN ELSE ENDIF COMMA DOT COLON SEMICOLON BAR UP DOT_DOT UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR RIGHT_BRK RIGHT_BRA MINUS_GT }]
  [literalExp ::= (*) primitiveLiteralExp , {EOF ENDPACKAGE CONTEXT INIT DERIVE INV DEF PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE IN THEN ELSE ENDIF COMMA DOT COLON SEMICOLON BAR UP DOT_DOT UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR RIGHT_BRK RIGHT_BRA MINUS_GT }]
  [oclExpression ::= (*) LET variableDeclarationList IN oclExpression , {EOF ENDPACKAGE CONTEXT INIT DERIVE INV DEF PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE IN THEN ELSE ENDIF COMMA DOT COLON SEMICOLON BAR UP DOT_DOT UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR RIGHT_BRK RIGHT_BRA MINUS_GT }]
  [oclExpression ::= (*) oclExpression GT oclExpression , {EOF ENDPACKAGE CONTEXT INIT DERIVE INV DEF PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE IN THEN ELSE ENDIF COMMA DOT COLON SEMICOLON BAR UP DOT_DOT UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR RIGHT_BRK RIGHT_BRA MINUS_GT }]
  [oclExpression ::= (*) oclExpression MINUS_GT ITERATE LEFT_PAR variableDeclaration BAR oclExpression RIGHT_PAR , {EOF ENDPACKAGE CONTEXT INIT DERIVE INV DEF PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE IN THEN ELSE ENDIF COMMA DOT COLON SEMICOLON BAR UP DOT_DOT UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR RIGHT_BRK RIGHT_BRA MINUS_GT }]
  [oclExpression ::= (*) literalExp , {EOF ENDPACKAGE CONTEXT INIT DERIVE INV DEF PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE IN THEN ELSE ENDIF COMMA DOT COLON SEMICOLON BAR UP DOT_DOT UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR RIGHT_BRK RIGHT_BRA MINUS_GT }]
  [primitiveLiteralExp ::= (*) INTEGER , {EOF ENDPACKAGE CONTEXT INIT DERIVE INV DEF PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE IN THEN ELSE ENDIF COMMA DOT COLON SEMICOLON BAR UP DOT_DOT UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR RIGHT_BRK RIGHT_BRA MINUS_GT }]
  [collectionKind ::= (*) BAG , {LEFT_BRA }]
  [oclExpression ::= (*) oclExpression AND oclExpression , {EOF ENDPACKAGE CONTEXT INIT DERIVE INV DEF PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE IN THEN ELSE ENDIF COMMA DOT COLON SEMICOLON BAR UP DOT_DOT UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR RIGHT_BRK RIGHT_BRA MINUS_GT }]
  [oclExpression ::= (*) oclExpression PLUS oclExpression , {EOF ENDPACKAGE CONTEXT INIT DERIVE INV DEF PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE IN THEN ELSE ENDIF COMMA DOT COLON SEMICOLON BAR UP DOT_DOT UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR RIGHT_BRK RIGHT_BRA MINUS_GT }]
  [oclExpression ::= (*) oclExpression LEFT_PAR variableDeclaration BAR oclExpression RIGHT_PAR , {EOF ENDPACKAGE CONTEXT INIT DERIVE INV DEF PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE IN THEN ELSE ENDIF COMMA DOT COLON SEMICOLON BAR UP DOT_DOT UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR RIGHT_BRK RIGHT_BRA MINUS_GT }]
  [pathName ::= (*) simpleName , {EOF ENDPACKAGE CONTEXT INIT DERIVE INV DEF PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE IN THEN ELSE ENDIF COMMA DOT COLON SEMICOLON BAR UP AT DOT_DOT COLON_COLON UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR RIGHT_BRK RIGHT_BRA MINUS_GT }]
  [oclExpression ::= (*) oclExpression UP_UP simpleName LEFT_PAR oclMessageArgumentList RIGHT_PAR , {EOF ENDPACKAGE CONTEXT INIT DERIVE INV DEF PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE IN THEN ELSE ENDIF COMMA DOT COLON SEMICOLON BAR UP DOT_DOT UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR RIGHT_BRK RIGHT_BRA MINUS_GT }]
  [oclExpression ::= (*) oclExpression LE oclExpression , {EOF ENDPACKAGE CONTEXT INIT DERIVE INV DEF PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE IN THEN ELSE ENDIF COMMA DOT COLON SEMICOLON BAR UP DOT_DOT UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR RIGHT_BRK RIGHT_BRA MINUS_GT }]
  [oclExpression ::= (*) NOT oclExpression , {EOF ENDPACKAGE CONTEXT INIT DERIVE INV DEF PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE IN THEN ELSE ENDIF COMMA DOT COLON SEMICOLON BAR UP DOT_DOT UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR RIGHT_BRK RIGHT_BRA MINUS_GT }]
  [oclExpression ::= (*) LEFT_PAR oclExpression RIGHT_PAR , {EOF ENDPACKAGE CONTEXT INIT DERIVE INV DEF PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE IN THEN ELSE ENDIF COMMA DOT COLON SEMICOLON BAR UP DOT_DOT UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR RIGHT_BRK RIGHT_BRA MINUS_GT }]
  [primitiveLiteralExp ::= (*) REAL , {EOF ENDPACKAGE CONTEXT INIT DERIVE INV DEF PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE IN THEN ELSE ENDIF COMMA DOT COLON SEMICOLON BAR UP DOT_DOT UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR RIGHT_BRK RIGHT_BRA MINUS_GT }]
  [collectionKind ::= (*) SEQUENCE , {LEFT_BRA }]
  [oclExpression ::= (*) oclExpression OR oclExpression , {EOF ENDPACKAGE CONTEXT INIT DERIVE INV DEF PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE IN THEN ELSE ENDIF COMMA DOT COLON SEMICOLON BAR UP DOT_DOT UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR RIGHT_BRK RIGHT_BRA MINUS_GT }]
  [oclExpression ::= (*) oclExpression MINUS oclExpression , {EOF ENDPACKAGE CONTEXT INIT DERIVE INV DEF PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE IN THEN ELSE ENDIF COMMA DOT COLON SEMICOLON BAR UP DOT_DOT UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR RIGHT_BRK RIGHT_BRA MINUS_GT }]
  [oclExpression ::= (*) oclExpression LEFT_BRK argumentList RIGHT_BRK isMarkedPre , {EOF ENDPACKAGE CONTEXT INIT DERIVE INV DEF PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE IN THEN ELSE ENDIF COMMA DOT COLON SEMICOLON BAR UP DOT_DOT UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR RIGHT_BRK RIGHT_BRA MINUS_GT }]
  [pathName ::= (*) pathName COLON_COLON simpleName , {EOF ENDPACKAGE CONTEXT INIT DERIVE INV DEF PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE IN THEN ELSE ENDIF COMMA DOT COLON SEMICOLON BAR UP AT DOT_DOT COLON_COLON UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR RIGHT_BRK RIGHT_BRA MINUS_GT }]
  [collectionLiteralExp ::= (*) collectionKind LEFT_BRA collectionLiteralParts RIGHT_BRA , {EOF ENDPACKAGE CONTEXT INIT DERIVE INV DEF PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE IN THEN ELSE ENDIF COMMA DOT COLON SEMICOLON BAR UP DOT_DOT UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR RIGHT_BRK RIGHT_BRA MINUS_GT }]
  [oclExpression ::= (*) oclExpression UP_UP simpleName LEFT_PAR RIGHT_PAR , {EOF ENDPACKAGE CONTEXT INIT DERIVE INV DEF PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE IN THEN ELSE ENDIF COMMA DOT COLON SEMICOLON BAR UP DOT_DOT UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR RIGHT_BRK RIGHT_BRA MINUS_GT }]
  [oclExpression ::= (*) oclExpression GE oclExpression , {EOF ENDPACKAGE CONTEXT INIT DERIVE INV DEF PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE IN THEN ELSE ENDIF COMMA DOT COLON SEMICOLON BAR UP DOT_DOT UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR RIGHT_BRK RIGHT_BRA MINUS_GT }]
  [oclExpression ::= (*) MINUS oclExpression , {EOF ENDPACKAGE CONTEXT INIT DERIVE INV DEF PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE IN THEN ELSE ENDIF COMMA DOT COLON SEMICOLON BAR UP DOT_DOT UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR RIGHT_BRK RIGHT_BRA MINUS_GT }]
  [oclExpression ::= (*) pathName isMarkedPre , {EOF ENDPACKAGE CONTEXT INIT DERIVE INV DEF PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE IN THEN ELSE ENDIF COMMA DOT COLON SEMICOLON BAR UP DOT_DOT UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR RIGHT_BRK RIGHT_BRA MINUS_GT }]
  [primitiveLiteralExp ::= (*) STRING , {EOF ENDPACKAGE CONTEXT INIT DERIVE INV DEF PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE IN THEN ELSE ENDIF COMMA DOT COLON SEMICOLON BAR UP DOT_DOT UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR RIGHT_BRK RIGHT_BRA MINUS_GT }]
  [collectionKind ::= (*) COLLECTION , {LEFT_BRA }]
  [literalExp ::= (*) collectionLiteralExp , {EOF ENDPACKAGE CONTEXT INIT DERIVE INV DEF PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE IN THEN ELSE ENDIF COMMA DOT COLON SEMICOLON BAR UP DOT_DOT UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR RIGHT_BRK RIGHT_BRA MINUS_GT }]
  [oclExpression ::= (*) oclExpression XOR oclExpression , {EOF ENDPACKAGE CONTEXT INIT DERIVE INV DEF PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE IN THEN ELSE ENDIF COMMA DOT COLON SEMICOLON BAR UP DOT_DOT UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR RIGHT_BRK RIGHT_BRA MINUS_GT }]
  [oclExpression ::= (*) IF oclExpression THEN oclExpression ELSE oclExpression ENDIF , {EOF ENDPACKAGE CONTEXT INIT DERIVE INV DEF PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE IN THEN ELSE ENDIF COMMA DOT COLON SEMICOLON BAR UP DOT_DOT UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR RIGHT_BRK RIGHT_BRA MINUS_GT }]
  [oclExpression ::= (*) oclExpression MINUS_GT simpleName , {EOF ENDPACKAGE CONTEXT INIT DERIVE INV DEF PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE IN THEN ELSE ENDIF COMMA DOT COLON SEMICOLON BAR UP DOT_DOT UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR RIGHT_BRK RIGHT_BRA MINUS_GT }]
  [simpleName ::= (*) SIMPLE_NAME , {EOF ENDPACKAGE CONTEXT INIT DERIVE INV DEF PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE IN THEN ELSE ENDIF COMMA DOT COLON SEMICOLON BAR UP AT DOT_DOT COLON_COLON UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR RIGHT_BRK RIGHT_BRA MINUS_GT }]
  [collectionLiteralExp ::= (*) collectionKind LEFT_BRA RIGHT_BRA , {EOF ENDPACKAGE CONTEXT INIT DERIVE INV DEF PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE IN THEN ELSE ENDIF COMMA DOT COLON SEMICOLON BAR UP DOT_DOT UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR RIGHT_BRK RIGHT_BRA MINUS_GT }]
  [oclExpression ::= oclExpression EQ (*) oclExpression , {EOF ENDPACKAGE CONTEXT INIT DERIVE INV DEF PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE IN THEN ELSE ENDIF COMMA DOT COLON SEMICOLON BAR UP DOT_DOT UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR RIGHT_BRK RIGHT_BRA MINUS_GT }]
}
transition on tupleLiteralExp to state [54]
transition on oclExpression to state [76]
transition on REAL to state [52]
transition on INTEGER to state [51]
transition on pathName to state [50]
transition on SIMPLE_NAME to state [12]
transition on LET to state [49]
transition on FALSE to state [48]
transition on MINUS to state [47]
transition on COLLECTION to state [28]
transition on SET to state [20]
transition on simpleName to state [26]
transition on collectionLiteralExp to state [46]
transition on LEFT_PAR to state [45]
transition on STRING to state [44]
transition on IF to state [43]
transition on TRUE to state [42]
transition on collectionKind to state [41]
transition on NOT to state [40]
transition on primitiveLiteralExp to state [39]
transition on TUPLE to state [38]
transition on literalExp to state [37]
transition on BAG to state [25]
transition on SEQUENCE to state [22]

-------------------
lalr_state [74]: {
  [oclExpression ::= (*) oclExpression UP simpleName LEFT_PAR oclMessageArgumentList RIGHT_PAR , {EOF ENDPACKAGE CONTEXT INIT DERIVE INV DEF PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE IN THEN ELSE ENDIF COMMA DOT COLON SEMICOLON BAR UP DOT_DOT UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR RIGHT_BRK RIGHT_BRA MINUS_GT }]
  [oclExpression ::= (*) oclExpression EQ oclExpression , {EOF ENDPACKAGE CONTEXT INIT DERIVE INV DEF PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE IN THEN ELSE ENDIF COMMA DOT COLON SEMICOLON BAR UP DOT_DOT UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR RIGHT_BRK RIGHT_BRA MINUS_GT }]
  [oclExpression ::= (*) oclExpression TIMES oclExpression , {EOF ENDPACKAGE CONTEXT INIT DERIVE INV DEF PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE IN THEN ELSE ENDIF COMMA DOT COLON SEMICOLON BAR UP DOT_DOT UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR RIGHT_BRK RIGHT_BRA MINUS_GT }]
  [oclExpression ::= (*) oclExpression DOT simpleName isMarkedPre , {EOF ENDPACKAGE CONTEXT INIT DERIVE INV DEF PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE IN THEN ELSE ENDIF COMMA DOT COLON SEMICOLON BAR UP DOT_DOT UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR RIGHT_BRK RIGHT_BRA MINUS_GT }]
  [primitiveLiteralExp ::= (*) TRUE , {EOF ENDPACKAGE CONTEXT INIT DERIVE INV DEF PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE IN THEN ELSE ENDIF COMMA DOT COLON SEMICOLON BAR UP DOT_DOT UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR RIGHT_BRK RIGHT_BRA MINUS_GT }]
  [literalExp ::= (*) tupleLiteralExp , {EOF ENDPACKAGE CONTEXT INIT DERIVE INV DEF PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE IN THEN ELSE ENDIF COMMA DOT COLON SEMICOLON BAR UP DOT_DOT UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR RIGHT_BRK RIGHT_BRA MINUS_GT }]
  [oclExpression ::= (*) oclExpression IMPLIES oclExpression , {EOF ENDPACKAGE CONTEXT INIT DERIVE INV DEF PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE IN THEN ELSE ENDIF COMMA DOT COLON SEMICOLON BAR UP DOT_DOT UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR RIGHT_BRK RIGHT_BRA MINUS_GT }]
  [oclExpression ::= (*) oclExpression LT oclExpression , {EOF ENDPACKAGE CONTEXT INIT DERIVE INV DEF PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE IN THEN ELSE ENDIF COMMA DOT COLON SEMICOLON BAR UP DOT_DOT UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR RIGHT_BRK RIGHT_BRA MINUS_GT }]
  [oclExpression ::= (*) oclExpression MINUS_GT ITERATE LEFT_PAR variableDeclaration SEMICOLON variableDeclaration BAR oclExpression RIGHT_PAR , {EOF ENDPACKAGE CONTEXT INIT DERIVE INV DEF PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE IN THEN ELSE ENDIF COMMA DOT COLON SEMICOLON BAR UP DOT_DOT UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR RIGHT_BRK RIGHT_BRA MINUS_GT }]
  [tupleLiteralExp ::= (*) TUPLE LEFT_BRA variableDeclarationList RIGHT_BRA , {EOF ENDPACKAGE CONTEXT INIT DERIVE INV DEF PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE IN THEN ELSE ENDIF COMMA DOT COLON SEMICOLON BAR UP DOT_DOT UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR RIGHT_BRK RIGHT_BRA MINUS_GT }]
  [collectionKind ::= (*) SET , {LEFT_BRA }]
  [oclExpression ::= (*) oclExpression UP simpleName LEFT_PAR RIGHT_PAR , {EOF ENDPACKAGE CONTEXT INIT DERIVE INV DEF PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE IN THEN ELSE ENDIF COMMA DOT COLON SEMICOLON BAR UP DOT_DOT UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR RIGHT_BRK RIGHT_BRA MINUS_GT }]
  [oclExpression ::= (*) oclExpression NE oclExpression , {EOF ENDPACKAGE CONTEXT INIT DERIVE INV DEF PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE IN THEN ELSE ENDIF COMMA DOT COLON SEMICOLON BAR UP DOT_DOT UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR RIGHT_BRK RIGHT_BRA MINUS_GT }]
  [oclExpression ::= (*) oclExpression DIVIDE oclExpression , {EOF ENDPACKAGE CONTEXT INIT DERIVE INV DEF PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE IN THEN ELSE ENDIF COMMA DOT COLON SEMICOLON BAR UP DOT_DOT UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR RIGHT_BRK RIGHT_BRA MINUS_GT }]
  [oclExpression ::= (*) oclExpression LEFT_PAR arguments RIGHT_PAR , {EOF ENDPACKAGE CONTEXT INIT DERIVE INV DEF PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE IN THEN ELSE ENDIF COMMA DOT COLON SEMICOLON BAR UP DOT_DOT UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR RIGHT_BRK RIGHT_BRA MINUS_GT }]
  [primitiveLiteralExp ::= (*) FALSE , {EOF ENDPACKAGE CONTEXT INIT DERIVE INV DEF PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE IN THEN ELSE ENDIF COMMA DOT COLON SEMICOLON BAR UP DOT_DOT UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR RIGHT_BRK RIGHT_BRA MINUS_GT }]
  [literalExp ::= (*) primitiveLiteralExp , {EOF ENDPACKAGE CONTEXT INIT DERIVE INV DEF PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE IN THEN ELSE ENDIF COMMA DOT COLON SEMICOLON BAR UP DOT_DOT UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR RIGHT_BRK RIGHT_BRA MINUS_GT }]
  [oclExpression ::= (*) LET variableDeclarationList IN oclExpression , {EOF ENDPACKAGE CONTEXT INIT DERIVE INV DEF PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE IN THEN ELSE ENDIF COMMA DOT COLON SEMICOLON BAR UP DOT_DOT UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR RIGHT_BRK RIGHT_BRA MINUS_GT }]
  [oclExpression ::= (*) oclExpression GT oclExpression , {EOF ENDPACKAGE CONTEXT INIT DERIVE INV DEF PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE IN THEN ELSE ENDIF COMMA DOT COLON SEMICOLON BAR UP DOT_DOT UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR RIGHT_BRK RIGHT_BRA MINUS_GT }]
  [oclExpression ::= (*) oclExpression MINUS_GT ITERATE LEFT_PAR variableDeclaration BAR oclExpression RIGHT_PAR , {EOF ENDPACKAGE CONTEXT INIT DERIVE INV DEF PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE IN THEN ELSE ENDIF COMMA DOT COLON SEMICOLON BAR UP DOT_DOT UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR RIGHT_BRK RIGHT_BRA MINUS_GT }]
  [oclExpression ::= (*) literalExp , {EOF ENDPACKAGE CONTEXT INIT DERIVE INV DEF PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE IN THEN ELSE ENDIF COMMA DOT COLON SEMICOLON BAR UP DOT_DOT UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR RIGHT_BRK RIGHT_BRA MINUS_GT }]
  [primitiveLiteralExp ::= (*) INTEGER , {EOF ENDPACKAGE CONTEXT INIT DERIVE INV DEF PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE IN THEN ELSE ENDIF COMMA DOT COLON SEMICOLON BAR UP DOT_DOT UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR RIGHT_BRK RIGHT_BRA MINUS_GT }]
  [collectionKind ::= (*) BAG , {LEFT_BRA }]
  [oclExpression ::= (*) oclExpression AND oclExpression , {EOF ENDPACKAGE CONTEXT INIT DERIVE INV DEF PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE IN THEN ELSE ENDIF COMMA DOT COLON SEMICOLON BAR UP DOT_DOT UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR RIGHT_BRK RIGHT_BRA MINUS_GT }]
  [oclExpression ::= (*) oclExpression PLUS oclExpression , {EOF ENDPACKAGE CONTEXT INIT DERIVE INV DEF PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE IN THEN ELSE ENDIF COMMA DOT COLON SEMICOLON BAR UP DOT_DOT UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR RIGHT_BRK RIGHT_BRA MINUS_GT }]
  [oclExpression ::= (*) oclExpression LEFT_PAR variableDeclaration BAR oclExpression RIGHT_PAR , {EOF ENDPACKAGE CONTEXT INIT DERIVE INV DEF PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE IN THEN ELSE ENDIF COMMA DOT COLON SEMICOLON BAR UP DOT_DOT UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR RIGHT_BRK RIGHT_BRA MINUS_GT }]
  [pathName ::= (*) simpleName , {EOF ENDPACKAGE CONTEXT INIT DERIVE INV DEF PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE IN THEN ELSE ENDIF COMMA DOT COLON SEMICOLON BAR UP AT DOT_DOT COLON_COLON UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR RIGHT_BRK RIGHT_BRA MINUS_GT }]
  [oclExpression ::= (*) oclExpression UP_UP simpleName LEFT_PAR oclMessageArgumentList RIGHT_PAR , {EOF ENDPACKAGE CONTEXT INIT DERIVE INV DEF PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE IN THEN ELSE ENDIF COMMA DOT COLON SEMICOLON BAR UP DOT_DOT UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR RIGHT_BRK RIGHT_BRA MINUS_GT }]
  [oclExpression ::= (*) oclExpression LE oclExpression , {EOF ENDPACKAGE CONTEXT INIT DERIVE INV DEF PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE IN THEN ELSE ENDIF COMMA DOT COLON SEMICOLON BAR UP DOT_DOT UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR RIGHT_BRK RIGHT_BRA MINUS_GT }]
  [oclExpression ::= (*) NOT oclExpression , {EOF ENDPACKAGE CONTEXT INIT DERIVE INV DEF PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE IN THEN ELSE ENDIF COMMA DOT COLON SEMICOLON BAR UP DOT_DOT UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR RIGHT_BRK RIGHT_BRA MINUS_GT }]
  [oclExpression ::= (*) LEFT_PAR oclExpression RIGHT_PAR , {EOF ENDPACKAGE CONTEXT INIT DERIVE INV DEF PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE IN THEN ELSE ENDIF COMMA DOT COLON SEMICOLON BAR UP DOT_DOT UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR RIGHT_BRK RIGHT_BRA MINUS_GT }]
  [primitiveLiteralExp ::= (*) REAL , {EOF ENDPACKAGE CONTEXT INIT DERIVE INV DEF PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE IN THEN ELSE ENDIF COMMA DOT COLON SEMICOLON BAR UP DOT_DOT UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR RIGHT_BRK RIGHT_BRA MINUS_GT }]
  [collectionKind ::= (*) SEQUENCE , {LEFT_BRA }]
  [oclExpression ::= (*) oclExpression OR oclExpression , {EOF ENDPACKAGE CONTEXT INIT DERIVE INV DEF PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE IN THEN ELSE ENDIF COMMA DOT COLON SEMICOLON BAR UP DOT_DOT UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR RIGHT_BRK RIGHT_BRA MINUS_GT }]
  [oclExpression ::= (*) oclExpression MINUS oclExpression , {EOF ENDPACKAGE CONTEXT INIT DERIVE INV DEF PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE IN THEN ELSE ENDIF COMMA DOT COLON SEMICOLON BAR UP DOT_DOT UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR RIGHT_BRK RIGHT_BRA MINUS_GT }]
  [oclExpression ::= (*) oclExpression LEFT_BRK argumentList RIGHT_BRK isMarkedPre , {EOF ENDPACKAGE CONTEXT INIT DERIVE INV DEF PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE IN THEN ELSE ENDIF COMMA DOT COLON SEMICOLON BAR UP DOT_DOT UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR RIGHT_BRK RIGHT_BRA MINUS_GT }]
  [pathName ::= (*) pathName COLON_COLON simpleName , {EOF ENDPACKAGE CONTEXT INIT DERIVE INV DEF PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE IN THEN ELSE ENDIF COMMA DOT COLON SEMICOLON BAR UP AT DOT_DOT COLON_COLON UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR RIGHT_BRK RIGHT_BRA MINUS_GT }]
  [collectionLiteralExp ::= (*) collectionKind LEFT_BRA collectionLiteralParts RIGHT_BRA , {EOF ENDPACKAGE CONTEXT INIT DERIVE INV DEF PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE IN THEN ELSE ENDIF COMMA DOT COLON SEMICOLON BAR UP DOT_DOT UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR RIGHT_BRK RIGHT_BRA MINUS_GT }]
  [oclExpression ::= (*) oclExpression UP_UP simpleName LEFT_PAR RIGHT_PAR , {EOF ENDPACKAGE CONTEXT INIT DERIVE INV DEF PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE IN THEN ELSE ENDIF COMMA DOT COLON SEMICOLON BAR UP DOT_DOT UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR RIGHT_BRK RIGHT_BRA MINUS_GT }]
  [oclExpression ::= (*) oclExpression GE oclExpression , {EOF ENDPACKAGE CONTEXT INIT DERIVE INV DEF PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE IN THEN ELSE ENDIF COMMA DOT COLON SEMICOLON BAR UP DOT_DOT UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR RIGHT_BRK RIGHT_BRA MINUS_GT }]
  [oclExpression ::= (*) MINUS oclExpression , {EOF ENDPACKAGE CONTEXT INIT DERIVE INV DEF PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE IN THEN ELSE ENDIF COMMA DOT COLON SEMICOLON BAR UP DOT_DOT UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR RIGHT_BRK RIGHT_BRA MINUS_GT }]
  [oclExpression ::= (*) pathName isMarkedPre , {EOF ENDPACKAGE CONTEXT INIT DERIVE INV DEF PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE IN THEN ELSE ENDIF COMMA DOT COLON SEMICOLON BAR UP DOT_DOT UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR RIGHT_BRK RIGHT_BRA MINUS_GT }]
  [primitiveLiteralExp ::= (*) STRING , {EOF ENDPACKAGE CONTEXT INIT DERIVE INV DEF PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE IN THEN ELSE ENDIF COMMA DOT COLON SEMICOLON BAR UP DOT_DOT UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR RIGHT_BRK RIGHT_BRA MINUS_GT }]
  [collectionKind ::= (*) COLLECTION , {LEFT_BRA }]
  [literalExp ::= (*) collectionLiteralExp , {EOF ENDPACKAGE CONTEXT INIT DERIVE INV DEF PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE IN THEN ELSE ENDIF COMMA DOT COLON SEMICOLON BAR UP DOT_DOT UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR RIGHT_BRK RIGHT_BRA MINUS_GT }]
  [oclExpression ::= oclExpression XOR (*) oclExpression , {EOF ENDPACKAGE CONTEXT INIT DERIVE INV DEF PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE IN THEN ELSE ENDIF COMMA DOT COLON SEMICOLON BAR UP DOT_DOT UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR RIGHT_BRK RIGHT_BRA MINUS_GT }]
  [oclExpression ::= (*) oclExpression XOR oclExpression , {EOF ENDPACKAGE CONTEXT INIT DERIVE INV DEF PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE IN THEN ELSE ENDIF COMMA DOT COLON SEMICOLON BAR UP DOT_DOT UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR RIGHT_BRK RIGHT_BRA MINUS_GT }]
  [oclExpression ::= (*) IF oclExpression THEN oclExpression ELSE oclExpression ENDIF , {EOF ENDPACKAGE CONTEXT INIT DERIVE INV DEF PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE IN THEN ELSE ENDIF COMMA DOT COLON SEMICOLON BAR UP DOT_DOT UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR RIGHT_BRK RIGHT_BRA MINUS_GT }]
  [oclExpression ::= (*) oclExpression MINUS_GT simpleName , {EOF ENDPACKAGE CONTEXT INIT DERIVE INV DEF PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE IN THEN ELSE ENDIF COMMA DOT COLON SEMICOLON BAR UP DOT_DOT UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR RIGHT_BRK RIGHT_BRA MINUS_GT }]
  [simpleName ::= (*) SIMPLE_NAME , {EOF ENDPACKAGE CONTEXT INIT DERIVE INV DEF PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE IN THEN ELSE ENDIF COMMA DOT COLON SEMICOLON BAR UP AT DOT_DOT COLON_COLON UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR RIGHT_BRK RIGHT_BRA MINUS_GT }]
  [collectionLiteralExp ::= (*) collectionKind LEFT_BRA RIGHT_BRA , {EOF ENDPACKAGE CONTEXT INIT DERIVE INV DEF PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE IN THEN ELSE ENDIF COMMA DOT COLON SEMICOLON BAR UP DOT_DOT UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR RIGHT_BRK RIGHT_BRA MINUS_GT }]
}
transition on tupleLiteralExp to state [54]
transition on oclExpression to state [75]
transition on REAL to state [52]
transition on INTEGER to state [51]
transition on pathName to state [50]
transition on SIMPLE_NAME to state [12]
transition on LET to state [49]
transition on FALSE to state [48]
transition on MINUS to state [47]
transition on COLLECTION to state [28]
transition on SET to state [20]
transition on simpleName to state [26]
transition on collectionLiteralExp to state [46]
transition on LEFT_PAR to state [45]
transition on STRING to state [44]
transition on IF to state [43]
transition on TRUE to state [42]
transition on collectionKind to state [41]
transition on NOT to state [40]
transition on primitiveLiteralExp to state [39]
transition on TUPLE to state [38]
transition on literalExp to state [37]
transition on BAG to state [25]
transition on SEQUENCE to state [22]

-------------------
lalr_state [75]: {
  [oclExpression ::= oclExpression (*) LEFT_BRK argumentList RIGHT_BRK isMarkedPre , {EOF ENDPACKAGE CONTEXT INIT DERIVE INV DEF PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE IN THEN ELSE ENDIF COMMA DOT COLON SEMICOLON BAR UP DOT_DOT UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR RIGHT_BRK RIGHT_BRA MINUS_GT }]
  [oclExpression ::= oclExpression (*) EQ oclExpression , {EOF ENDPACKAGE CONTEXT INIT DERIVE INV DEF PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE IN THEN ELSE ENDIF COMMA DOT COLON SEMICOLON BAR UP DOT_DOT UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR RIGHT_BRK RIGHT_BRA MINUS_GT }]
  [oclExpression ::= oclExpression (*) IMPLIES oclExpression , {EOF ENDPACKAGE CONTEXT INIT DERIVE INV DEF PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE IN THEN ELSE ENDIF COMMA DOT COLON SEMICOLON BAR UP DOT_DOT UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR RIGHT_BRK RIGHT_BRA MINUS_GT }]
  [oclExpression ::= oclExpression (*) UP simpleName LEFT_PAR RIGHT_PAR , {EOF ENDPACKAGE CONTEXT INIT DERIVE INV DEF PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE IN THEN ELSE ENDIF COMMA DOT COLON SEMICOLON BAR UP DOT_DOT UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR RIGHT_BRK RIGHT_BRA MINUS_GT }]
  [oclExpression ::= oclExpression (*) LEFT_PAR arguments RIGHT_PAR , {EOF ENDPACKAGE CONTEXT INIT DERIVE INV DEF PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE IN THEN ELSE ENDIF COMMA DOT COLON SEMICOLON BAR UP DOT_DOT UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR RIGHT_BRK RIGHT_BRA MINUS_GT }]
  [oclExpression ::= oclExpression (*) MINUS_GT ITERATE LEFT_PAR variableDeclaration BAR oclExpression RIGHT_PAR , {EOF ENDPACKAGE CONTEXT INIT DERIVE INV DEF PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE IN THEN ELSE ENDIF COMMA DOT COLON SEMICOLON BAR UP DOT_DOT UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR RIGHT_BRK RIGHT_BRA MINUS_GT }]
  [oclExpression ::= oclExpression (*) PLUS oclExpression , {EOF ENDPACKAGE CONTEXT INIT DERIVE INV DEF PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE IN THEN ELSE ENDIF COMMA DOT COLON SEMICOLON BAR UP DOT_DOT UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR RIGHT_BRK RIGHT_BRA MINUS_GT }]
  [oclExpression ::= oclExpression (*) LE oclExpression , {EOF ENDPACKAGE CONTEXT INIT DERIVE INV DEF PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE IN THEN ELSE ENDIF COMMA DOT COLON SEMICOLON BAR UP DOT_DOT UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR RIGHT_BRK RIGHT_BRA MINUS_GT }]
  [oclExpression ::= oclExpression (*) OR oclExpression , {EOF ENDPACKAGE CONTEXT INIT DERIVE INV DEF PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE IN THEN ELSE ENDIF COMMA DOT COLON SEMICOLON BAR UP DOT_DOT UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR RIGHT_BRK RIGHT_BRA MINUS_GT }]
  [oclExpression ::= oclExpression (*) UP_UP simpleName LEFT_PAR RIGHT_PAR , {EOF ENDPACKAGE CONTEXT INIT DERIVE INV DEF PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE IN THEN ELSE ENDIF COMMA DOT COLON SEMICOLON BAR UP DOT_DOT UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR RIGHT_BRK RIGHT_BRA MINUS_GT }]
  [oclExpression ::= oclExpression (*) MINUS_GT simpleName , {EOF ENDPACKAGE CONTEXT INIT DERIVE INV DEF PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE IN THEN ELSE ENDIF COMMA DOT COLON SEMICOLON BAR UP DOT_DOT UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR RIGHT_BRK RIGHT_BRA MINUS_GT }]
  [oclExpression ::= oclExpression (*) TIMES oclExpression , {EOF ENDPACKAGE CONTEXT INIT DERIVE INV DEF PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE IN THEN ELSE ENDIF COMMA DOT COLON SEMICOLON BAR UP DOT_DOT UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR RIGHT_BRK RIGHT_BRA MINUS_GT }]
  [oclExpression ::= oclExpression (*) LT oclExpression , {EOF ENDPACKAGE CONTEXT INIT DERIVE INV DEF PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE IN THEN ELSE ENDIF COMMA DOT COLON SEMICOLON BAR UP DOT_DOT UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR RIGHT_BRK RIGHT_BRA MINUS_GT }]
  [oclExpression ::= oclExpression (*) NE oclExpression , {EOF ENDPACKAGE CONTEXT INIT DERIVE INV DEF PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE IN THEN ELSE ENDIF COMMA DOT COLON SEMICOLON BAR UP DOT_DOT UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR RIGHT_BRK RIGHT_BRA MINUS_GT }]
  [oclExpression ::= oclExpression (*) LEFT_PAR variableDeclaration BAR oclExpression RIGHT_PAR , {EOF ENDPACKAGE CONTEXT INIT DERIVE INV DEF PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE IN THEN ELSE ENDIF COMMA DOT COLON SEMICOLON BAR UP DOT_DOT UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR RIGHT_BRK RIGHT_BRA MINUS_GT }]
  [oclExpression ::= oclExpression XOR oclExpression (*) , {EOF ENDPACKAGE CONTEXT INIT DERIVE INV DEF PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE IN THEN ELSE ENDIF COMMA DOT COLON SEMICOLON BAR UP DOT_DOT UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR RIGHT_BRK RIGHT_BRA MINUS_GT }]
  [oclExpression ::= oclExpression (*) MINUS oclExpression , {EOF ENDPACKAGE CONTEXT INIT DERIVE INV DEF PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE IN THEN ELSE ENDIF COMMA DOT COLON SEMICOLON BAR UP DOT_DOT UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR RIGHT_BRK RIGHT_BRA MINUS_GT }]
  [oclExpression ::= oclExpression (*) GE oclExpression , {EOF ENDPACKAGE CONTEXT INIT DERIVE INV DEF PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE IN THEN ELSE ENDIF COMMA DOT COLON SEMICOLON BAR UP DOT_DOT UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR RIGHT_BRK RIGHT_BRA MINUS_GT }]
  [oclExpression ::= oclExpression (*) XOR oclExpression , {EOF ENDPACKAGE CONTEXT INIT DERIVE INV DEF PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE IN THEN ELSE ENDIF COMMA DOT COLON SEMICOLON BAR UP DOT_DOT UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR RIGHT_BRK RIGHT_BRA MINUS_GT }]
  [oclExpression ::= oclExpression (*) UP simpleName LEFT_PAR oclMessageArgumentList RIGHT_PAR , {EOF ENDPACKAGE CONTEXT INIT DERIVE INV DEF PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE IN THEN ELSE ENDIF COMMA DOT COLON SEMICOLON BAR UP DOT_DOT UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR RIGHT_BRK RIGHT_BRA MINUS_GT }]
  [oclExpression ::= oclExpression (*) DOT simpleName isMarkedPre , {EOF ENDPACKAGE CONTEXT INIT DERIVE INV DEF PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE IN THEN ELSE ENDIF COMMA DOT COLON SEMICOLON BAR UP DOT_DOT UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR RIGHT_BRK RIGHT_BRA MINUS_GT }]
  [oclExpression ::= oclExpression (*) MINUS_GT ITERATE LEFT_PAR variableDeclaration SEMICOLON variableDeclaration BAR oclExpression RIGHT_PAR , {EOF ENDPACKAGE CONTEXT INIT DERIVE INV DEF PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE IN THEN ELSE ENDIF COMMA DOT COLON SEMICOLON BAR UP DOT_DOT UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR RIGHT_BRK RIGHT_BRA MINUS_GT }]
  [oclExpression ::= oclExpression (*) DIVIDE oclExpression , {EOF ENDPACKAGE CONTEXT INIT DERIVE INV DEF PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE IN THEN ELSE ENDIF COMMA DOT COLON SEMICOLON BAR UP DOT_DOT UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR RIGHT_BRK RIGHT_BRA MINUS_GT }]
  [oclExpression ::= oclExpression (*) GT oclExpression , {EOF ENDPACKAGE CONTEXT INIT DERIVE INV DEF PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE IN THEN ELSE ENDIF COMMA DOT COLON SEMICOLON BAR UP DOT_DOT UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR RIGHT_BRK RIGHT_BRA MINUS_GT }]
  [oclExpression ::= oclExpression (*) AND oclExpression , {EOF ENDPACKAGE CONTEXT INIT DERIVE INV DEF PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE IN THEN ELSE ENDIF COMMA DOT COLON SEMICOLON BAR UP DOT_DOT UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR RIGHT_BRK RIGHT_BRA MINUS_GT }]
  [oclExpression ::= oclExpression (*) UP_UP simpleName LEFT_PAR oclMessageArgumentList RIGHT_PAR , {EOF ENDPACKAGE CONTEXT INIT DERIVE INV DEF PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE IN THEN ELSE ENDIF COMMA DOT COLON SEMICOLON BAR UP DOT_DOT UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR RIGHT_BRK RIGHT_BRA MINUS_GT }]
}
transition on XOR to state [74]
transition on EQ to state [73]
transition on DOT to state [72]
transition on MINUS to state [71]
transition on GE to state [70]
transition on LEFT_BRK to state [69]
transition on DIVIDE to state [68]
transition on LEFT_PAR to state [67]
transition on MINUS_GT to state [66]
transition on LE to state [65]
transition on GT to state [64]
transition on IMPLIES to state [63]
transition on UP to state [62]
transition on UP_UP to state [61]
transition on OR to state [60]
transition on PLUS to state [59]
transition on NE to state [58]
transition on LT to state [57]
transition on AND to state [56]
transition on TIMES to state [55]

-------------------
lalr_state [76]: {
  [oclExpression ::= oclExpression (*) LEFT_BRK argumentList RIGHT_BRK isMarkedPre , {EOF ENDPACKAGE CONTEXT INIT DERIVE INV DEF PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE IN THEN ELSE ENDIF COMMA DOT COLON SEMICOLON BAR UP DOT_DOT UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR RIGHT_BRK RIGHT_BRA MINUS_GT }]
  [oclExpression ::= oclExpression EQ oclExpression (*) , {EOF ENDPACKAGE CONTEXT INIT DERIVE INV DEF PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE IN THEN ELSE ENDIF COMMA DOT COLON SEMICOLON BAR UP DOT_DOT UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR RIGHT_BRK RIGHT_BRA MINUS_GT }]
  [oclExpression ::= oclExpression (*) EQ oclExpression , {EOF ENDPACKAGE CONTEXT INIT DERIVE INV DEF PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE IN THEN ELSE ENDIF COMMA DOT COLON SEMICOLON BAR UP DOT_DOT UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR RIGHT_BRK RIGHT_BRA MINUS_GT }]
  [oclExpression ::= oclExpression (*) IMPLIES oclExpression , {EOF ENDPACKAGE CONTEXT INIT DERIVE INV DEF PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE IN THEN ELSE ENDIF COMMA DOT COLON SEMICOLON BAR UP DOT_DOT UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR RIGHT_BRK RIGHT_BRA MINUS_GT }]
  [oclExpression ::= oclExpression (*) UP simpleName LEFT_PAR RIGHT_PAR , {EOF ENDPACKAGE CONTEXT INIT DERIVE INV DEF PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE IN THEN ELSE ENDIF COMMA DOT COLON SEMICOLON BAR UP DOT_DOT UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR RIGHT_BRK RIGHT_BRA MINUS_GT }]
  [oclExpression ::= oclExpression (*) LEFT_PAR arguments RIGHT_PAR , {EOF ENDPACKAGE CONTEXT INIT DERIVE INV DEF PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE IN THEN ELSE ENDIF COMMA DOT COLON SEMICOLON BAR UP DOT_DOT UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR RIGHT_BRK RIGHT_BRA MINUS_GT }]
  [oclExpression ::= oclExpression (*) MINUS_GT ITERATE LEFT_PAR variableDeclaration BAR oclExpression RIGHT_PAR , {EOF ENDPACKAGE CONTEXT INIT DERIVE INV DEF PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE IN THEN ELSE ENDIF COMMA DOT COLON SEMICOLON BAR UP DOT_DOT UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR RIGHT_BRK RIGHT_BRA MINUS_GT }]
  [oclExpression ::= oclExpression (*) PLUS oclExpression , {EOF ENDPACKAGE CONTEXT INIT DERIVE INV DEF PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE IN THEN ELSE ENDIF COMMA DOT COLON SEMICOLON BAR UP DOT_DOT UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR RIGHT_BRK RIGHT_BRA MINUS_GT }]
  [oclExpression ::= oclExpression (*) LE oclExpression , {EOF ENDPACKAGE CONTEXT INIT DERIVE INV DEF PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE IN THEN ELSE ENDIF COMMA DOT COLON SEMICOLON BAR UP DOT_DOT UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR RIGHT_BRK RIGHT_BRA MINUS_GT }]
  [oclExpression ::= oclExpression (*) OR oclExpression , {EOF ENDPACKAGE CONTEXT INIT DERIVE INV DEF PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE IN THEN ELSE ENDIF COMMA DOT COLON SEMICOLON BAR UP DOT_DOT UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR RIGHT_BRK RIGHT_BRA MINUS_GT }]
  [oclExpression ::= oclExpression (*) UP_UP simpleName LEFT_PAR RIGHT_PAR , {EOF ENDPACKAGE CONTEXT INIT DERIVE INV DEF PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE IN THEN ELSE ENDIF COMMA DOT COLON SEMICOLON BAR UP DOT_DOT UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR RIGHT_BRK RIGHT_BRA MINUS_GT }]
  [oclExpression ::= oclExpression (*) MINUS_GT simpleName , {EOF ENDPACKAGE CONTEXT INIT DERIVE INV DEF PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE IN THEN ELSE ENDIF COMMA DOT COLON SEMICOLON BAR UP DOT_DOT UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR RIGHT_BRK RIGHT_BRA MINUS_GT }]
  [oclExpression ::= oclExpression (*) TIMES oclExpression , {EOF ENDPACKAGE CONTEXT INIT DERIVE INV DEF PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE IN THEN ELSE ENDIF COMMA DOT COLON SEMICOLON BAR UP DOT_DOT UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR RIGHT_BRK RIGHT_BRA MINUS_GT }]
  [oclExpression ::= oclExpression (*) LT oclExpression , {EOF ENDPACKAGE CONTEXT INIT DERIVE INV DEF PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE IN THEN ELSE ENDIF COMMA DOT COLON SEMICOLON BAR UP DOT_DOT UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR RIGHT_BRK RIGHT_BRA MINUS_GT }]
  [oclExpression ::= oclExpression (*) NE oclExpression , {EOF ENDPACKAGE CONTEXT INIT DERIVE INV DEF PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE IN THEN ELSE ENDIF COMMA DOT COLON SEMICOLON BAR UP DOT_DOT UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR RIGHT_BRK RIGHT_BRA MINUS_GT }]
  [oclExpression ::= oclExpression (*) LEFT_PAR variableDeclaration BAR oclExpression RIGHT_PAR , {EOF ENDPACKAGE CONTEXT INIT DERIVE INV DEF PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE IN THEN ELSE ENDIF COMMA DOT COLON SEMICOLON BAR UP DOT_DOT UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR RIGHT_BRK RIGHT_BRA MINUS_GT }]
  [oclExpression ::= oclExpression (*) MINUS oclExpression , {EOF ENDPACKAGE CONTEXT INIT DERIVE INV DEF PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE IN THEN ELSE ENDIF COMMA DOT COLON SEMICOLON BAR UP DOT_DOT UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR RIGHT_BRK RIGHT_BRA MINUS_GT }]
  [oclExpression ::= oclExpression (*) GE oclExpression , {EOF ENDPACKAGE CONTEXT INIT DERIVE INV DEF PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE IN THEN ELSE ENDIF COMMA DOT COLON SEMICOLON BAR UP DOT_DOT UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR RIGHT_BRK RIGHT_BRA MINUS_GT }]
  [oclExpression ::= oclExpression (*) XOR oclExpression , {EOF ENDPACKAGE CONTEXT INIT DERIVE INV DEF PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE IN THEN ELSE ENDIF COMMA DOT COLON SEMICOLON BAR UP DOT_DOT UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR RIGHT_BRK RIGHT_BRA MINUS_GT }]
  [oclExpression ::= oclExpression (*) UP simpleName LEFT_PAR oclMessageArgumentList RIGHT_PAR , {EOF ENDPACKAGE CONTEXT INIT DERIVE INV DEF PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE IN THEN ELSE ENDIF COMMA DOT COLON SEMICOLON BAR UP DOT_DOT UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR RIGHT_BRK RIGHT_BRA MINUS_GT }]
  [oclExpression ::= oclExpression (*) DOT simpleName isMarkedPre , {EOF ENDPACKAGE CONTEXT INIT DERIVE INV DEF PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE IN THEN ELSE ENDIF COMMA DOT COLON SEMICOLON BAR UP DOT_DOT UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR RIGHT_BRK RIGHT_BRA MINUS_GT }]
  [oclExpression ::= oclExpression (*) MINUS_GT ITERATE LEFT_PAR variableDeclaration SEMICOLON variableDeclaration BAR oclExpression RIGHT_PAR , {EOF ENDPACKAGE CONTEXT INIT DERIVE INV DEF PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE IN THEN ELSE ENDIF COMMA DOT COLON SEMICOLON BAR UP DOT_DOT UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR RIGHT_BRK RIGHT_BRA MINUS_GT }]
  [oclExpression ::= oclExpression (*) DIVIDE oclExpression , {EOF ENDPACKAGE CONTEXT INIT DERIVE INV DEF PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE IN THEN ELSE ENDIF COMMA DOT COLON SEMICOLON BAR UP DOT_DOT UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR RIGHT_BRK RIGHT_BRA MINUS_GT }]
  [oclExpression ::= oclExpression (*) GT oclExpression , {EOF ENDPACKAGE CONTEXT INIT DERIVE INV DEF PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE IN THEN ELSE ENDIF COMMA DOT COLON SEMICOLON BAR UP DOT_DOT UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR RIGHT_BRK RIGHT_BRA MINUS_GT }]
  [oclExpression ::= oclExpression (*) AND oclExpression , {EOF ENDPACKAGE CONTEXT INIT DERIVE INV DEF PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE IN THEN ELSE ENDIF COMMA DOT COLON SEMICOLON BAR UP DOT_DOT UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR RIGHT_BRK RIGHT_BRA MINUS_GT }]
  [oclExpression ::= oclExpression (*) UP_UP simpleName LEFT_PAR oclMessageArgumentList RIGHT_PAR , {EOF ENDPACKAGE CONTEXT INIT DERIVE INV DEF PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE IN THEN ELSE ENDIF COMMA DOT COLON SEMICOLON BAR UP DOT_DOT UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR RIGHT_BRK RIGHT_BRA MINUS_GT }]
}
transition on XOR to state [74]
transition on EQ to state [73]
transition on DOT to state [72]
transition on MINUS to state [71]
transition on GE to state [70]
transition on LEFT_BRK to state [69]
transition on DIVIDE to state [68]
transition on LEFT_PAR to state [67]
transition on MINUS_GT to state [66]
transition on LE to state [65]
transition on GT to state [64]
transition on IMPLIES to state [63]
transition on UP to state [62]
transition on UP_UP to state [61]
transition on OR to state [60]
transition on PLUS to state [59]
transition on NE to state [58]
transition on LT to state [57]
transition on AND to state [56]
transition on TIMES to state [55]

-------------------
lalr_state [77]: {
  [oclExpression ::= oclExpression DOT simpleName (*) isMarkedPre , {EOF ENDPACKAGE CONTEXT INIT DERIVE INV DEF PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE IN THEN ELSE ENDIF COMMA DOT COLON SEMICOLON BAR UP DOT_DOT UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR RIGHT_BRK RIGHT_BRA MINUS_GT }]
  [isMarkedPre ::= (*) AT PRE , {EOF ENDPACKAGE CONTEXT INIT DERIVE INV DEF PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE IN THEN ELSE ENDIF COMMA DOT COLON SEMICOLON BAR UP DOT_DOT UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR RIGHT_BRK RIGHT_BRA MINUS_GT }]
  [isMarkedPre ::= (*) , {EOF ENDPACKAGE CONTEXT INIT DERIVE INV DEF PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE IN THEN ELSE ENDIF COMMA DOT COLON SEMICOLON BAR UP DOT_DOT UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR RIGHT_BRK RIGHT_BRA MINUS_GT }]
}
transition on isMarkedPre to state [79]
transition on AT to state [78]

-------------------
lalr_state [78]: {
  [isMarkedPre ::= AT (*) PRE , {EOF ENDPACKAGE CONTEXT INIT DERIVE INV DEF PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE IN THEN ELSE ENDIF COMMA DOT COLON SEMICOLON BAR UP DOT_DOT UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR RIGHT_BRK RIGHT_BRA MINUS_GT }]
}
transition on PRE to state [80]

-------------------
lalr_state [79]: {
  [oclExpression ::= oclExpression DOT simpleName isMarkedPre (*) , {EOF ENDPACKAGE CONTEXT INIT DERIVE INV DEF PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE IN THEN ELSE ENDIF COMMA DOT COLON SEMICOLON BAR UP DOT_DOT UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR RIGHT_BRK RIGHT_BRA MINUS_GT }]
}

-------------------
lalr_state [80]: {
  [isMarkedPre ::= AT PRE (*) , {EOF ENDPACKAGE CONTEXT INIT DERIVE INV DEF PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE IN THEN ELSE ENDIF COMMA DOT COLON SEMICOLON BAR UP DOT_DOT UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR RIGHT_BRK RIGHT_BRA MINUS_GT }]
}

-------------------
lalr_state [81]: {
  [oclExpression ::= oclExpression (*) LEFT_BRK argumentList RIGHT_BRK isMarkedPre , {EOF ENDPACKAGE CONTEXT INIT DERIVE INV DEF PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE IN THEN ELSE ENDIF COMMA DOT COLON SEMICOLON BAR UP DOT_DOT UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR RIGHT_BRK RIGHT_BRA MINUS_GT }]
  [oclExpression ::= oclExpression (*) EQ oclExpression , {EOF ENDPACKAGE CONTEXT INIT DERIVE INV DEF PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE IN THEN ELSE ENDIF COMMA DOT COLON SEMICOLON BAR UP DOT_DOT UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR RIGHT_BRK RIGHT_BRA MINUS_GT }]
  [oclExpression ::= oclExpression (*) IMPLIES oclExpression , {EOF ENDPACKAGE CONTEXT INIT DERIVE INV DEF PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE IN THEN ELSE ENDIF COMMA DOT COLON SEMICOLON BAR UP DOT_DOT UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR RIGHT_BRK RIGHT_BRA MINUS_GT }]
  [oclExpression ::= oclExpression (*) UP simpleName LEFT_PAR RIGHT_PAR , {EOF ENDPACKAGE CONTEXT INIT DERIVE INV DEF PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE IN THEN ELSE ENDIF COMMA DOT COLON SEMICOLON BAR UP DOT_DOT UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR RIGHT_BRK RIGHT_BRA MINUS_GT }]
  [oclExpression ::= oclExpression (*) LEFT_PAR arguments RIGHT_PAR , {EOF ENDPACKAGE CONTEXT INIT DERIVE INV DEF PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE IN THEN ELSE ENDIF COMMA DOT COLON SEMICOLON BAR UP DOT_DOT UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR RIGHT_BRK RIGHT_BRA MINUS_GT }]
  [oclExpression ::= oclExpression (*) MINUS_GT ITERATE LEFT_PAR variableDeclaration BAR oclExpression RIGHT_PAR , {EOF ENDPACKAGE CONTEXT INIT DERIVE INV DEF PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE IN THEN ELSE ENDIF COMMA DOT COLON SEMICOLON BAR UP DOT_DOT UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR RIGHT_BRK RIGHT_BRA MINUS_GT }]
  [oclExpression ::= oclExpression (*) PLUS oclExpression , {EOF ENDPACKAGE CONTEXT INIT DERIVE INV DEF PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE IN THEN ELSE ENDIF COMMA DOT COLON SEMICOLON BAR UP DOT_DOT UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR RIGHT_BRK RIGHT_BRA MINUS_GT }]
  [oclExpression ::= oclExpression (*) LE oclExpression , {EOF ENDPACKAGE CONTEXT INIT DERIVE INV DEF PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE IN THEN ELSE ENDIF COMMA DOT COLON SEMICOLON BAR UP DOT_DOT UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR RIGHT_BRK RIGHT_BRA MINUS_GT }]
  [oclExpression ::= oclExpression (*) OR oclExpression , {EOF ENDPACKAGE CONTEXT INIT DERIVE INV DEF PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE IN THEN ELSE ENDIF COMMA DOT COLON SEMICOLON BAR UP DOT_DOT UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR RIGHT_BRK RIGHT_BRA MINUS_GT }]
  [oclExpression ::= oclExpression (*) UP_UP simpleName LEFT_PAR RIGHT_PAR , {EOF ENDPACKAGE CONTEXT INIT DERIVE INV DEF PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE IN THEN ELSE ENDIF COMMA DOT COLON SEMICOLON BAR UP DOT_DOT UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR RIGHT_BRK RIGHT_BRA MINUS_GT }]
  [oclExpression ::= oclExpression (*) MINUS_GT simpleName , {EOF ENDPACKAGE CONTEXT INIT DERIVE INV DEF PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE IN THEN ELSE ENDIF COMMA DOT COLON SEMICOLON BAR UP DOT_DOT UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR RIGHT_BRK RIGHT_BRA MINUS_GT }]
  [oclExpression ::= oclExpression (*) TIMES oclExpression , {EOF ENDPACKAGE CONTEXT INIT DERIVE INV DEF PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE IN THEN ELSE ENDIF COMMA DOT COLON SEMICOLON BAR UP DOT_DOT UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR RIGHT_BRK RIGHT_BRA MINUS_GT }]
  [oclExpression ::= oclExpression (*) LT oclExpression , {EOF ENDPACKAGE CONTEXT INIT DERIVE INV DEF PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE IN THEN ELSE ENDIF COMMA DOT COLON SEMICOLON BAR UP DOT_DOT UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR RIGHT_BRK RIGHT_BRA MINUS_GT }]
  [oclExpression ::= oclExpression (*) NE oclExpression , {EOF ENDPACKAGE CONTEXT INIT DERIVE INV DEF PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE IN THEN ELSE ENDIF COMMA DOT COLON SEMICOLON BAR UP DOT_DOT UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR RIGHT_BRK RIGHT_BRA MINUS_GT }]
  [oclExpression ::= oclExpression MINUS oclExpression (*) , {EOF ENDPACKAGE CONTEXT INIT DERIVE INV DEF PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE IN THEN ELSE ENDIF COMMA DOT COLON SEMICOLON BAR UP DOT_DOT UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR RIGHT_BRK RIGHT_BRA MINUS_GT }]
  [oclExpression ::= oclExpression (*) LEFT_PAR variableDeclaration BAR oclExpression RIGHT_PAR , {EOF ENDPACKAGE CONTEXT INIT DERIVE INV DEF PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE IN THEN ELSE ENDIF COMMA DOT COLON SEMICOLON BAR UP DOT_DOT UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR RIGHT_BRK RIGHT_BRA MINUS_GT }]
  [oclExpression ::= oclExpression (*) MINUS oclExpression , {EOF ENDPACKAGE CONTEXT INIT DERIVE INV DEF PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE IN THEN ELSE ENDIF COMMA DOT COLON SEMICOLON BAR UP DOT_DOT UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR RIGHT_BRK RIGHT_BRA MINUS_GT }]
  [oclExpression ::= oclExpression (*) GE oclExpression , {EOF ENDPACKAGE CONTEXT INIT DERIVE INV DEF PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE IN THEN ELSE ENDIF COMMA DOT COLON SEMICOLON BAR UP DOT_DOT UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR RIGHT_BRK RIGHT_BRA MINUS_GT }]
  [oclExpression ::= oclExpression (*) XOR oclExpression , {EOF ENDPACKAGE CONTEXT INIT DERIVE INV DEF PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE IN THEN ELSE ENDIF COMMA DOT COLON SEMICOLON BAR UP DOT_DOT UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR RIGHT_BRK RIGHT_BRA MINUS_GT }]
  [oclExpression ::= oclExpression (*) UP simpleName LEFT_PAR oclMessageArgumentList RIGHT_PAR , {EOF ENDPACKAGE CONTEXT INIT DERIVE INV DEF PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE IN THEN ELSE ENDIF COMMA DOT COLON SEMICOLON BAR UP DOT_DOT UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR RIGHT_BRK RIGHT_BRA MINUS_GT }]
  [oclExpression ::= oclExpression (*) DOT simpleName isMarkedPre , {EOF ENDPACKAGE CONTEXT INIT DERIVE INV DEF PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE IN THEN ELSE ENDIF COMMA DOT COLON SEMICOLON BAR UP DOT_DOT UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR RIGHT_BRK RIGHT_BRA MINUS_GT }]
  [oclExpression ::= oclExpression (*) MINUS_GT ITERATE LEFT_PAR variableDeclaration SEMICOLON variableDeclaration BAR oclExpression RIGHT_PAR , {EOF ENDPACKAGE CONTEXT INIT DERIVE INV DEF PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE IN THEN ELSE ENDIF COMMA DOT COLON SEMICOLON BAR UP DOT_DOT UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR RIGHT_BRK RIGHT_BRA MINUS_GT }]
  [oclExpression ::= oclExpression (*) DIVIDE oclExpression , {EOF ENDPACKAGE CONTEXT INIT DERIVE INV DEF PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE IN THEN ELSE ENDIF COMMA DOT COLON SEMICOLON BAR UP DOT_DOT UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR RIGHT_BRK RIGHT_BRA MINUS_GT }]
  [oclExpression ::= oclExpression (*) GT oclExpression , {EOF ENDPACKAGE CONTEXT INIT DERIVE INV DEF PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE IN THEN ELSE ENDIF COMMA DOT COLON SEMICOLON BAR UP DOT_DOT UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR RIGHT_BRK RIGHT_BRA MINUS_GT }]
  [oclExpression ::= oclExpression (*) AND oclExpression , {EOF ENDPACKAGE CONTEXT INIT DERIVE INV DEF PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE IN THEN ELSE ENDIF COMMA DOT COLON SEMICOLON BAR UP DOT_DOT UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR RIGHT_BRK RIGHT_BRA MINUS_GT }]
  [oclExpression ::= oclExpression (*) UP_UP simpleName LEFT_PAR oclMessageArgumentList RIGHT_PAR , {EOF ENDPACKAGE CONTEXT INIT DERIVE INV DEF PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE IN THEN ELSE ENDIF COMMA DOT COLON SEMICOLON BAR UP DOT_DOT UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR RIGHT_BRK RIGHT_BRA MINUS_GT }]
}
transition on XOR to state [74]
transition on EQ to state [73]
transition on DOT to state [72]
transition on MINUS to state [71]
transition on GE to state [70]
transition on LEFT_BRK to state [69]
transition on DIVIDE to state [68]
transition on LEFT_PAR to state [67]
transition on MINUS_GT to state [66]
transition on LE to state [65]
transition on GT to state [64]
transition on IMPLIES to state [63]
transition on UP to state [62]
transition on UP_UP to state [61]
transition on OR to state [60]
transition on PLUS to state [59]
transition on NE to state [58]
transition on LT to state [57]
transition on AND to state [56]
transition on TIMES to state [55]

-------------------
lalr_state [82]: {
  [oclExpression ::= oclExpression (*) LEFT_BRK argumentList RIGHT_BRK isMarkedPre , {EOF ENDPACKAGE CONTEXT INIT DERIVE INV DEF PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE IN THEN ELSE ENDIF COMMA DOT COLON SEMICOLON BAR UP DOT_DOT UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR RIGHT_BRK RIGHT_BRA MINUS_GT }]
  [oclExpression ::= oclExpression (*) EQ oclExpression , {EOF ENDPACKAGE CONTEXT INIT DERIVE INV DEF PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE IN THEN ELSE ENDIF COMMA DOT COLON SEMICOLON BAR UP DOT_DOT UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR RIGHT_BRK RIGHT_BRA MINUS_GT }]
  [oclExpression ::= oclExpression (*) IMPLIES oclExpression , {EOF ENDPACKAGE CONTEXT INIT DERIVE INV DEF PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE IN THEN ELSE ENDIF COMMA DOT COLON SEMICOLON BAR UP DOT_DOT UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR RIGHT_BRK RIGHT_BRA MINUS_GT }]
  [oclExpression ::= oclExpression (*) UP simpleName LEFT_PAR RIGHT_PAR , {EOF ENDPACKAGE CONTEXT INIT DERIVE INV DEF PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE IN THEN ELSE ENDIF COMMA DOT COLON SEMICOLON BAR UP DOT_DOT UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR RIGHT_BRK RIGHT_BRA MINUS_GT }]
  [oclExpression ::= oclExpression (*) LEFT_PAR arguments RIGHT_PAR , {EOF ENDPACKAGE CONTEXT INIT DERIVE INV DEF PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE IN THEN ELSE ENDIF COMMA DOT COLON SEMICOLON BAR UP DOT_DOT UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR RIGHT_BRK RIGHT_BRA MINUS_GT }]
  [oclExpression ::= oclExpression (*) MINUS_GT ITERATE LEFT_PAR variableDeclaration BAR oclExpression RIGHT_PAR , {EOF ENDPACKAGE CONTEXT INIT DERIVE INV DEF PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE IN THEN ELSE ENDIF COMMA DOT COLON SEMICOLON BAR UP DOT_DOT UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR RIGHT_BRK RIGHT_BRA MINUS_GT }]
  [oclExpression ::= oclExpression (*) PLUS oclExpression , {EOF ENDPACKAGE CONTEXT INIT DERIVE INV DEF PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE IN THEN ELSE ENDIF COMMA DOT COLON SEMICOLON BAR UP DOT_DOT UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR RIGHT_BRK RIGHT_BRA MINUS_GT }]
  [oclExpression ::= oclExpression (*) LE oclExpression , {EOF ENDPACKAGE CONTEXT INIT DERIVE INV DEF PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE IN THEN ELSE ENDIF COMMA DOT COLON SEMICOLON BAR UP DOT_DOT UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR RIGHT_BRK RIGHT_BRA MINUS_GT }]
  [oclExpression ::= oclExpression (*) OR oclExpression , {EOF ENDPACKAGE CONTEXT INIT DERIVE INV DEF PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE IN THEN ELSE ENDIF COMMA DOT COLON SEMICOLON BAR UP DOT_DOT UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR RIGHT_BRK RIGHT_BRA MINUS_GT }]
  [oclExpression ::= oclExpression (*) UP_UP simpleName LEFT_PAR RIGHT_PAR , {EOF ENDPACKAGE CONTEXT INIT DERIVE INV DEF PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE IN THEN ELSE ENDIF COMMA DOT COLON SEMICOLON BAR UP DOT_DOT UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR RIGHT_BRK RIGHT_BRA MINUS_GT }]
  [oclExpression ::= oclExpression (*) MINUS_GT simpleName , {EOF ENDPACKAGE CONTEXT INIT DERIVE INV DEF PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE IN THEN ELSE ENDIF COMMA DOT COLON SEMICOLON BAR UP DOT_DOT UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR RIGHT_BRK RIGHT_BRA MINUS_GT }]
  [oclExpression ::= oclExpression (*) TIMES oclExpression , {EOF ENDPACKAGE CONTEXT INIT DERIVE INV DEF PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE IN THEN ELSE ENDIF COMMA DOT COLON SEMICOLON BAR UP DOT_DOT UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR RIGHT_BRK RIGHT_BRA MINUS_GT }]
  [oclExpression ::= oclExpression (*) LT oclExpression , {EOF ENDPACKAGE CONTEXT INIT DERIVE INV DEF PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE IN THEN ELSE ENDIF COMMA DOT COLON SEMICOLON BAR UP DOT_DOT UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR RIGHT_BRK RIGHT_BRA MINUS_GT }]
  [oclExpression ::= oclExpression (*) NE oclExpression , {EOF ENDPACKAGE CONTEXT INIT DERIVE INV DEF PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE IN THEN ELSE ENDIF COMMA DOT COLON SEMICOLON BAR UP DOT_DOT UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR RIGHT_BRK RIGHT_BRA MINUS_GT }]
  [oclExpression ::= oclExpression (*) LEFT_PAR variableDeclaration BAR oclExpression RIGHT_PAR , {EOF ENDPACKAGE CONTEXT INIT DERIVE INV DEF PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE IN THEN ELSE ENDIF COMMA DOT COLON SEMICOLON BAR UP DOT_DOT UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR RIGHT_BRK RIGHT_BRA MINUS_GT }]
  [oclExpression ::= oclExpression GE oclExpression (*) , {EOF ENDPACKAGE CONTEXT INIT DERIVE INV DEF PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE IN THEN ELSE ENDIF COMMA DOT COLON SEMICOLON BAR UP DOT_DOT UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR RIGHT_BRK RIGHT_BRA MINUS_GT }]
  [oclExpression ::= oclExpression (*) MINUS oclExpression , {EOF ENDPACKAGE CONTEXT INIT DERIVE INV DEF PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE IN THEN ELSE ENDIF COMMA DOT COLON SEMICOLON BAR UP DOT_DOT UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR RIGHT_BRK RIGHT_BRA MINUS_GT }]
  [oclExpression ::= oclExpression (*) GE oclExpression , {EOF ENDPACKAGE CONTEXT INIT DERIVE INV DEF PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE IN THEN ELSE ENDIF COMMA DOT COLON SEMICOLON BAR UP DOT_DOT UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR RIGHT_BRK RIGHT_BRA MINUS_GT }]
  [oclExpression ::= oclExpression (*) XOR oclExpression , {EOF ENDPACKAGE CONTEXT INIT DERIVE INV DEF PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE IN THEN ELSE ENDIF COMMA DOT COLON SEMICOLON BAR UP DOT_DOT UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR RIGHT_BRK RIGHT_BRA MINUS_GT }]
  [oclExpression ::= oclExpression (*) UP simpleName LEFT_PAR oclMessageArgumentList RIGHT_PAR , {EOF ENDPACKAGE CONTEXT INIT DERIVE INV DEF PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE IN THEN ELSE ENDIF COMMA DOT COLON SEMICOLON BAR UP DOT_DOT UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR RIGHT_BRK RIGHT_BRA MINUS_GT }]
  [oclExpression ::= oclExpression (*) DOT simpleName isMarkedPre , {EOF ENDPACKAGE CONTEXT INIT DERIVE INV DEF PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE IN THEN ELSE ENDIF COMMA DOT COLON SEMICOLON BAR UP DOT_DOT UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR RIGHT_BRK RIGHT_BRA MINUS_GT }]
  [oclExpression ::= oclExpression (*) MINUS_GT ITERATE LEFT_PAR variableDeclaration SEMICOLON variableDeclaration BAR oclExpression RIGHT_PAR , {EOF ENDPACKAGE CONTEXT INIT DERIVE INV DEF PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE IN THEN ELSE ENDIF COMMA DOT COLON SEMICOLON BAR UP DOT_DOT UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR RIGHT_BRK RIGHT_BRA MINUS_GT }]
  [oclExpression ::= oclExpression (*) DIVIDE oclExpression , {EOF ENDPACKAGE CONTEXT INIT DERIVE INV DEF PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE IN THEN ELSE ENDIF COMMA DOT COLON SEMICOLON BAR UP DOT_DOT UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR RIGHT_BRK RIGHT_BRA MINUS_GT }]
  [oclExpression ::= oclExpression (*) GT oclExpression , {EOF ENDPACKAGE CONTEXT INIT DERIVE INV DEF PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE IN THEN ELSE ENDIF COMMA DOT COLON SEMICOLON BAR UP DOT_DOT UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR RIGHT_BRK RIGHT_BRA MINUS_GT }]
  [oclExpression ::= oclExpression (*) AND oclExpression , {EOF ENDPACKAGE CONTEXT INIT DERIVE INV DEF PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE IN THEN ELSE ENDIF COMMA DOT COLON SEMICOLON BAR UP DOT_DOT UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR RIGHT_BRK RIGHT_BRA MINUS_GT }]
  [oclExpression ::= oclExpression (*) UP_UP simpleName LEFT_PAR oclMessageArgumentList RIGHT_PAR , {EOF ENDPACKAGE CONTEXT INIT DERIVE INV DEF PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE IN THEN ELSE ENDIF COMMA DOT COLON SEMICOLON BAR UP DOT_DOT UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR RIGHT_BRK RIGHT_BRA MINUS_GT }]
}
transition on XOR to state [74]
transition on EQ to state [73]
transition on DOT to state [72]
transition on MINUS to state [71]
transition on GE to state [70]
transition on LEFT_BRK to state [69]
transition on DIVIDE to state [68]
transition on LEFT_PAR to state [67]
transition on MINUS_GT to state [66]
transition on LE to state [65]
transition on GT to state [64]
transition on IMPLIES to state [63]
transition on UP to state [62]
transition on UP_UP to state [61]
transition on OR to state [60]
transition on PLUS to state [59]
transition on NE to state [58]
transition on LT to state [57]
transition on AND to state [56]
transition on TIMES to state [55]

-------------------
lalr_state [83]: {
  [oclExpression ::= oclExpression (*) LEFT_BRK argumentList RIGHT_BRK isMarkedPre , {IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE COMMA DOT UP UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR RIGHT_BRK MINUS_GT }]
  [oclExpression ::= oclExpression (*) EQ oclExpression , {IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE COMMA DOT UP UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR RIGHT_BRK MINUS_GT }]
  [oclExpression ::= oclExpression (*) IMPLIES oclExpression , {IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE COMMA DOT UP UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR RIGHT_BRK MINUS_GT }]
  [oclExpression ::= oclExpression (*) UP simpleName LEFT_PAR RIGHT_PAR , {IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE COMMA DOT UP UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR RIGHT_BRK MINUS_GT }]
  [oclExpression ::= oclExpression (*) LEFT_PAR arguments RIGHT_PAR , {IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE COMMA DOT UP UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR RIGHT_BRK MINUS_GT }]
  [oclExpression ::= oclExpression (*) MINUS_GT ITERATE LEFT_PAR variableDeclaration BAR oclExpression RIGHT_PAR , {IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE COMMA DOT UP UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR RIGHT_BRK MINUS_GT }]
  [oclExpression ::= oclExpression (*) PLUS oclExpression , {IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE COMMA DOT UP UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR RIGHT_BRK MINUS_GT }]
  [oclExpression ::= oclExpression (*) LE oclExpression , {IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE COMMA DOT UP UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR RIGHT_BRK MINUS_GT }]
  [oclExpression ::= oclExpression (*) OR oclExpression , {IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE COMMA DOT UP UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR RIGHT_BRK MINUS_GT }]
  [oclExpression ::= oclExpression (*) UP_UP simpleName LEFT_PAR RIGHT_PAR , {IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE COMMA DOT UP UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR RIGHT_BRK MINUS_GT }]
  [argumentList ::= oclExpression (*) , {COMMA RIGHT_PAR RIGHT_BRK }]
  [oclExpression ::= oclExpression (*) MINUS_GT simpleName , {IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE COMMA DOT UP UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR RIGHT_BRK MINUS_GT }]
  [oclExpression ::= oclExpression (*) TIMES oclExpression , {IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE COMMA DOT UP UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR RIGHT_BRK MINUS_GT }]
  [oclExpression ::= oclExpression (*) LT oclExpression , {IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE COMMA DOT UP UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR RIGHT_BRK MINUS_GT }]
  [oclExpression ::= oclExpression (*) NE oclExpression , {IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE COMMA DOT UP UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR RIGHT_BRK MINUS_GT }]
  [oclExpression ::= oclExpression (*) LEFT_PAR variableDeclaration BAR oclExpression RIGHT_PAR , {IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE COMMA DOT UP UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR RIGHT_BRK MINUS_GT }]
  [oclExpression ::= oclExpression (*) MINUS oclExpression , {IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE COMMA DOT UP UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR RIGHT_BRK MINUS_GT }]
  [oclExpression ::= oclExpression (*) GE oclExpression , {IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE COMMA DOT UP UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR RIGHT_BRK MINUS_GT }]
  [oclExpression ::= oclExpression (*) XOR oclExpression , {IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE COMMA DOT UP UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR RIGHT_BRK MINUS_GT }]
  [oclExpression ::= oclExpression (*) UP simpleName LEFT_PAR oclMessageArgumentList RIGHT_PAR , {IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE COMMA DOT UP UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR RIGHT_BRK MINUS_GT }]
  [oclExpression ::= oclExpression (*) DOT simpleName isMarkedPre , {IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE COMMA DOT UP UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR RIGHT_BRK MINUS_GT }]
  [oclExpression ::= oclExpression (*) MINUS_GT ITERATE LEFT_PAR variableDeclaration SEMICOLON variableDeclaration BAR oclExpression RIGHT_PAR , {IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE COMMA DOT UP UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR RIGHT_BRK MINUS_GT }]
  [oclExpression ::= oclExpression (*) DIVIDE oclExpression , {IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE COMMA DOT UP UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR RIGHT_BRK MINUS_GT }]
  [oclExpression ::= oclExpression (*) GT oclExpression , {IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE COMMA DOT UP UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR RIGHT_BRK MINUS_GT }]
  [oclExpression ::= oclExpression (*) AND oclExpression , {IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE COMMA DOT UP UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR RIGHT_BRK MINUS_GT }]
  [oclExpression ::= oclExpression (*) UP_UP simpleName LEFT_PAR oclMessageArgumentList RIGHT_PAR , {IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE COMMA DOT UP UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR RIGHT_BRK MINUS_GT }]
}
transition on XOR to state [74]
transition on EQ to state [73]
transition on DOT to state [72]
transition on MINUS to state [71]
transition on GE to state [70]
transition on LEFT_BRK to state [69]
transition on DIVIDE to state [68]
transition on LEFT_PAR to state [67]
transition on MINUS_GT to state [66]
transition on LE to state [65]
transition on GT to state [64]
transition on IMPLIES to state [63]
transition on UP to state [62]
transition on UP_UP to state [61]
transition on OR to state [60]
transition on PLUS to state [59]
transition on NE to state [58]
transition on LT to state [57]
transition on AND to state [56]
transition on TIMES to state [55]

-------------------
lalr_state [84]: {
  [oclExpression ::= oclExpression LEFT_BRK argumentList (*) RIGHT_BRK isMarkedPre , {EOF ENDPACKAGE CONTEXT INIT DERIVE INV DEF PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE IN THEN ELSE ENDIF COMMA DOT COLON SEMICOLON BAR UP DOT_DOT UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR RIGHT_BRK RIGHT_BRA MINUS_GT }]
  [argumentList ::= argumentList (*) COMMA oclExpression , {COMMA RIGHT_BRK }]
}
transition on RIGHT_BRK to state [86]
transition on COMMA to state [85]

-------------------
lalr_state [85]: {
  [oclExpression ::= (*) oclExpression UP simpleName LEFT_PAR oclMessageArgumentList RIGHT_PAR , {IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE COMMA DOT UP UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR RIGHT_BRK MINUS_GT }]
  [oclExpression ::= (*) oclExpression EQ oclExpression , {IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE COMMA DOT UP UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR RIGHT_BRK MINUS_GT }]
  [oclExpression ::= (*) oclExpression TIMES oclExpression , {IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE COMMA DOT UP UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR RIGHT_BRK MINUS_GT }]
  [oclExpression ::= (*) oclExpression DOT simpleName isMarkedPre , {IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE COMMA DOT UP UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR RIGHT_BRK MINUS_GT }]
  [primitiveLiteralExp ::= (*) TRUE , {IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE COMMA DOT UP UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR RIGHT_BRK MINUS_GT }]
  [argumentList ::= argumentList COMMA (*) oclExpression , {COMMA RIGHT_PAR RIGHT_BRK }]
  [literalExp ::= (*) tupleLiteralExp , {IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE COMMA DOT UP UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR RIGHT_BRK MINUS_GT }]
  [oclExpression ::= (*) oclExpression IMPLIES oclExpression , {IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE COMMA DOT UP UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR RIGHT_BRK MINUS_GT }]
  [oclExpression ::= (*) oclExpression LT oclExpression , {IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE COMMA DOT UP UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR RIGHT_BRK MINUS_GT }]
  [oclExpression ::= (*) oclExpression MINUS_GT ITERATE LEFT_PAR variableDeclaration SEMICOLON variableDeclaration BAR oclExpression RIGHT_PAR , {IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE COMMA DOT UP UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR RIGHT_BRK MINUS_GT }]
  [tupleLiteralExp ::= (*) TUPLE LEFT_BRA variableDeclarationList RIGHT_BRA , {IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE COMMA DOT UP UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR RIGHT_BRK MINUS_GT }]
  [collectionKind ::= (*) SET , {LEFT_BRA }]
  [oclExpression ::= (*) oclExpression UP simpleName LEFT_PAR RIGHT_PAR , {IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE COMMA DOT UP UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR RIGHT_BRK MINUS_GT }]
  [oclExpression ::= (*) oclExpression NE oclExpression , {IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE COMMA DOT UP UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR RIGHT_BRK MINUS_GT }]
  [oclExpression ::= (*) oclExpression DIVIDE oclExpression , {IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE COMMA DOT UP UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR RIGHT_BRK MINUS_GT }]
  [oclExpression ::= (*) oclExpression LEFT_PAR arguments RIGHT_PAR , {IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE COMMA DOT UP UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR RIGHT_BRK MINUS_GT }]
  [primitiveLiteralExp ::= (*) FALSE , {IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE COMMA DOT UP UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR RIGHT_BRK MINUS_GT }]
  [literalExp ::= (*) primitiveLiteralExp , {IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE COMMA DOT UP UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR RIGHT_BRK MINUS_GT }]
  [oclExpression ::= (*) LET variableDeclarationList IN oclExpression , {IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE COMMA DOT UP UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR RIGHT_BRK MINUS_GT }]
  [oclExpression ::= (*) oclExpression GT oclExpression , {IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE COMMA DOT UP UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR RIGHT_BRK MINUS_GT }]
  [oclExpression ::= (*) oclExpression MINUS_GT ITERATE LEFT_PAR variableDeclaration BAR oclExpression RIGHT_PAR , {IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE COMMA DOT UP UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR RIGHT_BRK MINUS_GT }]
  [oclExpression ::= (*) literalExp , {IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE COMMA DOT UP UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR RIGHT_BRK MINUS_GT }]
  [primitiveLiteralExp ::= (*) INTEGER , {IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE COMMA DOT UP UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR RIGHT_BRK MINUS_GT }]
  [collectionKind ::= (*) BAG , {LEFT_BRA }]
  [oclExpression ::= (*) oclExpression AND oclExpression , {IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE COMMA DOT UP UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR RIGHT_BRK MINUS_GT }]
  [oclExpression ::= (*) oclExpression PLUS oclExpression , {IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE COMMA DOT UP UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR RIGHT_BRK MINUS_GT }]
  [oclExpression ::= (*) oclExpression LEFT_PAR variableDeclaration BAR oclExpression RIGHT_PAR , {IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE COMMA DOT UP UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR RIGHT_BRK MINUS_GT }]
  [pathName ::= (*) simpleName , {IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE COMMA DOT UP AT COLON_COLON UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR RIGHT_BRK MINUS_GT }]
  [oclExpression ::= (*) oclExpression UP_UP simpleName LEFT_PAR oclMessageArgumentList RIGHT_PAR , {IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE COMMA DOT UP UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR RIGHT_BRK MINUS_GT }]
  [oclExpression ::= (*) oclExpression LE oclExpression , {IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE COMMA DOT UP UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR RIGHT_BRK MINUS_GT }]
  [oclExpression ::= (*) NOT oclExpression , {IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE COMMA DOT UP UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR RIGHT_BRK MINUS_GT }]
  [oclExpression ::= (*) LEFT_PAR oclExpression RIGHT_PAR , {IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE COMMA DOT UP UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR RIGHT_BRK MINUS_GT }]
  [primitiveLiteralExp ::= (*) REAL , {IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE COMMA DOT UP UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR RIGHT_BRK MINUS_GT }]
  [collectionKind ::= (*) SEQUENCE , {LEFT_BRA }]
  [oclExpression ::= (*) oclExpression OR oclExpression , {IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE COMMA DOT UP UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR RIGHT_BRK MINUS_GT }]
  [oclExpression ::= (*) oclExpression MINUS oclExpression , {IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE COMMA DOT UP UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR RIGHT_BRK MINUS_GT }]
  [oclExpression ::= (*) oclExpression LEFT_BRK argumentList RIGHT_BRK isMarkedPre , {IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE COMMA DOT UP UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR RIGHT_BRK MINUS_GT }]
  [pathName ::= (*) pathName COLON_COLON simpleName , {IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE COMMA DOT UP AT COLON_COLON UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR RIGHT_BRK MINUS_GT }]
  [collectionLiteralExp ::= (*) collectionKind LEFT_BRA collectionLiteralParts RIGHT_BRA , {IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE COMMA DOT UP UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR RIGHT_BRK MINUS_GT }]
  [oclExpression ::= (*) oclExpression UP_UP simpleName LEFT_PAR RIGHT_PAR , {IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE COMMA DOT UP UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR RIGHT_BRK MINUS_GT }]
  [oclExpression ::= (*) oclExpression GE oclExpression , {IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE COMMA DOT UP UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR RIGHT_BRK MINUS_GT }]
  [oclExpression ::= (*) MINUS oclExpression , {IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE COMMA DOT UP UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR RIGHT_BRK MINUS_GT }]
  [oclExpression ::= (*) pathName isMarkedPre , {IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE COMMA DOT UP UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR RIGHT_BRK MINUS_GT }]
  [primitiveLiteralExp ::= (*) STRING , {IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE COMMA DOT UP UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR RIGHT_BRK MINUS_GT }]
  [collectionKind ::= (*) COLLECTION , {LEFT_BRA }]
  [literalExp ::= (*) collectionLiteralExp , {IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE COMMA DOT UP UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR RIGHT_BRK MINUS_GT }]
  [oclExpression ::= (*) oclExpression XOR oclExpression , {IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE COMMA DOT UP UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR RIGHT_BRK MINUS_GT }]
  [oclExpression ::= (*) IF oclExpression THEN oclExpression ELSE oclExpression ENDIF , {IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE COMMA DOT UP UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR RIGHT_BRK MINUS_GT }]
  [oclExpression ::= (*) oclExpression MINUS_GT simpleName , {IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE COMMA DOT UP UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR RIGHT_BRK MINUS_GT }]
  [simpleName ::= (*) SIMPLE_NAME , {IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE COMMA DOT UP AT COLON_COLON UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR RIGHT_BRK MINUS_GT }]
  [collectionLiteralExp ::= (*) collectionKind LEFT_BRA RIGHT_BRA , {IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE COMMA DOT UP UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR RIGHT_BRK MINUS_GT }]
}
transition on tupleLiteralExp to state [54]
transition on oclExpression to state [88]
transition on REAL to state [52]
transition on INTEGER to state [51]
transition on pathName to state [50]
transition on SIMPLE_NAME to state [12]
transition on LET to state [49]
transition on FALSE to state [48]
transition on MINUS to state [47]
transition on COLLECTION to state [28]
transition on SET to state [20]
transition on simpleName to state [26]
transition on collectionLiteralExp to state [46]
transition on LEFT_PAR to state [45]
transition on STRING to state [44]
transition on IF to state [43]
transition on TRUE to state [42]
transition on collectionKind to state [41]
transition on NOT to state [40]
transition on primitiveLiteralExp to state [39]
transition on TUPLE to state [38]
transition on literalExp to state [37]
transition on BAG to state [25]
transition on SEQUENCE to state [22]

-------------------
lalr_state [86]: {
  [oclExpression ::= oclExpression LEFT_BRK argumentList RIGHT_BRK (*) isMarkedPre , {EOF ENDPACKAGE CONTEXT INIT DERIVE INV DEF PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE IN THEN ELSE ENDIF COMMA DOT COLON SEMICOLON BAR UP DOT_DOT UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR RIGHT_BRK RIGHT_BRA MINUS_GT }]
  [isMarkedPre ::= (*) AT PRE , {EOF ENDPACKAGE CONTEXT INIT DERIVE INV DEF PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE IN THEN ELSE ENDIF COMMA DOT COLON SEMICOLON BAR UP DOT_DOT UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR RIGHT_BRK RIGHT_BRA MINUS_GT }]
  [isMarkedPre ::= (*) , {EOF ENDPACKAGE CONTEXT INIT DERIVE INV DEF PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE IN THEN ELSE ENDIF COMMA DOT COLON SEMICOLON BAR UP DOT_DOT UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR RIGHT_BRK RIGHT_BRA MINUS_GT }]
}
transition on isMarkedPre to state [87]
transition on AT to state [78]

-------------------
lalr_state [87]: {
  [oclExpression ::= oclExpression LEFT_BRK argumentList RIGHT_BRK isMarkedPre (*) , {EOF ENDPACKAGE CONTEXT INIT DERIVE INV DEF PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE IN THEN ELSE ENDIF COMMA DOT COLON SEMICOLON BAR UP DOT_DOT UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR RIGHT_BRK RIGHT_BRA MINUS_GT }]
}

-------------------
lalr_state [88]: {
  [oclExpression ::= oclExpression (*) LEFT_BRK argumentList RIGHT_BRK isMarkedPre , {IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE COMMA DOT UP UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR RIGHT_BRK MINUS_GT }]
  [oclExpression ::= oclExpression (*) EQ oclExpression , {IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE COMMA DOT UP UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR RIGHT_BRK MINUS_GT }]
  [oclExpression ::= oclExpression (*) IMPLIES oclExpression , {IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE COMMA DOT UP UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR RIGHT_BRK MINUS_GT }]
  [oclExpression ::= oclExpression (*) UP simpleName LEFT_PAR RIGHT_PAR , {IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE COMMA DOT UP UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR RIGHT_BRK MINUS_GT }]
  [oclExpression ::= oclExpression (*) LEFT_PAR arguments RIGHT_PAR , {IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE COMMA DOT UP UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR RIGHT_BRK MINUS_GT }]
  [oclExpression ::= oclExpression (*) MINUS_GT ITERATE LEFT_PAR variableDeclaration BAR oclExpression RIGHT_PAR , {IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE COMMA DOT UP UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR RIGHT_BRK MINUS_GT }]
  [oclExpression ::= oclExpression (*) PLUS oclExpression , {IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE COMMA DOT UP UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR RIGHT_BRK MINUS_GT }]
  [oclExpression ::= oclExpression (*) LE oclExpression , {IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE COMMA DOT UP UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR RIGHT_BRK MINUS_GT }]
  [oclExpression ::= oclExpression (*) OR oclExpression , {IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE COMMA DOT UP UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR RIGHT_BRK MINUS_GT }]
  [oclExpression ::= oclExpression (*) UP_UP simpleName LEFT_PAR RIGHT_PAR , {IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE COMMA DOT UP UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR RIGHT_BRK MINUS_GT }]
  [oclExpression ::= oclExpression (*) MINUS_GT simpleName , {IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE COMMA DOT UP UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR RIGHT_BRK MINUS_GT }]
  [oclExpression ::= oclExpression (*) TIMES oclExpression , {IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE COMMA DOT UP UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR RIGHT_BRK MINUS_GT }]
  [oclExpression ::= oclExpression (*) LT oclExpression , {IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE COMMA DOT UP UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR RIGHT_BRK MINUS_GT }]
  [oclExpression ::= oclExpression (*) NE oclExpression , {IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE COMMA DOT UP UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR RIGHT_BRK MINUS_GT }]
  [oclExpression ::= oclExpression (*) LEFT_PAR variableDeclaration BAR oclExpression RIGHT_PAR , {IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE COMMA DOT UP UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR RIGHT_BRK MINUS_GT }]
  [oclExpression ::= oclExpression (*) MINUS oclExpression , {IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE COMMA DOT UP UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR RIGHT_BRK MINUS_GT }]
  [oclExpression ::= oclExpression (*) GE oclExpression , {IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE COMMA DOT UP UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR RIGHT_BRK MINUS_GT }]
  [oclExpression ::= oclExpression (*) XOR oclExpression , {IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE COMMA DOT UP UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR RIGHT_BRK MINUS_GT }]
  [argumentList ::= argumentList COMMA oclExpression (*) , {COMMA RIGHT_PAR RIGHT_BRK }]
  [oclExpression ::= oclExpression (*) UP simpleName LEFT_PAR oclMessageArgumentList RIGHT_PAR , {IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE COMMA DOT UP UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR RIGHT_BRK MINUS_GT }]
  [oclExpression ::= oclExpression (*) DOT simpleName isMarkedPre , {IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE COMMA DOT UP UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR RIGHT_BRK MINUS_GT }]
  [oclExpression ::= oclExpression (*) MINUS_GT ITERATE LEFT_PAR variableDeclaration SEMICOLON variableDeclaration BAR oclExpression RIGHT_PAR , {IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE COMMA DOT UP UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR RIGHT_BRK MINUS_GT }]
  [oclExpression ::= oclExpression (*) DIVIDE oclExpression , {IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE COMMA DOT UP UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR RIGHT_BRK MINUS_GT }]
  [oclExpression ::= oclExpression (*) GT oclExpression , {IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE COMMA DOT UP UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR RIGHT_BRK MINUS_GT }]
  [oclExpression ::= oclExpression (*) AND oclExpression , {IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE COMMA DOT UP UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR RIGHT_BRK MINUS_GT }]
  [oclExpression ::= oclExpression (*) UP_UP simpleName LEFT_PAR oclMessageArgumentList RIGHT_PAR , {IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE COMMA DOT UP UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR RIGHT_BRK MINUS_GT }]
}
transition on XOR to state [74]
transition on EQ to state [73]
transition on DOT to state [72]
transition on MINUS to state [71]
transition on GE to state [70]
transition on LEFT_BRK to state [69]
transition on DIVIDE to state [68]
transition on LEFT_PAR to state [67]
transition on MINUS_GT to state [66]
transition on LE to state [65]
transition on GT to state [64]
transition on IMPLIES to state [63]
transition on UP to state [62]
transition on UP_UP to state [61]
transition on OR to state [60]
transition on PLUS to state [59]
transition on NE to state [58]
transition on LT to state [57]
transition on AND to state [56]
transition on TIMES to state [55]

-------------------
lalr_state [89]: {
  [oclExpression ::= oclExpression (*) LEFT_BRK argumentList RIGHT_BRK isMarkedPre , {EOF ENDPACKAGE CONTEXT INIT DERIVE INV DEF PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE IN THEN ELSE ENDIF COMMA DOT COLON SEMICOLON BAR UP DOT_DOT UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR RIGHT_BRK RIGHT_BRA MINUS_GT }]
  [oclExpression ::= oclExpression (*) EQ oclExpression , {EOF ENDPACKAGE CONTEXT INIT DERIVE INV DEF PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE IN THEN ELSE ENDIF COMMA DOT COLON SEMICOLON BAR UP DOT_DOT UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR RIGHT_BRK RIGHT_BRA MINUS_GT }]
  [oclExpression ::= oclExpression (*) IMPLIES oclExpression , {EOF ENDPACKAGE CONTEXT INIT DERIVE INV DEF PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE IN THEN ELSE ENDIF COMMA DOT COLON SEMICOLON BAR UP DOT_DOT UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR RIGHT_BRK RIGHT_BRA MINUS_GT }]
  [oclExpression ::= oclExpression (*) UP simpleName LEFT_PAR RIGHT_PAR , {EOF ENDPACKAGE CONTEXT INIT DERIVE INV DEF PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE IN THEN ELSE ENDIF COMMA DOT COLON SEMICOLON BAR UP DOT_DOT UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR RIGHT_BRK RIGHT_BRA MINUS_GT }]
  [oclExpression ::= oclExpression (*) LEFT_PAR arguments RIGHT_PAR , {EOF ENDPACKAGE CONTEXT INIT DERIVE INV DEF PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE IN THEN ELSE ENDIF COMMA DOT COLON SEMICOLON BAR UP DOT_DOT UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR RIGHT_BRK RIGHT_BRA MINUS_GT }]
  [oclExpression ::= oclExpression (*) MINUS_GT ITERATE LEFT_PAR variableDeclaration BAR oclExpression RIGHT_PAR , {EOF ENDPACKAGE CONTEXT INIT DERIVE INV DEF PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE IN THEN ELSE ENDIF COMMA DOT COLON SEMICOLON BAR UP DOT_DOT UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR RIGHT_BRK RIGHT_BRA MINUS_GT }]
  [oclExpression ::= oclExpression (*) PLUS oclExpression , {EOF ENDPACKAGE CONTEXT INIT DERIVE INV DEF PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE IN THEN ELSE ENDIF COMMA DOT COLON SEMICOLON BAR UP DOT_DOT UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR RIGHT_BRK RIGHT_BRA MINUS_GT }]
  [oclExpression ::= oclExpression (*) LE oclExpression , {EOF ENDPACKAGE CONTEXT INIT DERIVE INV DEF PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE IN THEN ELSE ENDIF COMMA DOT COLON SEMICOLON BAR UP DOT_DOT UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR RIGHT_BRK RIGHT_BRA MINUS_GT }]
  [oclExpression ::= oclExpression (*) OR oclExpression , {EOF ENDPACKAGE CONTEXT INIT DERIVE INV DEF PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE IN THEN ELSE ENDIF COMMA DOT COLON SEMICOLON BAR UP DOT_DOT UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR RIGHT_BRK RIGHT_BRA MINUS_GT }]
  [oclExpression ::= oclExpression (*) UP_UP simpleName LEFT_PAR RIGHT_PAR , {EOF ENDPACKAGE CONTEXT INIT DERIVE INV DEF PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE IN THEN ELSE ENDIF COMMA DOT COLON SEMICOLON BAR UP DOT_DOT UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR RIGHT_BRK RIGHT_BRA MINUS_GT }]
  [oclExpression ::= oclExpression (*) MINUS_GT simpleName , {EOF ENDPACKAGE CONTEXT INIT DERIVE INV DEF PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE IN THEN ELSE ENDIF COMMA DOT COLON SEMICOLON BAR UP DOT_DOT UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR RIGHT_BRK RIGHT_BRA MINUS_GT }]
  [oclExpression ::= oclExpression (*) TIMES oclExpression , {EOF ENDPACKAGE CONTEXT INIT DERIVE INV DEF PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE IN THEN ELSE ENDIF COMMA DOT COLON SEMICOLON BAR UP DOT_DOT UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR RIGHT_BRK RIGHT_BRA MINUS_GT }]
  [oclExpression ::= oclExpression (*) LT oclExpression , {EOF ENDPACKAGE CONTEXT INIT DERIVE INV DEF PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE IN THEN ELSE ENDIF COMMA DOT COLON SEMICOLON BAR UP DOT_DOT UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR RIGHT_BRK RIGHT_BRA MINUS_GT }]
  [oclExpression ::= oclExpression (*) NE oclExpression , {EOF ENDPACKAGE CONTEXT INIT DERIVE INV DEF PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE IN THEN ELSE ENDIF COMMA DOT COLON SEMICOLON BAR UP DOT_DOT UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR RIGHT_BRK RIGHT_BRA MINUS_GT }]
  [oclExpression ::= oclExpression (*) LEFT_PAR variableDeclaration BAR oclExpression RIGHT_PAR , {EOF ENDPACKAGE CONTEXT INIT DERIVE INV DEF PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE IN THEN ELSE ENDIF COMMA DOT COLON SEMICOLON BAR UP DOT_DOT UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR RIGHT_BRK RIGHT_BRA MINUS_GT }]
  [oclExpression ::= oclExpression (*) MINUS oclExpression , {EOF ENDPACKAGE CONTEXT INIT DERIVE INV DEF PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE IN THEN ELSE ENDIF COMMA DOT COLON SEMICOLON BAR UP DOT_DOT UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR RIGHT_BRK RIGHT_BRA MINUS_GT }]
  [oclExpression ::= oclExpression (*) GE oclExpression , {EOF ENDPACKAGE CONTEXT INIT DERIVE INV DEF PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE IN THEN ELSE ENDIF COMMA DOT COLON SEMICOLON BAR UP DOT_DOT UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR RIGHT_BRK RIGHT_BRA MINUS_GT }]
  [oclExpression ::= oclExpression (*) XOR oclExpression , {EOF ENDPACKAGE CONTEXT INIT DERIVE INV DEF PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE IN THEN ELSE ENDIF COMMA DOT COLON SEMICOLON BAR UP DOT_DOT UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR RIGHT_BRK RIGHT_BRA MINUS_GT }]
  [oclExpression ::= oclExpression (*) UP simpleName LEFT_PAR oclMessageArgumentList RIGHT_PAR , {EOF ENDPACKAGE CONTEXT INIT DERIVE INV DEF PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE IN THEN ELSE ENDIF COMMA DOT COLON SEMICOLON BAR UP DOT_DOT UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR RIGHT_BRK RIGHT_BRA MINUS_GT }]
  [oclExpression ::= oclExpression DIVIDE oclExpression (*) , {EOF ENDPACKAGE CONTEXT INIT DERIVE INV DEF PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE IN THEN ELSE ENDIF COMMA DOT COLON SEMICOLON BAR UP DOT_DOT UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR RIGHT_BRK RIGHT_BRA MINUS_GT }]
  [oclExpression ::= oclExpression (*) DOT simpleName isMarkedPre , {EOF ENDPACKAGE CONTEXT INIT DERIVE INV DEF PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE IN THEN ELSE ENDIF COMMA DOT COLON SEMICOLON BAR UP DOT_DOT UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR RIGHT_BRK RIGHT_BRA MINUS_GT }]
  [oclExpression ::= oclExpression (*) MINUS_GT ITERATE LEFT_PAR variableDeclaration SEMICOLON variableDeclaration BAR oclExpression RIGHT_PAR , {EOF ENDPACKAGE CONTEXT INIT DERIVE INV DEF PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE IN THEN ELSE ENDIF COMMA DOT COLON SEMICOLON BAR UP DOT_DOT UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR RIGHT_BRK RIGHT_BRA MINUS_GT }]
  [oclExpression ::= oclExpression (*) DIVIDE oclExpression , {EOF ENDPACKAGE CONTEXT INIT DERIVE INV DEF PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE IN THEN ELSE ENDIF COMMA DOT COLON SEMICOLON BAR UP DOT_DOT UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR RIGHT_BRK RIGHT_BRA MINUS_GT }]
  [oclExpression ::= oclExpression (*) GT oclExpression , {EOF ENDPACKAGE CONTEXT INIT DERIVE INV DEF PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE IN THEN ELSE ENDIF COMMA DOT COLON SEMICOLON BAR UP DOT_DOT UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR RIGHT_BRK RIGHT_BRA MINUS_GT }]
  [oclExpression ::= oclExpression (*) AND oclExpression , {EOF ENDPACKAGE CONTEXT INIT DERIVE INV DEF PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE IN THEN ELSE ENDIF COMMA DOT COLON SEMICOLON BAR UP DOT_DOT UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR RIGHT_BRK RIGHT_BRA MINUS_GT }]
  [oclExpression ::= oclExpression (*) UP_UP simpleName LEFT_PAR oclMessageArgumentList RIGHT_PAR , {EOF ENDPACKAGE CONTEXT INIT DERIVE INV DEF PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE IN THEN ELSE ENDIF COMMA DOT COLON SEMICOLON BAR UP DOT_DOT UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR RIGHT_BRK RIGHT_BRA MINUS_GT }]
}
transition on XOR to state [74]
transition on EQ to state [73]
transition on DOT to state [72]
transition on MINUS to state [71]
transition on GE to state [70]
transition on LEFT_BRK to state [69]
transition on DIVIDE to state [68]
transition on LEFT_PAR to state [67]
transition on MINUS_GT to state [66]
transition on LE to state [65]
transition on GT to state [64]
transition on IMPLIES to state [63]
transition on UP to state [62]
transition on UP_UP to state [61]
transition on OR to state [60]
transition on PLUS to state [59]
transition on NE to state [58]
transition on LT to state [57]
transition on AND to state [56]
transition on TIMES to state [55]

-------------------
lalr_state [90]: {
  [oclExpression ::= oclExpression LEFT_PAR variableDeclaration (*) BAR oclExpression RIGHT_PAR , {EOF ENDPACKAGE CONTEXT INIT DERIVE INV DEF PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE IN THEN ELSE ENDIF COMMA DOT COLON SEMICOLON BAR UP DOT_DOT UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR RIGHT_BRK RIGHT_BRA MINUS_GT }]
}
transition on BAR to state [95]

-------------------
lalr_state [91]: {
  [variableDeclaration ::= simpleName (*) EQ oclExpression , {BAR }]
  [pathName ::= simpleName (*) , {IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE COMMA DOT UP AT COLON_COLON UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR MINUS_GT }]
  [variableDeclaration ::= simpleName (*) COLON type , {BAR }]
  [variableDeclaration ::= simpleName (*) , {BAR }]
  [variableDeclaration ::= simpleName (*) COLON type EQ oclExpression , {BAR }]
}
transition on COLON to state [19]
transition on EQ to state [18]

-------------------
lalr_state [92]: {
  [oclExpression ::= oclExpression LEFT_PAR arguments (*) RIGHT_PAR , {EOF ENDPACKAGE CONTEXT INIT DERIVE INV DEF PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE IN THEN ELSE ENDIF COMMA DOT COLON SEMICOLON BAR UP DOT_DOT UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR RIGHT_BRK RIGHT_BRA MINUS_GT }]
}
transition on RIGHT_PAR to state [94]

-------------------
lalr_state [93]: {
  [arguments ::= argumentList (*) , {RIGHT_PAR }]
  [argumentList ::= argumentList (*) COMMA oclExpression , {COMMA RIGHT_PAR }]
}
transition on COMMA to state [85]

-------------------
lalr_state [94]: {
  [oclExpression ::= oclExpression LEFT_PAR arguments RIGHT_PAR (*) , {EOF ENDPACKAGE CONTEXT INIT DERIVE INV DEF PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE IN THEN ELSE ENDIF COMMA DOT COLON SEMICOLON BAR UP DOT_DOT UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR RIGHT_BRK RIGHT_BRA MINUS_GT }]
}

-------------------
lalr_state [95]: {
  [oclExpression ::= (*) oclExpression UP simpleName LEFT_PAR oclMessageArgumentList RIGHT_PAR , {IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE DOT UP UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR MINUS_GT }]
  [oclExpression ::= (*) oclExpression EQ oclExpression , {IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE DOT UP UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR MINUS_GT }]
  [oclExpression ::= (*) oclExpression TIMES oclExpression , {IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE DOT UP UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR MINUS_GT }]
  [oclExpression ::= (*) oclExpression DOT simpleName isMarkedPre , {IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE DOT UP UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR MINUS_GT }]
  [primitiveLiteralExp ::= (*) TRUE , {IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE DOT UP UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR MINUS_GT }]
  [literalExp ::= (*) tupleLiteralExp , {IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE DOT UP UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR MINUS_GT }]
  [oclExpression ::= (*) oclExpression IMPLIES oclExpression , {IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE DOT UP UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR MINUS_GT }]
  [oclExpression ::= (*) oclExpression LT oclExpression , {IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE DOT UP UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR MINUS_GT }]
  [oclExpression ::= (*) oclExpression MINUS_GT ITERATE LEFT_PAR variableDeclaration SEMICOLON variableDeclaration BAR oclExpression RIGHT_PAR , {IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE DOT UP UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR MINUS_GT }]
  [tupleLiteralExp ::= (*) TUPLE LEFT_BRA variableDeclarationList RIGHT_BRA , {IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE DOT UP UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR MINUS_GT }]
  [collectionKind ::= (*) SET , {LEFT_BRA }]
  [oclExpression ::= (*) oclExpression UP simpleName LEFT_PAR RIGHT_PAR , {IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE DOT UP UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR MINUS_GT }]
  [oclExpression ::= (*) oclExpression NE oclExpression , {IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE DOT UP UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR MINUS_GT }]
  [oclExpression ::= (*) oclExpression DIVIDE oclExpression , {IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE DOT UP UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR MINUS_GT }]
  [oclExpression ::= (*) oclExpression LEFT_PAR arguments RIGHT_PAR , {IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE DOT UP UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR MINUS_GT }]
  [primitiveLiteralExp ::= (*) FALSE , {IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE DOT UP UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR MINUS_GT }]
  [literalExp ::= (*) primitiveLiteralExp , {IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE DOT UP UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR MINUS_GT }]
  [oclExpression ::= (*) LET variableDeclarationList IN oclExpression , {IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE DOT UP UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR MINUS_GT }]
  [oclExpression ::= (*) oclExpression GT oclExpression , {IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE DOT UP UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR MINUS_GT }]
  [oclExpression ::= (*) oclExpression MINUS_GT ITERATE LEFT_PAR variableDeclaration BAR oclExpression RIGHT_PAR , {IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE DOT UP UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR MINUS_GT }]
  [oclExpression ::= (*) literalExp , {IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE DOT UP UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR MINUS_GT }]
  [primitiveLiteralExp ::= (*) INTEGER , {IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE DOT UP UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR MINUS_GT }]
  [collectionKind ::= (*) BAG , {LEFT_BRA }]
  [oclExpression ::= oclExpression LEFT_PAR variableDeclaration BAR (*) oclExpression RIGHT_PAR , {EOF ENDPACKAGE CONTEXT INIT DERIVE INV DEF PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE IN THEN ELSE ENDIF COMMA DOT COLON SEMICOLON BAR UP DOT_DOT UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR RIGHT_BRK RIGHT_BRA MINUS_GT }]
  [oclExpression ::= (*) oclExpression AND oclExpression , {IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE DOT UP UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR MINUS_GT }]
  [oclExpression ::= (*) oclExpression PLUS oclExpression , {IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE DOT UP UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR MINUS_GT }]
  [oclExpression ::= (*) oclExpression LEFT_PAR variableDeclaration BAR oclExpression RIGHT_PAR , {IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE DOT UP UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR MINUS_GT }]
  [pathName ::= (*) simpleName , {IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE DOT UP AT COLON_COLON UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR MINUS_GT }]
  [oclExpression ::= (*) oclExpression UP_UP simpleName LEFT_PAR oclMessageArgumentList RIGHT_PAR , {IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE DOT UP UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR MINUS_GT }]
  [oclExpression ::= (*) oclExpression LE oclExpression , {IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE DOT UP UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR MINUS_GT }]
  [oclExpression ::= (*) NOT oclExpression , {IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE DOT UP UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR MINUS_GT }]
  [oclExpression ::= (*) LEFT_PAR oclExpression RIGHT_PAR , {IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE DOT UP UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR MINUS_GT }]
  [primitiveLiteralExp ::= (*) REAL , {IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE DOT UP UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR MINUS_GT }]
  [collectionKind ::= (*) SEQUENCE , {LEFT_BRA }]
  [oclExpression ::= (*) oclExpression OR oclExpression , {IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE DOT UP UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR MINUS_GT }]
  [oclExpression ::= (*) oclExpression MINUS oclExpression , {IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE DOT UP UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR MINUS_GT }]
  [oclExpression ::= (*) oclExpression LEFT_BRK argumentList RIGHT_BRK isMarkedPre , {IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE DOT UP UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR MINUS_GT }]
  [pathName ::= (*) pathName COLON_COLON simpleName , {IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE DOT UP AT COLON_COLON UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR MINUS_GT }]
  [collectionLiteralExp ::= (*) collectionKind LEFT_BRA collectionLiteralParts RIGHT_BRA , {IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE DOT UP UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR MINUS_GT }]
  [oclExpression ::= (*) oclExpression UP_UP simpleName LEFT_PAR RIGHT_PAR , {IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE DOT UP UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR MINUS_GT }]
  [oclExpression ::= (*) oclExpression GE oclExpression , {IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE DOT UP UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR MINUS_GT }]
  [oclExpression ::= (*) MINUS oclExpression , {IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE DOT UP UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR MINUS_GT }]
  [oclExpression ::= (*) pathName isMarkedPre , {IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE DOT UP UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR MINUS_GT }]
  [primitiveLiteralExp ::= (*) STRING , {IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE DOT UP UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR MINUS_GT }]
  [collectionKind ::= (*) COLLECTION , {LEFT_BRA }]
  [literalExp ::= (*) collectionLiteralExp , {IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE DOT UP UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR MINUS_GT }]
  [oclExpression ::= (*) oclExpression XOR oclExpression , {IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE DOT UP UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR MINUS_GT }]
  [oclExpression ::= (*) IF oclExpression THEN oclExpression ELSE oclExpression ENDIF , {IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE DOT UP UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR MINUS_GT }]
  [oclExpression ::= (*) oclExpression MINUS_GT simpleName , {IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE DOT UP UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR MINUS_GT }]
  [simpleName ::= (*) SIMPLE_NAME , {IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE DOT UP AT COLON_COLON UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR MINUS_GT }]
  [collectionLiteralExp ::= (*) collectionKind LEFT_BRA RIGHT_BRA , {IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE DOT UP UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR MINUS_GT }]
}
transition on tupleLiteralExp to state [54]
transition on oclExpression to state [96]
transition on REAL to state [52]
transition on INTEGER to state [51]
transition on pathName to state [50]
transition on SIMPLE_NAME to state [12]
transition on LET to state [49]
transition on FALSE to state [48]
transition on MINUS to state [47]
transition on COLLECTION to state [28]
transition on SET to state [20]
transition on simpleName to state [26]
transition on collectionLiteralExp to state [46]
transition on LEFT_PAR to state [45]
transition on STRING to state [44]
transition on IF to state [43]
transition on TRUE to state [42]
transition on collectionKind to state [41]
transition on NOT to state [40]
transition on primitiveLiteralExp to state [39]
transition on TUPLE to state [38]
transition on literalExp to state [37]
transition on BAG to state [25]
transition on SEQUENCE to state [22]

-------------------
lalr_state [96]: {
  [oclExpression ::= oclExpression (*) LEFT_BRK argumentList RIGHT_BRK isMarkedPre , {IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE DOT UP UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR MINUS_GT }]
  [oclExpression ::= oclExpression (*) EQ oclExpression , {IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE DOT UP UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR MINUS_GT }]
  [oclExpression ::= oclExpression (*) IMPLIES oclExpression , {IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE DOT UP UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR MINUS_GT }]
  [oclExpression ::= oclExpression (*) UP simpleName LEFT_PAR RIGHT_PAR , {IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE DOT UP UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR MINUS_GT }]
  [oclExpression ::= oclExpression (*) LEFT_PAR arguments RIGHT_PAR , {IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE DOT UP UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR MINUS_GT }]
  [oclExpression ::= oclExpression (*) MINUS_GT ITERATE LEFT_PAR variableDeclaration BAR oclExpression RIGHT_PAR , {IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE DOT UP UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR MINUS_GT }]
  [oclExpression ::= oclExpression (*) PLUS oclExpression , {IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE DOT UP UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR MINUS_GT }]
  [oclExpression ::= oclExpression (*) LE oclExpression , {IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE DOT UP UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR MINUS_GT }]
  [oclExpression ::= oclExpression (*) OR oclExpression , {IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE DOT UP UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR MINUS_GT }]
  [oclExpression ::= oclExpression (*) UP_UP simpleName LEFT_PAR RIGHT_PAR , {IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE DOT UP UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR MINUS_GT }]
  [oclExpression ::= oclExpression (*) MINUS_GT simpleName , {IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE DOT UP UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR MINUS_GT }]
  [oclExpression ::= oclExpression (*) TIMES oclExpression , {IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE DOT UP UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR MINUS_GT }]
  [oclExpression ::= oclExpression (*) LT oclExpression , {IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE DOT UP UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR MINUS_GT }]
  [oclExpression ::= oclExpression (*) NE oclExpression , {IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE DOT UP UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR MINUS_GT }]
  [oclExpression ::= oclExpression LEFT_PAR variableDeclaration BAR oclExpression (*) RIGHT_PAR , {EOF ENDPACKAGE CONTEXT INIT DERIVE INV DEF PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE IN THEN ELSE ENDIF COMMA DOT COLON SEMICOLON BAR UP DOT_DOT UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR RIGHT_BRK RIGHT_BRA MINUS_GT }]
  [oclExpression ::= oclExpression (*) LEFT_PAR variableDeclaration BAR oclExpression RIGHT_PAR , {IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE DOT UP UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR MINUS_GT }]
  [oclExpression ::= oclExpression (*) MINUS oclExpression , {IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE DOT UP UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR MINUS_GT }]
  [oclExpression ::= oclExpression (*) GE oclExpression , {IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE DOT UP UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR MINUS_GT }]
  [oclExpression ::= oclExpression (*) XOR oclExpression , {IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE DOT UP UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR MINUS_GT }]
  [oclExpression ::= oclExpression (*) UP simpleName LEFT_PAR oclMessageArgumentList RIGHT_PAR , {IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE DOT UP UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR MINUS_GT }]
  [oclExpression ::= oclExpression (*) DOT simpleName isMarkedPre , {IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE DOT UP UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR MINUS_GT }]
  [oclExpression ::= oclExpression (*) MINUS_GT ITERATE LEFT_PAR variableDeclaration SEMICOLON variableDeclaration BAR oclExpression RIGHT_PAR , {IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE DOT UP UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR MINUS_GT }]
  [oclExpression ::= oclExpression (*) DIVIDE oclExpression , {IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE DOT UP UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR MINUS_GT }]
  [oclExpression ::= oclExpression (*) GT oclExpression , {IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE DOT UP UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR MINUS_GT }]
  [oclExpression ::= oclExpression (*) AND oclExpression , {IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE DOT UP UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR MINUS_GT }]
  [oclExpression ::= oclExpression (*) UP_UP simpleName LEFT_PAR oclMessageArgumentList RIGHT_PAR , {IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE DOT UP UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR MINUS_GT }]
}
transition on XOR to state [74]
transition on EQ to state [73]
transition on DOT to state [72]
transition on MINUS to state [71]
transition on GE to state [70]
transition on LEFT_BRK to state [69]
transition on RIGHT_PAR to state [97]
transition on DIVIDE to state [68]
transition on LEFT_PAR to state [67]
transition on MINUS_GT to state [66]
transition on LE to state [65]
transition on GT to state [64]
transition on IMPLIES to state [63]
transition on UP to state [62]
transition on UP_UP to state [61]
transition on OR to state [60]
transition on PLUS to state [59]
transition on NE to state [58]
transition on LT to state [57]
transition on AND to state [56]
transition on TIMES to state [55]

-------------------
lalr_state [97]: {
  [oclExpression ::= oclExpression LEFT_PAR variableDeclaration BAR oclExpression RIGHT_PAR (*) , {EOF ENDPACKAGE CONTEXT INIT DERIVE INV DEF PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE IN THEN ELSE ENDIF COMMA DOT COLON SEMICOLON BAR UP DOT_DOT UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR RIGHT_BRK RIGHT_BRA MINUS_GT }]
}

-------------------
lalr_state [98]: {
  [oclExpression ::= oclExpression MINUS_GT simpleName (*) , {EOF ENDPACKAGE CONTEXT INIT DERIVE INV DEF PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE IN THEN ELSE ENDIF COMMA DOT COLON SEMICOLON BAR UP DOT_DOT UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR RIGHT_BRK RIGHT_BRA MINUS_GT }]
}

-------------------
lalr_state [99]: {
  [oclExpression ::= oclExpression MINUS_GT ITERATE (*) LEFT_PAR variableDeclaration BAR oclExpression RIGHT_PAR , {EOF ENDPACKAGE CONTEXT INIT DERIVE INV DEF PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE IN THEN ELSE ENDIF COMMA DOT COLON SEMICOLON BAR UP DOT_DOT UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR RIGHT_BRK RIGHT_BRA MINUS_GT }]
  [oclExpression ::= oclExpression MINUS_GT ITERATE (*) LEFT_PAR variableDeclaration SEMICOLON variableDeclaration BAR oclExpression RIGHT_PAR , {EOF ENDPACKAGE CONTEXT INIT DERIVE INV DEF PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE IN THEN ELSE ENDIF COMMA DOT COLON SEMICOLON BAR UP DOT_DOT UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR RIGHT_BRK RIGHT_BRA MINUS_GT }]
}
transition on LEFT_PAR to state [100]

-------------------
lalr_state [100]: {
  [variableDeclaration ::= (*) simpleName EQ oclExpression , {SEMICOLON BAR }]
  [oclExpression ::= oclExpression MINUS_GT ITERATE LEFT_PAR (*) variableDeclaration SEMICOLON variableDeclaration BAR oclExpression RIGHT_PAR , {EOF ENDPACKAGE CONTEXT INIT DERIVE INV DEF PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE IN THEN ELSE ENDIF COMMA DOT COLON SEMICOLON BAR UP DOT_DOT UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR RIGHT_BRK RIGHT_BRA MINUS_GT }]
  [variableDeclaration ::= (*) simpleName COLON type , {SEMICOLON BAR }]
  [simpleName ::= (*) SIMPLE_NAME , {EQ COLON SEMICOLON BAR }]
  [variableDeclaration ::= (*) simpleName , {SEMICOLON BAR }]
  [variableDeclaration ::= (*) simpleName COLON type EQ oclExpression , {SEMICOLON BAR }]
  [oclExpression ::= oclExpression MINUS_GT ITERATE LEFT_PAR (*) variableDeclaration BAR oclExpression RIGHT_PAR , {EOF ENDPACKAGE CONTEXT INIT DERIVE INV DEF PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE IN THEN ELSE ENDIF COMMA DOT COLON SEMICOLON BAR UP DOT_DOT UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR RIGHT_BRK RIGHT_BRA MINUS_GT }]
}
transition on SIMPLE_NAME to state [12]
transition on variableDeclaration to state [101]
transition on simpleName to state [16]

-------------------
lalr_state [101]: {
  [oclExpression ::= oclExpression MINUS_GT ITERATE LEFT_PAR variableDeclaration (*) SEMICOLON variableDeclaration BAR oclExpression RIGHT_PAR , {EOF ENDPACKAGE CONTEXT INIT DERIVE INV DEF PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE IN THEN ELSE ENDIF COMMA DOT COLON SEMICOLON BAR UP DOT_DOT UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR RIGHT_BRK RIGHT_BRA MINUS_GT }]
  [oclExpression ::= oclExpression MINUS_GT ITERATE LEFT_PAR variableDeclaration (*) BAR oclExpression RIGHT_PAR , {EOF ENDPACKAGE CONTEXT INIT DERIVE INV DEF PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE IN THEN ELSE ENDIF COMMA DOT COLON SEMICOLON BAR UP DOT_DOT UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR RIGHT_BRK RIGHT_BRA MINUS_GT }]
}
transition on BAR to state [103]
transition on SEMICOLON to state [102]

-------------------
lalr_state [102]: {
  [variableDeclaration ::= (*) simpleName EQ oclExpression , {BAR }]
  [oclExpression ::= oclExpression MINUS_GT ITERATE LEFT_PAR variableDeclaration SEMICOLON (*) variableDeclaration BAR oclExpression RIGHT_PAR , {EOF ENDPACKAGE CONTEXT INIT DERIVE INV DEF PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE IN THEN ELSE ENDIF COMMA DOT COLON SEMICOLON BAR UP DOT_DOT UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR RIGHT_BRK RIGHT_BRA MINUS_GT }]
  [variableDeclaration ::= (*) simpleName COLON type , {BAR }]
  [simpleName ::= (*) SIMPLE_NAME , {EQ COLON BAR }]
  [variableDeclaration ::= (*) simpleName , {BAR }]
  [variableDeclaration ::= (*) simpleName COLON type EQ oclExpression , {BAR }]
}
transition on SIMPLE_NAME to state [12]
transition on variableDeclaration to state [106]
transition on simpleName to state [16]

-------------------
lalr_state [103]: {
  [oclExpression ::= (*) oclExpression UP simpleName LEFT_PAR oclMessageArgumentList RIGHT_PAR , {IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE DOT UP UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR MINUS_GT }]
  [oclExpression ::= (*) oclExpression EQ oclExpression , {IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE DOT UP UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR MINUS_GT }]
  [oclExpression ::= (*) oclExpression TIMES oclExpression , {IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE DOT UP UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR MINUS_GT }]
  [oclExpression ::= (*) oclExpression DOT simpleName isMarkedPre , {IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE DOT UP UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR MINUS_GT }]
  [primitiveLiteralExp ::= (*) TRUE , {IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE DOT UP UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR MINUS_GT }]
  [literalExp ::= (*) tupleLiteralExp , {IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE DOT UP UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR MINUS_GT }]
  [oclExpression ::= (*) oclExpression IMPLIES oclExpression , {IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE DOT UP UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR MINUS_GT }]
  [oclExpression ::= (*) oclExpression LT oclExpression , {IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE DOT UP UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR MINUS_GT }]
  [oclExpression ::= (*) oclExpression MINUS_GT ITERATE LEFT_PAR variableDeclaration SEMICOLON variableDeclaration BAR oclExpression RIGHT_PAR , {IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE DOT UP UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR MINUS_GT }]
  [tupleLiteralExp ::= (*) TUPLE LEFT_BRA variableDeclarationList RIGHT_BRA , {IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE DOT UP UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR MINUS_GT }]
  [collectionKind ::= (*) SET , {LEFT_BRA }]
  [oclExpression ::= (*) oclExpression UP simpleName LEFT_PAR RIGHT_PAR , {IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE DOT UP UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR MINUS_GT }]
  [oclExpression ::= (*) oclExpression NE oclExpression , {IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE DOT UP UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR MINUS_GT }]
  [oclExpression ::= (*) oclExpression DIVIDE oclExpression , {IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE DOT UP UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR MINUS_GT }]
  [oclExpression ::= (*) oclExpression LEFT_PAR arguments RIGHT_PAR , {IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE DOT UP UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR MINUS_GT }]
  [primitiveLiteralExp ::= (*) FALSE , {IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE DOT UP UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR MINUS_GT }]
  [oclExpression ::= oclExpression MINUS_GT ITERATE LEFT_PAR variableDeclaration BAR (*) oclExpression RIGHT_PAR , {EOF ENDPACKAGE CONTEXT INIT DERIVE INV DEF PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE IN THEN ELSE ENDIF COMMA DOT COLON SEMICOLON BAR UP DOT_DOT UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR RIGHT_BRK RIGHT_BRA MINUS_GT }]
  [literalExp ::= (*) primitiveLiteralExp , {IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE DOT UP UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR MINUS_GT }]
  [oclExpression ::= (*) LET variableDeclarationList IN oclExpression , {IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE DOT UP UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR MINUS_GT }]
  [oclExpression ::= (*) oclExpression GT oclExpression , {IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE DOT UP UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR MINUS_GT }]
  [oclExpression ::= (*) oclExpression MINUS_GT ITERATE LEFT_PAR variableDeclaration BAR oclExpression RIGHT_PAR , {IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE DOT UP UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR MINUS_GT }]
  [oclExpression ::= (*) literalExp , {IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE DOT UP UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR MINUS_GT }]
  [primitiveLiteralExp ::= (*) INTEGER , {IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE DOT UP UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR MINUS_GT }]
  [collectionKind ::= (*) BAG , {LEFT_BRA }]
  [oclExpression ::= (*) oclExpression AND oclExpression , {IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE DOT UP UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR MINUS_GT }]
  [oclExpression ::= (*) oclExpression PLUS oclExpression , {IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE DOT UP UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR MINUS_GT }]
  [oclExpression ::= (*) oclExpression LEFT_PAR variableDeclaration BAR oclExpression RIGHT_PAR , {IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE DOT UP UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR MINUS_GT }]
  [pathName ::= (*) simpleName , {IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE DOT UP AT COLON_COLON UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR MINUS_GT }]
  [oclExpression ::= (*) oclExpression UP_UP simpleName LEFT_PAR oclMessageArgumentList RIGHT_PAR , {IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE DOT UP UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR MINUS_GT }]
  [oclExpression ::= (*) oclExpression LE oclExpression , {IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE DOT UP UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR MINUS_GT }]
  [oclExpression ::= (*) NOT oclExpression , {IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE DOT UP UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR MINUS_GT }]
  [oclExpression ::= (*) LEFT_PAR oclExpression RIGHT_PAR , {IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE DOT UP UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR MINUS_GT }]
  [primitiveLiteralExp ::= (*) REAL , {IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE DOT UP UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR MINUS_GT }]
  [collectionKind ::= (*) SEQUENCE , {LEFT_BRA }]
  [oclExpression ::= (*) oclExpression OR oclExpression , {IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE DOT UP UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR MINUS_GT }]
  [oclExpression ::= (*) oclExpression MINUS oclExpression , {IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE DOT UP UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR MINUS_GT }]
  [oclExpression ::= (*) oclExpression LEFT_BRK argumentList RIGHT_BRK isMarkedPre , {IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE DOT UP UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR MINUS_GT }]
  [pathName ::= (*) pathName COLON_COLON simpleName , {IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE DOT UP AT COLON_COLON UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR MINUS_GT }]
  [collectionLiteralExp ::= (*) collectionKind LEFT_BRA collectionLiteralParts RIGHT_BRA , {IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE DOT UP UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR MINUS_GT }]
  [oclExpression ::= (*) oclExpression UP_UP simpleName LEFT_PAR RIGHT_PAR , {IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE DOT UP UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR MINUS_GT }]
  [oclExpression ::= (*) oclExpression GE oclExpression , {IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE DOT UP UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR MINUS_GT }]
  [oclExpression ::= (*) MINUS oclExpression , {IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE DOT UP UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR MINUS_GT }]
  [oclExpression ::= (*) pathName isMarkedPre , {IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE DOT UP UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR MINUS_GT }]
  [primitiveLiteralExp ::= (*) STRING , {IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE DOT UP UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR MINUS_GT }]
  [collectionKind ::= (*) COLLECTION , {LEFT_BRA }]
  [literalExp ::= (*) collectionLiteralExp , {IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE DOT UP UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR MINUS_GT }]
  [oclExpression ::= (*) oclExpression XOR oclExpression , {IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE DOT UP UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR MINUS_GT }]
  [oclExpression ::= (*) IF oclExpression THEN oclExpression ELSE oclExpression ENDIF , {IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE DOT UP UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR MINUS_GT }]
  [oclExpression ::= (*) oclExpression MINUS_GT simpleName , {IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE DOT UP UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR MINUS_GT }]
  [simpleName ::= (*) SIMPLE_NAME , {IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE DOT UP AT COLON_COLON UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR MINUS_GT }]
  [collectionLiteralExp ::= (*) collectionKind LEFT_BRA RIGHT_BRA , {IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE DOT UP UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR MINUS_GT }]
}
transition on tupleLiteralExp to state [54]
transition on oclExpression to state [104]
transition on REAL to state [52]
transition on INTEGER to state [51]
transition on pathName to state [50]
transition on SIMPLE_NAME to state [12]
transition on LET to state [49]
transition on FALSE to state [48]
transition on MINUS to state [47]
transition on COLLECTION to state [28]
transition on SET to state [20]
transition on simpleName to state [26]
transition on collectionLiteralExp to state [46]
transition on LEFT_PAR to state [45]
transition on STRING to state [44]
transition on IF to state [43]
transition on TRUE to state [42]
transition on collectionKind to state [41]
transition on NOT to state [40]
transition on primitiveLiteralExp to state [39]
transition on TUPLE to state [38]
transition on literalExp to state [37]
transition on BAG to state [25]
transition on SEQUENCE to state [22]

-------------------
lalr_state [104]: {
  [oclExpression ::= oclExpression (*) LEFT_BRK argumentList RIGHT_BRK isMarkedPre , {IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE DOT UP UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR MINUS_GT }]
  [oclExpression ::= oclExpression (*) EQ oclExpression , {IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE DOT UP UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR MINUS_GT }]
  [oclExpression ::= oclExpression (*) IMPLIES oclExpression , {IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE DOT UP UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR MINUS_GT }]
  [oclExpression ::= oclExpression MINUS_GT ITERATE LEFT_PAR variableDeclaration BAR oclExpression (*) RIGHT_PAR , {EOF ENDPACKAGE CONTEXT INIT DERIVE INV DEF PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE IN THEN ELSE ENDIF COMMA DOT COLON SEMICOLON BAR UP DOT_DOT UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR RIGHT_BRK RIGHT_BRA MINUS_GT }]
  [oclExpression ::= oclExpression (*) UP simpleName LEFT_PAR RIGHT_PAR , {IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE DOT UP UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR MINUS_GT }]
  [oclExpression ::= oclExpression (*) LEFT_PAR arguments RIGHT_PAR , {IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE DOT UP UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR MINUS_GT }]
  [oclExpression ::= oclExpression (*) MINUS_GT ITERATE LEFT_PAR variableDeclaration BAR oclExpression RIGHT_PAR , {IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE DOT UP UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR MINUS_GT }]
  [oclExpression ::= oclExpression (*) PLUS oclExpression , {IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE DOT UP UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR MINUS_GT }]
  [oclExpression ::= oclExpression (*) LE oclExpression , {IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE DOT UP UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR MINUS_GT }]
  [oclExpression ::= oclExpression (*) OR oclExpression , {IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE DOT UP UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR MINUS_GT }]
  [oclExpression ::= oclExpression (*) UP_UP simpleName LEFT_PAR RIGHT_PAR , {IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE DOT UP UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR MINUS_GT }]
  [oclExpression ::= oclExpression (*) MINUS_GT simpleName , {IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE DOT UP UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR MINUS_GT }]
  [oclExpression ::= oclExpression (*) TIMES oclExpression , {IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE DOT UP UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR MINUS_GT }]
  [oclExpression ::= oclExpression (*) LT oclExpression , {IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE DOT UP UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR MINUS_GT }]
  [oclExpression ::= oclExpression (*) NE oclExpression , {IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE DOT UP UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR MINUS_GT }]
  [oclExpression ::= oclExpression (*) LEFT_PAR variableDeclaration BAR oclExpression RIGHT_PAR , {IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE DOT UP UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR MINUS_GT }]
  [oclExpression ::= oclExpression (*) MINUS oclExpression , {IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE DOT UP UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR MINUS_GT }]
  [oclExpression ::= oclExpression (*) GE oclExpression , {IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE DOT UP UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR MINUS_GT }]
  [oclExpression ::= oclExpression (*) XOR oclExpression , {IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE DOT UP UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR MINUS_GT }]
  [oclExpression ::= oclExpression (*) UP simpleName LEFT_PAR oclMessageArgumentList RIGHT_PAR , {IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE DOT UP UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR MINUS_GT }]
  [oclExpression ::= oclExpression (*) DOT simpleName isMarkedPre , {IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE DOT UP UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR MINUS_GT }]
  [oclExpression ::= oclExpression (*) MINUS_GT ITERATE LEFT_PAR variableDeclaration SEMICOLON variableDeclaration BAR oclExpression RIGHT_PAR , {IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE DOT UP UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR MINUS_GT }]
  [oclExpression ::= oclExpression (*) DIVIDE oclExpression , {IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE DOT UP UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR MINUS_GT }]
  [oclExpression ::= oclExpression (*) GT oclExpression , {IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE DOT UP UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR MINUS_GT }]
  [oclExpression ::= oclExpression (*) AND oclExpression , {IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE DOT UP UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR MINUS_GT }]
  [oclExpression ::= oclExpression (*) UP_UP simpleName LEFT_PAR oclMessageArgumentList RIGHT_PAR , {IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE DOT UP UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR MINUS_GT }]
}
transition on XOR to state [74]
transition on EQ to state [73]
transition on DOT to state [72]
transition on MINUS to state [71]
transition on GE to state [70]
transition on LEFT_BRK to state [69]
transition on RIGHT_PAR to state [105]
transition on DIVIDE to state [68]
transition on LEFT_PAR to state [67]
transition on MINUS_GT to state [66]
transition on LE to state [65]
transition on GT to state [64]
transition on IMPLIES to state [63]
transition on UP to state [62]
transition on UP_UP to state [61]
transition on OR to state [60]
transition on PLUS to state [59]
transition on NE to state [58]
transition on LT to state [57]
transition on AND to state [56]
transition on TIMES to state [55]

-------------------
lalr_state [105]: {
  [oclExpression ::= oclExpression MINUS_GT ITERATE LEFT_PAR variableDeclaration BAR oclExpression RIGHT_PAR (*) , {EOF ENDPACKAGE CONTEXT INIT DERIVE INV DEF PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE IN THEN ELSE ENDIF COMMA DOT COLON SEMICOLON BAR UP DOT_DOT UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR RIGHT_BRK RIGHT_BRA MINUS_GT }]
}

-------------------
lalr_state [106]: {
  [oclExpression ::= oclExpression MINUS_GT ITERATE LEFT_PAR variableDeclaration SEMICOLON variableDeclaration (*) BAR oclExpression RIGHT_PAR , {EOF ENDPACKAGE CONTEXT INIT DERIVE INV DEF PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE IN THEN ELSE ENDIF COMMA DOT COLON SEMICOLON BAR UP DOT_DOT UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR RIGHT_BRK RIGHT_BRA MINUS_GT }]
}
transition on BAR to state [107]

-------------------
lalr_state [107]: {
  [oclExpression ::= (*) oclExpression UP simpleName LEFT_PAR oclMessageArgumentList RIGHT_PAR , {IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE DOT UP UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR MINUS_GT }]
  [oclExpression ::= (*) oclExpression EQ oclExpression , {IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE DOT UP UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR MINUS_GT }]
  [oclExpression ::= (*) oclExpression TIMES oclExpression , {IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE DOT UP UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR MINUS_GT }]
  [oclExpression ::= (*) oclExpression DOT simpleName isMarkedPre , {IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE DOT UP UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR MINUS_GT }]
  [oclExpression ::= oclExpression MINUS_GT ITERATE LEFT_PAR variableDeclaration SEMICOLON variableDeclaration BAR (*) oclExpression RIGHT_PAR , {EOF ENDPACKAGE CONTEXT INIT DERIVE INV DEF PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE IN THEN ELSE ENDIF COMMA DOT COLON SEMICOLON BAR UP DOT_DOT UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR RIGHT_BRK RIGHT_BRA MINUS_GT }]
  [primitiveLiteralExp ::= (*) TRUE , {IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE DOT UP UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR MINUS_GT }]
  [literalExp ::= (*) tupleLiteralExp , {IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE DOT UP UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR MINUS_GT }]
  [oclExpression ::= (*) oclExpression IMPLIES oclExpression , {IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE DOT UP UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR MINUS_GT }]
  [oclExpression ::= (*) oclExpression LT oclExpression , {IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE DOT UP UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR MINUS_GT }]
  [oclExpression ::= (*) oclExpression MINUS_GT ITERATE LEFT_PAR variableDeclaration SEMICOLON variableDeclaration BAR oclExpression RIGHT_PAR , {IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE DOT UP UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR MINUS_GT }]
  [tupleLiteralExp ::= (*) TUPLE LEFT_BRA variableDeclarationList RIGHT_BRA , {IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE DOT UP UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR MINUS_GT }]
  [collectionKind ::= (*) SET , {LEFT_BRA }]
  [oclExpression ::= (*) oclExpression UP simpleName LEFT_PAR RIGHT_PAR , {IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE DOT UP UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR MINUS_GT }]
  [oclExpression ::= (*) oclExpression NE oclExpression , {IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE DOT UP UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR MINUS_GT }]
  [oclExpression ::= (*) oclExpression DIVIDE oclExpression , {IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE DOT UP UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR MINUS_GT }]
  [oclExpression ::= (*) oclExpression LEFT_PAR arguments RIGHT_PAR , {IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE DOT UP UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR MINUS_GT }]
  [primitiveLiteralExp ::= (*) FALSE , {IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE DOT UP UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR MINUS_GT }]
  [literalExp ::= (*) primitiveLiteralExp , {IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE DOT UP UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR MINUS_GT }]
  [oclExpression ::= (*) LET variableDeclarationList IN oclExpression , {IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE DOT UP UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR MINUS_GT }]
  [oclExpression ::= (*) oclExpression GT oclExpression , {IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE DOT UP UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR MINUS_GT }]
  [oclExpression ::= (*) oclExpression MINUS_GT ITERATE LEFT_PAR variableDeclaration BAR oclExpression RIGHT_PAR , {IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE DOT UP UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR MINUS_GT }]
  [oclExpression ::= (*) literalExp , {IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE DOT UP UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR MINUS_GT }]
  [primitiveLiteralExp ::= (*) INTEGER , {IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE DOT UP UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR MINUS_GT }]
  [collectionKind ::= (*) BAG , {LEFT_BRA }]
  [oclExpression ::= (*) oclExpression AND oclExpression , {IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE DOT UP UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR MINUS_GT }]
  [oclExpression ::= (*) oclExpression PLUS oclExpression , {IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE DOT UP UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR MINUS_GT }]
  [oclExpression ::= (*) oclExpression LEFT_PAR variableDeclaration BAR oclExpression RIGHT_PAR , {IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE DOT UP UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR MINUS_GT }]
  [pathName ::= (*) simpleName , {IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE DOT UP AT COLON_COLON UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR MINUS_GT }]
  [oclExpression ::= (*) oclExpression UP_UP simpleName LEFT_PAR oclMessageArgumentList RIGHT_PAR , {IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE DOT UP UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR MINUS_GT }]
  [oclExpression ::= (*) oclExpression LE oclExpression , {IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE DOT UP UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR MINUS_GT }]
  [oclExpression ::= (*) NOT oclExpression , {IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE DOT UP UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR MINUS_GT }]
  [oclExpression ::= (*) LEFT_PAR oclExpression RIGHT_PAR , {IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE DOT UP UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR MINUS_GT }]
  [primitiveLiteralExp ::= (*) REAL , {IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE DOT UP UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR MINUS_GT }]
  [collectionKind ::= (*) SEQUENCE , {LEFT_BRA }]
  [oclExpression ::= (*) oclExpression OR oclExpression , {IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE DOT UP UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR MINUS_GT }]
  [oclExpression ::= (*) oclExpression MINUS oclExpression , {IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE DOT UP UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR MINUS_GT }]
  [oclExpression ::= (*) oclExpression LEFT_BRK argumentList RIGHT_BRK isMarkedPre , {IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE DOT UP UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR MINUS_GT }]
  [pathName ::= (*) pathName COLON_COLON simpleName , {IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE DOT UP AT COLON_COLON UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR MINUS_GT }]
  [collectionLiteralExp ::= (*) collectionKind LEFT_BRA collectionLiteralParts RIGHT_BRA , {IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE DOT UP UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR MINUS_GT }]
  [oclExpression ::= (*) oclExpression UP_UP simpleName LEFT_PAR RIGHT_PAR , {IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE DOT UP UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR MINUS_GT }]
  [oclExpression ::= (*) oclExpression GE oclExpression , {IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE DOT UP UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR MINUS_GT }]
  [oclExpression ::= (*) MINUS oclExpression , {IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE DOT UP UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR MINUS_GT }]
  [oclExpression ::= (*) pathName isMarkedPre , {IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE DOT UP UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR MINUS_GT }]
  [primitiveLiteralExp ::= (*) STRING , {IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE DOT UP UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR MINUS_GT }]
  [collectionKind ::= (*) COLLECTION , {LEFT_BRA }]
  [literalExp ::= (*) collectionLiteralExp , {IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE DOT UP UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR MINUS_GT }]
  [oclExpression ::= (*) oclExpression XOR oclExpression , {IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE DOT UP UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR MINUS_GT }]
  [oclExpression ::= (*) IF oclExpression THEN oclExpression ELSE oclExpression ENDIF , {IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE DOT UP UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR MINUS_GT }]
  [oclExpression ::= (*) oclExpression MINUS_GT simpleName , {IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE DOT UP UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR MINUS_GT }]
  [simpleName ::= (*) SIMPLE_NAME , {IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE DOT UP AT COLON_COLON UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR MINUS_GT }]
  [collectionLiteralExp ::= (*) collectionKind LEFT_BRA RIGHT_BRA , {IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE DOT UP UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR MINUS_GT }]
}
transition on tupleLiteralExp to state [54]
transition on oclExpression to state [108]
transition on REAL to state [52]
transition on INTEGER to state [51]
transition on pathName to state [50]
transition on SIMPLE_NAME to state [12]
transition on LET to state [49]
transition on FALSE to state [48]
transition on MINUS to state [47]
transition on COLLECTION to state [28]
transition on SET to state [20]
transition on simpleName to state [26]
transition on collectionLiteralExp to state [46]
transition on LEFT_PAR to state [45]
transition on STRING to state [44]
transition on IF to state [43]
transition on TRUE to state [42]
transition on collectionKind to state [41]
transition on NOT to state [40]
transition on primitiveLiteralExp to state [39]
transition on TUPLE to state [38]
transition on literalExp to state [37]
transition on BAG to state [25]
transition on SEQUENCE to state [22]

-------------------
lalr_state [108]: {
  [oclExpression ::= oclExpression (*) LEFT_BRK argumentList RIGHT_BRK isMarkedPre , {IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE DOT UP UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR MINUS_GT }]
  [oclExpression ::= oclExpression (*) EQ oclExpression , {IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE DOT UP UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR MINUS_GT }]
  [oclExpression ::= oclExpression (*) IMPLIES oclExpression , {IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE DOT UP UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR MINUS_GT }]
  [oclExpression ::= oclExpression (*) UP simpleName LEFT_PAR RIGHT_PAR , {IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE DOT UP UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR MINUS_GT }]
  [oclExpression ::= oclExpression (*) LEFT_PAR arguments RIGHT_PAR , {IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE DOT UP UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR MINUS_GT }]
  [oclExpression ::= oclExpression (*) MINUS_GT ITERATE LEFT_PAR variableDeclaration BAR oclExpression RIGHT_PAR , {IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE DOT UP UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR MINUS_GT }]
  [oclExpression ::= oclExpression (*) PLUS oclExpression , {IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE DOT UP UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR MINUS_GT }]
  [oclExpression ::= oclExpression (*) LE oclExpression , {IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE DOT UP UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR MINUS_GT }]
  [oclExpression ::= oclExpression (*) OR oclExpression , {IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE DOT UP UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR MINUS_GT }]
  [oclExpression ::= oclExpression (*) UP_UP simpleName LEFT_PAR RIGHT_PAR , {IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE DOT UP UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR MINUS_GT }]
  [oclExpression ::= oclExpression (*) MINUS_GT simpleName , {IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE DOT UP UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR MINUS_GT }]
  [oclExpression ::= oclExpression (*) TIMES oclExpression , {IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE DOT UP UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR MINUS_GT }]
  [oclExpression ::= oclExpression (*) LT oclExpression , {IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE DOT UP UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR MINUS_GT }]
  [oclExpression ::= oclExpression (*) NE oclExpression , {IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE DOT UP UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR MINUS_GT }]
  [oclExpression ::= oclExpression (*) LEFT_PAR variableDeclaration BAR oclExpression RIGHT_PAR , {IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE DOT UP UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR MINUS_GT }]
  [oclExpression ::= oclExpression (*) MINUS oclExpression , {IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE DOT UP UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR MINUS_GT }]
  [oclExpression ::= oclExpression MINUS_GT ITERATE LEFT_PAR variableDeclaration SEMICOLON variableDeclaration BAR oclExpression (*) RIGHT_PAR , {EOF ENDPACKAGE CONTEXT INIT DERIVE INV DEF PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE IN THEN ELSE ENDIF COMMA DOT COLON SEMICOLON BAR UP DOT_DOT UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR RIGHT_BRK RIGHT_BRA MINUS_GT }]
  [oclExpression ::= oclExpression (*) GE oclExpression , {IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE DOT UP UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR MINUS_GT }]
  [oclExpression ::= oclExpression (*) XOR oclExpression , {IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE DOT UP UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR MINUS_GT }]
  [oclExpression ::= oclExpression (*) UP simpleName LEFT_PAR oclMessageArgumentList RIGHT_PAR , {IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE DOT UP UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR MINUS_GT }]
  [oclExpression ::= oclExpression (*) DOT simpleName isMarkedPre , {IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE DOT UP UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR MINUS_GT }]
  [oclExpression ::= oclExpression (*) MINUS_GT ITERATE LEFT_PAR variableDeclaration SEMICOLON variableDeclaration BAR oclExpression RIGHT_PAR , {IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE DOT UP UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR MINUS_GT }]
  [oclExpression ::= oclExpression (*) DIVIDE oclExpression , {IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE DOT UP UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR MINUS_GT }]
  [oclExpression ::= oclExpression (*) GT oclExpression , {IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE DOT UP UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR MINUS_GT }]
  [oclExpression ::= oclExpression (*) AND oclExpression , {IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE DOT UP UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR MINUS_GT }]
  [oclExpression ::= oclExpression (*) UP_UP simpleName LEFT_PAR oclMessageArgumentList RIGHT_PAR , {IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE DOT UP UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR MINUS_GT }]
}
transition on XOR to state [74]
transition on EQ to state [73]
transition on DOT to state [72]
transition on MINUS to state [71]
transition on GE to state [70]
transition on LEFT_BRK to state [69]
transition on RIGHT_PAR to state [109]
transition on DIVIDE to state [68]
transition on LEFT_PAR to state [67]
transition on MINUS_GT to state [66]
transition on LE to state [65]
transition on GT to state [64]
transition on IMPLIES to state [63]
transition on UP to state [62]
transition on UP_UP to state [61]
transition on OR to state [60]
transition on PLUS to state [59]
transition on NE to state [58]
transition on LT to state [57]
transition on AND to state [56]
transition on TIMES to state [55]

-------------------
lalr_state [109]: {
  [oclExpression ::= oclExpression MINUS_GT ITERATE LEFT_PAR variableDeclaration SEMICOLON variableDeclaration BAR oclExpression RIGHT_PAR (*) , {EOF ENDPACKAGE CONTEXT INIT DERIVE INV DEF PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE IN THEN ELSE ENDIF COMMA DOT COLON SEMICOLON BAR UP DOT_DOT UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR RIGHT_BRK RIGHT_BRA MINUS_GT }]
}

-------------------
lalr_state [110]: {
  [oclExpression ::= oclExpression (*) LEFT_BRK argumentList RIGHT_BRK isMarkedPre , {EOF ENDPACKAGE CONTEXT INIT DERIVE INV DEF PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE IN THEN ELSE ENDIF COMMA DOT COLON SEMICOLON BAR UP DOT_DOT UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR RIGHT_BRK RIGHT_BRA MINUS_GT }]
  [oclExpression ::= oclExpression (*) EQ oclExpression , {EOF ENDPACKAGE CONTEXT INIT DERIVE INV DEF PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE IN THEN ELSE ENDIF COMMA DOT COLON SEMICOLON BAR UP DOT_DOT UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR RIGHT_BRK RIGHT_BRA MINUS_GT }]
  [oclExpression ::= oclExpression (*) IMPLIES oclExpression , {EOF ENDPACKAGE CONTEXT INIT DERIVE INV DEF PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE IN THEN ELSE ENDIF COMMA DOT COLON SEMICOLON BAR UP DOT_DOT UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR RIGHT_BRK RIGHT_BRA MINUS_GT }]
  [oclExpression ::= oclExpression (*) UP simpleName LEFT_PAR RIGHT_PAR , {EOF ENDPACKAGE CONTEXT INIT DERIVE INV DEF PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE IN THEN ELSE ENDIF COMMA DOT COLON SEMICOLON BAR UP DOT_DOT UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR RIGHT_BRK RIGHT_BRA MINUS_GT }]
  [oclExpression ::= oclExpression (*) LEFT_PAR arguments RIGHT_PAR , {EOF ENDPACKAGE CONTEXT INIT DERIVE INV DEF PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE IN THEN ELSE ENDIF COMMA DOT COLON SEMICOLON BAR UP DOT_DOT UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR RIGHT_BRK RIGHT_BRA MINUS_GT }]
  [oclExpression ::= oclExpression LE oclExpression (*) , {EOF ENDPACKAGE CONTEXT INIT DERIVE INV DEF PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE IN THEN ELSE ENDIF COMMA DOT COLON SEMICOLON BAR UP DOT_DOT UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR RIGHT_BRK RIGHT_BRA MINUS_GT }]
  [oclExpression ::= oclExpression (*) MINUS_GT ITERATE LEFT_PAR variableDeclaration BAR oclExpression RIGHT_PAR , {EOF ENDPACKAGE CONTEXT INIT DERIVE INV DEF PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE IN THEN ELSE ENDIF COMMA DOT COLON SEMICOLON BAR UP DOT_DOT UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR RIGHT_BRK RIGHT_BRA MINUS_GT }]
  [oclExpression ::= oclExpression (*) PLUS oclExpression , {EOF ENDPACKAGE CONTEXT INIT DERIVE INV DEF PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE IN THEN ELSE ENDIF COMMA DOT COLON SEMICOLON BAR UP DOT_DOT UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR RIGHT_BRK RIGHT_BRA MINUS_GT }]
  [oclExpression ::= oclExpression (*) LE oclExpression , {EOF ENDPACKAGE CONTEXT INIT DERIVE INV DEF PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE IN THEN ELSE ENDIF COMMA DOT COLON SEMICOLON BAR UP DOT_DOT UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR RIGHT_BRK RIGHT_BRA MINUS_GT }]
  [oclExpression ::= oclExpression (*) OR oclExpression , {EOF ENDPACKAGE CONTEXT INIT DERIVE INV DEF PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE IN THEN ELSE ENDIF COMMA DOT COLON SEMICOLON BAR UP DOT_DOT UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR RIGHT_BRK RIGHT_BRA MINUS_GT }]
  [oclExpression ::= oclExpression (*) UP_UP simpleName LEFT_PAR RIGHT_PAR , {EOF ENDPACKAGE CONTEXT INIT DERIVE INV DEF PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE IN THEN ELSE ENDIF COMMA DOT COLON SEMICOLON BAR UP DOT_DOT UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR RIGHT_BRK RIGHT_BRA MINUS_GT }]
  [oclExpression ::= oclExpression (*) MINUS_GT simpleName , {EOF ENDPACKAGE CONTEXT INIT DERIVE INV DEF PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE IN THEN ELSE ENDIF COMMA DOT COLON SEMICOLON BAR UP DOT_DOT UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR RIGHT_BRK RIGHT_BRA MINUS_GT }]
  [oclExpression ::= oclExpression (*) TIMES oclExpression , {EOF ENDPACKAGE CONTEXT INIT DERIVE INV DEF PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE IN THEN ELSE ENDIF COMMA DOT COLON SEMICOLON BAR UP DOT_DOT UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR RIGHT_BRK RIGHT_BRA MINUS_GT }]
  [oclExpression ::= oclExpression (*) LT oclExpression , {EOF ENDPACKAGE CONTEXT INIT DERIVE INV DEF PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE IN THEN ELSE ENDIF COMMA DOT COLON SEMICOLON BAR UP DOT_DOT UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR RIGHT_BRK RIGHT_BRA MINUS_GT }]
  [oclExpression ::= oclExpression (*) NE oclExpression , {EOF ENDPACKAGE CONTEXT INIT DERIVE INV DEF PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE IN THEN ELSE ENDIF COMMA DOT COLON SEMICOLON BAR UP DOT_DOT UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR RIGHT_BRK RIGHT_BRA MINUS_GT }]
  [oclExpression ::= oclExpression (*) LEFT_PAR variableDeclaration BAR oclExpression RIGHT_PAR , {EOF ENDPACKAGE CONTEXT INIT DERIVE INV DEF PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE IN THEN ELSE ENDIF COMMA DOT COLON SEMICOLON BAR UP DOT_DOT UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR RIGHT_BRK RIGHT_BRA MINUS_GT }]
  [oclExpression ::= oclExpression (*) MINUS oclExpression , {EOF ENDPACKAGE CONTEXT INIT DERIVE INV DEF PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE IN THEN ELSE ENDIF COMMA DOT COLON SEMICOLON BAR UP DOT_DOT UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR RIGHT_BRK RIGHT_BRA MINUS_GT }]
  [oclExpression ::= oclExpression (*) GE oclExpression , {EOF ENDPACKAGE CONTEXT INIT DERIVE INV DEF PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE IN THEN ELSE ENDIF COMMA DOT COLON SEMICOLON BAR UP DOT_DOT UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR RIGHT_BRK RIGHT_BRA MINUS_GT }]
  [oclExpression ::= oclExpression (*) XOR oclExpression , {EOF ENDPACKAGE CONTEXT INIT DERIVE INV DEF PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE IN THEN ELSE ENDIF COMMA DOT COLON SEMICOLON BAR UP DOT_DOT UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR RIGHT_BRK RIGHT_BRA MINUS_GT }]
  [oclExpression ::= oclExpression (*) UP simpleName LEFT_PAR oclMessageArgumentList RIGHT_PAR , {EOF ENDPACKAGE CONTEXT INIT DERIVE INV DEF PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE IN THEN ELSE ENDIF COMMA DOT COLON SEMICOLON BAR UP DOT_DOT UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR RIGHT_BRK RIGHT_BRA MINUS_GT }]
  [oclExpression ::= oclExpression (*) DOT simpleName isMarkedPre , {EOF ENDPACKAGE CONTEXT INIT DERIVE INV DEF PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE IN THEN ELSE ENDIF COMMA DOT COLON SEMICOLON BAR UP DOT_DOT UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR RIGHT_BRK RIGHT_BRA MINUS_GT }]
  [oclExpression ::= oclExpression (*) MINUS_GT ITERATE LEFT_PAR variableDeclaration SEMICOLON variableDeclaration BAR oclExpression RIGHT_PAR , {EOF ENDPACKAGE CONTEXT INIT DERIVE INV DEF PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE IN THEN ELSE ENDIF COMMA DOT COLON SEMICOLON BAR UP DOT_DOT UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR RIGHT_BRK RIGHT_BRA MINUS_GT }]
  [oclExpression ::= oclExpression (*) DIVIDE oclExpression , {EOF ENDPACKAGE CONTEXT INIT DERIVE INV DEF PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE IN THEN ELSE ENDIF COMMA DOT COLON SEMICOLON BAR UP DOT_DOT UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR RIGHT_BRK RIGHT_BRA MINUS_GT }]
  [oclExpression ::= oclExpression (*) GT oclExpression , {EOF ENDPACKAGE CONTEXT INIT DERIVE INV DEF PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE IN THEN ELSE ENDIF COMMA DOT COLON SEMICOLON BAR UP DOT_DOT UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR RIGHT_BRK RIGHT_BRA MINUS_GT }]
  [oclExpression ::= oclExpression (*) AND oclExpression , {EOF ENDPACKAGE CONTEXT INIT DERIVE INV DEF PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE IN THEN ELSE ENDIF COMMA DOT COLON SEMICOLON BAR UP DOT_DOT UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR RIGHT_BRK RIGHT_BRA MINUS_GT }]
  [oclExpression ::= oclExpression (*) UP_UP simpleName LEFT_PAR oclMessageArgumentList RIGHT_PAR , {EOF ENDPACKAGE CONTEXT INIT DERIVE INV DEF PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE IN THEN ELSE ENDIF COMMA DOT COLON SEMICOLON BAR UP DOT_DOT UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR RIGHT_BRK RIGHT_BRA MINUS_GT }]
}
transition on XOR to state [74]
transition on EQ to state [73]
transition on DOT to state [72]
transition on MINUS to state [71]
transition on GE to state [70]
transition on LEFT_BRK to state [69]
transition on DIVIDE to state [68]
transition on LEFT_PAR to state [67]
transition on MINUS_GT to state [66]
transition on LE to state [65]
transition on GT to state [64]
transition on IMPLIES to state [63]
transition on UP to state [62]
transition on UP_UP to state [61]
transition on OR to state [60]
transition on PLUS to state [59]
transition on NE to state [58]
transition on LT to state [57]
transition on AND to state [56]
transition on TIMES to state [55]

-------------------
lalr_state [111]: {
  [oclExpression ::= oclExpression (*) LEFT_BRK argumentList RIGHT_BRK isMarkedPre , {EOF ENDPACKAGE CONTEXT INIT DERIVE INV DEF PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE IN THEN ELSE ENDIF COMMA DOT COLON SEMICOLON BAR UP DOT_DOT UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR RIGHT_BRK RIGHT_BRA MINUS_GT }]
  [oclExpression ::= oclExpression (*) EQ oclExpression , {EOF ENDPACKAGE CONTEXT INIT DERIVE INV DEF PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE IN THEN ELSE ENDIF COMMA DOT COLON SEMICOLON BAR UP DOT_DOT UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR RIGHT_BRK RIGHT_BRA MINUS_GT }]
  [oclExpression ::= oclExpression (*) IMPLIES oclExpression , {EOF ENDPACKAGE CONTEXT INIT DERIVE INV DEF PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE IN THEN ELSE ENDIF COMMA DOT COLON SEMICOLON BAR UP DOT_DOT UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR RIGHT_BRK RIGHT_BRA MINUS_GT }]
  [oclExpression ::= oclExpression (*) UP simpleName LEFT_PAR RIGHT_PAR , {EOF ENDPACKAGE CONTEXT INIT DERIVE INV DEF PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE IN THEN ELSE ENDIF COMMA DOT COLON SEMICOLON BAR UP DOT_DOT UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR RIGHT_BRK RIGHT_BRA MINUS_GT }]
  [oclExpression ::= oclExpression (*) LEFT_PAR arguments RIGHT_PAR , {EOF ENDPACKAGE CONTEXT INIT DERIVE INV DEF PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE IN THEN ELSE ENDIF COMMA DOT COLON SEMICOLON BAR UP DOT_DOT UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR RIGHT_BRK RIGHT_BRA MINUS_GT }]
  [oclExpression ::= oclExpression (*) MINUS_GT ITERATE LEFT_PAR variableDeclaration BAR oclExpression RIGHT_PAR , {EOF ENDPACKAGE CONTEXT INIT DERIVE INV DEF PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE IN THEN ELSE ENDIF COMMA DOT COLON SEMICOLON BAR UP DOT_DOT UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR RIGHT_BRK RIGHT_BRA MINUS_GT }]
  [oclExpression ::= oclExpression (*) PLUS oclExpression , {EOF ENDPACKAGE CONTEXT INIT DERIVE INV DEF PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE IN THEN ELSE ENDIF COMMA DOT COLON SEMICOLON BAR UP DOT_DOT UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR RIGHT_BRK RIGHT_BRA MINUS_GT }]
  [oclExpression ::= oclExpression (*) LE oclExpression , {EOF ENDPACKAGE CONTEXT INIT DERIVE INV DEF PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE IN THEN ELSE ENDIF COMMA DOT COLON SEMICOLON BAR UP DOT_DOT UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR RIGHT_BRK RIGHT_BRA MINUS_GT }]
  [oclExpression ::= oclExpression (*) OR oclExpression , {EOF ENDPACKAGE CONTEXT INIT DERIVE INV DEF PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE IN THEN ELSE ENDIF COMMA DOT COLON SEMICOLON BAR UP DOT_DOT UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR RIGHT_BRK RIGHT_BRA MINUS_GT }]
  [oclExpression ::= oclExpression (*) UP_UP simpleName LEFT_PAR RIGHT_PAR , {EOF ENDPACKAGE CONTEXT INIT DERIVE INV DEF PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE IN THEN ELSE ENDIF COMMA DOT COLON SEMICOLON BAR UP DOT_DOT UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR RIGHT_BRK RIGHT_BRA MINUS_GT }]
  [oclExpression ::= oclExpression (*) MINUS_GT simpleName , {EOF ENDPACKAGE CONTEXT INIT DERIVE INV DEF PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE IN THEN ELSE ENDIF COMMA DOT COLON SEMICOLON BAR UP DOT_DOT UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR RIGHT_BRK RIGHT_BRA MINUS_GT }]
  [oclExpression ::= oclExpression (*) TIMES oclExpression , {EOF ENDPACKAGE CONTEXT INIT DERIVE INV DEF PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE IN THEN ELSE ENDIF COMMA DOT COLON SEMICOLON BAR UP DOT_DOT UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR RIGHT_BRK RIGHT_BRA MINUS_GT }]
  [oclExpression ::= oclExpression (*) LT oclExpression , {EOF ENDPACKAGE CONTEXT INIT DERIVE INV DEF PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE IN THEN ELSE ENDIF COMMA DOT COLON SEMICOLON BAR UP DOT_DOT UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR RIGHT_BRK RIGHT_BRA MINUS_GT }]
  [oclExpression ::= oclExpression (*) NE oclExpression , {EOF ENDPACKAGE CONTEXT INIT DERIVE INV DEF PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE IN THEN ELSE ENDIF COMMA DOT COLON SEMICOLON BAR UP DOT_DOT UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR RIGHT_BRK RIGHT_BRA MINUS_GT }]
  [oclExpression ::= oclExpression (*) LEFT_PAR variableDeclaration BAR oclExpression RIGHT_PAR , {EOF ENDPACKAGE CONTEXT INIT DERIVE INV DEF PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE IN THEN ELSE ENDIF COMMA DOT COLON SEMICOLON BAR UP DOT_DOT UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR RIGHT_BRK RIGHT_BRA MINUS_GT }]
  [oclExpression ::= oclExpression (*) MINUS oclExpression , {EOF ENDPACKAGE CONTEXT INIT DERIVE INV DEF PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE IN THEN ELSE ENDIF COMMA DOT COLON SEMICOLON BAR UP DOT_DOT UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR RIGHT_BRK RIGHT_BRA MINUS_GT }]
  [oclExpression ::= oclExpression (*) GE oclExpression , {EOF ENDPACKAGE CONTEXT INIT DERIVE INV DEF PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE IN THEN ELSE ENDIF COMMA DOT COLON SEMICOLON BAR UP DOT_DOT UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR RIGHT_BRK RIGHT_BRA MINUS_GT }]
  [oclExpression ::= oclExpression (*) XOR oclExpression , {EOF ENDPACKAGE CONTEXT INIT DERIVE INV DEF PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE IN THEN ELSE ENDIF COMMA DOT COLON SEMICOLON BAR UP DOT_DOT UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR RIGHT_BRK RIGHT_BRA MINUS_GT }]
  [oclExpression ::= oclExpression (*) UP simpleName LEFT_PAR oclMessageArgumentList RIGHT_PAR , {EOF ENDPACKAGE CONTEXT INIT DERIVE INV DEF PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE IN THEN ELSE ENDIF COMMA DOT COLON SEMICOLON BAR UP DOT_DOT UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR RIGHT_BRK RIGHT_BRA MINUS_GT }]
  [oclExpression ::= oclExpression (*) DOT simpleName isMarkedPre , {EOF ENDPACKAGE CONTEXT INIT DERIVE INV DEF PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE IN THEN ELSE ENDIF COMMA DOT COLON SEMICOLON BAR UP DOT_DOT UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR RIGHT_BRK RIGHT_BRA MINUS_GT }]
  [oclExpression ::= oclExpression (*) MINUS_GT ITERATE LEFT_PAR variableDeclaration SEMICOLON variableDeclaration BAR oclExpression RIGHT_PAR , {EOF ENDPACKAGE CONTEXT INIT DERIVE INV DEF PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE IN THEN ELSE ENDIF COMMA DOT COLON SEMICOLON BAR UP DOT_DOT UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR RIGHT_BRK RIGHT_BRA MINUS_GT }]
  [oclExpression ::= oclExpression GT oclExpression (*) , {EOF ENDPACKAGE CONTEXT INIT DERIVE INV DEF PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE IN THEN ELSE ENDIF COMMA DOT COLON SEMICOLON BAR UP DOT_DOT UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR RIGHT_BRK RIGHT_BRA MINUS_GT }]
  [oclExpression ::= oclExpression (*) DIVIDE oclExpression , {EOF ENDPACKAGE CONTEXT INIT DERIVE INV DEF PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE IN THEN ELSE ENDIF COMMA DOT COLON SEMICOLON BAR UP DOT_DOT UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR RIGHT_BRK RIGHT_BRA MINUS_GT }]
  [oclExpression ::= oclExpression (*) GT oclExpression , {EOF ENDPACKAGE CONTEXT INIT DERIVE INV DEF PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE IN THEN ELSE ENDIF COMMA DOT COLON SEMICOLON BAR UP DOT_DOT UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR RIGHT_BRK RIGHT_BRA MINUS_GT }]
  [oclExpression ::= oclExpression (*) AND oclExpression , {EOF ENDPACKAGE CONTEXT INIT DERIVE INV DEF PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE IN THEN ELSE ENDIF COMMA DOT COLON SEMICOLON BAR UP DOT_DOT UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR RIGHT_BRK RIGHT_BRA MINUS_GT }]
  [oclExpression ::= oclExpression (*) UP_UP simpleName LEFT_PAR oclMessageArgumentList RIGHT_PAR , {EOF ENDPACKAGE CONTEXT INIT DERIVE INV DEF PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE IN THEN ELSE ENDIF COMMA DOT COLON SEMICOLON BAR UP DOT_DOT UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR RIGHT_BRK RIGHT_BRA MINUS_GT }]
}
transition on XOR to state [74]
transition on EQ to state [73]
transition on DOT to state [72]
transition on MINUS to state [71]
transition on GE to state [70]
transition on LEFT_BRK to state [69]
transition on DIVIDE to state [68]
transition on LEFT_PAR to state [67]
transition on MINUS_GT to state [66]
transition on LE to state [65]
transition on GT to state [64]
transition on IMPLIES to state [63]
transition on UP to state [62]
transition on UP_UP to state [61]
transition on OR to state [60]
transition on PLUS to state [59]
transition on NE to state [58]
transition on LT to state [57]
transition on AND to state [56]
transition on TIMES to state [55]

-------------------
lalr_state [112]: {
  [oclExpression ::= oclExpression (*) LEFT_BRK argumentList RIGHT_BRK isMarkedPre , {EOF ENDPACKAGE CONTEXT INIT DERIVE INV DEF PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE IN THEN ELSE ENDIF COMMA DOT COLON SEMICOLON BAR UP DOT_DOT UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR RIGHT_BRK RIGHT_BRA MINUS_GT }]
  [oclExpression ::= oclExpression IMPLIES oclExpression (*) , {EOF ENDPACKAGE CONTEXT INIT DERIVE INV DEF PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE IN THEN ELSE ENDIF COMMA DOT COLON SEMICOLON BAR UP DOT_DOT UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR RIGHT_BRK RIGHT_BRA MINUS_GT }]
  [oclExpression ::= oclExpression (*) EQ oclExpression , {EOF ENDPACKAGE CONTEXT INIT DERIVE INV DEF PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE IN THEN ELSE ENDIF COMMA DOT COLON SEMICOLON BAR UP DOT_DOT UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR RIGHT_BRK RIGHT_BRA MINUS_GT }]
  [oclExpression ::= oclExpression (*) IMPLIES oclExpression , {EOF ENDPACKAGE CONTEXT INIT DERIVE INV DEF PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE IN THEN ELSE ENDIF COMMA DOT COLON SEMICOLON BAR UP DOT_DOT UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR RIGHT_BRK RIGHT_BRA MINUS_GT }]
  [oclExpression ::= oclExpression (*) UP simpleName LEFT_PAR RIGHT_PAR , {EOF ENDPACKAGE CONTEXT INIT DERIVE INV DEF PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE IN THEN ELSE ENDIF COMMA DOT COLON SEMICOLON BAR UP DOT_DOT UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR RIGHT_BRK RIGHT_BRA MINUS_GT }]
  [oclExpression ::= oclExpression (*) LEFT_PAR arguments RIGHT_PAR , {EOF ENDPACKAGE CONTEXT INIT DERIVE INV DEF PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE IN THEN ELSE ENDIF COMMA DOT COLON SEMICOLON BAR UP DOT_DOT UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR RIGHT_BRK RIGHT_BRA MINUS_GT }]
  [oclExpression ::= oclExpression (*) MINUS_GT ITERATE LEFT_PAR variableDeclaration BAR oclExpression RIGHT_PAR , {EOF ENDPACKAGE CONTEXT INIT DERIVE INV DEF PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE IN THEN ELSE ENDIF COMMA DOT COLON SEMICOLON BAR UP DOT_DOT UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR RIGHT_BRK RIGHT_BRA MINUS_GT }]
  [oclExpression ::= oclExpression (*) PLUS oclExpression , {EOF ENDPACKAGE CONTEXT INIT DERIVE INV DEF PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE IN THEN ELSE ENDIF COMMA DOT COLON SEMICOLON BAR UP DOT_DOT UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR RIGHT_BRK RIGHT_BRA MINUS_GT }]
  [oclExpression ::= oclExpression (*) LE oclExpression , {EOF ENDPACKAGE CONTEXT INIT DERIVE INV DEF PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE IN THEN ELSE ENDIF COMMA DOT COLON SEMICOLON BAR UP DOT_DOT UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR RIGHT_BRK RIGHT_BRA MINUS_GT }]
  [oclExpression ::= oclExpression (*) OR oclExpression , {EOF ENDPACKAGE CONTEXT INIT DERIVE INV DEF PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE IN THEN ELSE ENDIF COMMA DOT COLON SEMICOLON BAR UP DOT_DOT UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR RIGHT_BRK RIGHT_BRA MINUS_GT }]
  [oclExpression ::= oclExpression (*) UP_UP simpleName LEFT_PAR RIGHT_PAR , {EOF ENDPACKAGE CONTEXT INIT DERIVE INV DEF PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE IN THEN ELSE ENDIF COMMA DOT COLON SEMICOLON BAR UP DOT_DOT UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR RIGHT_BRK RIGHT_BRA MINUS_GT }]
  [oclExpression ::= oclExpression (*) MINUS_GT simpleName , {EOF ENDPACKAGE CONTEXT INIT DERIVE INV DEF PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE IN THEN ELSE ENDIF COMMA DOT COLON SEMICOLON BAR UP DOT_DOT UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR RIGHT_BRK RIGHT_BRA MINUS_GT }]
  [oclExpression ::= oclExpression (*) TIMES oclExpression , {EOF ENDPACKAGE CONTEXT INIT DERIVE INV DEF PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE IN THEN ELSE ENDIF COMMA DOT COLON SEMICOLON BAR UP DOT_DOT UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR RIGHT_BRK RIGHT_BRA MINUS_GT }]
  [oclExpression ::= oclExpression (*) LT oclExpression , {EOF ENDPACKAGE CONTEXT INIT DERIVE INV DEF PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE IN THEN ELSE ENDIF COMMA DOT COLON SEMICOLON BAR UP DOT_DOT UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR RIGHT_BRK RIGHT_BRA MINUS_GT }]
  [oclExpression ::= oclExpression (*) NE oclExpression , {EOF ENDPACKAGE CONTEXT INIT DERIVE INV DEF PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE IN THEN ELSE ENDIF COMMA DOT COLON SEMICOLON BAR UP DOT_DOT UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR RIGHT_BRK RIGHT_BRA MINUS_GT }]
  [oclExpression ::= oclExpression (*) LEFT_PAR variableDeclaration BAR oclExpression RIGHT_PAR , {EOF ENDPACKAGE CONTEXT INIT DERIVE INV DEF PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE IN THEN ELSE ENDIF COMMA DOT COLON SEMICOLON BAR UP DOT_DOT UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR RIGHT_BRK RIGHT_BRA MINUS_GT }]
  [oclExpression ::= oclExpression (*) MINUS oclExpression , {EOF ENDPACKAGE CONTEXT INIT DERIVE INV DEF PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE IN THEN ELSE ENDIF COMMA DOT COLON SEMICOLON BAR UP DOT_DOT UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR RIGHT_BRK RIGHT_BRA MINUS_GT }]
  [oclExpression ::= oclExpression (*) GE oclExpression , {EOF ENDPACKAGE CONTEXT INIT DERIVE INV DEF PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE IN THEN ELSE ENDIF COMMA DOT COLON SEMICOLON BAR UP DOT_DOT UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR RIGHT_BRK RIGHT_BRA MINUS_GT }]
  [oclExpression ::= oclExpression (*) XOR oclExpression , {EOF ENDPACKAGE CONTEXT INIT DERIVE INV DEF PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE IN THEN ELSE ENDIF COMMA DOT COLON SEMICOLON BAR UP DOT_DOT UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR RIGHT_BRK RIGHT_BRA MINUS_GT }]
  [oclExpression ::= oclExpression (*) UP simpleName LEFT_PAR oclMessageArgumentList RIGHT_PAR , {EOF ENDPACKAGE CONTEXT INIT DERIVE INV DEF PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE IN THEN ELSE ENDIF COMMA DOT COLON SEMICOLON BAR UP DOT_DOT UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR RIGHT_BRK RIGHT_BRA MINUS_GT }]
  [oclExpression ::= oclExpression (*) DOT simpleName isMarkedPre , {EOF ENDPACKAGE CONTEXT INIT DERIVE INV DEF PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE IN THEN ELSE ENDIF COMMA DOT COLON SEMICOLON BAR UP DOT_DOT UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR RIGHT_BRK RIGHT_BRA MINUS_GT }]
  [oclExpression ::= oclExpression (*) MINUS_GT ITERATE LEFT_PAR variableDeclaration SEMICOLON variableDeclaration BAR oclExpression RIGHT_PAR , {EOF ENDPACKAGE CONTEXT INIT DERIVE INV DEF PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE IN THEN ELSE ENDIF COMMA DOT COLON SEMICOLON BAR UP DOT_DOT UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR RIGHT_BRK RIGHT_BRA MINUS_GT }]
  [oclExpression ::= oclExpression (*) DIVIDE oclExpression , {EOF ENDPACKAGE CONTEXT INIT DERIVE INV DEF PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE IN THEN ELSE ENDIF COMMA DOT COLON SEMICOLON BAR UP DOT_DOT UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR RIGHT_BRK RIGHT_BRA MINUS_GT }]
  [oclExpression ::= oclExpression (*) GT oclExpression , {EOF ENDPACKAGE CONTEXT INIT DERIVE INV DEF PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE IN THEN ELSE ENDIF COMMA DOT COLON SEMICOLON BAR UP DOT_DOT UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR RIGHT_BRK RIGHT_BRA MINUS_GT }]
  [oclExpression ::= oclExpression (*) AND oclExpression , {EOF ENDPACKAGE CONTEXT INIT DERIVE INV DEF PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE IN THEN ELSE ENDIF COMMA DOT COLON SEMICOLON BAR UP DOT_DOT UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR RIGHT_BRK RIGHT_BRA MINUS_GT }]
  [oclExpression ::= oclExpression (*) UP_UP simpleName LEFT_PAR oclMessageArgumentList RIGHT_PAR , {EOF ENDPACKAGE CONTEXT INIT DERIVE INV DEF PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE IN THEN ELSE ENDIF COMMA DOT COLON SEMICOLON BAR UP DOT_DOT UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR RIGHT_BRK RIGHT_BRA MINUS_GT }]
}
transition on XOR to state [74]
transition on EQ to state [73]
transition on DOT to state [72]
transition on MINUS to state [71]
transition on GE to state [70]
transition on LEFT_BRK to state [69]
transition on DIVIDE to state [68]
transition on LEFT_PAR to state [67]
transition on MINUS_GT to state [66]
transition on LE to state [65]
transition on GT to state [64]
transition on IMPLIES to state [63]
transition on UP to state [62]
transition on UP_UP to state [61]
transition on OR to state [60]
transition on PLUS to state [59]
transition on NE to state [58]
transition on LT to state [57]
transition on AND to state [56]
transition on TIMES to state [55]

-------------------
lalr_state [113]: {
  [oclExpression ::= oclExpression UP simpleName (*) LEFT_PAR RIGHT_PAR , {EOF ENDPACKAGE CONTEXT INIT DERIVE INV DEF PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE IN THEN ELSE ENDIF COMMA DOT COLON SEMICOLON BAR UP DOT_DOT UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR RIGHT_BRK RIGHT_BRA MINUS_GT }]
  [oclExpression ::= oclExpression UP simpleName (*) LEFT_PAR oclMessageArgumentList RIGHT_PAR , {EOF ENDPACKAGE CONTEXT INIT DERIVE INV DEF PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE IN THEN ELSE ENDIF COMMA DOT COLON SEMICOLON BAR UP DOT_DOT UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR RIGHT_BRK RIGHT_BRA MINUS_GT }]
}
transition on LEFT_PAR to state [114]

-------------------
lalr_state [114]: {
  [oclExpression ::= (*) oclExpression UP simpleName LEFT_PAR oclMessageArgumentList RIGHT_PAR , {IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE COMMA DOT UP UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR MINUS_GT }]
  [oclExpression ::= (*) oclExpression EQ oclExpression , {IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE COMMA DOT UP UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR MINUS_GT }]
  [oclExpression ::= (*) oclExpression TIMES oclExpression , {IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE COMMA DOT UP UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR MINUS_GT }]
  [oclExpression ::= (*) oclExpression DOT simpleName isMarkedPre , {IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE COMMA DOT UP UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR MINUS_GT }]
  [primitiveLiteralExp ::= (*) TRUE , {IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE COMMA DOT UP UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR MINUS_GT }]
  [literalExp ::= (*) tupleLiteralExp , {IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE COMMA DOT UP UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR MINUS_GT }]
  [oclExpression ::= (*) oclExpression IMPLIES oclExpression , {IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE COMMA DOT UP UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR MINUS_GT }]
  [oclExpression ::= (*) oclExpression LT oclExpression , {IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE COMMA DOT UP UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR MINUS_GT }]
  [oclExpression ::= (*) oclExpression MINUS_GT ITERATE LEFT_PAR variableDeclaration SEMICOLON variableDeclaration BAR oclExpression RIGHT_PAR , {IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE COMMA DOT UP UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR MINUS_GT }]
  [oclExpression ::= oclExpression UP simpleName LEFT_PAR (*) RIGHT_PAR , {EOF ENDPACKAGE CONTEXT INIT DERIVE INV DEF PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE IN THEN ELSE ENDIF COMMA DOT COLON SEMICOLON BAR UP DOT_DOT UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR RIGHT_BRK RIGHT_BRA MINUS_GT }]
  [tupleLiteralExp ::= (*) TUPLE LEFT_BRA variableDeclarationList RIGHT_BRA , {IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE COMMA DOT UP UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR MINUS_GT }]
  [collectionKind ::= (*) SET , {LEFT_BRA }]
  [oclMessageArgument ::= (*) oclExpression , {COMMA RIGHT_PAR }]
  [oclExpression ::= (*) oclExpression UP simpleName LEFT_PAR RIGHT_PAR , {IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE COMMA DOT UP UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR MINUS_GT }]
  [oclExpression ::= (*) oclExpression NE oclExpression , {IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE COMMA DOT UP UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR MINUS_GT }]
  [oclExpression ::= (*) oclExpression DIVIDE oclExpression , {IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE COMMA DOT UP UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR MINUS_GT }]
  [oclExpression ::= (*) oclExpression LEFT_PAR arguments RIGHT_PAR , {IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE COMMA DOT UP UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR MINUS_GT }]
  [primitiveLiteralExp ::= (*) FALSE , {IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE COMMA DOT UP UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR MINUS_GT }]
  [literalExp ::= (*) primitiveLiteralExp , {IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE COMMA DOT UP UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR MINUS_GT }]
  [oclMessageArgumentList ::= (*) oclMessageArgument , {COMMA RIGHT_PAR }]
  [oclExpression ::= (*) LET variableDeclarationList IN oclExpression , {IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE COMMA DOT UP UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR MINUS_GT }]
  [oclExpression ::= (*) oclExpression GT oclExpression , {IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE COMMA DOT UP UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR MINUS_GT }]
  [oclExpression ::= (*) oclExpression MINUS_GT ITERATE LEFT_PAR variableDeclaration BAR oclExpression RIGHT_PAR , {IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE COMMA DOT UP UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR MINUS_GT }]
  [oclExpression ::= (*) literalExp , {IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE COMMA DOT UP UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR MINUS_GT }]
  [primitiveLiteralExp ::= (*) INTEGER , {IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE COMMA DOT UP UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR MINUS_GT }]
  [collectionKind ::= (*) BAG , {LEFT_BRA }]
  [oclExpression ::= (*) oclExpression AND oclExpression , {IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE COMMA DOT UP UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR MINUS_GT }]
  [oclExpression ::= (*) oclExpression PLUS oclExpression , {IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE COMMA DOT UP UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR MINUS_GT }]
  [oclExpression ::= (*) oclExpression LEFT_PAR variableDeclaration BAR oclExpression RIGHT_PAR , {IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE COMMA DOT UP UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR MINUS_GT }]
  [pathName ::= (*) simpleName , {IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE COMMA DOT UP AT COLON_COLON UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR MINUS_GT }]
  [oclMessageArgumentList ::= (*) oclMessageArgumentList COMMA oclMessageArgument , {COMMA RIGHT_PAR }]
  [oclExpression ::= (*) oclExpression UP_UP simpleName LEFT_PAR oclMessageArgumentList RIGHT_PAR , {IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE COMMA DOT UP UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR MINUS_GT }]
  [oclExpression ::= (*) oclExpression LE oclExpression , {IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE COMMA DOT UP UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR MINUS_GT }]
  [oclExpression ::= (*) NOT oclExpression , {IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE COMMA DOT UP UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR MINUS_GT }]
  [oclExpression ::= (*) LEFT_PAR oclExpression RIGHT_PAR , {IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE COMMA DOT UP UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR MINUS_GT }]
  [primitiveLiteralExp ::= (*) REAL , {IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE COMMA DOT UP UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR MINUS_GT }]
  [collectionKind ::= (*) SEQUENCE , {LEFT_BRA }]
  [oclExpression ::= (*) oclExpression OR oclExpression , {IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE COMMA DOT UP UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR MINUS_GT }]
  [oclExpression ::= (*) oclExpression MINUS oclExpression , {IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE COMMA DOT UP UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR MINUS_GT }]
  [oclExpression ::= (*) oclExpression LEFT_BRK argumentList RIGHT_BRK isMarkedPre , {IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE COMMA DOT UP UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR MINUS_GT }]
  [pathName ::= (*) pathName COLON_COLON simpleName , {IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE COMMA DOT UP AT COLON_COLON UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR MINUS_GT }]
  [collectionLiteralExp ::= (*) collectionKind LEFT_BRA collectionLiteralParts RIGHT_BRA , {IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE COMMA DOT UP UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR MINUS_GT }]
  [oclMessageArgument ::= (*) QUESTION , {COMMA RIGHT_PAR }]
  [oclExpression ::= (*) oclExpression UP_UP simpleName LEFT_PAR RIGHT_PAR , {IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE COMMA DOT UP UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR MINUS_GT }]
  [oclExpression ::= (*) oclExpression GE oclExpression , {IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE COMMA DOT UP UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR MINUS_GT }]
  [oclExpression ::= (*) MINUS oclExpression , {IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE COMMA DOT UP UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR MINUS_GT }]
  [oclExpression ::= (*) pathName isMarkedPre , {IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE COMMA DOT UP UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR MINUS_GT }]
  [primitiveLiteralExp ::= (*) STRING , {IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE COMMA DOT UP UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR MINUS_GT }]
  [collectionKind ::= (*) COLLECTION , {LEFT_BRA }]
  [literalExp ::= (*) collectionLiteralExp , {IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE COMMA DOT UP UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR MINUS_GT }]
  [oclExpression ::= (*) oclExpression XOR oclExpression , {IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE COMMA DOT UP UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR MINUS_GT }]
  [oclExpression ::= (*) IF oclExpression THEN oclExpression ELSE oclExpression ENDIF , {IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE COMMA DOT UP UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR MINUS_GT }]
  [oclExpression ::= (*) oclExpression MINUS_GT simpleName , {IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE COMMA DOT UP UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR MINUS_GT }]
  [simpleName ::= (*) SIMPLE_NAME , {IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE COMMA DOT UP AT COLON_COLON UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR MINUS_GT }]
  [oclExpression ::= oclExpression UP simpleName LEFT_PAR (*) oclMessageArgumentList RIGHT_PAR , {EOF ENDPACKAGE CONTEXT INIT DERIVE INV DEF PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE IN THEN ELSE ENDIF COMMA DOT COLON SEMICOLON BAR UP DOT_DOT UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR RIGHT_BRK RIGHT_BRA MINUS_GT }]
  [collectionLiteralExp ::= (*) collectionKind LEFT_BRA RIGHT_BRA , {IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE COMMA DOT UP UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR MINUS_GT }]
  [oclMessageArgument ::= (*) QUESTION COLON type , {COMMA RIGHT_PAR }]
}
transition on tupleLiteralExp to state [54]
transition on oclExpression to state [119]
transition on REAL to state [52]
transition on INTEGER to state [51]
transition on pathName to state [50]
transition on SIMPLE_NAME to state [12]
transition on LET to state [49]
transition on FALSE to state [48]
transition on MINUS to state [47]
transition on COLLECTION to state [28]
transition on oclMessageArgumentList to state [118]
transition on SET to state [20]
transition on RIGHT_PAR to state [117]
transition on simpleName to state [26]
transition on collectionLiteralExp to state [46]
transition on LEFT_PAR to state [45]
transition on STRING to state [44]
transition on oclMessageArgument to state [116]
transition on IF to state [43]
transition on TRUE to state [42]
transition on collectionKind to state [41]
transition on NOT to state [40]
transition on primitiveLiteralExp to state [39]
transition on TUPLE to state [38]
transition on literalExp to state [37]
transition on BAG to state [25]
transition on QUESTION to state [115]
transition on SEQUENCE to state [22]

-------------------
lalr_state [115]: {
  [oclMessageArgument ::= QUESTION (*) COLON type , {COMMA RIGHT_PAR }]
  [oclMessageArgument ::= QUESTION (*) , {COMMA RIGHT_PAR }]
}
transition on COLON to state [123]

-------------------
lalr_state [116]: {
  [oclMessageArgumentList ::= oclMessageArgument (*) , {COMMA RIGHT_PAR }]
}

-------------------
lalr_state [117]: {
  [oclExpression ::= oclExpression UP simpleName LEFT_PAR RIGHT_PAR (*) , {EOF ENDPACKAGE CONTEXT INIT DERIVE INV DEF PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE IN THEN ELSE ENDIF COMMA DOT COLON SEMICOLON BAR UP DOT_DOT UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR RIGHT_BRK RIGHT_BRA MINUS_GT }]
}

-------------------
lalr_state [118]: {
  [oclMessageArgumentList ::= oclMessageArgumentList (*) COMMA oclMessageArgument , {COMMA RIGHT_PAR }]
  [oclExpression ::= oclExpression UP simpleName LEFT_PAR oclMessageArgumentList (*) RIGHT_PAR , {EOF ENDPACKAGE CONTEXT INIT DERIVE INV DEF PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE IN THEN ELSE ENDIF COMMA DOT COLON SEMICOLON BAR UP DOT_DOT UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR RIGHT_BRK RIGHT_BRA MINUS_GT }]
}
transition on RIGHT_PAR to state [121]
transition on COMMA to state [120]

-------------------
lalr_state [119]: {
  [oclExpression ::= oclExpression (*) LEFT_BRK argumentList RIGHT_BRK isMarkedPre , {IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE COMMA DOT UP UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR MINUS_GT }]
  [oclExpression ::= oclExpression (*) EQ oclExpression , {IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE COMMA DOT UP UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR MINUS_GT }]
  [oclExpression ::= oclExpression (*) IMPLIES oclExpression , {IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE COMMA DOT UP UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR MINUS_GT }]
  [oclExpression ::= oclExpression (*) UP simpleName LEFT_PAR RIGHT_PAR , {IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE COMMA DOT UP UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR MINUS_GT }]
  [oclExpression ::= oclExpression (*) LEFT_PAR arguments RIGHT_PAR , {IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE COMMA DOT UP UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR MINUS_GT }]
  [oclExpression ::= oclExpression (*) MINUS_GT ITERATE LEFT_PAR variableDeclaration BAR oclExpression RIGHT_PAR , {IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE COMMA DOT UP UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR MINUS_GT }]
  [oclExpression ::= oclExpression (*) PLUS oclExpression , {IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE COMMA DOT UP UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR MINUS_GT }]
  [oclExpression ::= oclExpression (*) LE oclExpression , {IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE COMMA DOT UP UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR MINUS_GT }]
  [oclExpression ::= oclExpression (*) OR oclExpression , {IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE COMMA DOT UP UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR MINUS_GT }]
  [oclExpression ::= oclExpression (*) UP_UP simpleName LEFT_PAR RIGHT_PAR , {IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE COMMA DOT UP UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR MINUS_GT }]
  [oclExpression ::= oclExpression (*) MINUS_GT simpleName , {IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE COMMA DOT UP UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR MINUS_GT }]
  [oclExpression ::= oclExpression (*) TIMES oclExpression , {IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE COMMA DOT UP UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR MINUS_GT }]
  [oclExpression ::= oclExpression (*) LT oclExpression , {IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE COMMA DOT UP UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR MINUS_GT }]
  [oclExpression ::= oclExpression (*) NE oclExpression , {IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE COMMA DOT UP UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR MINUS_GT }]
  [oclExpression ::= oclExpression (*) LEFT_PAR variableDeclaration BAR oclExpression RIGHT_PAR , {IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE COMMA DOT UP UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR MINUS_GT }]
  [oclExpression ::= oclExpression (*) MINUS oclExpression , {IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE COMMA DOT UP UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR MINUS_GT }]
  [oclExpression ::= oclExpression (*) GE oclExpression , {IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE COMMA DOT UP UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR MINUS_GT }]
  [oclExpression ::= oclExpression (*) XOR oclExpression , {IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE COMMA DOT UP UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR MINUS_GT }]
  [oclExpression ::= oclExpression (*) UP simpleName LEFT_PAR oclMessageArgumentList RIGHT_PAR , {IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE COMMA DOT UP UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR MINUS_GT }]
  [oclMessageArgument ::= oclExpression (*) , {COMMA RIGHT_PAR }]
  [oclExpression ::= oclExpression (*) DOT simpleName isMarkedPre , {IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE COMMA DOT UP UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR MINUS_GT }]
  [oclExpression ::= oclExpression (*) MINUS_GT ITERATE LEFT_PAR variableDeclaration SEMICOLON variableDeclaration BAR oclExpression RIGHT_PAR , {IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE COMMA DOT UP UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR MINUS_GT }]
  [oclExpression ::= oclExpression (*) DIVIDE oclExpression , {IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE COMMA DOT UP UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR MINUS_GT }]
  [oclExpression ::= oclExpression (*) GT oclExpression , {IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE COMMA DOT UP UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR MINUS_GT }]
  [oclExpression ::= oclExpression (*) AND oclExpression , {IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE COMMA DOT UP UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR MINUS_GT }]
  [oclExpression ::= oclExpression (*) UP_UP simpleName LEFT_PAR oclMessageArgumentList RIGHT_PAR , {IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE COMMA DOT UP UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR MINUS_GT }]
}
transition on XOR to state [74]
transition on EQ to state [73]
transition on DOT to state [72]
transition on MINUS to state [71]
transition on GE to state [70]
transition on LEFT_BRK to state [69]
transition on DIVIDE to state [68]
transition on LEFT_PAR to state [67]
transition on MINUS_GT to state [66]
transition on LE to state [65]
transition on GT to state [64]
transition on IMPLIES to state [63]
transition on UP to state [62]
transition on UP_UP to state [61]
transition on OR to state [60]
transition on PLUS to state [59]
transition on NE to state [58]
transition on LT to state [57]
transition on AND to state [56]
transition on TIMES to state [55]

-------------------
lalr_state [120]: {
  [oclExpression ::= (*) oclExpression UP simpleName LEFT_PAR oclMessageArgumentList RIGHT_PAR , {IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE COMMA DOT UP UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR MINUS_GT }]
  [oclExpression ::= (*) oclExpression EQ oclExpression , {IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE COMMA DOT UP UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR MINUS_GT }]
  [oclExpression ::= (*) oclExpression TIMES oclExpression , {IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE COMMA DOT UP UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR MINUS_GT }]
  [oclExpression ::= (*) oclExpression DOT simpleName isMarkedPre , {IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE COMMA DOT UP UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR MINUS_GT }]
  [primitiveLiteralExp ::= (*) TRUE , {IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE COMMA DOT UP UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR MINUS_GT }]
  [literalExp ::= (*) tupleLiteralExp , {IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE COMMA DOT UP UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR MINUS_GT }]
  [oclExpression ::= (*) oclExpression IMPLIES oclExpression , {IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE COMMA DOT UP UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR MINUS_GT }]
  [oclExpression ::= (*) oclExpression LT oclExpression , {IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE COMMA DOT UP UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR MINUS_GT }]
  [oclExpression ::= (*) oclExpression MINUS_GT ITERATE LEFT_PAR variableDeclaration SEMICOLON variableDeclaration BAR oclExpression RIGHT_PAR , {IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE COMMA DOT UP UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR MINUS_GT }]
  [tupleLiteralExp ::= (*) TUPLE LEFT_BRA variableDeclarationList RIGHT_BRA , {IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE COMMA DOT UP UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR MINUS_GT }]
  [collectionKind ::= (*) SET , {LEFT_BRA }]
  [oclMessageArgument ::= (*) oclExpression , {COMMA RIGHT_PAR }]
  [oclExpression ::= (*) oclExpression UP simpleName LEFT_PAR RIGHT_PAR , {IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE COMMA DOT UP UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR MINUS_GT }]
  [oclExpression ::= (*) oclExpression NE oclExpression , {IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE COMMA DOT UP UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR MINUS_GT }]
  [oclExpression ::= (*) oclExpression DIVIDE oclExpression , {IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE COMMA DOT UP UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR MINUS_GT }]
  [oclExpression ::= (*) oclExpression LEFT_PAR arguments RIGHT_PAR , {IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE COMMA DOT UP UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR MINUS_GT }]
  [primitiveLiteralExp ::= (*) FALSE , {IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE COMMA DOT UP UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR MINUS_GT }]
  [literalExp ::= (*) primitiveLiteralExp , {IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE COMMA DOT UP UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR MINUS_GT }]
  [oclExpression ::= (*) LET variableDeclarationList IN oclExpression , {IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE COMMA DOT UP UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR MINUS_GT }]
  [oclExpression ::= (*) oclExpression GT oclExpression , {IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE COMMA DOT UP UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR MINUS_GT }]
  [oclExpression ::= (*) oclExpression MINUS_GT ITERATE LEFT_PAR variableDeclaration BAR oclExpression RIGHT_PAR , {IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE COMMA DOT UP UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR MINUS_GT }]
  [oclExpression ::= (*) literalExp , {IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE COMMA DOT UP UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR MINUS_GT }]
  [primitiveLiteralExp ::= (*) INTEGER , {IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE COMMA DOT UP UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR MINUS_GT }]
  [collectionKind ::= (*) BAG , {LEFT_BRA }]
  [oclExpression ::= (*) oclExpression AND oclExpression , {IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE COMMA DOT UP UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR MINUS_GT }]
  [oclExpression ::= (*) oclExpression PLUS oclExpression , {IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE COMMA DOT UP UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR MINUS_GT }]
  [oclExpression ::= (*) oclExpression LEFT_PAR variableDeclaration BAR oclExpression RIGHT_PAR , {IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE COMMA DOT UP UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR MINUS_GT }]
  [pathName ::= (*) simpleName , {IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE COMMA DOT UP AT COLON_COLON UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR MINUS_GT }]
  [oclMessageArgumentList ::= oclMessageArgumentList COMMA (*) oclMessageArgument , {COMMA RIGHT_PAR }]
  [oclExpression ::= (*) oclExpression UP_UP simpleName LEFT_PAR oclMessageArgumentList RIGHT_PAR , {IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE COMMA DOT UP UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR MINUS_GT }]
  [oclExpression ::= (*) oclExpression LE oclExpression , {IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE COMMA DOT UP UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR MINUS_GT }]
  [oclExpression ::= (*) NOT oclExpression , {IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE COMMA DOT UP UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR MINUS_GT }]
  [oclExpression ::= (*) LEFT_PAR oclExpression RIGHT_PAR , {IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE COMMA DOT UP UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR MINUS_GT }]
  [primitiveLiteralExp ::= (*) REAL , {IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE COMMA DOT UP UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR MINUS_GT }]
  [collectionKind ::= (*) SEQUENCE , {LEFT_BRA }]
  [oclExpression ::= (*) oclExpression OR oclExpression , {IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE COMMA DOT UP UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR MINUS_GT }]
  [oclExpression ::= (*) oclExpression MINUS oclExpression , {IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE COMMA DOT UP UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR MINUS_GT }]
  [oclExpression ::= (*) oclExpression LEFT_BRK argumentList RIGHT_BRK isMarkedPre , {IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE COMMA DOT UP UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR MINUS_GT }]
  [pathName ::= (*) pathName COLON_COLON simpleName , {IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE COMMA DOT UP AT COLON_COLON UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR MINUS_GT }]
  [collectionLiteralExp ::= (*) collectionKind LEFT_BRA collectionLiteralParts RIGHT_BRA , {IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE COMMA DOT UP UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR MINUS_GT }]
  [oclMessageArgument ::= (*) QUESTION , {COMMA RIGHT_PAR }]
  [oclExpression ::= (*) oclExpression UP_UP simpleName LEFT_PAR RIGHT_PAR , {IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE COMMA DOT UP UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR MINUS_GT }]
  [oclExpression ::= (*) oclExpression GE oclExpression , {IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE COMMA DOT UP UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR MINUS_GT }]
  [oclExpression ::= (*) MINUS oclExpression , {IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE COMMA DOT UP UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR MINUS_GT }]
  [oclExpression ::= (*) pathName isMarkedPre , {IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE COMMA DOT UP UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR MINUS_GT }]
  [primitiveLiteralExp ::= (*) STRING , {IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE COMMA DOT UP UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR MINUS_GT }]
  [collectionKind ::= (*) COLLECTION , {LEFT_BRA }]
  [literalExp ::= (*) collectionLiteralExp , {IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE COMMA DOT UP UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR MINUS_GT }]
  [oclExpression ::= (*) oclExpression XOR oclExpression , {IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE COMMA DOT UP UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR MINUS_GT }]
  [oclExpression ::= (*) IF oclExpression THEN oclExpression ELSE oclExpression ENDIF , {IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE COMMA DOT UP UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR MINUS_GT }]
  [oclExpression ::= (*) oclExpression MINUS_GT simpleName , {IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE COMMA DOT UP UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR MINUS_GT }]
  [simpleName ::= (*) SIMPLE_NAME , {IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE COMMA DOT UP AT COLON_COLON UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR MINUS_GT }]
  [collectionLiteralExp ::= (*) collectionKind LEFT_BRA RIGHT_BRA , {IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE COMMA DOT UP UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR MINUS_GT }]
  [oclMessageArgument ::= (*) QUESTION COLON type , {COMMA RIGHT_PAR }]
}
transition on tupleLiteralExp to state [54]
transition on oclExpression to state [119]
transition on REAL to state [52]
transition on INTEGER to state [51]
transition on pathName to state [50]
transition on SIMPLE_NAME to state [12]
transition on LET to state [49]
transition on FALSE to state [48]
transition on MINUS to state [47]
transition on COLLECTION to state [28]
transition on SET to state [20]
transition on simpleName to state [26]
transition on collectionLiteralExp to state [46]
transition on LEFT_PAR to state [45]
transition on STRING to state [44]
transition on oclMessageArgument to state [122]
transition on IF to state [43]
transition on TRUE to state [42]
transition on collectionKind to state [41]
transition on NOT to state [40]
transition on primitiveLiteralExp to state [39]
transition on TUPLE to state [38]
transition on literalExp to state [37]
transition on BAG to state [25]
transition on QUESTION to state [115]
transition on SEQUENCE to state [22]

-------------------
lalr_state [121]: {
  [oclExpression ::= oclExpression UP simpleName LEFT_PAR oclMessageArgumentList RIGHT_PAR (*) , {EOF ENDPACKAGE CONTEXT INIT DERIVE INV DEF PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE IN THEN ELSE ENDIF COMMA DOT COLON SEMICOLON BAR UP DOT_DOT UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR RIGHT_BRK RIGHT_BRA MINUS_GT }]
}

-------------------
lalr_state [122]: {
  [oclMessageArgumentList ::= oclMessageArgumentList COMMA oclMessageArgument (*) , {COMMA RIGHT_PAR }]
}

-------------------
lalr_state [123]: {
  [collectionKind ::= (*) BAG , {LEFT_PAR }]
  [collectionType ::= (*) collectionKind LEFT_PAR type RIGHT_PAR , {COMMA RIGHT_PAR }]
  [pathName ::= (*) simpleName , {COMMA COLON_COLON RIGHT_PAR }]
  [type ::= (*) pathName , {COMMA RIGHT_PAR }]
  [collectionKind ::= (*) COLLECTION , {LEFT_PAR }]
  [collectionKind ::= (*) SET , {LEFT_PAR }]
  [simpleName ::= (*) SIMPLE_NAME , {COMMA COLON_COLON RIGHT_PAR }]
  [type ::= (*) tupleType , {COMMA RIGHT_PAR }]
  [collectionKind ::= (*) SEQUENCE , {LEFT_PAR }]
  [tupleType ::= (*) TUPLE_TYPE LEFT_PAR variableDeclarationList RIGHT_PAR , {COMMA RIGHT_PAR }]
  [oclMessageArgument ::= QUESTION COLON (*) type , {COMMA RIGHT_PAR }]
  [pathName ::= (*) pathName COLON_COLON simpleName , {COMMA COLON_COLON RIGHT_PAR }]
  [type ::= (*) collectionType , {COMMA RIGHT_PAR }]
}
transition on collectionType to state [30]
transition on TUPLE_TYPE to state [29]
transition on COLLECTION to state [28]
transition on simpleName to state [26]
transition on type to state [124]
transition on BAG to state [25]
transition on collectionKind to state [24]
transition on pathName to state [23]
transition on SEQUENCE to state [22]
transition on tupleType to state [21]
transition on SET to state [20]
transition on SIMPLE_NAME to state [12]

-------------------
lalr_state [124]: {
  [oclMessageArgument ::= QUESTION COLON type (*) , {COMMA RIGHT_PAR }]
}

-------------------
lalr_state [125]: {
  [oclExpression ::= oclExpression UP_UP simpleName (*) LEFT_PAR oclMessageArgumentList RIGHT_PAR , {EOF ENDPACKAGE CONTEXT INIT DERIVE INV DEF PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE IN THEN ELSE ENDIF COMMA DOT COLON SEMICOLON BAR UP DOT_DOT UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR RIGHT_BRK RIGHT_BRA MINUS_GT }]
  [oclExpression ::= oclExpression UP_UP simpleName (*) LEFT_PAR RIGHT_PAR , {EOF ENDPACKAGE CONTEXT INIT DERIVE INV DEF PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE IN THEN ELSE ENDIF COMMA DOT COLON SEMICOLON BAR UP DOT_DOT UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR RIGHT_BRK RIGHT_BRA MINUS_GT }]
}
transition on LEFT_PAR to state [126]

-------------------
lalr_state [126]: {
  [oclExpression ::= (*) oclExpression UP simpleName LEFT_PAR oclMessageArgumentList RIGHT_PAR , {IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE COMMA DOT UP UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR MINUS_GT }]
  [oclExpression ::= (*) oclExpression EQ oclExpression , {IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE COMMA DOT UP UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR MINUS_GT }]
  [oclExpression ::= (*) oclExpression TIMES oclExpression , {IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE COMMA DOT UP UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR MINUS_GT }]
  [oclExpression ::= (*) oclExpression DOT simpleName isMarkedPre , {IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE COMMA DOT UP UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR MINUS_GT }]
  [primitiveLiteralExp ::= (*) TRUE , {IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE COMMA DOT UP UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR MINUS_GT }]
  [literalExp ::= (*) tupleLiteralExp , {IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE COMMA DOT UP UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR MINUS_GT }]
  [oclExpression ::= (*) oclExpression IMPLIES oclExpression , {IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE COMMA DOT UP UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR MINUS_GT }]
  [oclExpression ::= (*) oclExpression LT oclExpression , {IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE COMMA DOT UP UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR MINUS_GT }]
  [oclExpression ::= (*) oclExpression MINUS_GT ITERATE LEFT_PAR variableDeclaration SEMICOLON variableDeclaration BAR oclExpression RIGHT_PAR , {IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE COMMA DOT UP UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR MINUS_GT }]
  [tupleLiteralExp ::= (*) TUPLE LEFT_BRA variableDeclarationList RIGHT_BRA , {IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE COMMA DOT UP UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR MINUS_GT }]
  [collectionKind ::= (*) SET , {LEFT_BRA }]
  [oclMessageArgument ::= (*) oclExpression , {COMMA RIGHT_PAR }]
  [oclExpression ::= (*) oclExpression UP simpleName LEFT_PAR RIGHT_PAR , {IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE COMMA DOT UP UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR MINUS_GT }]
  [oclExpression ::= (*) oclExpression NE oclExpression , {IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE COMMA DOT UP UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR MINUS_GT }]
  [oclExpression ::= (*) oclExpression DIVIDE oclExpression , {IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE COMMA DOT UP UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR MINUS_GT }]
  [oclExpression ::= (*) oclExpression LEFT_PAR arguments RIGHT_PAR , {IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE COMMA DOT UP UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR MINUS_GT }]
  [primitiveLiteralExp ::= (*) FALSE , {IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE COMMA DOT UP UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR MINUS_GT }]
  [literalExp ::= (*) primitiveLiteralExp , {IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE COMMA DOT UP UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR MINUS_GT }]
  [oclMessageArgumentList ::= (*) oclMessageArgument , {COMMA RIGHT_PAR }]
  [oclExpression ::= (*) LET variableDeclarationList IN oclExpression , {IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE COMMA DOT UP UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR MINUS_GT }]
  [oclExpression ::= (*) oclExpression GT oclExpression , {IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE COMMA DOT UP UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR MINUS_GT }]
  [oclExpression ::= (*) oclExpression MINUS_GT ITERATE LEFT_PAR variableDeclaration BAR oclExpression RIGHT_PAR , {IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE COMMA DOT UP UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR MINUS_GT }]
  [oclExpression ::= (*) literalExp , {IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE COMMA DOT UP UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR MINUS_GT }]
  [primitiveLiteralExp ::= (*) INTEGER , {IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE COMMA DOT UP UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR MINUS_GT }]
  [collectionKind ::= (*) BAG , {LEFT_BRA }]
  [oclExpression ::= (*) oclExpression AND oclExpression , {IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE COMMA DOT UP UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR MINUS_GT }]
  [oclExpression ::= (*) oclExpression PLUS oclExpression , {IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE COMMA DOT UP UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR MINUS_GT }]
  [oclExpression ::= (*) oclExpression LEFT_PAR variableDeclaration BAR oclExpression RIGHT_PAR , {IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE COMMA DOT UP UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR MINUS_GT }]
  [pathName ::= (*) simpleName , {IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE COMMA DOT UP AT COLON_COLON UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR MINUS_GT }]
  [oclExpression ::= oclExpression UP_UP simpleName LEFT_PAR (*) oclMessageArgumentList RIGHT_PAR , {EOF ENDPACKAGE CONTEXT INIT DERIVE INV DEF PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE IN THEN ELSE ENDIF COMMA DOT COLON SEMICOLON BAR UP DOT_DOT UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR RIGHT_BRK RIGHT_BRA MINUS_GT }]
  [oclMessageArgumentList ::= (*) oclMessageArgumentList COMMA oclMessageArgument , {COMMA RIGHT_PAR }]
  [oclExpression ::= (*) oclExpression UP_UP simpleName LEFT_PAR oclMessageArgumentList RIGHT_PAR , {IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE COMMA DOT UP UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR MINUS_GT }]
  [oclExpression ::= (*) oclExpression LE oclExpression , {IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE COMMA DOT UP UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR MINUS_GT }]
  [oclExpression ::= (*) NOT oclExpression , {IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE COMMA DOT UP UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR MINUS_GT }]
  [oclExpression ::= (*) LEFT_PAR oclExpression RIGHT_PAR , {IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE COMMA DOT UP UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR MINUS_GT }]
  [primitiveLiteralExp ::= (*) REAL , {IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE COMMA DOT UP UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR MINUS_GT }]
  [collectionKind ::= (*) SEQUENCE , {LEFT_BRA }]
  [oclExpression ::= (*) oclExpression OR oclExpression , {IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE COMMA DOT UP UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR MINUS_GT }]
  [oclExpression ::= (*) oclExpression MINUS oclExpression , {IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE COMMA DOT UP UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR MINUS_GT }]
  [oclExpression ::= (*) oclExpression LEFT_BRK argumentList RIGHT_BRK isMarkedPre , {IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE COMMA DOT UP UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR MINUS_GT }]
  [pathName ::= (*) pathName COLON_COLON simpleName , {IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE COMMA DOT UP AT COLON_COLON UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR MINUS_GT }]
  [oclExpression ::= oclExpression UP_UP simpleName LEFT_PAR (*) RIGHT_PAR , {EOF ENDPACKAGE CONTEXT INIT DERIVE INV DEF PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE IN THEN ELSE ENDIF COMMA DOT COLON SEMICOLON BAR UP DOT_DOT UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR RIGHT_BRK RIGHT_BRA MINUS_GT }]
  [collectionLiteralExp ::= (*) collectionKind LEFT_BRA collectionLiteralParts RIGHT_BRA , {IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE COMMA DOT UP UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR MINUS_GT }]
  [oclMessageArgument ::= (*) QUESTION , {COMMA RIGHT_PAR }]
  [oclExpression ::= (*) oclExpression UP_UP simpleName LEFT_PAR RIGHT_PAR , {IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE COMMA DOT UP UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR MINUS_GT }]
  [oclExpression ::= (*) oclExpression GE oclExpression , {IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE COMMA DOT UP UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR MINUS_GT }]
  [oclExpression ::= (*) MINUS oclExpression , {IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE COMMA DOT UP UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR MINUS_GT }]
  [oclExpression ::= (*) pathName isMarkedPre , {IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE COMMA DOT UP UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR MINUS_GT }]
  [primitiveLiteralExp ::= (*) STRING , {IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE COMMA DOT UP UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR MINUS_GT }]
  [collectionKind ::= (*) COLLECTION , {LEFT_BRA }]
  [literalExp ::= (*) collectionLiteralExp , {IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE COMMA DOT UP UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR MINUS_GT }]
  [oclExpression ::= (*) oclExpression XOR oclExpression , {IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE COMMA DOT UP UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR MINUS_GT }]
  [oclExpression ::= (*) IF oclExpression THEN oclExpression ELSE oclExpression ENDIF , {IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE COMMA DOT UP UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR MINUS_GT }]
  [oclExpression ::= (*) oclExpression MINUS_GT simpleName , {IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE COMMA DOT UP UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR MINUS_GT }]
  [simpleName ::= (*) SIMPLE_NAME , {IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE COMMA DOT UP AT COLON_COLON UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR MINUS_GT }]
  [collectionLiteralExp ::= (*) collectionKind LEFT_BRA RIGHT_BRA , {IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE COMMA DOT UP UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR MINUS_GT }]
  [oclMessageArgument ::= (*) QUESTION COLON type , {COMMA RIGHT_PAR }]
}
transition on tupleLiteralExp to state [54]
transition on oclExpression to state [119]
transition on REAL to state [52]
transition on INTEGER to state [51]
transition on pathName to state [50]
transition on SIMPLE_NAME to state [12]
transition on LET to state [49]
transition on FALSE to state [48]
transition on MINUS to state [47]
transition on COLLECTION to state [28]
transition on oclMessageArgumentList to state [128]
transition on SET to state [20]
transition on RIGHT_PAR to state [127]
transition on simpleName to state [26]
transition on collectionLiteralExp to state [46]
transition on LEFT_PAR to state [45]
transition on STRING to state [44]
transition on oclMessageArgument to state [116]
transition on IF to state [43]
transition on TRUE to state [42]
transition on collectionKind to state [41]
transition on NOT to state [40]
transition on primitiveLiteralExp to state [39]
transition on TUPLE to state [38]
transition on literalExp to state [37]
transition on BAG to state [25]
transition on QUESTION to state [115]
transition on SEQUENCE to state [22]

-------------------
lalr_state [127]: {
  [oclExpression ::= oclExpression UP_UP simpleName LEFT_PAR RIGHT_PAR (*) , {EOF ENDPACKAGE CONTEXT INIT DERIVE INV DEF PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE IN THEN ELSE ENDIF COMMA DOT COLON SEMICOLON BAR UP DOT_DOT UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR RIGHT_BRK RIGHT_BRA MINUS_GT }]
}

-------------------
lalr_state [128]: {
  [oclMessageArgumentList ::= oclMessageArgumentList (*) COMMA oclMessageArgument , {COMMA RIGHT_PAR }]
  [oclExpression ::= oclExpression UP_UP simpleName LEFT_PAR oclMessageArgumentList (*) RIGHT_PAR , {EOF ENDPACKAGE CONTEXT INIT DERIVE INV DEF PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE IN THEN ELSE ENDIF COMMA DOT COLON SEMICOLON BAR UP DOT_DOT UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR RIGHT_BRK RIGHT_BRA MINUS_GT }]
}
transition on RIGHT_PAR to state [129]
transition on COMMA to state [120]

-------------------
lalr_state [129]: {
  [oclExpression ::= oclExpression UP_UP simpleName LEFT_PAR oclMessageArgumentList RIGHT_PAR (*) , {EOF ENDPACKAGE CONTEXT INIT DERIVE INV DEF PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE IN THEN ELSE ENDIF COMMA DOT COLON SEMICOLON BAR UP DOT_DOT UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR RIGHT_BRK RIGHT_BRA MINUS_GT }]
}

-------------------
lalr_state [130]: {
  [oclExpression ::= oclExpression (*) LEFT_BRK argumentList RIGHT_BRK isMarkedPre , {EOF ENDPACKAGE CONTEXT INIT DERIVE INV DEF PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE IN THEN ELSE ENDIF COMMA DOT COLON SEMICOLON BAR UP DOT_DOT UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR RIGHT_BRK RIGHT_BRA MINUS_GT }]
  [oclExpression ::= oclExpression (*) EQ oclExpression , {EOF ENDPACKAGE CONTEXT INIT DERIVE INV DEF PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE IN THEN ELSE ENDIF COMMA DOT COLON SEMICOLON BAR UP DOT_DOT UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR RIGHT_BRK RIGHT_BRA MINUS_GT }]
  [oclExpression ::= oclExpression (*) IMPLIES oclExpression , {EOF ENDPACKAGE CONTEXT INIT DERIVE INV DEF PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE IN THEN ELSE ENDIF COMMA DOT COLON SEMICOLON BAR UP DOT_DOT UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR RIGHT_BRK RIGHT_BRA MINUS_GT }]
  [oclExpression ::= oclExpression (*) UP simpleName LEFT_PAR RIGHT_PAR , {EOF ENDPACKAGE CONTEXT INIT DERIVE INV DEF PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE IN THEN ELSE ENDIF COMMA DOT COLON SEMICOLON BAR UP DOT_DOT UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR RIGHT_BRK RIGHT_BRA MINUS_GT }]
  [oclExpression ::= oclExpression (*) LEFT_PAR arguments RIGHT_PAR , {EOF ENDPACKAGE CONTEXT INIT DERIVE INV DEF PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE IN THEN ELSE ENDIF COMMA DOT COLON SEMICOLON BAR UP DOT_DOT UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR RIGHT_BRK RIGHT_BRA MINUS_GT }]
  [oclExpression ::= oclExpression (*) MINUS_GT ITERATE LEFT_PAR variableDeclaration BAR oclExpression RIGHT_PAR , {EOF ENDPACKAGE CONTEXT INIT DERIVE INV DEF PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE IN THEN ELSE ENDIF COMMA DOT COLON SEMICOLON BAR UP DOT_DOT UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR RIGHT_BRK RIGHT_BRA MINUS_GT }]
  [oclExpression ::= oclExpression OR oclExpression (*) , {EOF ENDPACKAGE CONTEXT INIT DERIVE INV DEF PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE IN THEN ELSE ENDIF COMMA DOT COLON SEMICOLON BAR UP DOT_DOT UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR RIGHT_BRK RIGHT_BRA MINUS_GT }]
  [oclExpression ::= oclExpression (*) PLUS oclExpression , {EOF ENDPACKAGE CONTEXT INIT DERIVE INV DEF PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE IN THEN ELSE ENDIF COMMA DOT COLON SEMICOLON BAR UP DOT_DOT UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR RIGHT_BRK RIGHT_BRA MINUS_GT }]
  [oclExpression ::= oclExpression (*) LE oclExpression , {EOF ENDPACKAGE CONTEXT INIT DERIVE INV DEF PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE IN THEN ELSE ENDIF COMMA DOT COLON SEMICOLON BAR UP DOT_DOT UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR RIGHT_BRK RIGHT_BRA MINUS_GT }]
  [oclExpression ::= oclExpression (*) OR oclExpression , {EOF ENDPACKAGE CONTEXT INIT DERIVE INV DEF PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE IN THEN ELSE ENDIF COMMA DOT COLON SEMICOLON BAR UP DOT_DOT UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR RIGHT_BRK RIGHT_BRA MINUS_GT }]
  [oclExpression ::= oclExpression (*) UP_UP simpleName LEFT_PAR RIGHT_PAR , {EOF ENDPACKAGE CONTEXT INIT DERIVE INV DEF PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE IN THEN ELSE ENDIF COMMA DOT COLON SEMICOLON BAR UP DOT_DOT UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR RIGHT_BRK RIGHT_BRA MINUS_GT }]
  [oclExpression ::= oclExpression (*) MINUS_GT simpleName , {EOF ENDPACKAGE CONTEXT INIT DERIVE INV DEF PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE IN THEN ELSE ENDIF COMMA DOT COLON SEMICOLON BAR UP DOT_DOT UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR RIGHT_BRK RIGHT_BRA MINUS_GT }]
  [oclExpression ::= oclExpression (*) TIMES oclExpression , {EOF ENDPACKAGE CONTEXT INIT DERIVE INV DEF PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE IN THEN ELSE ENDIF COMMA DOT COLON SEMICOLON BAR UP DOT_DOT UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR RIGHT_BRK RIGHT_BRA MINUS_GT }]
  [oclExpression ::= oclExpression (*) LT oclExpression , {EOF ENDPACKAGE CONTEXT INIT DERIVE INV DEF PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE IN THEN ELSE ENDIF COMMA DOT COLON SEMICOLON BAR UP DOT_DOT UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR RIGHT_BRK RIGHT_BRA MINUS_GT }]
  [oclExpression ::= oclExpression (*) NE oclExpression , {EOF ENDPACKAGE CONTEXT INIT DERIVE INV DEF PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE IN THEN ELSE ENDIF COMMA DOT COLON SEMICOLON BAR UP DOT_DOT UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR RIGHT_BRK RIGHT_BRA MINUS_GT }]
  [oclExpression ::= oclExpression (*) LEFT_PAR variableDeclaration BAR oclExpression RIGHT_PAR , {EOF ENDPACKAGE CONTEXT INIT DERIVE INV DEF PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE IN THEN ELSE ENDIF COMMA DOT COLON SEMICOLON BAR UP DOT_DOT UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR RIGHT_BRK RIGHT_BRA MINUS_GT }]
  [oclExpression ::= oclExpression (*) MINUS oclExpression , {EOF ENDPACKAGE CONTEXT INIT DERIVE INV DEF PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE IN THEN ELSE ENDIF COMMA DOT COLON SEMICOLON BAR UP DOT_DOT UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR RIGHT_BRK RIGHT_BRA MINUS_GT }]
  [oclExpression ::= oclExpression (*) GE oclExpression , {EOF ENDPACKAGE CONTEXT INIT DERIVE INV DEF PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE IN THEN ELSE ENDIF COMMA DOT COLON SEMICOLON BAR UP DOT_DOT UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR RIGHT_BRK RIGHT_BRA MINUS_GT }]
  [oclExpression ::= oclExpression (*) XOR oclExpression , {EOF ENDPACKAGE CONTEXT INIT DERIVE INV DEF PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE IN THEN ELSE ENDIF COMMA DOT COLON SEMICOLON BAR UP DOT_DOT UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR RIGHT_BRK RIGHT_BRA MINUS_GT }]
  [oclExpression ::= oclExpression (*) UP simpleName LEFT_PAR oclMessageArgumentList RIGHT_PAR , {EOF ENDPACKAGE CONTEXT INIT DERIVE INV DEF PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE IN THEN ELSE ENDIF COMMA DOT COLON SEMICOLON BAR UP DOT_DOT UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR RIGHT_BRK RIGHT_BRA MINUS_GT }]
  [oclExpression ::= oclExpression (*) DOT simpleName isMarkedPre , {EOF ENDPACKAGE CONTEXT INIT DERIVE INV DEF PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE IN THEN ELSE ENDIF COMMA DOT COLON SEMICOLON BAR UP DOT_DOT UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR RIGHT_BRK RIGHT_BRA MINUS_GT }]
  [oclExpression ::= oclExpression (*) MINUS_GT ITERATE LEFT_PAR variableDeclaration SEMICOLON variableDeclaration BAR oclExpression RIGHT_PAR , {EOF ENDPACKAGE CONTEXT INIT DERIVE INV DEF PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE IN THEN ELSE ENDIF COMMA DOT COLON SEMICOLON BAR UP DOT_DOT UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR RIGHT_BRK RIGHT_BRA MINUS_GT }]
  [oclExpression ::= oclExpression (*) DIVIDE oclExpression , {EOF ENDPACKAGE CONTEXT INIT DERIVE INV DEF PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE IN THEN ELSE ENDIF COMMA DOT COLON SEMICOLON BAR UP DOT_DOT UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR RIGHT_BRK RIGHT_BRA MINUS_GT }]
  [oclExpression ::= oclExpression (*) GT oclExpression , {EOF ENDPACKAGE CONTEXT INIT DERIVE INV DEF PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE IN THEN ELSE ENDIF COMMA DOT COLON SEMICOLON BAR UP DOT_DOT UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR RIGHT_BRK RIGHT_BRA MINUS_GT }]
  [oclExpression ::= oclExpression (*) AND oclExpression , {EOF ENDPACKAGE CONTEXT INIT DERIVE INV DEF PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE IN THEN ELSE ENDIF COMMA DOT COLON SEMICOLON BAR UP DOT_DOT UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR RIGHT_BRK RIGHT_BRA MINUS_GT }]
  [oclExpression ::= oclExpression (*) UP_UP simpleName LEFT_PAR oclMessageArgumentList RIGHT_PAR , {EOF ENDPACKAGE CONTEXT INIT DERIVE INV DEF PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE IN THEN ELSE ENDIF COMMA DOT COLON SEMICOLON BAR UP DOT_DOT UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR RIGHT_BRK RIGHT_BRA MINUS_GT }]
}
transition on XOR to state [74]
transition on EQ to state [73]
transition on DOT to state [72]
transition on MINUS to state [71]
transition on GE to state [70]
transition on LEFT_BRK to state [69]
transition on DIVIDE to state [68]
transition on LEFT_PAR to state [67]
transition on MINUS_GT to state [66]
transition on LE to state [65]
transition on GT to state [64]
transition on IMPLIES to state [63]
transition on UP to state [62]
transition on UP_UP to state [61]
transition on OR to state [60]
transition on PLUS to state [59]
transition on NE to state [58]
transition on LT to state [57]
transition on AND to state [56]
transition on TIMES to state [55]

-------------------
lalr_state [131]: {
  [oclExpression ::= oclExpression (*) LEFT_BRK argumentList RIGHT_BRK isMarkedPre , {EOF ENDPACKAGE CONTEXT INIT DERIVE INV DEF PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE IN THEN ELSE ENDIF COMMA DOT COLON SEMICOLON BAR UP DOT_DOT UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR RIGHT_BRK RIGHT_BRA MINUS_GT }]
  [oclExpression ::= oclExpression (*) EQ oclExpression , {EOF ENDPACKAGE CONTEXT INIT DERIVE INV DEF PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE IN THEN ELSE ENDIF COMMA DOT COLON SEMICOLON BAR UP DOT_DOT UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR RIGHT_BRK RIGHT_BRA MINUS_GT }]
  [oclExpression ::= oclExpression (*) IMPLIES oclExpression , {EOF ENDPACKAGE CONTEXT INIT DERIVE INV DEF PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE IN THEN ELSE ENDIF COMMA DOT COLON SEMICOLON BAR UP DOT_DOT UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR RIGHT_BRK RIGHT_BRA MINUS_GT }]
  [oclExpression ::= oclExpression (*) UP simpleName LEFT_PAR RIGHT_PAR , {EOF ENDPACKAGE CONTEXT INIT DERIVE INV DEF PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE IN THEN ELSE ENDIF COMMA DOT COLON SEMICOLON BAR UP DOT_DOT UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR RIGHT_BRK RIGHT_BRA MINUS_GT }]
  [oclExpression ::= oclExpression PLUS oclExpression (*) , {EOF ENDPACKAGE CONTEXT INIT DERIVE INV DEF PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE IN THEN ELSE ENDIF COMMA DOT COLON SEMICOLON BAR UP DOT_DOT UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR RIGHT_BRK RIGHT_BRA MINUS_GT }]
  [oclExpression ::= oclExpression (*) LEFT_PAR arguments RIGHT_PAR , {EOF ENDPACKAGE CONTEXT INIT DERIVE INV DEF PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE IN THEN ELSE ENDIF COMMA DOT COLON SEMICOLON BAR UP DOT_DOT UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR RIGHT_BRK RIGHT_BRA MINUS_GT }]
  [oclExpression ::= oclExpression (*) MINUS_GT ITERATE LEFT_PAR variableDeclaration BAR oclExpression RIGHT_PAR , {EOF ENDPACKAGE CONTEXT INIT DERIVE INV DEF PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE IN THEN ELSE ENDIF COMMA DOT COLON SEMICOLON BAR UP DOT_DOT UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR RIGHT_BRK RIGHT_BRA MINUS_GT }]
  [oclExpression ::= oclExpression (*) PLUS oclExpression , {EOF ENDPACKAGE CONTEXT INIT DERIVE INV DEF PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE IN THEN ELSE ENDIF COMMA DOT COLON SEMICOLON BAR UP DOT_DOT UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR RIGHT_BRK RIGHT_BRA MINUS_GT }]
  [oclExpression ::= oclExpression (*) LE oclExpression , {EOF ENDPACKAGE CONTEXT INIT DERIVE INV DEF PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE IN THEN ELSE ENDIF COMMA DOT COLON SEMICOLON BAR UP DOT_DOT UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR RIGHT_BRK RIGHT_BRA MINUS_GT }]
  [oclExpression ::= oclExpression (*) OR oclExpression , {EOF ENDPACKAGE CONTEXT INIT DERIVE INV DEF PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE IN THEN ELSE ENDIF COMMA DOT COLON SEMICOLON BAR UP DOT_DOT UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR RIGHT_BRK RIGHT_BRA MINUS_GT }]
  [oclExpression ::= oclExpression (*) UP_UP simpleName LEFT_PAR RIGHT_PAR , {EOF ENDPACKAGE CONTEXT INIT DERIVE INV DEF PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE IN THEN ELSE ENDIF COMMA DOT COLON SEMICOLON BAR UP DOT_DOT UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR RIGHT_BRK RIGHT_BRA MINUS_GT }]
  [oclExpression ::= oclExpression (*) MINUS_GT simpleName , {EOF ENDPACKAGE CONTEXT INIT DERIVE INV DEF PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE IN THEN ELSE ENDIF COMMA DOT COLON SEMICOLON BAR UP DOT_DOT UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR RIGHT_BRK RIGHT_BRA MINUS_GT }]
  [oclExpression ::= oclExpression (*) TIMES oclExpression , {EOF ENDPACKAGE CONTEXT INIT DERIVE INV DEF PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE IN THEN ELSE ENDIF COMMA DOT COLON SEMICOLON BAR UP DOT_DOT UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR RIGHT_BRK RIGHT_BRA MINUS_GT }]
  [oclExpression ::= oclExpression (*) LT oclExpression , {EOF ENDPACKAGE CONTEXT INIT DERIVE INV DEF PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE IN THEN ELSE ENDIF COMMA DOT COLON SEMICOLON BAR UP DOT_DOT UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR RIGHT_BRK RIGHT_BRA MINUS_GT }]
  [oclExpression ::= oclExpression (*) NE oclExpression , {EOF ENDPACKAGE CONTEXT INIT DERIVE INV DEF PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE IN THEN ELSE ENDIF COMMA DOT COLON SEMICOLON BAR UP DOT_DOT UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR RIGHT_BRK RIGHT_BRA MINUS_GT }]
  [oclExpression ::= oclExpression (*) LEFT_PAR variableDeclaration BAR oclExpression RIGHT_PAR , {EOF ENDPACKAGE CONTEXT INIT DERIVE INV DEF PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE IN THEN ELSE ENDIF COMMA DOT COLON SEMICOLON BAR UP DOT_DOT UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR RIGHT_BRK RIGHT_BRA MINUS_GT }]
  [oclExpression ::= oclExpression (*) MINUS oclExpression , {EOF ENDPACKAGE CONTEXT INIT DERIVE INV DEF PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE IN THEN ELSE ENDIF COMMA DOT COLON SEMICOLON BAR UP DOT_DOT UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR RIGHT_BRK RIGHT_BRA MINUS_GT }]
  [oclExpression ::= oclExpression (*) GE oclExpression , {EOF ENDPACKAGE CONTEXT INIT DERIVE INV DEF PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE IN THEN ELSE ENDIF COMMA DOT COLON SEMICOLON BAR UP DOT_DOT UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR RIGHT_BRK RIGHT_BRA MINUS_GT }]
  [oclExpression ::= oclExpression (*) XOR oclExpression , {EOF ENDPACKAGE CONTEXT INIT DERIVE INV DEF PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE IN THEN ELSE ENDIF COMMA DOT COLON SEMICOLON BAR UP DOT_DOT UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR RIGHT_BRK RIGHT_BRA MINUS_GT }]
  [oclExpression ::= oclExpression (*) UP simpleName LEFT_PAR oclMessageArgumentList RIGHT_PAR , {EOF ENDPACKAGE CONTEXT INIT DERIVE INV DEF PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE IN THEN ELSE ENDIF COMMA DOT COLON SEMICOLON BAR UP DOT_DOT UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR RIGHT_BRK RIGHT_BRA MINUS_GT }]
  [oclExpression ::= oclExpression (*) DOT simpleName isMarkedPre , {EOF ENDPACKAGE CONTEXT INIT DERIVE INV DEF PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE IN THEN ELSE ENDIF COMMA DOT COLON SEMICOLON BAR UP DOT_DOT UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR RIGHT_BRK RIGHT_BRA MINUS_GT }]
  [oclExpression ::= oclExpression (*) MINUS_GT ITERATE LEFT_PAR variableDeclaration SEMICOLON variableDeclaration BAR oclExpression RIGHT_PAR , {EOF ENDPACKAGE CONTEXT INIT DERIVE INV DEF PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE IN THEN ELSE ENDIF COMMA DOT COLON SEMICOLON BAR UP DOT_DOT UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR RIGHT_BRK RIGHT_BRA MINUS_GT }]
  [oclExpression ::= oclExpression (*) DIVIDE oclExpression , {EOF ENDPACKAGE CONTEXT INIT DERIVE INV DEF PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE IN THEN ELSE ENDIF COMMA DOT COLON SEMICOLON BAR UP DOT_DOT UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR RIGHT_BRK RIGHT_BRA MINUS_GT }]
  [oclExpression ::= oclExpression (*) GT oclExpression , {EOF ENDPACKAGE CONTEXT INIT DERIVE INV DEF PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE IN THEN ELSE ENDIF COMMA DOT COLON SEMICOLON BAR UP DOT_DOT UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR RIGHT_BRK RIGHT_BRA MINUS_GT }]
  [oclExpression ::= oclExpression (*) AND oclExpression , {EOF ENDPACKAGE CONTEXT INIT DERIVE INV DEF PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE IN THEN ELSE ENDIF COMMA DOT COLON SEMICOLON BAR UP DOT_DOT UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR RIGHT_BRK RIGHT_BRA MINUS_GT }]
  [oclExpression ::= oclExpression (*) UP_UP simpleName LEFT_PAR oclMessageArgumentList RIGHT_PAR , {EOF ENDPACKAGE CONTEXT INIT DERIVE INV DEF PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE IN THEN ELSE ENDIF COMMA DOT COLON SEMICOLON BAR UP DOT_DOT UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR RIGHT_BRK RIGHT_BRA MINUS_GT }]
}
transition on XOR to state [74]
transition on EQ to state [73]
transition on DOT to state [72]
transition on MINUS to state [71]
transition on GE to state [70]
transition on LEFT_BRK to state [69]
transition on DIVIDE to state [68]
transition on LEFT_PAR to state [67]
transition on MINUS_GT to state [66]
transition on LE to state [65]
transition on GT to state [64]
transition on IMPLIES to state [63]
transition on UP to state [62]
transition on UP_UP to state [61]
transition on OR to state [60]
transition on PLUS to state [59]
transition on NE to state [58]
transition on LT to state [57]
transition on AND to state [56]
transition on TIMES to state [55]

-------------------
lalr_state [132]: {
  [oclExpression ::= oclExpression (*) LEFT_BRK argumentList RIGHT_BRK isMarkedPre , {EOF ENDPACKAGE CONTEXT INIT DERIVE INV DEF PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE IN THEN ELSE ENDIF COMMA DOT COLON SEMICOLON BAR UP DOT_DOT UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR RIGHT_BRK RIGHT_BRA MINUS_GT }]
  [oclExpression ::= oclExpression (*) EQ oclExpression , {EOF ENDPACKAGE CONTEXT INIT DERIVE INV DEF PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE IN THEN ELSE ENDIF COMMA DOT COLON SEMICOLON BAR UP DOT_DOT UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR RIGHT_BRK RIGHT_BRA MINUS_GT }]
  [oclExpression ::= oclExpression (*) IMPLIES oclExpression , {EOF ENDPACKAGE CONTEXT INIT DERIVE INV DEF PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE IN THEN ELSE ENDIF COMMA DOT COLON SEMICOLON BAR UP DOT_DOT UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR RIGHT_BRK RIGHT_BRA MINUS_GT }]
  [oclExpression ::= oclExpression (*) UP simpleName LEFT_PAR RIGHT_PAR , {EOF ENDPACKAGE CONTEXT INIT DERIVE INV DEF PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE IN THEN ELSE ENDIF COMMA DOT COLON SEMICOLON BAR UP DOT_DOT UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR RIGHT_BRK RIGHT_BRA MINUS_GT }]
  [oclExpression ::= oclExpression (*) LEFT_PAR arguments RIGHT_PAR , {EOF ENDPACKAGE CONTEXT INIT DERIVE INV DEF PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE IN THEN ELSE ENDIF COMMA DOT COLON SEMICOLON BAR UP DOT_DOT UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR RIGHT_BRK RIGHT_BRA MINUS_GT }]
  [oclExpression ::= oclExpression (*) MINUS_GT ITERATE LEFT_PAR variableDeclaration BAR oclExpression RIGHT_PAR , {EOF ENDPACKAGE CONTEXT INIT DERIVE INV DEF PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE IN THEN ELSE ENDIF COMMA DOT COLON SEMICOLON BAR UP DOT_DOT UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR RIGHT_BRK RIGHT_BRA MINUS_GT }]
  [oclExpression ::= oclExpression (*) PLUS oclExpression , {EOF ENDPACKAGE CONTEXT INIT DERIVE INV DEF PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE IN THEN ELSE ENDIF COMMA DOT COLON SEMICOLON BAR UP DOT_DOT UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR RIGHT_BRK RIGHT_BRA MINUS_GT }]
  [oclExpression ::= oclExpression (*) LE oclExpression , {EOF ENDPACKAGE CONTEXT INIT DERIVE INV DEF PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE IN THEN ELSE ENDIF COMMA DOT COLON SEMICOLON BAR UP DOT_DOT UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR RIGHT_BRK RIGHT_BRA MINUS_GT }]
  [oclExpression ::= oclExpression (*) OR oclExpression , {EOF ENDPACKAGE CONTEXT INIT DERIVE INV DEF PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE IN THEN ELSE ENDIF COMMA DOT COLON SEMICOLON BAR UP DOT_DOT UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR RIGHT_BRK RIGHT_BRA MINUS_GT }]
  [oclExpression ::= oclExpression (*) UP_UP simpleName LEFT_PAR RIGHT_PAR , {EOF ENDPACKAGE CONTEXT INIT DERIVE INV DEF PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE IN THEN ELSE ENDIF COMMA DOT COLON SEMICOLON BAR UP DOT_DOT UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR RIGHT_BRK RIGHT_BRA MINUS_GT }]
  [oclExpression ::= oclExpression (*) MINUS_GT simpleName , {EOF ENDPACKAGE CONTEXT INIT DERIVE INV DEF PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE IN THEN ELSE ENDIF COMMA DOT COLON SEMICOLON BAR UP DOT_DOT UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR RIGHT_BRK RIGHT_BRA MINUS_GT }]
  [oclExpression ::= oclExpression NE oclExpression (*) , {EOF ENDPACKAGE CONTEXT INIT DERIVE INV DEF PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE IN THEN ELSE ENDIF COMMA DOT COLON SEMICOLON BAR UP DOT_DOT UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR RIGHT_BRK RIGHT_BRA MINUS_GT }]
  [oclExpression ::= oclExpression (*) TIMES oclExpression , {EOF ENDPACKAGE CONTEXT INIT DERIVE INV DEF PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE IN THEN ELSE ENDIF COMMA DOT COLON SEMICOLON BAR UP DOT_DOT UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR RIGHT_BRK RIGHT_BRA MINUS_GT }]
  [oclExpression ::= oclExpression (*) LT oclExpression , {EOF ENDPACKAGE CONTEXT INIT DERIVE INV DEF PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE IN THEN ELSE ENDIF COMMA DOT COLON SEMICOLON BAR UP DOT_DOT UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR RIGHT_BRK RIGHT_BRA MINUS_GT }]
  [oclExpression ::= oclExpression (*) NE oclExpression , {EOF ENDPACKAGE CONTEXT INIT DERIVE INV DEF PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE IN THEN ELSE ENDIF COMMA DOT COLON SEMICOLON BAR UP DOT_DOT UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR RIGHT_BRK RIGHT_BRA MINUS_GT }]
  [oclExpression ::= oclExpression (*) LEFT_PAR variableDeclaration BAR oclExpression RIGHT_PAR , {EOF ENDPACKAGE CONTEXT INIT DERIVE INV DEF PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE IN THEN ELSE ENDIF COMMA DOT COLON SEMICOLON BAR UP DOT_DOT UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR RIGHT_BRK RIGHT_BRA MINUS_GT }]
  [oclExpression ::= oclExpression (*) MINUS oclExpression , {EOF ENDPACKAGE CONTEXT INIT DERIVE INV DEF PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE IN THEN ELSE ENDIF COMMA DOT COLON SEMICOLON BAR UP DOT_DOT UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR RIGHT_BRK RIGHT_BRA MINUS_GT }]
  [oclExpression ::= oclExpression (*) GE oclExpression , {EOF ENDPACKAGE CONTEXT INIT DERIVE INV DEF PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE IN THEN ELSE ENDIF COMMA DOT COLON SEMICOLON BAR UP DOT_DOT UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR RIGHT_BRK RIGHT_BRA MINUS_GT }]
  [oclExpression ::= oclExpression (*) XOR oclExpression , {EOF ENDPACKAGE CONTEXT INIT DERIVE INV DEF PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE IN THEN ELSE ENDIF COMMA DOT COLON SEMICOLON BAR UP DOT_DOT UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR RIGHT_BRK RIGHT_BRA MINUS_GT }]
  [oclExpression ::= oclExpression (*) UP simpleName LEFT_PAR oclMessageArgumentList RIGHT_PAR , {EOF ENDPACKAGE CONTEXT INIT DERIVE INV DEF PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE IN THEN ELSE ENDIF COMMA DOT COLON SEMICOLON BAR UP DOT_DOT UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR RIGHT_BRK RIGHT_BRA MINUS_GT }]
  [oclExpression ::= oclExpression (*) DOT simpleName isMarkedPre , {EOF ENDPACKAGE CONTEXT INIT DERIVE INV DEF PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE IN THEN ELSE ENDIF COMMA DOT COLON SEMICOLON BAR UP DOT_DOT UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR RIGHT_BRK RIGHT_BRA MINUS_GT }]
  [oclExpression ::= oclExpression (*) MINUS_GT ITERATE LEFT_PAR variableDeclaration SEMICOLON variableDeclaration BAR oclExpression RIGHT_PAR , {EOF ENDPACKAGE CONTEXT INIT DERIVE INV DEF PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE IN THEN ELSE ENDIF COMMA DOT COLON SEMICOLON BAR UP DOT_DOT UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR RIGHT_BRK RIGHT_BRA MINUS_GT }]
  [oclExpression ::= oclExpression (*) DIVIDE oclExpression , {EOF ENDPACKAGE CONTEXT INIT DERIVE INV DEF PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE IN THEN ELSE ENDIF COMMA DOT COLON SEMICOLON BAR UP DOT_DOT UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR RIGHT_BRK RIGHT_BRA MINUS_GT }]
  [oclExpression ::= oclExpression (*) GT oclExpression , {EOF ENDPACKAGE CONTEXT INIT DERIVE INV DEF PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE IN THEN ELSE ENDIF COMMA DOT COLON SEMICOLON BAR UP DOT_DOT UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR RIGHT_BRK RIGHT_BRA MINUS_GT }]
  [oclExpression ::= oclExpression (*) AND oclExpression , {EOF ENDPACKAGE CONTEXT INIT DERIVE INV DEF PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE IN THEN ELSE ENDIF COMMA DOT COLON SEMICOLON BAR UP DOT_DOT UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR RIGHT_BRK RIGHT_BRA MINUS_GT }]
  [oclExpression ::= oclExpression (*) UP_UP simpleName LEFT_PAR oclMessageArgumentList RIGHT_PAR , {EOF ENDPACKAGE CONTEXT INIT DERIVE INV DEF PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE IN THEN ELSE ENDIF COMMA DOT COLON SEMICOLON BAR UP DOT_DOT UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR RIGHT_BRK RIGHT_BRA MINUS_GT }]
}
transition on XOR to state [74]
transition on EQ to state [73]
transition on DOT to state [72]
transition on MINUS to state [71]
transition on GE to state [70]
transition on LEFT_BRK to state [69]
transition on DIVIDE to state [68]
transition on LEFT_PAR to state [67]
transition on MINUS_GT to state [66]
transition on LE to state [65]
transition on GT to state [64]
transition on IMPLIES to state [63]
transition on UP to state [62]
transition on UP_UP to state [61]
transition on OR to state [60]
transition on PLUS to state [59]
transition on NE to state [58]
transition on LT to state [57]
transition on AND to state [56]
transition on TIMES to state [55]

-------------------
lalr_state [133]: {
  [oclExpression ::= oclExpression (*) LEFT_BRK argumentList RIGHT_BRK isMarkedPre , {EOF ENDPACKAGE CONTEXT INIT DERIVE INV DEF PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE IN THEN ELSE ENDIF COMMA DOT COLON SEMICOLON BAR UP DOT_DOT UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR RIGHT_BRK RIGHT_BRA MINUS_GT }]
  [oclExpression ::= oclExpression (*) EQ oclExpression , {EOF ENDPACKAGE CONTEXT INIT DERIVE INV DEF PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE IN THEN ELSE ENDIF COMMA DOT COLON SEMICOLON BAR UP DOT_DOT UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR RIGHT_BRK RIGHT_BRA MINUS_GT }]
  [oclExpression ::= oclExpression (*) IMPLIES oclExpression , {EOF ENDPACKAGE CONTEXT INIT DERIVE INV DEF PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE IN THEN ELSE ENDIF COMMA DOT COLON SEMICOLON BAR UP DOT_DOT UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR RIGHT_BRK RIGHT_BRA MINUS_GT }]
  [oclExpression ::= oclExpression (*) UP simpleName LEFT_PAR RIGHT_PAR , {EOF ENDPACKAGE CONTEXT INIT DERIVE INV DEF PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE IN THEN ELSE ENDIF COMMA DOT COLON SEMICOLON BAR UP DOT_DOT UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR RIGHT_BRK RIGHT_BRA MINUS_GT }]
  [oclExpression ::= oclExpression (*) LEFT_PAR arguments RIGHT_PAR , {EOF ENDPACKAGE CONTEXT INIT DERIVE INV DEF PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE IN THEN ELSE ENDIF COMMA DOT COLON SEMICOLON BAR UP DOT_DOT UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR RIGHT_BRK RIGHT_BRA MINUS_GT }]
  [oclExpression ::= oclExpression (*) MINUS_GT ITERATE LEFT_PAR variableDeclaration BAR oclExpression RIGHT_PAR , {EOF ENDPACKAGE CONTEXT INIT DERIVE INV DEF PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE IN THEN ELSE ENDIF COMMA DOT COLON SEMICOLON BAR UP DOT_DOT UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR RIGHT_BRK RIGHT_BRA MINUS_GT }]
  [oclExpression ::= oclExpression (*) PLUS oclExpression , {EOF ENDPACKAGE CONTEXT INIT DERIVE INV DEF PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE IN THEN ELSE ENDIF COMMA DOT COLON SEMICOLON BAR UP DOT_DOT UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR RIGHT_BRK RIGHT_BRA MINUS_GT }]
  [oclExpression ::= oclExpression (*) LE oclExpression , {EOF ENDPACKAGE CONTEXT INIT DERIVE INV DEF PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE IN THEN ELSE ENDIF COMMA DOT COLON SEMICOLON BAR UP DOT_DOT UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR RIGHT_BRK RIGHT_BRA MINUS_GT }]
  [oclExpression ::= oclExpression (*) OR oclExpression , {EOF ENDPACKAGE CONTEXT INIT DERIVE INV DEF PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE IN THEN ELSE ENDIF COMMA DOT COLON SEMICOLON BAR UP DOT_DOT UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR RIGHT_BRK RIGHT_BRA MINUS_GT }]
  [oclExpression ::= oclExpression (*) UP_UP simpleName LEFT_PAR RIGHT_PAR , {EOF ENDPACKAGE CONTEXT INIT DERIVE INV DEF PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE IN THEN ELSE ENDIF COMMA DOT COLON SEMICOLON BAR UP DOT_DOT UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR RIGHT_BRK RIGHT_BRA MINUS_GT }]
  [oclExpression ::= oclExpression (*) MINUS_GT simpleName , {EOF ENDPACKAGE CONTEXT INIT DERIVE INV DEF PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE IN THEN ELSE ENDIF COMMA DOT COLON SEMICOLON BAR UP DOT_DOT UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR RIGHT_BRK RIGHT_BRA MINUS_GT }]
  [oclExpression ::= oclExpression LT oclExpression (*) , {EOF ENDPACKAGE CONTEXT INIT DERIVE INV DEF PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE IN THEN ELSE ENDIF COMMA DOT COLON SEMICOLON BAR UP DOT_DOT UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR RIGHT_BRK RIGHT_BRA MINUS_GT }]
  [oclExpression ::= oclExpression (*) TIMES oclExpression , {EOF ENDPACKAGE CONTEXT INIT DERIVE INV DEF PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE IN THEN ELSE ENDIF COMMA DOT COLON SEMICOLON BAR UP DOT_DOT UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR RIGHT_BRK RIGHT_BRA MINUS_GT }]
  [oclExpression ::= oclExpression (*) LT oclExpression , {EOF ENDPACKAGE CONTEXT INIT DERIVE INV DEF PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE IN THEN ELSE ENDIF COMMA DOT COLON SEMICOLON BAR UP DOT_DOT UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR RIGHT_BRK RIGHT_BRA MINUS_GT }]
  [oclExpression ::= oclExpression (*) NE oclExpression , {EOF ENDPACKAGE CONTEXT INIT DERIVE INV DEF PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE IN THEN ELSE ENDIF COMMA DOT COLON SEMICOLON BAR UP DOT_DOT UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR RIGHT_BRK RIGHT_BRA MINUS_GT }]
  [oclExpression ::= oclExpression (*) LEFT_PAR variableDeclaration BAR oclExpression RIGHT_PAR , {EOF ENDPACKAGE CONTEXT INIT DERIVE INV DEF PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE IN THEN ELSE ENDIF COMMA DOT COLON SEMICOLON BAR UP DOT_DOT UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR RIGHT_BRK RIGHT_BRA MINUS_GT }]
  [oclExpression ::= oclExpression (*) MINUS oclExpression , {EOF ENDPACKAGE CONTEXT INIT DERIVE INV DEF PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE IN THEN ELSE ENDIF COMMA DOT COLON SEMICOLON BAR UP DOT_DOT UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR RIGHT_BRK RIGHT_BRA MINUS_GT }]
  [oclExpression ::= oclExpression (*) GE oclExpression , {EOF ENDPACKAGE CONTEXT INIT DERIVE INV DEF PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE IN THEN ELSE ENDIF COMMA DOT COLON SEMICOLON BAR UP DOT_DOT UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR RIGHT_BRK RIGHT_BRA MINUS_GT }]
  [oclExpression ::= oclExpression (*) XOR oclExpression , {EOF ENDPACKAGE CONTEXT INIT DERIVE INV DEF PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE IN THEN ELSE ENDIF COMMA DOT COLON SEMICOLON BAR UP DOT_DOT UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR RIGHT_BRK RIGHT_BRA MINUS_GT }]
  [oclExpression ::= oclExpression (*) UP simpleName LEFT_PAR oclMessageArgumentList RIGHT_PAR , {EOF ENDPACKAGE CONTEXT INIT DERIVE INV DEF PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE IN THEN ELSE ENDIF COMMA DOT COLON SEMICOLON BAR UP DOT_DOT UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR RIGHT_BRK RIGHT_BRA MINUS_GT }]
  [oclExpression ::= oclExpression (*) DOT simpleName isMarkedPre , {EOF ENDPACKAGE CONTEXT INIT DERIVE INV DEF PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE IN THEN ELSE ENDIF COMMA DOT COLON SEMICOLON BAR UP DOT_DOT UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR RIGHT_BRK RIGHT_BRA MINUS_GT }]
  [oclExpression ::= oclExpression (*) MINUS_GT ITERATE LEFT_PAR variableDeclaration SEMICOLON variableDeclaration BAR oclExpression RIGHT_PAR , {EOF ENDPACKAGE CONTEXT INIT DERIVE INV DEF PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE IN THEN ELSE ENDIF COMMA DOT COLON SEMICOLON BAR UP DOT_DOT UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR RIGHT_BRK RIGHT_BRA MINUS_GT }]
  [oclExpression ::= oclExpression (*) DIVIDE oclExpression , {EOF ENDPACKAGE CONTEXT INIT DERIVE INV DEF PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE IN THEN ELSE ENDIF COMMA DOT COLON SEMICOLON BAR UP DOT_DOT UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR RIGHT_BRK RIGHT_BRA MINUS_GT }]
  [oclExpression ::= oclExpression (*) GT oclExpression , {EOF ENDPACKAGE CONTEXT INIT DERIVE INV DEF PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE IN THEN ELSE ENDIF COMMA DOT COLON SEMICOLON BAR UP DOT_DOT UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR RIGHT_BRK RIGHT_BRA MINUS_GT }]
  [oclExpression ::= oclExpression (*) AND oclExpression , {EOF ENDPACKAGE CONTEXT INIT DERIVE INV DEF PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE IN THEN ELSE ENDIF COMMA DOT COLON SEMICOLON BAR UP DOT_DOT UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR RIGHT_BRK RIGHT_BRA MINUS_GT }]
  [oclExpression ::= oclExpression (*) UP_UP simpleName LEFT_PAR oclMessageArgumentList RIGHT_PAR , {EOF ENDPACKAGE CONTEXT INIT DERIVE INV DEF PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE IN THEN ELSE ENDIF COMMA DOT COLON SEMICOLON BAR UP DOT_DOT UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR RIGHT_BRK RIGHT_BRA MINUS_GT }]
}
transition on XOR to state [74]
transition on EQ to state [73]
transition on DOT to state [72]
transition on MINUS to state [71]
transition on GE to state [70]
transition on LEFT_BRK to state [69]
transition on DIVIDE to state [68]
transition on LEFT_PAR to state [67]
transition on MINUS_GT to state [66]
transition on LE to state [65]
transition on GT to state [64]
transition on IMPLIES to state [63]
transition on UP to state [62]
transition on UP_UP to state [61]
transition on OR to state [60]
transition on PLUS to state [59]
transition on NE to state [58]
transition on LT to state [57]
transition on AND to state [56]
transition on TIMES to state [55]

-------------------
lalr_state [134]: {
  [oclExpression ::= oclExpression (*) LEFT_BRK argumentList RIGHT_BRK isMarkedPre , {EOF ENDPACKAGE CONTEXT INIT DERIVE INV DEF PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE IN THEN ELSE ENDIF COMMA DOT COLON SEMICOLON BAR UP DOT_DOT UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR RIGHT_BRK RIGHT_BRA MINUS_GT }]
  [oclExpression ::= oclExpression (*) EQ oclExpression , {EOF ENDPACKAGE CONTEXT INIT DERIVE INV DEF PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE IN THEN ELSE ENDIF COMMA DOT COLON SEMICOLON BAR UP DOT_DOT UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR RIGHT_BRK RIGHT_BRA MINUS_GT }]
  [oclExpression ::= oclExpression (*) IMPLIES oclExpression , {EOF ENDPACKAGE CONTEXT INIT DERIVE INV DEF PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE IN THEN ELSE ENDIF COMMA DOT COLON SEMICOLON BAR UP DOT_DOT UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR RIGHT_BRK RIGHT_BRA MINUS_GT }]
  [oclExpression ::= oclExpression (*) UP simpleName LEFT_PAR RIGHT_PAR , {EOF ENDPACKAGE CONTEXT INIT DERIVE INV DEF PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE IN THEN ELSE ENDIF COMMA DOT COLON SEMICOLON BAR UP DOT_DOT UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR RIGHT_BRK RIGHT_BRA MINUS_GT }]
  [oclExpression ::= oclExpression (*) LEFT_PAR arguments RIGHT_PAR , {EOF ENDPACKAGE CONTEXT INIT DERIVE INV DEF PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE IN THEN ELSE ENDIF COMMA DOT COLON SEMICOLON BAR UP DOT_DOT UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR RIGHT_BRK RIGHT_BRA MINUS_GT }]
  [oclExpression ::= oclExpression (*) MINUS_GT ITERATE LEFT_PAR variableDeclaration BAR oclExpression RIGHT_PAR , {EOF ENDPACKAGE CONTEXT INIT DERIVE INV DEF PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE IN THEN ELSE ENDIF COMMA DOT COLON SEMICOLON BAR UP DOT_DOT UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR RIGHT_BRK RIGHT_BRA MINUS_GT }]
  [oclExpression ::= oclExpression (*) PLUS oclExpression , {EOF ENDPACKAGE CONTEXT INIT DERIVE INV DEF PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE IN THEN ELSE ENDIF COMMA DOT COLON SEMICOLON BAR UP DOT_DOT UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR RIGHT_BRK RIGHT_BRA MINUS_GT }]
  [oclExpression ::= oclExpression (*) LE oclExpression , {EOF ENDPACKAGE CONTEXT INIT DERIVE INV DEF PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE IN THEN ELSE ENDIF COMMA DOT COLON SEMICOLON BAR UP DOT_DOT UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR RIGHT_BRK RIGHT_BRA MINUS_GT }]
  [oclExpression ::= oclExpression (*) OR oclExpression , {EOF ENDPACKAGE CONTEXT INIT DERIVE INV DEF PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE IN THEN ELSE ENDIF COMMA DOT COLON SEMICOLON BAR UP DOT_DOT UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR RIGHT_BRK RIGHT_BRA MINUS_GT }]
  [oclExpression ::= oclExpression (*) UP_UP simpleName LEFT_PAR RIGHT_PAR , {EOF ENDPACKAGE CONTEXT INIT DERIVE INV DEF PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE IN THEN ELSE ENDIF COMMA DOT COLON SEMICOLON BAR UP DOT_DOT UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR RIGHT_BRK RIGHT_BRA MINUS_GT }]
  [oclExpression ::= oclExpression (*) MINUS_GT simpleName , {EOF ENDPACKAGE CONTEXT INIT DERIVE INV DEF PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE IN THEN ELSE ENDIF COMMA DOT COLON SEMICOLON BAR UP DOT_DOT UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR RIGHT_BRK RIGHT_BRA MINUS_GT }]
  [oclExpression ::= oclExpression (*) TIMES oclExpression , {EOF ENDPACKAGE CONTEXT INIT DERIVE INV DEF PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE IN THEN ELSE ENDIF COMMA DOT COLON SEMICOLON BAR UP DOT_DOT UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR RIGHT_BRK RIGHT_BRA MINUS_GT }]
  [oclExpression ::= oclExpression (*) LT oclExpression , {EOF ENDPACKAGE CONTEXT INIT DERIVE INV DEF PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE IN THEN ELSE ENDIF COMMA DOT COLON SEMICOLON BAR UP DOT_DOT UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR RIGHT_BRK RIGHT_BRA MINUS_GT }]
  [oclExpression ::= oclExpression (*) NE oclExpression , {EOF ENDPACKAGE CONTEXT INIT DERIVE INV DEF PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE IN THEN ELSE ENDIF COMMA DOT COLON SEMICOLON BAR UP DOT_DOT UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR RIGHT_BRK RIGHT_BRA MINUS_GT }]
  [oclExpression ::= oclExpression (*) LEFT_PAR variableDeclaration BAR oclExpression RIGHT_PAR , {EOF ENDPACKAGE CONTEXT INIT DERIVE INV DEF PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE IN THEN ELSE ENDIF COMMA DOT COLON SEMICOLON BAR UP DOT_DOT UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR RIGHT_BRK RIGHT_BRA MINUS_GT }]
  [oclExpression ::= oclExpression (*) MINUS oclExpression , {EOF ENDPACKAGE CONTEXT INIT DERIVE INV DEF PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE IN THEN ELSE ENDIF COMMA DOT COLON SEMICOLON BAR UP DOT_DOT UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR RIGHT_BRK RIGHT_BRA MINUS_GT }]
  [oclExpression ::= oclExpression (*) GE oclExpression , {EOF ENDPACKAGE CONTEXT INIT DERIVE INV DEF PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE IN THEN ELSE ENDIF COMMA DOT COLON SEMICOLON BAR UP DOT_DOT UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR RIGHT_BRK RIGHT_BRA MINUS_GT }]
  [oclExpression ::= oclExpression (*) XOR oclExpression , {EOF ENDPACKAGE CONTEXT INIT DERIVE INV DEF PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE IN THEN ELSE ENDIF COMMA DOT COLON SEMICOLON BAR UP DOT_DOT UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR RIGHT_BRK RIGHT_BRA MINUS_GT }]
  [oclExpression ::= oclExpression (*) UP simpleName LEFT_PAR oclMessageArgumentList RIGHT_PAR , {EOF ENDPACKAGE CONTEXT INIT DERIVE INV DEF PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE IN THEN ELSE ENDIF COMMA DOT COLON SEMICOLON BAR UP DOT_DOT UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR RIGHT_BRK RIGHT_BRA MINUS_GT }]
  [oclExpression ::= oclExpression (*) DOT simpleName isMarkedPre , {EOF ENDPACKAGE CONTEXT INIT DERIVE INV DEF PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE IN THEN ELSE ENDIF COMMA DOT COLON SEMICOLON BAR UP DOT_DOT UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR RIGHT_BRK RIGHT_BRA MINUS_GT }]
  [oclExpression ::= oclExpression (*) MINUS_GT ITERATE LEFT_PAR variableDeclaration SEMICOLON variableDeclaration BAR oclExpression RIGHT_PAR , {EOF ENDPACKAGE CONTEXT INIT DERIVE INV DEF PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE IN THEN ELSE ENDIF COMMA DOT COLON SEMICOLON BAR UP DOT_DOT UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR RIGHT_BRK RIGHT_BRA MINUS_GT }]
  [oclExpression ::= oclExpression (*) DIVIDE oclExpression , {EOF ENDPACKAGE CONTEXT INIT DERIVE INV DEF PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE IN THEN ELSE ENDIF COMMA DOT COLON SEMICOLON BAR UP DOT_DOT UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR RIGHT_BRK RIGHT_BRA MINUS_GT }]
  [oclExpression ::= oclExpression AND oclExpression (*) , {EOF ENDPACKAGE CONTEXT INIT DERIVE INV DEF PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE IN THEN ELSE ENDIF COMMA DOT COLON SEMICOLON BAR UP DOT_DOT UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR RIGHT_BRK RIGHT_BRA MINUS_GT }]
  [oclExpression ::= oclExpression (*) GT oclExpression , {EOF ENDPACKAGE CONTEXT INIT DERIVE INV DEF PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE IN THEN ELSE ENDIF COMMA DOT COLON SEMICOLON BAR UP DOT_DOT UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR RIGHT_BRK RIGHT_BRA MINUS_GT }]
  [oclExpression ::= oclExpression (*) AND oclExpression , {EOF ENDPACKAGE CONTEXT INIT DERIVE INV DEF PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE IN THEN ELSE ENDIF COMMA DOT COLON SEMICOLON BAR UP DOT_DOT UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR RIGHT_BRK RIGHT_BRA MINUS_GT }]
  [oclExpression ::= oclExpression (*) UP_UP simpleName LEFT_PAR oclMessageArgumentList RIGHT_PAR , {EOF ENDPACKAGE CONTEXT INIT DERIVE INV DEF PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE IN THEN ELSE ENDIF COMMA DOT COLON SEMICOLON BAR UP DOT_DOT UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR RIGHT_BRK RIGHT_BRA MINUS_GT }]
}
transition on XOR to state [74]
transition on EQ to state [73]
transition on DOT to state [72]
transition on MINUS to state [71]
transition on GE to state [70]
transition on LEFT_BRK to state [69]
transition on DIVIDE to state [68]
transition on LEFT_PAR to state [67]
transition on MINUS_GT to state [66]
transition on LE to state [65]
transition on GT to state [64]
transition on IMPLIES to state [63]
transition on UP to state [62]
transition on UP_UP to state [61]
transition on OR to state [60]
transition on PLUS to state [59]
transition on NE to state [58]
transition on LT to state [57]
transition on AND to state [56]
transition on TIMES to state [55]

-------------------
lalr_state [135]: {
  [oclExpression ::= oclExpression (*) LEFT_BRK argumentList RIGHT_BRK isMarkedPre , {EOF ENDPACKAGE CONTEXT INIT DERIVE INV DEF PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE IN THEN ELSE ENDIF COMMA DOT COLON SEMICOLON BAR UP DOT_DOT UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR RIGHT_BRK RIGHT_BRA MINUS_GT }]
  [oclExpression ::= oclExpression (*) EQ oclExpression , {EOF ENDPACKAGE CONTEXT INIT DERIVE INV DEF PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE IN THEN ELSE ENDIF COMMA DOT COLON SEMICOLON BAR UP DOT_DOT UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR RIGHT_BRK RIGHT_BRA MINUS_GT }]
  [oclExpression ::= oclExpression (*) IMPLIES oclExpression , {EOF ENDPACKAGE CONTEXT INIT DERIVE INV DEF PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE IN THEN ELSE ENDIF COMMA DOT COLON SEMICOLON BAR UP DOT_DOT UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR RIGHT_BRK RIGHT_BRA MINUS_GT }]
  [oclExpression ::= oclExpression (*) UP simpleName LEFT_PAR RIGHT_PAR , {EOF ENDPACKAGE CONTEXT INIT DERIVE INV DEF PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE IN THEN ELSE ENDIF COMMA DOT COLON SEMICOLON BAR UP DOT_DOT UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR RIGHT_BRK RIGHT_BRA MINUS_GT }]
  [oclExpression ::= oclExpression (*) LEFT_PAR arguments RIGHT_PAR , {EOF ENDPACKAGE CONTEXT INIT DERIVE INV DEF PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE IN THEN ELSE ENDIF COMMA DOT COLON SEMICOLON BAR UP DOT_DOT UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR RIGHT_BRK RIGHT_BRA MINUS_GT }]
  [oclExpression ::= oclExpression (*) MINUS_GT ITERATE LEFT_PAR variableDeclaration BAR oclExpression RIGHT_PAR , {EOF ENDPACKAGE CONTEXT INIT DERIVE INV DEF PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE IN THEN ELSE ENDIF COMMA DOT COLON SEMICOLON BAR UP DOT_DOT UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR RIGHT_BRK RIGHT_BRA MINUS_GT }]
  [oclExpression ::= oclExpression (*) PLUS oclExpression , {EOF ENDPACKAGE CONTEXT INIT DERIVE INV DEF PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE IN THEN ELSE ENDIF COMMA DOT COLON SEMICOLON BAR UP DOT_DOT UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR RIGHT_BRK RIGHT_BRA MINUS_GT }]
  [oclExpression ::= oclExpression (*) LE oclExpression , {EOF ENDPACKAGE CONTEXT INIT DERIVE INV DEF PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE IN THEN ELSE ENDIF COMMA DOT COLON SEMICOLON BAR UP DOT_DOT UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR RIGHT_BRK RIGHT_BRA MINUS_GT }]
  [oclExpression ::= oclExpression (*) OR oclExpression , {EOF ENDPACKAGE CONTEXT INIT DERIVE INV DEF PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE IN THEN ELSE ENDIF COMMA DOT COLON SEMICOLON BAR UP DOT_DOT UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR RIGHT_BRK RIGHT_BRA MINUS_GT }]
  [oclExpression ::= oclExpression (*) UP_UP simpleName LEFT_PAR RIGHT_PAR , {EOF ENDPACKAGE CONTEXT INIT DERIVE INV DEF PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE IN THEN ELSE ENDIF COMMA DOT COLON SEMICOLON BAR UP DOT_DOT UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR RIGHT_BRK RIGHT_BRA MINUS_GT }]
  [oclExpression ::= oclExpression TIMES oclExpression (*) , {EOF ENDPACKAGE CONTEXT INIT DERIVE INV DEF PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE IN THEN ELSE ENDIF COMMA DOT COLON SEMICOLON BAR UP DOT_DOT UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR RIGHT_BRK RIGHT_BRA MINUS_GT }]
  [oclExpression ::= oclExpression (*) MINUS_GT simpleName , {EOF ENDPACKAGE CONTEXT INIT DERIVE INV DEF PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE IN THEN ELSE ENDIF COMMA DOT COLON SEMICOLON BAR UP DOT_DOT UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR RIGHT_BRK RIGHT_BRA MINUS_GT }]
  [oclExpression ::= oclExpression (*) TIMES oclExpression , {EOF ENDPACKAGE CONTEXT INIT DERIVE INV DEF PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE IN THEN ELSE ENDIF COMMA DOT COLON SEMICOLON BAR UP DOT_DOT UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR RIGHT_BRK RIGHT_BRA MINUS_GT }]
  [oclExpression ::= oclExpression (*) LT oclExpression , {EOF ENDPACKAGE CONTEXT INIT DERIVE INV DEF PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE IN THEN ELSE ENDIF COMMA DOT COLON SEMICOLON BAR UP DOT_DOT UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR RIGHT_BRK RIGHT_BRA MINUS_GT }]
  [oclExpression ::= oclExpression (*) NE oclExpression , {EOF ENDPACKAGE CONTEXT INIT DERIVE INV DEF PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE IN THEN ELSE ENDIF COMMA DOT COLON SEMICOLON BAR UP DOT_DOT UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR RIGHT_BRK RIGHT_BRA MINUS_GT }]
  [oclExpression ::= oclExpression (*) LEFT_PAR variableDeclaration BAR oclExpression RIGHT_PAR , {EOF ENDPACKAGE CONTEXT INIT DERIVE INV DEF PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE IN THEN ELSE ENDIF COMMA DOT COLON SEMICOLON BAR UP DOT_DOT UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR RIGHT_BRK RIGHT_BRA MINUS_GT }]
  [oclExpression ::= oclExpression (*) MINUS oclExpression , {EOF ENDPACKAGE CONTEXT INIT DERIVE INV DEF PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE IN THEN ELSE ENDIF COMMA DOT COLON SEMICOLON BAR UP DOT_DOT UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR RIGHT_BRK RIGHT_BRA MINUS_GT }]
  [oclExpression ::= oclExpression (*) GE oclExpression , {EOF ENDPACKAGE CONTEXT INIT DERIVE INV DEF PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE IN THEN ELSE ENDIF COMMA DOT COLON SEMICOLON BAR UP DOT_DOT UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR RIGHT_BRK RIGHT_BRA MINUS_GT }]
  [oclExpression ::= oclExpression (*) XOR oclExpression , {EOF ENDPACKAGE CONTEXT INIT DERIVE INV DEF PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE IN THEN ELSE ENDIF COMMA DOT COLON SEMICOLON BAR UP DOT_DOT UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR RIGHT_BRK RIGHT_BRA MINUS_GT }]
  [oclExpression ::= oclExpression (*) UP simpleName LEFT_PAR oclMessageArgumentList RIGHT_PAR , {EOF ENDPACKAGE CONTEXT INIT DERIVE INV DEF PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE IN THEN ELSE ENDIF COMMA DOT COLON SEMICOLON BAR UP DOT_DOT UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR RIGHT_BRK RIGHT_BRA MINUS_GT }]
  [oclExpression ::= oclExpression (*) DOT simpleName isMarkedPre , {EOF ENDPACKAGE CONTEXT INIT DERIVE INV DEF PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE IN THEN ELSE ENDIF COMMA DOT COLON SEMICOLON BAR UP DOT_DOT UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR RIGHT_BRK RIGHT_BRA MINUS_GT }]
  [oclExpression ::= oclExpression (*) MINUS_GT ITERATE LEFT_PAR variableDeclaration SEMICOLON variableDeclaration BAR oclExpression RIGHT_PAR , {EOF ENDPACKAGE CONTEXT INIT DERIVE INV DEF PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE IN THEN ELSE ENDIF COMMA DOT COLON SEMICOLON BAR UP DOT_DOT UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR RIGHT_BRK RIGHT_BRA MINUS_GT }]
  [oclExpression ::= oclExpression (*) DIVIDE oclExpression , {EOF ENDPACKAGE CONTEXT INIT DERIVE INV DEF PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE IN THEN ELSE ENDIF COMMA DOT COLON SEMICOLON BAR UP DOT_DOT UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR RIGHT_BRK RIGHT_BRA MINUS_GT }]
  [oclExpression ::= oclExpression (*) GT oclExpression , {EOF ENDPACKAGE CONTEXT INIT DERIVE INV DEF PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE IN THEN ELSE ENDIF COMMA DOT COLON SEMICOLON BAR UP DOT_DOT UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR RIGHT_BRK RIGHT_BRA MINUS_GT }]
  [oclExpression ::= oclExpression (*) AND oclExpression , {EOF ENDPACKAGE CONTEXT INIT DERIVE INV DEF PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE IN THEN ELSE ENDIF COMMA DOT COLON SEMICOLON BAR UP DOT_DOT UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR RIGHT_BRK RIGHT_BRA MINUS_GT }]
  [oclExpression ::= oclExpression (*) UP_UP simpleName LEFT_PAR oclMessageArgumentList RIGHT_PAR , {EOF ENDPACKAGE CONTEXT INIT DERIVE INV DEF PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE IN THEN ELSE ENDIF COMMA DOT COLON SEMICOLON BAR UP DOT_DOT UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR RIGHT_BRK RIGHT_BRA MINUS_GT }]
}
transition on XOR to state [74]
transition on EQ to state [73]
transition on DOT to state [72]
transition on MINUS to state [71]
transition on GE to state [70]
transition on LEFT_BRK to state [69]
transition on DIVIDE to state [68]
transition on LEFT_PAR to state [67]
transition on MINUS_GT to state [66]
transition on LE to state [65]
transition on GT to state [64]
transition on IMPLIES to state [63]
transition on UP to state [62]
transition on UP_UP to state [61]
transition on OR to state [60]
transition on PLUS to state [59]
transition on NE to state [58]
transition on LT to state [57]
transition on AND to state [56]
transition on TIMES to state [55]

-------------------
lalr_state [136]: {
  [oclExpression ::= pathName isMarkedPre (*) , {EOF ENDPACKAGE CONTEXT INIT DERIVE INV DEF PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE IN THEN ELSE ENDIF COMMA DOT COLON SEMICOLON BAR UP DOT_DOT UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR RIGHT_BRK RIGHT_BRA MINUS_GT }]
}

-------------------
lalr_state [137]: {
  [simpleName ::= (*) SIMPLE_NAME , {EOF ENDPACKAGE CONTEXT INIT DERIVE INV DEF PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE IN THEN ELSE ENDIF COMMA DOT COLON SEMICOLON BAR UP AT DOT_DOT COLON_COLON UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR RIGHT_BRK RIGHT_BRA MINUS_GT }]
  [pathName ::= pathName COLON_COLON (*) simpleName , {EOF ENDPACKAGE CONTEXT INIT DERIVE INV DEF PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE IN THEN ELSE ENDIF COMMA DOT COLON SEMICOLON BAR UP AT DOT_DOT COLON_COLON UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR RIGHT_BRK RIGHT_BRA MINUS_GT }]
}
transition on SIMPLE_NAME to state [12]
transition on simpleName to state [138]

-------------------
lalr_state [138]: {
  [pathName ::= pathName COLON_COLON simpleName (*) , {EOF ENDPACKAGE CONTEXT INIT DERIVE INV DEF PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE IN THEN ELSE ENDIF COMMA DOT COLON SEMICOLON BAR UP AT DOT_DOT COLON_COLON UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR RIGHT_BRK RIGHT_BRA MINUS_GT }]
}

-------------------
lalr_state [139]: {
  [variableDeclarationList ::= variableDeclarationList (*) COMMA variableDeclaration , {IN COMMA }]
  [oclExpression ::= LET variableDeclarationList (*) IN oclExpression , {EOF ENDPACKAGE CONTEXT INIT DERIVE INV DEF PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE IN THEN ELSE ENDIF COMMA DOT COLON SEMICOLON BAR UP DOT_DOT UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR RIGHT_BRK RIGHT_BRA MINUS_GT }]
}
transition on IN to state [140]
transition on COMMA to state [33]

-------------------
lalr_state [140]: {
  [oclExpression ::= (*) oclExpression UP simpleName LEFT_PAR oclMessageArgumentList RIGHT_PAR , {EOF ENDPACKAGE CONTEXT INIT DERIVE INV DEF PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE IN THEN ELSE ENDIF COMMA DOT COLON SEMICOLON BAR UP DOT_DOT UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR RIGHT_BRK RIGHT_BRA MINUS_GT }]
  [oclExpression ::= (*) oclExpression EQ oclExpression , {EOF ENDPACKAGE CONTEXT INIT DERIVE INV DEF PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE IN THEN ELSE ENDIF COMMA DOT COLON SEMICOLON BAR UP DOT_DOT UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR RIGHT_BRK RIGHT_BRA MINUS_GT }]
  [oclExpression ::= (*) oclExpression TIMES oclExpression , {EOF ENDPACKAGE CONTEXT INIT DERIVE INV DEF PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE IN THEN ELSE ENDIF COMMA DOT COLON SEMICOLON BAR UP DOT_DOT UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR RIGHT_BRK RIGHT_BRA MINUS_GT }]
  [oclExpression ::= (*) oclExpression DOT simpleName isMarkedPre , {EOF ENDPACKAGE CONTEXT INIT DERIVE INV DEF PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE IN THEN ELSE ENDIF COMMA DOT COLON SEMICOLON BAR UP DOT_DOT UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR RIGHT_BRK RIGHT_BRA MINUS_GT }]
  [primitiveLiteralExp ::= (*) TRUE , {EOF ENDPACKAGE CONTEXT INIT DERIVE INV DEF PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE IN THEN ELSE ENDIF COMMA DOT COLON SEMICOLON BAR UP DOT_DOT UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR RIGHT_BRK RIGHT_BRA MINUS_GT }]
  [literalExp ::= (*) tupleLiteralExp , {EOF ENDPACKAGE CONTEXT INIT DERIVE INV DEF PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE IN THEN ELSE ENDIF COMMA DOT COLON SEMICOLON BAR UP DOT_DOT UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR RIGHT_BRK RIGHT_BRA MINUS_GT }]
  [oclExpression ::= (*) oclExpression IMPLIES oclExpression , {EOF ENDPACKAGE CONTEXT INIT DERIVE INV DEF PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE IN THEN ELSE ENDIF COMMA DOT COLON SEMICOLON BAR UP DOT_DOT UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR RIGHT_BRK RIGHT_BRA MINUS_GT }]
  [oclExpression ::= (*) oclExpression LT oclExpression , {EOF ENDPACKAGE CONTEXT INIT DERIVE INV DEF PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE IN THEN ELSE ENDIF COMMA DOT COLON SEMICOLON BAR UP DOT_DOT UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR RIGHT_BRK RIGHT_BRA MINUS_GT }]
  [oclExpression ::= (*) oclExpression MINUS_GT ITERATE LEFT_PAR variableDeclaration SEMICOLON variableDeclaration BAR oclExpression RIGHT_PAR , {EOF ENDPACKAGE CONTEXT INIT DERIVE INV DEF PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE IN THEN ELSE ENDIF COMMA DOT COLON SEMICOLON BAR UP DOT_DOT UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR RIGHT_BRK RIGHT_BRA MINUS_GT }]
  [tupleLiteralExp ::= (*) TUPLE LEFT_BRA variableDeclarationList RIGHT_BRA , {EOF ENDPACKAGE CONTEXT INIT DERIVE INV DEF PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE IN THEN ELSE ENDIF COMMA DOT COLON SEMICOLON BAR UP DOT_DOT UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR RIGHT_BRK RIGHT_BRA MINUS_GT }]
  [collectionKind ::= (*) SET , {LEFT_BRA }]
  [oclExpression ::= (*) oclExpression UP simpleName LEFT_PAR RIGHT_PAR , {EOF ENDPACKAGE CONTEXT INIT DERIVE INV DEF PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE IN THEN ELSE ENDIF COMMA DOT COLON SEMICOLON BAR UP DOT_DOT UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR RIGHT_BRK RIGHT_BRA MINUS_GT }]
  [oclExpression ::= (*) oclExpression NE oclExpression , {EOF ENDPACKAGE CONTEXT INIT DERIVE INV DEF PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE IN THEN ELSE ENDIF COMMA DOT COLON SEMICOLON BAR UP DOT_DOT UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR RIGHT_BRK RIGHT_BRA MINUS_GT }]
  [oclExpression ::= (*) oclExpression DIVIDE oclExpression , {EOF ENDPACKAGE CONTEXT INIT DERIVE INV DEF PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE IN THEN ELSE ENDIF COMMA DOT COLON SEMICOLON BAR UP DOT_DOT UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR RIGHT_BRK RIGHT_BRA MINUS_GT }]
  [oclExpression ::= (*) oclExpression LEFT_PAR arguments RIGHT_PAR , {EOF ENDPACKAGE CONTEXT INIT DERIVE INV DEF PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE IN THEN ELSE ENDIF COMMA DOT COLON SEMICOLON BAR UP DOT_DOT UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR RIGHT_BRK RIGHT_BRA MINUS_GT }]
  [primitiveLiteralExp ::= (*) FALSE , {EOF ENDPACKAGE CONTEXT INIT DERIVE INV DEF PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE IN THEN ELSE ENDIF COMMA DOT COLON SEMICOLON BAR UP DOT_DOT UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR RIGHT_BRK RIGHT_BRA MINUS_GT }]
  [oclExpression ::= LET variableDeclarationList IN (*) oclExpression , {EOF ENDPACKAGE CONTEXT INIT DERIVE INV DEF PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE IN THEN ELSE ENDIF COMMA DOT COLON SEMICOLON BAR UP DOT_DOT UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR RIGHT_BRK RIGHT_BRA MINUS_GT }]
  [literalExp ::= (*) primitiveLiteralExp , {EOF ENDPACKAGE CONTEXT INIT DERIVE INV DEF PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE IN THEN ELSE ENDIF COMMA DOT COLON SEMICOLON BAR UP DOT_DOT UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR RIGHT_BRK RIGHT_BRA MINUS_GT }]
  [oclExpression ::= (*) LET variableDeclarationList IN oclExpression , {EOF ENDPACKAGE CONTEXT INIT DERIVE INV DEF PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE IN THEN ELSE ENDIF COMMA DOT COLON SEMICOLON BAR UP DOT_DOT UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR RIGHT_BRK RIGHT_BRA MINUS_GT }]
  [oclExpression ::= (*) oclExpression GT oclExpression , {EOF ENDPACKAGE CONTEXT INIT DERIVE INV DEF PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE IN THEN ELSE ENDIF COMMA DOT COLON SEMICOLON BAR UP DOT_DOT UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR RIGHT_BRK RIGHT_BRA MINUS_GT }]
  [oclExpression ::= (*) oclExpression MINUS_GT ITERATE LEFT_PAR variableDeclaration BAR oclExpression RIGHT_PAR , {EOF ENDPACKAGE CONTEXT INIT DERIVE INV DEF PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE IN THEN ELSE ENDIF COMMA DOT COLON SEMICOLON BAR UP DOT_DOT UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR RIGHT_BRK RIGHT_BRA MINUS_GT }]
  [oclExpression ::= (*) literalExp , {EOF ENDPACKAGE CONTEXT INIT DERIVE INV DEF PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE IN THEN ELSE ENDIF COMMA DOT COLON SEMICOLON BAR UP DOT_DOT UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR RIGHT_BRK RIGHT_BRA MINUS_GT }]
  [primitiveLiteralExp ::= (*) INTEGER , {EOF ENDPACKAGE CONTEXT INIT DERIVE INV DEF PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE IN THEN ELSE ENDIF COMMA DOT COLON SEMICOLON BAR UP DOT_DOT UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR RIGHT_BRK RIGHT_BRA MINUS_GT }]
  [collectionKind ::= (*) BAG , {LEFT_BRA }]
  [oclExpression ::= (*) oclExpression AND oclExpression , {EOF ENDPACKAGE CONTEXT INIT DERIVE INV DEF PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE IN THEN ELSE ENDIF COMMA DOT COLON SEMICOLON BAR UP DOT_DOT UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR RIGHT_BRK RIGHT_BRA MINUS_GT }]
  [oclExpression ::= (*) oclExpression PLUS oclExpression , {EOF ENDPACKAGE CONTEXT INIT DERIVE INV DEF PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE IN THEN ELSE ENDIF COMMA DOT COLON SEMICOLON BAR UP DOT_DOT UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR RIGHT_BRK RIGHT_BRA MINUS_GT }]
  [oclExpression ::= (*) oclExpression LEFT_PAR variableDeclaration BAR oclExpression RIGHT_PAR , {EOF ENDPACKAGE CONTEXT INIT DERIVE INV DEF PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE IN THEN ELSE ENDIF COMMA DOT COLON SEMICOLON BAR UP DOT_DOT UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR RIGHT_BRK RIGHT_BRA MINUS_GT }]
  [pathName ::= (*) simpleName , {EOF ENDPACKAGE CONTEXT INIT DERIVE INV DEF PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE IN THEN ELSE ENDIF COMMA DOT COLON SEMICOLON BAR UP AT DOT_DOT COLON_COLON UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR RIGHT_BRK RIGHT_BRA MINUS_GT }]
  [oclExpression ::= (*) oclExpression UP_UP simpleName LEFT_PAR oclMessageArgumentList RIGHT_PAR , {EOF ENDPACKAGE CONTEXT INIT DERIVE INV DEF PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE IN THEN ELSE ENDIF COMMA DOT COLON SEMICOLON BAR UP DOT_DOT UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR RIGHT_BRK RIGHT_BRA MINUS_GT }]
  [oclExpression ::= (*) oclExpression LE oclExpression , {EOF ENDPACKAGE CONTEXT INIT DERIVE INV DEF PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE IN THEN ELSE ENDIF COMMA DOT COLON SEMICOLON BAR UP DOT_DOT UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR RIGHT_BRK RIGHT_BRA MINUS_GT }]
  [oclExpression ::= (*) NOT oclExpression , {EOF ENDPACKAGE CONTEXT INIT DERIVE INV DEF PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE IN THEN ELSE ENDIF COMMA DOT COLON SEMICOLON BAR UP DOT_DOT UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR RIGHT_BRK RIGHT_BRA MINUS_GT }]
  [oclExpression ::= (*) LEFT_PAR oclExpression RIGHT_PAR , {EOF ENDPACKAGE CONTEXT INIT DERIVE INV DEF PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE IN THEN ELSE ENDIF COMMA DOT COLON SEMICOLON BAR UP DOT_DOT UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR RIGHT_BRK RIGHT_BRA MINUS_GT }]
  [primitiveLiteralExp ::= (*) REAL , {EOF ENDPACKAGE CONTEXT INIT DERIVE INV DEF PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE IN THEN ELSE ENDIF COMMA DOT COLON SEMICOLON BAR UP DOT_DOT UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR RIGHT_BRK RIGHT_BRA MINUS_GT }]
  [collectionKind ::= (*) SEQUENCE , {LEFT_BRA }]
  [oclExpression ::= (*) oclExpression OR oclExpression , {EOF ENDPACKAGE CONTEXT INIT DERIVE INV DEF PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE IN THEN ELSE ENDIF COMMA DOT COLON SEMICOLON BAR UP DOT_DOT UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR RIGHT_BRK RIGHT_BRA MINUS_GT }]
  [oclExpression ::= (*) oclExpression MINUS oclExpression , {EOF ENDPACKAGE CONTEXT INIT DERIVE INV DEF PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE IN THEN ELSE ENDIF COMMA DOT COLON SEMICOLON BAR UP DOT_DOT UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR RIGHT_BRK RIGHT_BRA MINUS_GT }]
  [oclExpression ::= (*) oclExpression LEFT_BRK argumentList RIGHT_BRK isMarkedPre , {EOF ENDPACKAGE CONTEXT INIT DERIVE INV DEF PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE IN THEN ELSE ENDIF COMMA DOT COLON SEMICOLON BAR UP DOT_DOT UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR RIGHT_BRK RIGHT_BRA MINUS_GT }]
  [pathName ::= (*) pathName COLON_COLON simpleName , {EOF ENDPACKAGE CONTEXT INIT DERIVE INV DEF PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE IN THEN ELSE ENDIF COMMA DOT COLON SEMICOLON BAR UP AT DOT_DOT COLON_COLON UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR RIGHT_BRK RIGHT_BRA MINUS_GT }]
  [collectionLiteralExp ::= (*) collectionKind LEFT_BRA collectionLiteralParts RIGHT_BRA , {EOF ENDPACKAGE CONTEXT INIT DERIVE INV DEF PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE IN THEN ELSE ENDIF COMMA DOT COLON SEMICOLON BAR UP DOT_DOT UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR RIGHT_BRK RIGHT_BRA MINUS_GT }]
  [oclExpression ::= (*) oclExpression UP_UP simpleName LEFT_PAR RIGHT_PAR , {EOF ENDPACKAGE CONTEXT INIT DERIVE INV DEF PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE IN THEN ELSE ENDIF COMMA DOT COLON SEMICOLON BAR UP DOT_DOT UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR RIGHT_BRK RIGHT_BRA MINUS_GT }]
  [oclExpression ::= (*) oclExpression GE oclExpression , {EOF ENDPACKAGE CONTEXT INIT DERIVE INV DEF PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE IN THEN ELSE ENDIF COMMA DOT COLON SEMICOLON BAR UP DOT_DOT UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR RIGHT_BRK RIGHT_BRA MINUS_GT }]
  [oclExpression ::= (*) MINUS oclExpression , {EOF ENDPACKAGE CONTEXT INIT DERIVE INV DEF PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE IN THEN ELSE ENDIF COMMA DOT COLON SEMICOLON BAR UP DOT_DOT UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR RIGHT_BRK RIGHT_BRA MINUS_GT }]
  [oclExpression ::= (*) pathName isMarkedPre , {EOF ENDPACKAGE CONTEXT INIT DERIVE INV DEF PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE IN THEN ELSE ENDIF COMMA DOT COLON SEMICOLON BAR UP DOT_DOT UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR RIGHT_BRK RIGHT_BRA MINUS_GT }]
  [primitiveLiteralExp ::= (*) STRING , {EOF ENDPACKAGE CONTEXT INIT DERIVE INV DEF PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE IN THEN ELSE ENDIF COMMA DOT COLON SEMICOLON BAR UP DOT_DOT UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR RIGHT_BRK RIGHT_BRA MINUS_GT }]
  [collectionKind ::= (*) COLLECTION , {LEFT_BRA }]
  [literalExp ::= (*) collectionLiteralExp , {EOF ENDPACKAGE CONTEXT INIT DERIVE INV DEF PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE IN THEN ELSE ENDIF COMMA DOT COLON SEMICOLON BAR UP DOT_DOT UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR RIGHT_BRK RIGHT_BRA MINUS_GT }]
  [oclExpression ::= (*) oclExpression XOR oclExpression , {EOF ENDPACKAGE CONTEXT INIT DERIVE INV DEF PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE IN THEN ELSE ENDIF COMMA DOT COLON SEMICOLON BAR UP DOT_DOT UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR RIGHT_BRK RIGHT_BRA MINUS_GT }]
  [oclExpression ::= (*) IF oclExpression THEN oclExpression ELSE oclExpression ENDIF , {EOF ENDPACKAGE CONTEXT INIT DERIVE INV DEF PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE IN THEN ELSE ENDIF COMMA DOT COLON SEMICOLON BAR UP DOT_DOT UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR RIGHT_BRK RIGHT_BRA MINUS_GT }]
  [oclExpression ::= (*) oclExpression MINUS_GT simpleName , {EOF ENDPACKAGE CONTEXT INIT DERIVE INV DEF PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE IN THEN ELSE ENDIF COMMA DOT COLON SEMICOLON BAR UP DOT_DOT UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR RIGHT_BRK RIGHT_BRA MINUS_GT }]
  [simpleName ::= (*) SIMPLE_NAME , {EOF ENDPACKAGE CONTEXT INIT DERIVE INV DEF PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE IN THEN ELSE ENDIF COMMA DOT COLON SEMICOLON BAR UP AT DOT_DOT COLON_COLON UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR RIGHT_BRK RIGHT_BRA MINUS_GT }]
  [collectionLiteralExp ::= (*) collectionKind LEFT_BRA RIGHT_BRA , {EOF ENDPACKAGE CONTEXT INIT DERIVE INV DEF PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE IN THEN ELSE ENDIF COMMA DOT COLON SEMICOLON BAR UP DOT_DOT UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR RIGHT_BRK RIGHT_BRA MINUS_GT }]
}
transition on tupleLiteralExp to state [54]
transition on oclExpression to state [141]
transition on REAL to state [52]
transition on INTEGER to state [51]
transition on pathName to state [50]
transition on SIMPLE_NAME to state [12]
transition on LET to state [49]
transition on FALSE to state [48]
transition on MINUS to state [47]
transition on COLLECTION to state [28]
transition on SET to state [20]
transition on simpleName to state [26]
transition on collectionLiteralExp to state [46]
transition on LEFT_PAR to state [45]
transition on STRING to state [44]
transition on IF to state [43]
transition on TRUE to state [42]
transition on collectionKind to state [41]
transition on NOT to state [40]
transition on primitiveLiteralExp to state [39]
transition on TUPLE to state [38]
transition on literalExp to state [37]
transition on BAG to state [25]
transition on SEQUENCE to state [22]

-------------------
lalr_state [141]: {
  [oclExpression ::= oclExpression (*) LEFT_BRK argumentList RIGHT_BRK isMarkedPre , {EOF ENDPACKAGE CONTEXT INIT DERIVE INV DEF PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE IN THEN ELSE ENDIF COMMA DOT COLON SEMICOLON BAR UP DOT_DOT UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR RIGHT_BRK RIGHT_BRA MINUS_GT }]
  [oclExpression ::= oclExpression (*) EQ oclExpression , {EOF ENDPACKAGE CONTEXT INIT DERIVE INV DEF PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE IN THEN ELSE ENDIF COMMA DOT COLON SEMICOLON BAR UP DOT_DOT UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR RIGHT_BRK RIGHT_BRA MINUS_GT }]
  [oclExpression ::= oclExpression (*) IMPLIES oclExpression , {EOF ENDPACKAGE CONTEXT INIT DERIVE INV DEF PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE IN THEN ELSE ENDIF COMMA DOT COLON SEMICOLON BAR UP DOT_DOT UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR RIGHT_BRK RIGHT_BRA MINUS_GT }]
  [oclExpression ::= oclExpression (*) UP simpleName LEFT_PAR RIGHT_PAR , {EOF ENDPACKAGE CONTEXT INIT DERIVE INV DEF PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE IN THEN ELSE ENDIF COMMA DOT COLON SEMICOLON BAR UP DOT_DOT UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR RIGHT_BRK RIGHT_BRA MINUS_GT }]
  [oclExpression ::= oclExpression (*) LEFT_PAR arguments RIGHT_PAR , {EOF ENDPACKAGE CONTEXT INIT DERIVE INV DEF PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE IN THEN ELSE ENDIF COMMA DOT COLON SEMICOLON BAR UP DOT_DOT UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR RIGHT_BRK RIGHT_BRA MINUS_GT }]
  [oclExpression ::= oclExpression (*) MINUS_GT ITERATE LEFT_PAR variableDeclaration BAR oclExpression RIGHT_PAR , {EOF ENDPACKAGE CONTEXT INIT DERIVE INV DEF PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE IN THEN ELSE ENDIF COMMA DOT COLON SEMICOLON BAR UP DOT_DOT UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR RIGHT_BRK RIGHT_BRA MINUS_GT }]
  [oclExpression ::= oclExpression (*) PLUS oclExpression , {EOF ENDPACKAGE CONTEXT INIT DERIVE INV DEF PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE IN THEN ELSE ENDIF COMMA DOT COLON SEMICOLON BAR UP DOT_DOT UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR RIGHT_BRK RIGHT_BRA MINUS_GT }]
  [oclExpression ::= oclExpression (*) LE oclExpression , {EOF ENDPACKAGE CONTEXT INIT DERIVE INV DEF PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE IN THEN ELSE ENDIF COMMA DOT COLON SEMICOLON BAR UP DOT_DOT UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR RIGHT_BRK RIGHT_BRA MINUS_GT }]
  [oclExpression ::= oclExpression (*) OR oclExpression , {EOF ENDPACKAGE CONTEXT INIT DERIVE INV DEF PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE IN THEN ELSE ENDIF COMMA DOT COLON SEMICOLON BAR UP DOT_DOT UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR RIGHT_BRK RIGHT_BRA MINUS_GT }]
  [oclExpression ::= oclExpression (*) UP_UP simpleName LEFT_PAR RIGHT_PAR , {EOF ENDPACKAGE CONTEXT INIT DERIVE INV DEF PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE IN THEN ELSE ENDIF COMMA DOT COLON SEMICOLON BAR UP DOT_DOT UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR RIGHT_BRK RIGHT_BRA MINUS_GT }]
  [oclExpression ::= oclExpression (*) MINUS_GT simpleName , {EOF ENDPACKAGE CONTEXT INIT DERIVE INV DEF PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE IN THEN ELSE ENDIF COMMA DOT COLON SEMICOLON BAR UP DOT_DOT UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR RIGHT_BRK RIGHT_BRA MINUS_GT }]
  [oclExpression ::= LET variableDeclarationList IN oclExpression (*) , {EOF ENDPACKAGE CONTEXT INIT DERIVE INV DEF PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE IN THEN ELSE ENDIF COMMA DOT COLON SEMICOLON BAR UP DOT_DOT UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR RIGHT_BRK RIGHT_BRA MINUS_GT }]
  [oclExpression ::= oclExpression (*) TIMES oclExpression , {EOF ENDPACKAGE CONTEXT INIT DERIVE INV DEF PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE IN THEN ELSE ENDIF COMMA DOT COLON SEMICOLON BAR UP DOT_DOT UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR RIGHT_BRK RIGHT_BRA MINUS_GT }]
  [oclExpression ::= oclExpression (*) LT oclExpression , {EOF ENDPACKAGE CONTEXT INIT DERIVE INV DEF PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE IN THEN ELSE ENDIF COMMA DOT COLON SEMICOLON BAR UP DOT_DOT UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR RIGHT_BRK RIGHT_BRA MINUS_GT }]
  [oclExpression ::= oclExpression (*) NE oclExpression , {EOF ENDPACKAGE CONTEXT INIT DERIVE INV DEF PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE IN THEN ELSE ENDIF COMMA DOT COLON SEMICOLON BAR UP DOT_DOT UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR RIGHT_BRK RIGHT_BRA MINUS_GT }]
  [oclExpression ::= oclExpression (*) LEFT_PAR variableDeclaration BAR oclExpression RIGHT_PAR , {EOF ENDPACKAGE CONTEXT INIT DERIVE INV DEF PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE IN THEN ELSE ENDIF COMMA DOT COLON SEMICOLON BAR UP DOT_DOT UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR RIGHT_BRK RIGHT_BRA MINUS_GT }]
  [oclExpression ::= oclExpression (*) MINUS oclExpression , {EOF ENDPACKAGE CONTEXT INIT DERIVE INV DEF PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE IN THEN ELSE ENDIF COMMA DOT COLON SEMICOLON BAR UP DOT_DOT UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR RIGHT_BRK RIGHT_BRA MINUS_GT }]
  [oclExpression ::= oclExpression (*) GE oclExpression , {EOF ENDPACKAGE CONTEXT INIT DERIVE INV DEF PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE IN THEN ELSE ENDIF COMMA DOT COLON SEMICOLON BAR UP DOT_DOT UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR RIGHT_BRK RIGHT_BRA MINUS_GT }]
  [oclExpression ::= oclExpression (*) XOR oclExpression , {EOF ENDPACKAGE CONTEXT INIT DERIVE INV DEF PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE IN THEN ELSE ENDIF COMMA DOT COLON SEMICOLON BAR UP DOT_DOT UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR RIGHT_BRK RIGHT_BRA MINUS_GT }]
  [oclExpression ::= oclExpression (*) UP simpleName LEFT_PAR oclMessageArgumentList RIGHT_PAR , {EOF ENDPACKAGE CONTEXT INIT DERIVE INV DEF PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE IN THEN ELSE ENDIF COMMA DOT COLON SEMICOLON BAR UP DOT_DOT UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR RIGHT_BRK RIGHT_BRA MINUS_GT }]
  [oclExpression ::= oclExpression (*) DOT simpleName isMarkedPre , {EOF ENDPACKAGE CONTEXT INIT DERIVE INV DEF PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE IN THEN ELSE ENDIF COMMA DOT COLON SEMICOLON BAR UP DOT_DOT UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR RIGHT_BRK RIGHT_BRA MINUS_GT }]
  [oclExpression ::= oclExpression (*) MINUS_GT ITERATE LEFT_PAR variableDeclaration SEMICOLON variableDeclaration BAR oclExpression RIGHT_PAR , {EOF ENDPACKAGE CONTEXT INIT DERIVE INV DEF PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE IN THEN ELSE ENDIF COMMA DOT COLON SEMICOLON BAR UP DOT_DOT UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR RIGHT_BRK RIGHT_BRA MINUS_GT }]
  [oclExpression ::= oclExpression (*) DIVIDE oclExpression , {EOF ENDPACKAGE CONTEXT INIT DERIVE INV DEF PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE IN THEN ELSE ENDIF COMMA DOT COLON SEMICOLON BAR UP DOT_DOT UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR RIGHT_BRK RIGHT_BRA MINUS_GT }]
  [oclExpression ::= oclExpression (*) GT oclExpression , {EOF ENDPACKAGE CONTEXT INIT DERIVE INV DEF PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE IN THEN ELSE ENDIF COMMA DOT COLON SEMICOLON BAR UP DOT_DOT UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR RIGHT_BRK RIGHT_BRA MINUS_GT }]
  [oclExpression ::= oclExpression (*) AND oclExpression , {EOF ENDPACKAGE CONTEXT INIT DERIVE INV DEF PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE IN THEN ELSE ENDIF COMMA DOT COLON SEMICOLON BAR UP DOT_DOT UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR RIGHT_BRK RIGHT_BRA MINUS_GT }]
  [oclExpression ::= oclExpression (*) UP_UP simpleName LEFT_PAR oclMessageArgumentList RIGHT_PAR , {EOF ENDPACKAGE CONTEXT INIT DERIVE INV DEF PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE IN THEN ELSE ENDIF COMMA DOT COLON SEMICOLON BAR UP DOT_DOT UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR RIGHT_BRK RIGHT_BRA MINUS_GT }]
}
transition on XOR to state [74]
transition on EQ to state [73]
transition on DOT to state [72]
transition on MINUS to state [71]
transition on GE to state [70]
transition on LEFT_BRK to state [69]
transition on DIVIDE to state [68]
transition on LEFT_PAR to state [67]
transition on MINUS_GT to state [66]
transition on LE to state [65]
transition on GT to state [64]
transition on IMPLIES to state [63]
transition on UP to state [62]
transition on UP_UP to state [61]
transition on OR to state [60]
transition on PLUS to state [59]
transition on NE to state [58]
transition on LT to state [57]
transition on AND to state [56]
transition on TIMES to state [55]

-------------------
lalr_state [142]: {
  [oclExpression ::= MINUS oclExpression (*) , {EOF ENDPACKAGE CONTEXT INIT DERIVE INV DEF PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE IN THEN ELSE ENDIF COMMA DOT COLON SEMICOLON BAR UP DOT_DOT UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR RIGHT_BRK RIGHT_BRA MINUS_GT }]
  [oclExpression ::= oclExpression (*) LEFT_BRK argumentList RIGHT_BRK isMarkedPre , {EOF ENDPACKAGE CONTEXT INIT DERIVE INV DEF PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE IN THEN ELSE ENDIF COMMA DOT COLON SEMICOLON BAR UP DOT_DOT UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR RIGHT_BRK RIGHT_BRA MINUS_GT }]
  [oclExpression ::= oclExpression (*) EQ oclExpression , {EOF ENDPACKAGE CONTEXT INIT DERIVE INV DEF PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE IN THEN ELSE ENDIF COMMA DOT COLON SEMICOLON BAR UP DOT_DOT UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR RIGHT_BRK RIGHT_BRA MINUS_GT }]
  [oclExpression ::= oclExpression (*) IMPLIES oclExpression , {EOF ENDPACKAGE CONTEXT INIT DERIVE INV DEF PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE IN THEN ELSE ENDIF COMMA DOT COLON SEMICOLON BAR UP DOT_DOT UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR RIGHT_BRK RIGHT_BRA MINUS_GT }]
  [oclExpression ::= oclExpression (*) UP simpleName LEFT_PAR RIGHT_PAR , {EOF ENDPACKAGE CONTEXT INIT DERIVE INV DEF PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE IN THEN ELSE ENDIF COMMA DOT COLON SEMICOLON BAR UP DOT_DOT UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR RIGHT_BRK RIGHT_BRA MINUS_GT }]
  [oclExpression ::= oclExpression (*) LEFT_PAR arguments RIGHT_PAR , {EOF ENDPACKAGE CONTEXT INIT DERIVE INV DEF PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE IN THEN ELSE ENDIF COMMA DOT COLON SEMICOLON BAR UP DOT_DOT UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR RIGHT_BRK RIGHT_BRA MINUS_GT }]
  [oclExpression ::= oclExpression (*) MINUS_GT ITERATE LEFT_PAR variableDeclaration BAR oclExpression RIGHT_PAR , {EOF ENDPACKAGE CONTEXT INIT DERIVE INV DEF PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE IN THEN ELSE ENDIF COMMA DOT COLON SEMICOLON BAR UP DOT_DOT UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR RIGHT_BRK RIGHT_BRA MINUS_GT }]
  [oclExpression ::= oclExpression (*) PLUS oclExpression , {EOF ENDPACKAGE CONTEXT INIT DERIVE INV DEF PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE IN THEN ELSE ENDIF COMMA DOT COLON SEMICOLON BAR UP DOT_DOT UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR RIGHT_BRK RIGHT_BRA MINUS_GT }]
  [oclExpression ::= oclExpression (*) LE oclExpression , {EOF ENDPACKAGE CONTEXT INIT DERIVE INV DEF PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE IN THEN ELSE ENDIF COMMA DOT COLON SEMICOLON BAR UP DOT_DOT UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR RIGHT_BRK RIGHT_BRA MINUS_GT }]
  [oclExpression ::= oclExpression (*) OR oclExpression , {EOF ENDPACKAGE CONTEXT INIT DERIVE INV DEF PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE IN THEN ELSE ENDIF COMMA DOT COLON SEMICOLON BAR UP DOT_DOT UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR RIGHT_BRK RIGHT_BRA MINUS_GT }]
  [oclExpression ::= oclExpression (*) UP_UP simpleName LEFT_PAR RIGHT_PAR , {EOF ENDPACKAGE CONTEXT INIT DERIVE INV DEF PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE IN THEN ELSE ENDIF COMMA DOT COLON SEMICOLON BAR UP DOT_DOT UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR RIGHT_BRK RIGHT_BRA MINUS_GT }]
  [oclExpression ::= oclExpression (*) MINUS_GT simpleName , {EOF ENDPACKAGE CONTEXT INIT DERIVE INV DEF PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE IN THEN ELSE ENDIF COMMA DOT COLON SEMICOLON BAR UP DOT_DOT UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR RIGHT_BRK RIGHT_BRA MINUS_GT }]
  [oclExpression ::= oclExpression (*) TIMES oclExpression , {EOF ENDPACKAGE CONTEXT INIT DERIVE INV DEF PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE IN THEN ELSE ENDIF COMMA DOT COLON SEMICOLON BAR UP DOT_DOT UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR RIGHT_BRK RIGHT_BRA MINUS_GT }]
  [oclExpression ::= oclExpression (*) LT oclExpression , {EOF ENDPACKAGE CONTEXT INIT DERIVE INV DEF PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE IN THEN ELSE ENDIF COMMA DOT COLON SEMICOLON BAR UP DOT_DOT UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR RIGHT_BRK RIGHT_BRA MINUS_GT }]
  [oclExpression ::= oclExpression (*) NE oclExpression , {EOF ENDPACKAGE CONTEXT INIT DERIVE INV DEF PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE IN THEN ELSE ENDIF COMMA DOT COLON SEMICOLON BAR UP DOT_DOT UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR RIGHT_BRK RIGHT_BRA MINUS_GT }]
  [oclExpression ::= oclExpression (*) LEFT_PAR variableDeclaration BAR oclExpression RIGHT_PAR , {EOF ENDPACKAGE CONTEXT INIT DERIVE INV DEF PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE IN THEN ELSE ENDIF COMMA DOT COLON SEMICOLON BAR UP DOT_DOT UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR RIGHT_BRK RIGHT_BRA MINUS_GT }]
  [oclExpression ::= oclExpression (*) MINUS oclExpression , {EOF ENDPACKAGE CONTEXT INIT DERIVE INV DEF PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE IN THEN ELSE ENDIF COMMA DOT COLON SEMICOLON BAR UP DOT_DOT UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR RIGHT_BRK RIGHT_BRA MINUS_GT }]
  [oclExpression ::= oclExpression (*) GE oclExpression , {EOF ENDPACKAGE CONTEXT INIT DERIVE INV DEF PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE IN THEN ELSE ENDIF COMMA DOT COLON SEMICOLON BAR UP DOT_DOT UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR RIGHT_BRK RIGHT_BRA MINUS_GT }]
  [oclExpression ::= oclExpression (*) XOR oclExpression , {EOF ENDPACKAGE CONTEXT INIT DERIVE INV DEF PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE IN THEN ELSE ENDIF COMMA DOT COLON SEMICOLON BAR UP DOT_DOT UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR RIGHT_BRK RIGHT_BRA MINUS_GT }]
  [oclExpression ::= oclExpression (*) UP simpleName LEFT_PAR oclMessageArgumentList RIGHT_PAR , {EOF ENDPACKAGE CONTEXT INIT DERIVE INV DEF PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE IN THEN ELSE ENDIF COMMA DOT COLON SEMICOLON BAR UP DOT_DOT UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR RIGHT_BRK RIGHT_BRA MINUS_GT }]
  [oclExpression ::= oclExpression (*) DOT simpleName isMarkedPre , {EOF ENDPACKAGE CONTEXT INIT DERIVE INV DEF PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE IN THEN ELSE ENDIF COMMA DOT COLON SEMICOLON BAR UP DOT_DOT UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR RIGHT_BRK RIGHT_BRA MINUS_GT }]
  [oclExpression ::= oclExpression (*) MINUS_GT ITERATE LEFT_PAR variableDeclaration SEMICOLON variableDeclaration BAR oclExpression RIGHT_PAR , {EOF ENDPACKAGE CONTEXT INIT DERIVE INV DEF PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE IN THEN ELSE ENDIF COMMA DOT COLON SEMICOLON BAR UP DOT_DOT UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR RIGHT_BRK RIGHT_BRA MINUS_GT }]
  [oclExpression ::= oclExpression (*) DIVIDE oclExpression , {EOF ENDPACKAGE CONTEXT INIT DERIVE INV DEF PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE IN THEN ELSE ENDIF COMMA DOT COLON SEMICOLON BAR UP DOT_DOT UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR RIGHT_BRK RIGHT_BRA MINUS_GT }]
  [oclExpression ::= oclExpression (*) GT oclExpression , {EOF ENDPACKAGE CONTEXT INIT DERIVE INV DEF PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE IN THEN ELSE ENDIF COMMA DOT COLON SEMICOLON BAR UP DOT_DOT UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR RIGHT_BRK RIGHT_BRA MINUS_GT }]
  [oclExpression ::= oclExpression (*) AND oclExpression , {EOF ENDPACKAGE CONTEXT INIT DERIVE INV DEF PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE IN THEN ELSE ENDIF COMMA DOT COLON SEMICOLON BAR UP DOT_DOT UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR RIGHT_BRK RIGHT_BRA MINUS_GT }]
  [oclExpression ::= oclExpression (*) UP_UP simpleName LEFT_PAR oclMessageArgumentList RIGHT_PAR , {EOF ENDPACKAGE CONTEXT INIT DERIVE INV DEF PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE IN THEN ELSE ENDIF COMMA DOT COLON SEMICOLON BAR UP DOT_DOT UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR RIGHT_BRK RIGHT_BRA MINUS_GT }]
}
transition on XOR to state [74]
transition on EQ to state [73]
transition on DOT to state [72]
transition on MINUS to state [71]
transition on GE to state [70]
transition on LEFT_BRK to state [69]
transition on DIVIDE to state [68]
transition on LEFT_PAR to state [67]
transition on MINUS_GT to state [66]
transition on LE to state [65]
transition on GT to state [64]
transition on IMPLIES to state [63]
transition on UP to state [62]
transition on UP_UP to state [61]
transition on OR to state [60]
transition on PLUS to state [59]
transition on NE to state [58]
transition on LT to state [57]
transition on AND to state [56]
transition on TIMES to state [55]

-------------------
lalr_state [143]: {
  [oclExpression ::= oclExpression (*) LEFT_BRK argumentList RIGHT_BRK isMarkedPre , {IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE DOT UP UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR MINUS_GT }]
  [oclExpression ::= oclExpression (*) EQ oclExpression , {IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE DOT UP UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR MINUS_GT }]
  [oclExpression ::= oclExpression (*) IMPLIES oclExpression , {IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE DOT UP UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR MINUS_GT }]
  [oclExpression ::= oclExpression (*) UP simpleName LEFT_PAR RIGHT_PAR , {IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE DOT UP UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR MINUS_GT }]
  [oclExpression ::= oclExpression (*) LEFT_PAR arguments RIGHT_PAR , {IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE DOT UP UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR MINUS_GT }]
  [oclExpression ::= oclExpression (*) MINUS_GT ITERATE LEFT_PAR variableDeclaration BAR oclExpression RIGHT_PAR , {IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE DOT UP UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR MINUS_GT }]
  [oclExpression ::= oclExpression (*) PLUS oclExpression , {IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE DOT UP UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR MINUS_GT }]
  [oclExpression ::= oclExpression (*) LE oclExpression , {IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE DOT UP UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR MINUS_GT }]
  [oclExpression ::= oclExpression (*) OR oclExpression , {IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE DOT UP UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR MINUS_GT }]
  [oclExpression ::= oclExpression (*) UP_UP simpleName LEFT_PAR RIGHT_PAR , {IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE DOT UP UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR MINUS_GT }]
  [oclExpression ::= oclExpression (*) MINUS_GT simpleName , {IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE DOT UP UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR MINUS_GT }]
  [oclExpression ::= oclExpression (*) TIMES oclExpression , {IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE DOT UP UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR MINUS_GT }]
  [oclExpression ::= oclExpression (*) LT oclExpression , {IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE DOT UP UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR MINUS_GT }]
  [oclExpression ::= oclExpression (*) NE oclExpression , {IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE DOT UP UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR MINUS_GT }]
  [oclExpression ::= oclExpression (*) LEFT_PAR variableDeclaration BAR oclExpression RIGHT_PAR , {IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE DOT UP UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR MINUS_GT }]
  [oclExpression ::= oclExpression (*) MINUS oclExpression , {IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE DOT UP UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR MINUS_GT }]
  [oclExpression ::= oclExpression (*) GE oclExpression , {IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE DOT UP UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR MINUS_GT }]
  [oclExpression ::= oclExpression (*) XOR oclExpression , {IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE DOT UP UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR MINUS_GT }]
  [oclExpression ::= oclExpression (*) UP simpleName LEFT_PAR oclMessageArgumentList RIGHT_PAR , {IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE DOT UP UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR MINUS_GT }]
  [oclExpression ::= oclExpression (*) DOT simpleName isMarkedPre , {IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE DOT UP UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR MINUS_GT }]
  [oclExpression ::= oclExpression (*) MINUS_GT ITERATE LEFT_PAR variableDeclaration SEMICOLON variableDeclaration BAR oclExpression RIGHT_PAR , {IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE DOT UP UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR MINUS_GT }]
  [oclExpression ::= oclExpression (*) DIVIDE oclExpression , {IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE DOT UP UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR MINUS_GT }]
  [oclExpression ::= oclExpression (*) GT oclExpression , {IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE DOT UP UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR MINUS_GT }]
  [oclExpression ::= oclExpression (*) AND oclExpression , {IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE DOT UP UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR MINUS_GT }]
  [oclExpression ::= oclExpression (*) UP_UP simpleName LEFT_PAR oclMessageArgumentList RIGHT_PAR , {IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE DOT UP UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR MINUS_GT }]
  [oclExpression ::= LEFT_PAR oclExpression (*) RIGHT_PAR , {EOF ENDPACKAGE CONTEXT INIT DERIVE INV DEF PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE IN THEN ELSE ENDIF COMMA DOT COLON SEMICOLON BAR UP DOT_DOT UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR RIGHT_BRK RIGHT_BRA MINUS_GT }]
}
transition on XOR to state [74]
transition on EQ to state [73]
transition on DOT to state [72]
transition on MINUS to state [71]
transition on GE to state [70]
transition on LEFT_BRK to state [69]
transition on DIVIDE to state [68]
transition on RIGHT_PAR to state [144]
transition on LEFT_PAR to state [67]
transition on MINUS_GT to state [66]
transition on LE to state [65]
transition on GT to state [64]
transition on IMPLIES to state [63]
transition on UP to state [62]
transition on UP_UP to state [61]
transition on OR to state [60]
transition on PLUS to state [59]
transition on NE to state [58]
transition on LT to state [57]
transition on AND to state [56]
transition on TIMES to state [55]

-------------------
lalr_state [144]: {
  [oclExpression ::= LEFT_PAR oclExpression RIGHT_PAR (*) , {EOF ENDPACKAGE CONTEXT INIT DERIVE INV DEF PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE IN THEN ELSE ENDIF COMMA DOT COLON SEMICOLON BAR UP DOT_DOT UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR RIGHT_BRK RIGHT_BRA MINUS_GT }]
}

-------------------
lalr_state [145]: {
  [oclExpression ::= oclExpression (*) LEFT_BRK argumentList RIGHT_BRK isMarkedPre , {IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE THEN DOT UP UP_UP LEFT_PAR LEFT_BRK MINUS_GT }]
  [oclExpression ::= IF oclExpression (*) THEN oclExpression ELSE oclExpression ENDIF , {EOF ENDPACKAGE CONTEXT INIT DERIVE INV DEF PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE IN THEN ELSE ENDIF COMMA DOT COLON SEMICOLON BAR UP DOT_DOT UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR RIGHT_BRK RIGHT_BRA MINUS_GT }]
  [oclExpression ::= oclExpression (*) EQ oclExpression , {IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE THEN DOT UP UP_UP LEFT_PAR LEFT_BRK MINUS_GT }]
  [oclExpression ::= oclExpression (*) IMPLIES oclExpression , {IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE THEN DOT UP UP_UP LEFT_PAR LEFT_BRK MINUS_GT }]
  [oclExpression ::= oclExpression (*) UP simpleName LEFT_PAR RIGHT_PAR , {IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE THEN DOT UP UP_UP LEFT_PAR LEFT_BRK MINUS_GT }]
  [oclExpression ::= oclExpression (*) LEFT_PAR arguments RIGHT_PAR , {IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE THEN DOT UP UP_UP LEFT_PAR LEFT_BRK MINUS_GT }]
  [oclExpression ::= oclExpression (*) MINUS_GT ITERATE LEFT_PAR variableDeclaration BAR oclExpression RIGHT_PAR , {IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE THEN DOT UP UP_UP LEFT_PAR LEFT_BRK MINUS_GT }]
  [oclExpression ::= oclExpression (*) PLUS oclExpression , {IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE THEN DOT UP UP_UP LEFT_PAR LEFT_BRK MINUS_GT }]
  [oclExpression ::= oclExpression (*) LE oclExpression , {IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE THEN DOT UP UP_UP LEFT_PAR LEFT_BRK MINUS_GT }]
  [oclExpression ::= oclExpression (*) OR oclExpression , {IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE THEN DOT UP UP_UP LEFT_PAR LEFT_BRK MINUS_GT }]
  [oclExpression ::= oclExpression (*) UP_UP simpleName LEFT_PAR RIGHT_PAR , {IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE THEN DOT UP UP_UP LEFT_PAR LEFT_BRK MINUS_GT }]
  [oclExpression ::= oclExpression (*) MINUS_GT simpleName , {IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE THEN DOT UP UP_UP LEFT_PAR LEFT_BRK MINUS_GT }]
  [oclExpression ::= oclExpression (*) TIMES oclExpression , {IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE THEN DOT UP UP_UP LEFT_PAR LEFT_BRK MINUS_GT }]
  [oclExpression ::= oclExpression (*) LT oclExpression , {IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE THEN DOT UP UP_UP LEFT_PAR LEFT_BRK MINUS_GT }]
  [oclExpression ::= oclExpression (*) NE oclExpression , {IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE THEN DOT UP UP_UP LEFT_PAR LEFT_BRK MINUS_GT }]
  [oclExpression ::= oclExpression (*) LEFT_PAR variableDeclaration BAR oclExpression RIGHT_PAR , {IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE THEN DOT UP UP_UP LEFT_PAR LEFT_BRK MINUS_GT }]
  [oclExpression ::= oclExpression (*) MINUS oclExpression , {IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE THEN DOT UP UP_UP LEFT_PAR LEFT_BRK MINUS_GT }]
  [oclExpression ::= oclExpression (*) GE oclExpression , {IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE THEN DOT UP UP_UP LEFT_PAR LEFT_BRK MINUS_GT }]
  [oclExpression ::= oclExpression (*) XOR oclExpression , {IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE THEN DOT UP UP_UP LEFT_PAR LEFT_BRK MINUS_GT }]
  [oclExpression ::= oclExpression (*) UP simpleName LEFT_PAR oclMessageArgumentList RIGHT_PAR , {IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE THEN DOT UP UP_UP LEFT_PAR LEFT_BRK MINUS_GT }]
  [oclExpression ::= oclExpression (*) DOT simpleName isMarkedPre , {IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE THEN DOT UP UP_UP LEFT_PAR LEFT_BRK MINUS_GT }]
  [oclExpression ::= oclExpression (*) MINUS_GT ITERATE LEFT_PAR variableDeclaration SEMICOLON variableDeclaration BAR oclExpression RIGHT_PAR , {IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE THEN DOT UP UP_UP LEFT_PAR LEFT_BRK MINUS_GT }]
  [oclExpression ::= oclExpression (*) DIVIDE oclExpression , {IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE THEN DOT UP UP_UP LEFT_PAR LEFT_BRK MINUS_GT }]
  [oclExpression ::= oclExpression (*) GT oclExpression , {IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE THEN DOT UP UP_UP LEFT_PAR LEFT_BRK MINUS_GT }]
  [oclExpression ::= oclExpression (*) AND oclExpression , {IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE THEN DOT UP UP_UP LEFT_PAR LEFT_BRK MINUS_GT }]
  [oclExpression ::= oclExpression (*) UP_UP simpleName LEFT_PAR oclMessageArgumentList RIGHT_PAR , {IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE THEN DOT UP UP_UP LEFT_PAR LEFT_BRK MINUS_GT }]
}
transition on XOR to state [74]
transition on EQ to state [73]
transition on DOT to state [72]
transition on MINUS to state [71]
transition on GE to state [70]
transition on LEFT_BRK to state [69]
transition on DIVIDE to state [68]
transition on LEFT_PAR to state [67]
transition on MINUS_GT to state [66]
transition on LE to state [65]
transition on GT to state [64]
transition on IMPLIES to state [63]
transition on UP to state [62]
transition on THEN to state [146]
transition on UP_UP to state [61]
transition on OR to state [60]
transition on PLUS to state [59]
transition on NE to state [58]
transition on LT to state [57]
transition on AND to state [56]
transition on TIMES to state [55]

-------------------
lalr_state [146]: {
  [oclExpression ::= (*) oclExpression UP simpleName LEFT_PAR oclMessageArgumentList RIGHT_PAR , {IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE ELSE DOT UP UP_UP LEFT_PAR LEFT_BRK MINUS_GT }]
  [oclExpression ::= (*) oclExpression EQ oclExpression , {IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE ELSE DOT UP UP_UP LEFT_PAR LEFT_BRK MINUS_GT }]
  [oclExpression ::= (*) oclExpression TIMES oclExpression , {IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE ELSE DOT UP UP_UP LEFT_PAR LEFT_BRK MINUS_GT }]
  [oclExpression ::= (*) oclExpression DOT simpleName isMarkedPre , {IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE ELSE DOT UP UP_UP LEFT_PAR LEFT_BRK MINUS_GT }]
  [primitiveLiteralExp ::= (*) TRUE , {IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE ELSE DOT UP UP_UP LEFT_PAR LEFT_BRK MINUS_GT }]
  [literalExp ::= (*) tupleLiteralExp , {IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE ELSE DOT UP UP_UP LEFT_PAR LEFT_BRK MINUS_GT }]
  [oclExpression ::= (*) oclExpression IMPLIES oclExpression , {IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE ELSE DOT UP UP_UP LEFT_PAR LEFT_BRK MINUS_GT }]
  [oclExpression ::= (*) oclExpression LT oclExpression , {IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE ELSE DOT UP UP_UP LEFT_PAR LEFT_BRK MINUS_GT }]
  [oclExpression ::= (*) oclExpression MINUS_GT ITERATE LEFT_PAR variableDeclaration SEMICOLON variableDeclaration BAR oclExpression RIGHT_PAR , {IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE ELSE DOT UP UP_UP LEFT_PAR LEFT_BRK MINUS_GT }]
  [tupleLiteralExp ::= (*) TUPLE LEFT_BRA variableDeclarationList RIGHT_BRA , {IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE ELSE DOT UP UP_UP LEFT_PAR LEFT_BRK MINUS_GT }]
  [collectionKind ::= (*) SET , {LEFT_BRA }]
  [oclExpression ::= (*) oclExpression UP simpleName LEFT_PAR RIGHT_PAR , {IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE ELSE DOT UP UP_UP LEFT_PAR LEFT_BRK MINUS_GT }]
  [oclExpression ::= (*) oclExpression NE oclExpression , {IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE ELSE DOT UP UP_UP LEFT_PAR LEFT_BRK MINUS_GT }]
  [oclExpression ::= (*) oclExpression DIVIDE oclExpression , {IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE ELSE DOT UP UP_UP LEFT_PAR LEFT_BRK MINUS_GT }]
  [oclExpression ::= (*) oclExpression LEFT_PAR arguments RIGHT_PAR , {IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE ELSE DOT UP UP_UP LEFT_PAR LEFT_BRK MINUS_GT }]
  [primitiveLiteralExp ::= (*) FALSE , {IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE ELSE DOT UP UP_UP LEFT_PAR LEFT_BRK MINUS_GT }]
  [literalExp ::= (*) primitiveLiteralExp , {IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE ELSE DOT UP UP_UP LEFT_PAR LEFT_BRK MINUS_GT }]
  [oclExpression ::= (*) LET variableDeclarationList IN oclExpression , {IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE ELSE DOT UP UP_UP LEFT_PAR LEFT_BRK MINUS_GT }]
  [oclExpression ::= (*) oclExpression GT oclExpression , {IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE ELSE DOT UP UP_UP LEFT_PAR LEFT_BRK MINUS_GT }]
  [oclExpression ::= (*) oclExpression MINUS_GT ITERATE LEFT_PAR variableDeclaration BAR oclExpression RIGHT_PAR , {IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE ELSE DOT UP UP_UP LEFT_PAR LEFT_BRK MINUS_GT }]
  [oclExpression ::= (*) literalExp , {IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE ELSE DOT UP UP_UP LEFT_PAR LEFT_BRK MINUS_GT }]
  [primitiveLiteralExp ::= (*) INTEGER , {IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE ELSE DOT UP UP_UP LEFT_PAR LEFT_BRK MINUS_GT }]
  [collectionKind ::= (*) BAG , {LEFT_BRA }]
  [oclExpression ::= (*) oclExpression AND oclExpression , {IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE ELSE DOT UP UP_UP LEFT_PAR LEFT_BRK MINUS_GT }]
  [oclExpression ::= (*) oclExpression PLUS oclExpression , {IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE ELSE DOT UP UP_UP LEFT_PAR LEFT_BRK MINUS_GT }]
  [oclExpression ::= (*) oclExpression LEFT_PAR variableDeclaration BAR oclExpression RIGHT_PAR , {IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE ELSE DOT UP UP_UP LEFT_PAR LEFT_BRK MINUS_GT }]
  [pathName ::= (*) simpleName , {IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE ELSE DOT UP AT COLON_COLON UP_UP LEFT_PAR LEFT_BRK MINUS_GT }]
  [oclExpression ::= (*) oclExpression UP_UP simpleName LEFT_PAR oclMessageArgumentList RIGHT_PAR , {IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE ELSE DOT UP UP_UP LEFT_PAR LEFT_BRK MINUS_GT }]
  [oclExpression ::= (*) oclExpression LE oclExpression , {IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE ELSE DOT UP UP_UP LEFT_PAR LEFT_BRK MINUS_GT }]
  [oclExpression ::= (*) NOT oclExpression , {IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE ELSE DOT UP UP_UP LEFT_PAR LEFT_BRK MINUS_GT }]
  [oclExpression ::= (*) LEFT_PAR oclExpression RIGHT_PAR , {IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE ELSE DOT UP UP_UP LEFT_PAR LEFT_BRK MINUS_GT }]
  [primitiveLiteralExp ::= (*) REAL , {IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE ELSE DOT UP UP_UP LEFT_PAR LEFT_BRK MINUS_GT }]
  [collectionKind ::= (*) SEQUENCE , {LEFT_BRA }]
  [oclExpression ::= (*) oclExpression OR oclExpression , {IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE ELSE DOT UP UP_UP LEFT_PAR LEFT_BRK MINUS_GT }]
  [oclExpression ::= (*) oclExpression MINUS oclExpression , {IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE ELSE DOT UP UP_UP LEFT_PAR LEFT_BRK MINUS_GT }]
  [oclExpression ::= (*) oclExpression LEFT_BRK argumentList RIGHT_BRK isMarkedPre , {IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE ELSE DOT UP UP_UP LEFT_PAR LEFT_BRK MINUS_GT }]
  [pathName ::= (*) pathName COLON_COLON simpleName , {IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE ELSE DOT UP AT COLON_COLON UP_UP LEFT_PAR LEFT_BRK MINUS_GT }]
  [collectionLiteralExp ::= (*) collectionKind LEFT_BRA collectionLiteralParts RIGHT_BRA , {IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE ELSE DOT UP UP_UP LEFT_PAR LEFT_BRK MINUS_GT }]
  [oclExpression ::= (*) oclExpression UP_UP simpleName LEFT_PAR RIGHT_PAR , {IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE ELSE DOT UP UP_UP LEFT_PAR LEFT_BRK MINUS_GT }]
  [oclExpression ::= (*) oclExpression GE oclExpression , {IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE ELSE DOT UP UP_UP LEFT_PAR LEFT_BRK MINUS_GT }]
  [oclExpression ::= (*) MINUS oclExpression , {IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE ELSE DOT UP UP_UP LEFT_PAR LEFT_BRK MINUS_GT }]
  [oclExpression ::= (*) pathName isMarkedPre , {IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE ELSE DOT UP UP_UP LEFT_PAR LEFT_BRK MINUS_GT }]
  [primitiveLiteralExp ::= (*) STRING , {IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE ELSE DOT UP UP_UP LEFT_PAR LEFT_BRK MINUS_GT }]
  [collectionKind ::= (*) COLLECTION , {LEFT_BRA }]
  [literalExp ::= (*) collectionLiteralExp , {IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE ELSE DOT UP UP_UP LEFT_PAR LEFT_BRK MINUS_GT }]
  [oclExpression ::= IF oclExpression THEN (*) oclExpression ELSE oclExpression ENDIF , {EOF ENDPACKAGE CONTEXT INIT DERIVE INV DEF PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE IN THEN ELSE ENDIF COMMA DOT COLON SEMICOLON BAR UP DOT_DOT UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR RIGHT_BRK RIGHT_BRA MINUS_GT }]
  [oclExpression ::= (*) oclExpression XOR oclExpression , {IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE ELSE DOT UP UP_UP LEFT_PAR LEFT_BRK MINUS_GT }]
  [oclExpression ::= (*) IF oclExpression THEN oclExpression ELSE oclExpression ENDIF , {IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE ELSE DOT UP UP_UP LEFT_PAR LEFT_BRK MINUS_GT }]
  [oclExpression ::= (*) oclExpression MINUS_GT simpleName , {IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE ELSE DOT UP UP_UP LEFT_PAR LEFT_BRK MINUS_GT }]
  [simpleName ::= (*) SIMPLE_NAME , {IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE ELSE DOT UP AT COLON_COLON UP_UP LEFT_PAR LEFT_BRK MINUS_GT }]
  [collectionLiteralExp ::= (*) collectionKind LEFT_BRA RIGHT_BRA , {IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE ELSE DOT UP UP_UP LEFT_PAR LEFT_BRK MINUS_GT }]
}
transition on tupleLiteralExp to state [54]
transition on oclExpression to state [147]
transition on REAL to state [52]
transition on INTEGER to state [51]
transition on pathName to state [50]
transition on SIMPLE_NAME to state [12]
transition on LET to state [49]
transition on FALSE to state [48]
transition on MINUS to state [47]
transition on COLLECTION to state [28]
transition on SET to state [20]
transition on simpleName to state [26]
transition on collectionLiteralExp to state [46]
transition on LEFT_PAR to state [45]
transition on STRING to state [44]
transition on IF to state [43]
transition on TRUE to state [42]
transition on collectionKind to state [41]
transition on NOT to state [40]
transition on primitiveLiteralExp to state [39]
transition on TUPLE to state [38]
transition on literalExp to state [37]
transition on BAG to state [25]
transition on SEQUENCE to state [22]

-------------------
lalr_state [147]: {
  [oclExpression ::= IF oclExpression THEN oclExpression (*) ELSE oclExpression ENDIF , {EOF ENDPACKAGE CONTEXT INIT DERIVE INV DEF PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE IN THEN ELSE ENDIF COMMA DOT COLON SEMICOLON BAR UP DOT_DOT UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR RIGHT_BRK RIGHT_BRA MINUS_GT }]
  [oclExpression ::= oclExpression (*) LEFT_BRK argumentList RIGHT_BRK isMarkedPre , {IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE ELSE DOT UP UP_UP LEFT_PAR LEFT_BRK MINUS_GT }]
  [oclExpression ::= oclExpression (*) EQ oclExpression , {IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE ELSE DOT UP UP_UP LEFT_PAR LEFT_BRK MINUS_GT }]
  [oclExpression ::= oclExpression (*) IMPLIES oclExpression , {IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE ELSE DOT UP UP_UP LEFT_PAR LEFT_BRK MINUS_GT }]
  [oclExpression ::= oclExpression (*) UP simpleName LEFT_PAR RIGHT_PAR , {IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE ELSE DOT UP UP_UP LEFT_PAR LEFT_BRK MINUS_GT }]
  [oclExpression ::= oclExpression (*) LEFT_PAR arguments RIGHT_PAR , {IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE ELSE DOT UP UP_UP LEFT_PAR LEFT_BRK MINUS_GT }]
  [oclExpression ::= oclExpression (*) MINUS_GT ITERATE LEFT_PAR variableDeclaration BAR oclExpression RIGHT_PAR , {IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE ELSE DOT UP UP_UP LEFT_PAR LEFT_BRK MINUS_GT }]
  [oclExpression ::= oclExpression (*) PLUS oclExpression , {IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE ELSE DOT UP UP_UP LEFT_PAR LEFT_BRK MINUS_GT }]
  [oclExpression ::= oclExpression (*) LE oclExpression , {IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE ELSE DOT UP UP_UP LEFT_PAR LEFT_BRK MINUS_GT }]
  [oclExpression ::= oclExpression (*) OR oclExpression , {IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE ELSE DOT UP UP_UP LEFT_PAR LEFT_BRK MINUS_GT }]
  [oclExpression ::= oclExpression (*) UP_UP simpleName LEFT_PAR RIGHT_PAR , {IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE ELSE DOT UP UP_UP LEFT_PAR LEFT_BRK MINUS_GT }]
  [oclExpression ::= oclExpression (*) MINUS_GT simpleName , {IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE ELSE DOT UP UP_UP LEFT_PAR LEFT_BRK MINUS_GT }]
  [oclExpression ::= oclExpression (*) TIMES oclExpression , {IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE ELSE DOT UP UP_UP LEFT_PAR LEFT_BRK MINUS_GT }]
  [oclExpression ::= oclExpression (*) LT oclExpression , {IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE ELSE DOT UP UP_UP LEFT_PAR LEFT_BRK MINUS_GT }]
  [oclExpression ::= oclExpression (*) NE oclExpression , {IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE ELSE DOT UP UP_UP LEFT_PAR LEFT_BRK MINUS_GT }]
  [oclExpression ::= oclExpression (*) LEFT_PAR variableDeclaration BAR oclExpression RIGHT_PAR , {IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE ELSE DOT UP UP_UP LEFT_PAR LEFT_BRK MINUS_GT }]
  [oclExpression ::= oclExpression (*) MINUS oclExpression , {IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE ELSE DOT UP UP_UP LEFT_PAR LEFT_BRK MINUS_GT }]
  [oclExpression ::= oclExpression (*) GE oclExpression , {IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE ELSE DOT UP UP_UP LEFT_PAR LEFT_BRK MINUS_GT }]
  [oclExpression ::= oclExpression (*) XOR oclExpression , {IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE ELSE DOT UP UP_UP LEFT_PAR LEFT_BRK MINUS_GT }]
  [oclExpression ::= oclExpression (*) UP simpleName LEFT_PAR oclMessageArgumentList RIGHT_PAR , {IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE ELSE DOT UP UP_UP LEFT_PAR LEFT_BRK MINUS_GT }]
  [oclExpression ::= oclExpression (*) DOT simpleName isMarkedPre , {IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE ELSE DOT UP UP_UP LEFT_PAR LEFT_BRK MINUS_GT }]
  [oclExpression ::= oclExpression (*) MINUS_GT ITERATE LEFT_PAR variableDeclaration SEMICOLON variableDeclaration BAR oclExpression RIGHT_PAR , {IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE ELSE DOT UP UP_UP LEFT_PAR LEFT_BRK MINUS_GT }]
  [oclExpression ::= oclExpression (*) DIVIDE oclExpression , {IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE ELSE DOT UP UP_UP LEFT_PAR LEFT_BRK MINUS_GT }]
  [oclExpression ::= oclExpression (*) GT oclExpression , {IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE ELSE DOT UP UP_UP LEFT_PAR LEFT_BRK MINUS_GT }]
  [oclExpression ::= oclExpression (*) AND oclExpression , {IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE ELSE DOT UP UP_UP LEFT_PAR LEFT_BRK MINUS_GT }]
  [oclExpression ::= oclExpression (*) UP_UP simpleName LEFT_PAR oclMessageArgumentList RIGHT_PAR , {IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE ELSE DOT UP UP_UP LEFT_PAR LEFT_BRK MINUS_GT }]
}
transition on XOR to state [74]
transition on EQ to state [73]
transition on DOT to state [72]
transition on MINUS to state [71]
transition on GE to state [70]
transition on LEFT_BRK to state [69]
transition on DIVIDE to state [68]
transition on LEFT_PAR to state [67]
transition on MINUS_GT to state [66]
transition on LE to state [65]
transition on GT to state [64]
transition on IMPLIES to state [63]
transition on UP to state [62]
transition on UP_UP to state [61]
transition on OR to state [60]
transition on PLUS to state [59]
transition on ELSE to state [148]
transition on NE to state [58]
transition on LT to state [57]
transition on AND to state [56]
transition on TIMES to state [55]

-------------------
lalr_state [148]: {
  [oclExpression ::= (*) oclExpression UP simpleName LEFT_PAR oclMessageArgumentList RIGHT_PAR , {IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE ENDIF DOT UP UP_UP LEFT_PAR LEFT_BRK MINUS_GT }]
  [oclExpression ::= (*) oclExpression EQ oclExpression , {IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE ENDIF DOT UP UP_UP LEFT_PAR LEFT_BRK MINUS_GT }]
  [oclExpression ::= (*) oclExpression TIMES oclExpression , {IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE ENDIF DOT UP UP_UP LEFT_PAR LEFT_BRK MINUS_GT }]
  [oclExpression ::= (*) oclExpression DOT simpleName isMarkedPre , {IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE ENDIF DOT UP UP_UP LEFT_PAR LEFT_BRK MINUS_GT }]
  [primitiveLiteralExp ::= (*) TRUE , {IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE ENDIF DOT UP UP_UP LEFT_PAR LEFT_BRK MINUS_GT }]
  [literalExp ::= (*) tupleLiteralExp , {IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE ENDIF DOT UP UP_UP LEFT_PAR LEFT_BRK MINUS_GT }]
  [oclExpression ::= (*) oclExpression IMPLIES oclExpression , {IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE ENDIF DOT UP UP_UP LEFT_PAR LEFT_BRK MINUS_GT }]
  [oclExpression ::= (*) oclExpression LT oclExpression , {IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE ENDIF DOT UP UP_UP LEFT_PAR LEFT_BRK MINUS_GT }]
  [oclExpression ::= (*) oclExpression MINUS_GT ITERATE LEFT_PAR variableDeclaration SEMICOLON variableDeclaration BAR oclExpression RIGHT_PAR , {IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE ENDIF DOT UP UP_UP LEFT_PAR LEFT_BRK MINUS_GT }]
  [tupleLiteralExp ::= (*) TUPLE LEFT_BRA variableDeclarationList RIGHT_BRA , {IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE ENDIF DOT UP UP_UP LEFT_PAR LEFT_BRK MINUS_GT }]
  [collectionKind ::= (*) SET , {LEFT_BRA }]
  [oclExpression ::= (*) oclExpression UP simpleName LEFT_PAR RIGHT_PAR , {IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE ENDIF DOT UP UP_UP LEFT_PAR LEFT_BRK MINUS_GT }]
  [oclExpression ::= (*) oclExpression NE oclExpression , {IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE ENDIF DOT UP UP_UP LEFT_PAR LEFT_BRK MINUS_GT }]
  [oclExpression ::= (*) oclExpression DIVIDE oclExpression , {IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE ENDIF DOT UP UP_UP LEFT_PAR LEFT_BRK MINUS_GT }]
  [oclExpression ::= (*) oclExpression LEFT_PAR arguments RIGHT_PAR , {IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE ENDIF DOT UP UP_UP LEFT_PAR LEFT_BRK MINUS_GT }]
  [primitiveLiteralExp ::= (*) FALSE , {IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE ENDIF DOT UP UP_UP LEFT_PAR LEFT_BRK MINUS_GT }]
  [literalExp ::= (*) primitiveLiteralExp , {IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE ENDIF DOT UP UP_UP LEFT_PAR LEFT_BRK MINUS_GT }]
  [oclExpression ::= (*) LET variableDeclarationList IN oclExpression , {IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE ENDIF DOT UP UP_UP LEFT_PAR LEFT_BRK MINUS_GT }]
  [oclExpression ::= (*) oclExpression GT oclExpression , {IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE ENDIF DOT UP UP_UP LEFT_PAR LEFT_BRK MINUS_GT }]
  [oclExpression ::= (*) oclExpression MINUS_GT ITERATE LEFT_PAR variableDeclaration BAR oclExpression RIGHT_PAR , {IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE ENDIF DOT UP UP_UP LEFT_PAR LEFT_BRK MINUS_GT }]
  [oclExpression ::= (*) literalExp , {IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE ENDIF DOT UP UP_UP LEFT_PAR LEFT_BRK MINUS_GT }]
  [primitiveLiteralExp ::= (*) INTEGER , {IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE ENDIF DOT UP UP_UP LEFT_PAR LEFT_BRK MINUS_GT }]
  [collectionKind ::= (*) BAG , {LEFT_BRA }]
  [oclExpression ::= (*) oclExpression AND oclExpression , {IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE ENDIF DOT UP UP_UP LEFT_PAR LEFT_BRK MINUS_GT }]
  [oclExpression ::= (*) oclExpression PLUS oclExpression , {IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE ENDIF DOT UP UP_UP LEFT_PAR LEFT_BRK MINUS_GT }]
  [oclExpression ::= (*) oclExpression LEFT_PAR variableDeclaration BAR oclExpression RIGHT_PAR , {IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE ENDIF DOT UP UP_UP LEFT_PAR LEFT_BRK MINUS_GT }]
  [pathName ::= (*) simpleName , {IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE ENDIF DOT UP AT COLON_COLON UP_UP LEFT_PAR LEFT_BRK MINUS_GT }]
  [oclExpression ::= (*) oclExpression UP_UP simpleName LEFT_PAR oclMessageArgumentList RIGHT_PAR , {IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE ENDIF DOT UP UP_UP LEFT_PAR LEFT_BRK MINUS_GT }]
  [oclExpression ::= (*) oclExpression LE oclExpression , {IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE ENDIF DOT UP UP_UP LEFT_PAR LEFT_BRK MINUS_GT }]
  [oclExpression ::= (*) NOT oclExpression , {IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE ENDIF DOT UP UP_UP LEFT_PAR LEFT_BRK MINUS_GT }]
  [oclExpression ::= (*) LEFT_PAR oclExpression RIGHT_PAR , {IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE ENDIF DOT UP UP_UP LEFT_PAR LEFT_BRK MINUS_GT }]
  [primitiveLiteralExp ::= (*) REAL , {IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE ENDIF DOT UP UP_UP LEFT_PAR LEFT_BRK MINUS_GT }]
  [collectionKind ::= (*) SEQUENCE , {LEFT_BRA }]
  [oclExpression ::= (*) oclExpression OR oclExpression , {IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE ENDIF DOT UP UP_UP LEFT_PAR LEFT_BRK MINUS_GT }]
  [oclExpression ::= (*) oclExpression MINUS oclExpression , {IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE ENDIF DOT UP UP_UP LEFT_PAR LEFT_BRK MINUS_GT }]
  [oclExpression ::= (*) oclExpression LEFT_BRK argumentList RIGHT_BRK isMarkedPre , {IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE ENDIF DOT UP UP_UP LEFT_PAR LEFT_BRK MINUS_GT }]
  [pathName ::= (*) pathName COLON_COLON simpleName , {IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE ENDIF DOT UP AT COLON_COLON UP_UP LEFT_PAR LEFT_BRK MINUS_GT }]
  [collectionLiteralExp ::= (*) collectionKind LEFT_BRA collectionLiteralParts RIGHT_BRA , {IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE ENDIF DOT UP UP_UP LEFT_PAR LEFT_BRK MINUS_GT }]
  [oclExpression ::= (*) oclExpression UP_UP simpleName LEFT_PAR RIGHT_PAR , {IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE ENDIF DOT UP UP_UP LEFT_PAR LEFT_BRK MINUS_GT }]
  [oclExpression ::= (*) oclExpression GE oclExpression , {IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE ENDIF DOT UP UP_UP LEFT_PAR LEFT_BRK MINUS_GT }]
  [oclExpression ::= (*) MINUS oclExpression , {IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE ENDIF DOT UP UP_UP LEFT_PAR LEFT_BRK MINUS_GT }]
  [oclExpression ::= (*) pathName isMarkedPre , {IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE ENDIF DOT UP UP_UP LEFT_PAR LEFT_BRK MINUS_GT }]
  [primitiveLiteralExp ::= (*) STRING , {IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE ENDIF DOT UP UP_UP LEFT_PAR LEFT_BRK MINUS_GT }]
  [oclExpression ::= IF oclExpression THEN oclExpression ELSE (*) oclExpression ENDIF , {EOF ENDPACKAGE CONTEXT INIT DERIVE INV DEF PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE IN THEN ELSE ENDIF COMMA DOT COLON SEMICOLON BAR UP DOT_DOT UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR RIGHT_BRK RIGHT_BRA MINUS_GT }]
  [collectionKind ::= (*) COLLECTION , {LEFT_BRA }]
  [literalExp ::= (*) collectionLiteralExp , {IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE ENDIF DOT UP UP_UP LEFT_PAR LEFT_BRK MINUS_GT }]
  [oclExpression ::= (*) oclExpression XOR oclExpression , {IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE ENDIF DOT UP UP_UP LEFT_PAR LEFT_BRK MINUS_GT }]
  [oclExpression ::= (*) IF oclExpression THEN oclExpression ELSE oclExpression ENDIF , {IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE ENDIF DOT UP UP_UP LEFT_PAR LEFT_BRK MINUS_GT }]
  [oclExpression ::= (*) oclExpression MINUS_GT simpleName , {IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE ENDIF DOT UP UP_UP LEFT_PAR LEFT_BRK MINUS_GT }]
  [simpleName ::= (*) SIMPLE_NAME , {IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE ENDIF DOT UP AT COLON_COLON UP_UP LEFT_PAR LEFT_BRK MINUS_GT }]
  [collectionLiteralExp ::= (*) collectionKind LEFT_BRA RIGHT_BRA , {IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE ENDIF DOT UP UP_UP LEFT_PAR LEFT_BRK MINUS_GT }]
}
transition on tupleLiteralExp to state [54]
transition on oclExpression to state [149]
transition on REAL to state [52]
transition on INTEGER to state [51]
transition on pathName to state [50]
transition on SIMPLE_NAME to state [12]
transition on LET to state [49]
transition on FALSE to state [48]
transition on MINUS to state [47]
transition on COLLECTION to state [28]
transition on SET to state [20]
transition on simpleName to state [26]
transition on collectionLiteralExp to state [46]
transition on LEFT_PAR to state [45]
transition on STRING to state [44]
transition on IF to state [43]
transition on TRUE to state [42]
transition on collectionKind to state [41]
transition on NOT to state [40]
transition on primitiveLiteralExp to state [39]
transition on TUPLE to state [38]
transition on literalExp to state [37]
transition on BAG to state [25]
transition on SEQUENCE to state [22]

-------------------
lalr_state [149]: {
  [oclExpression ::= oclExpression (*) LEFT_BRK argumentList RIGHT_BRK isMarkedPre , {IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE ENDIF DOT UP UP_UP LEFT_PAR LEFT_BRK MINUS_GT }]
  [oclExpression ::= oclExpression (*) EQ oclExpression , {IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE ENDIF DOT UP UP_UP LEFT_PAR LEFT_BRK MINUS_GT }]
  [oclExpression ::= oclExpression (*) IMPLIES oclExpression , {IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE ENDIF DOT UP UP_UP LEFT_PAR LEFT_BRK MINUS_GT }]
  [oclExpression ::= oclExpression (*) UP simpleName LEFT_PAR RIGHT_PAR , {IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE ENDIF DOT UP UP_UP LEFT_PAR LEFT_BRK MINUS_GT }]
  [oclExpression ::= oclExpression (*) LEFT_PAR arguments RIGHT_PAR , {IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE ENDIF DOT UP UP_UP LEFT_PAR LEFT_BRK MINUS_GT }]
  [oclExpression ::= oclExpression (*) MINUS_GT ITERATE LEFT_PAR variableDeclaration BAR oclExpression RIGHT_PAR , {IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE ENDIF DOT UP UP_UP LEFT_PAR LEFT_BRK MINUS_GT }]
  [oclExpression ::= oclExpression (*) PLUS oclExpression , {IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE ENDIF DOT UP UP_UP LEFT_PAR LEFT_BRK MINUS_GT }]
  [oclExpression ::= oclExpression (*) LE oclExpression , {IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE ENDIF DOT UP UP_UP LEFT_PAR LEFT_BRK MINUS_GT }]
  [oclExpression ::= oclExpression (*) OR oclExpression , {IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE ENDIF DOT UP UP_UP LEFT_PAR LEFT_BRK MINUS_GT }]
  [oclExpression ::= oclExpression (*) UP_UP simpleName LEFT_PAR RIGHT_PAR , {IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE ENDIF DOT UP UP_UP LEFT_PAR LEFT_BRK MINUS_GT }]
  [oclExpression ::= oclExpression (*) MINUS_GT simpleName , {IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE ENDIF DOT UP UP_UP LEFT_PAR LEFT_BRK MINUS_GT }]
  [oclExpression ::= oclExpression (*) TIMES oclExpression , {IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE ENDIF DOT UP UP_UP LEFT_PAR LEFT_BRK MINUS_GT }]
  [oclExpression ::= oclExpression (*) LT oclExpression , {IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE ENDIF DOT UP UP_UP LEFT_PAR LEFT_BRK MINUS_GT }]
  [oclExpression ::= oclExpression (*) NE oclExpression , {IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE ENDIF DOT UP UP_UP LEFT_PAR LEFT_BRK MINUS_GT }]
  [oclExpression ::= oclExpression (*) LEFT_PAR variableDeclaration BAR oclExpression RIGHT_PAR , {IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE ENDIF DOT UP UP_UP LEFT_PAR LEFT_BRK MINUS_GT }]
  [oclExpression ::= oclExpression (*) MINUS oclExpression , {IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE ENDIF DOT UP UP_UP LEFT_PAR LEFT_BRK MINUS_GT }]
  [oclExpression ::= oclExpression (*) GE oclExpression , {IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE ENDIF DOT UP UP_UP LEFT_PAR LEFT_BRK MINUS_GT }]
  [oclExpression ::= oclExpression (*) XOR oclExpression , {IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE ENDIF DOT UP UP_UP LEFT_PAR LEFT_BRK MINUS_GT }]
  [oclExpression ::= oclExpression (*) UP simpleName LEFT_PAR oclMessageArgumentList RIGHT_PAR , {IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE ENDIF DOT UP UP_UP LEFT_PAR LEFT_BRK MINUS_GT }]
  [oclExpression ::= oclExpression (*) DOT simpleName isMarkedPre , {IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE ENDIF DOT UP UP_UP LEFT_PAR LEFT_BRK MINUS_GT }]
  [oclExpression ::= oclExpression (*) MINUS_GT ITERATE LEFT_PAR variableDeclaration SEMICOLON variableDeclaration BAR oclExpression RIGHT_PAR , {IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE ENDIF DOT UP UP_UP LEFT_PAR LEFT_BRK MINUS_GT }]
  [oclExpression ::= oclExpression (*) DIVIDE oclExpression , {IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE ENDIF DOT UP UP_UP LEFT_PAR LEFT_BRK MINUS_GT }]
  [oclExpression ::= oclExpression (*) GT oclExpression , {IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE ENDIF DOT UP UP_UP LEFT_PAR LEFT_BRK MINUS_GT }]
  [oclExpression ::= oclExpression (*) AND oclExpression , {IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE ENDIF DOT UP UP_UP LEFT_PAR LEFT_BRK MINUS_GT }]
  [oclExpression ::= oclExpression (*) UP_UP simpleName LEFT_PAR oclMessageArgumentList RIGHT_PAR , {IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE ENDIF DOT UP UP_UP LEFT_PAR LEFT_BRK MINUS_GT }]
  [oclExpression ::= IF oclExpression THEN oclExpression ELSE oclExpression (*) ENDIF , {EOF ENDPACKAGE CONTEXT INIT DERIVE INV DEF PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE IN THEN ELSE ENDIF COMMA DOT COLON SEMICOLON BAR UP DOT_DOT UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR RIGHT_BRK RIGHT_BRA MINUS_GT }]
}
transition on XOR to state [74]
transition on EQ to state [73]
transition on DOT to state [72]
transition on MINUS to state [71]
transition on GE to state [70]
transition on LEFT_BRK to state [69]
transition on DIVIDE to state [68]
transition on LEFT_PAR to state [67]
transition on MINUS_GT to state [66]
transition on LE to state [65]
transition on GT to state [64]
transition on IMPLIES to state [63]
transition on UP to state [62]
transition on ENDIF to state [150]
transition on UP_UP to state [61]
transition on OR to state [60]
transition on PLUS to state [59]
transition on NE to state [58]
transition on LT to state [57]
transition on AND to state [56]
transition on TIMES to state [55]

-------------------
lalr_state [150]: {
  [oclExpression ::= IF oclExpression THEN oclExpression ELSE oclExpression ENDIF (*) , {EOF ENDPACKAGE CONTEXT INIT DERIVE INV DEF PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE IN THEN ELSE ENDIF COMMA DOT COLON SEMICOLON BAR UP DOT_DOT UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR RIGHT_BRK RIGHT_BRA MINUS_GT }]
}

-------------------
lalr_state [151]: {
  [oclExpression ::= (*) oclExpression UP simpleName LEFT_PAR oclMessageArgumentList RIGHT_PAR , {IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE COMMA DOT UP DOT_DOT UP_UP LEFT_PAR LEFT_BRK RIGHT_BRA MINUS_GT }]
  [oclExpression ::= (*) oclExpression EQ oclExpression , {IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE COMMA DOT UP DOT_DOT UP_UP LEFT_PAR LEFT_BRK RIGHT_BRA MINUS_GT }]
  [oclExpression ::= (*) oclExpression TIMES oclExpression , {IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE COMMA DOT UP DOT_DOT UP_UP LEFT_PAR LEFT_BRK RIGHT_BRA MINUS_GT }]
  [oclExpression ::= (*) oclExpression DOT simpleName isMarkedPre , {IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE COMMA DOT UP DOT_DOT UP_UP LEFT_PAR LEFT_BRK RIGHT_BRA MINUS_GT }]
  [primitiveLiteralExp ::= (*) TRUE , {IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE COMMA DOT UP DOT_DOT UP_UP LEFT_PAR LEFT_BRK RIGHT_BRA MINUS_GT }]
  [collectionLiteralParts ::= (*) collectionLiteralPart , {COMMA RIGHT_BRA }]
  [literalExp ::= (*) tupleLiteralExp , {IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE COMMA DOT UP DOT_DOT UP_UP LEFT_PAR LEFT_BRK RIGHT_BRA MINUS_GT }]
  [oclExpression ::= (*) oclExpression IMPLIES oclExpression , {IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE COMMA DOT UP DOT_DOT UP_UP LEFT_PAR LEFT_BRK RIGHT_BRA MINUS_GT }]
  [oclExpression ::= (*) oclExpression LT oclExpression , {IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE COMMA DOT UP DOT_DOT UP_UP LEFT_PAR LEFT_BRK RIGHT_BRA MINUS_GT }]
  [oclExpression ::= (*) oclExpression MINUS_GT ITERATE LEFT_PAR variableDeclaration SEMICOLON variableDeclaration BAR oclExpression RIGHT_PAR , {IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE COMMA DOT UP DOT_DOT UP_UP LEFT_PAR LEFT_BRK RIGHT_BRA MINUS_GT }]
  [tupleLiteralExp ::= (*) TUPLE LEFT_BRA variableDeclarationList RIGHT_BRA , {IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE COMMA DOT UP DOT_DOT UP_UP LEFT_PAR LEFT_BRK RIGHT_BRA MINUS_GT }]
  [collectionKind ::= (*) SET , {LEFT_BRA }]
  [oclExpression ::= (*) oclExpression UP simpleName LEFT_PAR RIGHT_PAR , {IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE COMMA DOT UP DOT_DOT UP_UP LEFT_PAR LEFT_BRK RIGHT_BRA MINUS_GT }]
  [oclExpression ::= (*) oclExpression NE oclExpression , {IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE COMMA DOT UP DOT_DOT UP_UP LEFT_PAR LEFT_BRK RIGHT_BRA MINUS_GT }]
  [oclExpression ::= (*) oclExpression DIVIDE oclExpression , {IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE COMMA DOT UP DOT_DOT UP_UP LEFT_PAR LEFT_BRK RIGHT_BRA MINUS_GT }]
  [oclExpression ::= (*) oclExpression LEFT_PAR arguments RIGHT_PAR , {IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE COMMA DOT UP DOT_DOT UP_UP LEFT_PAR LEFT_BRK RIGHT_BRA MINUS_GT }]
  [primitiveLiteralExp ::= (*) FALSE , {IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE COMMA DOT UP DOT_DOT UP_UP LEFT_PAR LEFT_BRK RIGHT_BRA MINUS_GT }]
  [collectionLiteralParts ::= (*) collectionLiteralParts COMMA collectionLiteralPart , {COMMA RIGHT_BRA }]
  [literalExp ::= (*) primitiveLiteralExp , {IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE COMMA DOT UP DOT_DOT UP_UP LEFT_PAR LEFT_BRK RIGHT_BRA MINUS_GT }]
  [oclExpression ::= (*) LET variableDeclarationList IN oclExpression , {IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE COMMA DOT UP DOT_DOT UP_UP LEFT_PAR LEFT_BRK RIGHT_BRA MINUS_GT }]
  [oclExpression ::= (*) oclExpression GT oclExpression , {IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE COMMA DOT UP DOT_DOT UP_UP LEFT_PAR LEFT_BRK RIGHT_BRA MINUS_GT }]
  [oclExpression ::= (*) oclExpression MINUS_GT ITERATE LEFT_PAR variableDeclaration BAR oclExpression RIGHT_PAR , {IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE COMMA DOT UP DOT_DOT UP_UP LEFT_PAR LEFT_BRK RIGHT_BRA MINUS_GT }]
  [oclExpression ::= (*) literalExp , {IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE COMMA DOT UP DOT_DOT UP_UP LEFT_PAR LEFT_BRK RIGHT_BRA MINUS_GT }]
  [primitiveLiteralExp ::= (*) INTEGER , {IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE COMMA DOT UP DOT_DOT UP_UP LEFT_PAR LEFT_BRK RIGHT_BRA MINUS_GT }]
  [collectionKind ::= (*) BAG , {LEFT_BRA }]
  [oclExpression ::= (*) oclExpression AND oclExpression , {IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE COMMA DOT UP DOT_DOT UP_UP LEFT_PAR LEFT_BRK RIGHT_BRA MINUS_GT }]
  [oclExpression ::= (*) oclExpression PLUS oclExpression , {IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE COMMA DOT UP DOT_DOT UP_UP LEFT_PAR LEFT_BRK RIGHT_BRA MINUS_GT }]
  [oclExpression ::= (*) oclExpression LEFT_PAR variableDeclaration BAR oclExpression RIGHT_PAR , {IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE COMMA DOT UP DOT_DOT UP_UP LEFT_PAR LEFT_BRK RIGHT_BRA MINUS_GT }]
  [pathName ::= (*) simpleName , {IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE COMMA DOT UP AT DOT_DOT COLON_COLON UP_UP LEFT_PAR LEFT_BRK RIGHT_BRA MINUS_GT }]
  [collectionLiteralPart ::= (*) oclExpression , {COMMA RIGHT_BRA }]
  [oclExpression ::= (*) oclExpression UP_UP simpleName LEFT_PAR oclMessageArgumentList RIGHT_PAR , {IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE COMMA DOT UP DOT_DOT UP_UP LEFT_PAR LEFT_BRK RIGHT_BRA MINUS_GT }]
  [oclExpression ::= (*) oclExpression LE oclExpression , {IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE COMMA DOT UP DOT_DOT UP_UP LEFT_PAR LEFT_BRK RIGHT_BRA MINUS_GT }]
  [oclExpression ::= (*) NOT oclExpression , {IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE COMMA DOT UP DOT_DOT UP_UP LEFT_PAR LEFT_BRK RIGHT_BRA MINUS_GT }]
  [oclExpression ::= (*) LEFT_PAR oclExpression RIGHT_PAR , {IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE COMMA DOT UP DOT_DOT UP_UP LEFT_PAR LEFT_BRK RIGHT_BRA MINUS_GT }]
  [primitiveLiteralExp ::= (*) REAL , {IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE COMMA DOT UP DOT_DOT UP_UP LEFT_PAR LEFT_BRK RIGHT_BRA MINUS_GT }]
  [collectionKind ::= (*) SEQUENCE , {LEFT_BRA }]
  [oclExpression ::= (*) oclExpression OR oclExpression , {IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE COMMA DOT UP DOT_DOT UP_UP LEFT_PAR LEFT_BRK RIGHT_BRA MINUS_GT }]
  [oclExpression ::= (*) oclExpression MINUS oclExpression , {IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE COMMA DOT UP DOT_DOT UP_UP LEFT_PAR LEFT_BRK RIGHT_BRA MINUS_GT }]
  [oclExpression ::= (*) oclExpression LEFT_BRK argumentList RIGHT_BRK isMarkedPre , {IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE COMMA DOT UP DOT_DOT UP_UP LEFT_PAR LEFT_BRK RIGHT_BRA MINUS_GT }]
  [pathName ::= (*) pathName COLON_COLON simpleName , {IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE COMMA DOT UP AT DOT_DOT COLON_COLON UP_UP LEFT_PAR LEFT_BRK RIGHT_BRA MINUS_GT }]
  [collectionLiteralExp ::= collectionKind LEFT_BRA (*) collectionLiteralParts RIGHT_BRA , {EOF ENDPACKAGE CONTEXT INIT DERIVE INV DEF PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE IN THEN ELSE ENDIF COMMA DOT COLON SEMICOLON BAR UP DOT_DOT UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR RIGHT_BRK RIGHT_BRA MINUS_GT }]
  [collectionLiteralPart ::= (*) collectionRange , {COMMA RIGHT_BRA }]
  [collectionLiteralExp ::= (*) collectionKind LEFT_BRA collectionLiteralParts RIGHT_BRA , {IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE COMMA DOT UP DOT_DOT UP_UP LEFT_PAR LEFT_BRK RIGHT_BRA MINUS_GT }]
  [oclExpression ::= (*) oclExpression UP_UP simpleName LEFT_PAR RIGHT_PAR , {IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE COMMA DOT UP DOT_DOT UP_UP LEFT_PAR LEFT_BRK RIGHT_BRA MINUS_GT }]
  [oclExpression ::= (*) oclExpression GE oclExpression , {IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE COMMA DOT UP DOT_DOT UP_UP LEFT_PAR LEFT_BRK RIGHT_BRA MINUS_GT }]
  [oclExpression ::= (*) MINUS oclExpression , {IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE COMMA DOT UP DOT_DOT UP_UP LEFT_PAR LEFT_BRK RIGHT_BRA MINUS_GT }]
  [oclExpression ::= (*) pathName isMarkedPre , {IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE COMMA DOT UP DOT_DOT UP_UP LEFT_PAR LEFT_BRK RIGHT_BRA MINUS_GT }]
  [primitiveLiteralExp ::= (*) STRING , {IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE COMMA DOT UP DOT_DOT UP_UP LEFT_PAR LEFT_BRK RIGHT_BRA MINUS_GT }]
  [collectionKind ::= (*) COLLECTION , {LEFT_BRA }]
  [literalExp ::= (*) collectionLiteralExp , {IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE COMMA DOT UP DOT_DOT UP_UP LEFT_PAR LEFT_BRK RIGHT_BRA MINUS_GT }]
  [oclExpression ::= (*) oclExpression XOR oclExpression , {IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE COMMA DOT UP DOT_DOT UP_UP LEFT_PAR LEFT_BRK RIGHT_BRA MINUS_GT }]
  [oclExpression ::= (*) IF oclExpression THEN oclExpression ELSE oclExpression ENDIF , {IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE COMMA DOT UP DOT_DOT UP_UP LEFT_PAR LEFT_BRK RIGHT_BRA MINUS_GT }]
  [oclExpression ::= (*) oclExpression MINUS_GT simpleName , {IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE COMMA DOT UP DOT_DOT UP_UP LEFT_PAR LEFT_BRK RIGHT_BRA MINUS_GT }]
  [simpleName ::= (*) SIMPLE_NAME , {IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE COMMA DOT UP AT DOT_DOT COLON_COLON UP_UP LEFT_PAR LEFT_BRK RIGHT_BRA MINUS_GT }]
  [collectionLiteralExp ::= collectionKind LEFT_BRA (*) RIGHT_BRA , {EOF ENDPACKAGE CONTEXT INIT DERIVE INV DEF PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE IN THEN ELSE ENDIF COMMA DOT COLON SEMICOLON BAR UP DOT_DOT UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR RIGHT_BRK RIGHT_BRA MINUS_GT }]
  [collectionRange ::= (*) oclExpression DOT_DOT oclExpression , {COMMA RIGHT_BRA }]
  [collectionLiteralExp ::= (*) collectionKind LEFT_BRA RIGHT_BRA , {IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE COMMA DOT UP DOT_DOT UP_UP LEFT_PAR LEFT_BRK RIGHT_BRA MINUS_GT }]
}
transition on RIGHT_BRA to state [156]
transition on tupleLiteralExp to state [54]
transition on oclExpression to state [155]
transition on REAL to state [52]
transition on INTEGER to state [51]
transition on collectionLiteralParts to state [154]
transition on pathName to state [50]
transition on SIMPLE_NAME to state [12]
transition on LET to state [49]
transition on FALSE to state [48]
transition on MINUS to state [47]
transition on COLLECTION to state [28]
transition on SET to state [20]
transition on simpleName to state [26]
transition on collectionLiteralExp to state [46]
transition on LEFT_PAR to state [45]
transition on STRING to state [44]
transition on IF to state [43]
transition on TRUE to state [42]
transition on collectionKind to state [41]
transition on NOT to state [40]
transition on primitiveLiteralExp to state [39]
transition on TUPLE to state [38]
transition on literalExp to state [37]
transition on BAG to state [25]
transition on SEQUENCE to state [22]
transition on collectionLiteralPart to state [153]
transition on collectionRange to state [152]

-------------------
lalr_state [152]: {
  [collectionLiteralPart ::= collectionRange (*) , {COMMA RIGHT_BRA }]
}

-------------------
lalr_state [153]: {
  [collectionLiteralParts ::= collectionLiteralPart (*) , {COMMA RIGHT_BRA }]
}

-------------------
lalr_state [154]: {
  [collectionLiteralExp ::= collectionKind LEFT_BRA collectionLiteralParts (*) RIGHT_BRA , {EOF ENDPACKAGE CONTEXT INIT DERIVE INV DEF PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE IN THEN ELSE ENDIF COMMA DOT COLON SEMICOLON BAR UP DOT_DOT UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR RIGHT_BRK RIGHT_BRA MINUS_GT }]
  [collectionLiteralParts ::= collectionLiteralParts (*) COMMA collectionLiteralPart , {COMMA RIGHT_BRA }]
}
transition on RIGHT_BRA to state [160]
transition on COMMA to state [159]

-------------------
lalr_state [155]: {
  [oclExpression ::= oclExpression (*) LEFT_BRK argumentList RIGHT_BRK isMarkedPre , {IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE COMMA DOT UP DOT_DOT UP_UP LEFT_PAR LEFT_BRK RIGHT_BRA MINUS_GT }]
  [oclExpression ::= oclExpression (*) EQ oclExpression , {IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE COMMA DOT UP DOT_DOT UP_UP LEFT_PAR LEFT_BRK RIGHT_BRA MINUS_GT }]
  [oclExpression ::= oclExpression (*) IMPLIES oclExpression , {IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE COMMA DOT UP DOT_DOT UP_UP LEFT_PAR LEFT_BRK RIGHT_BRA MINUS_GT }]
  [oclExpression ::= oclExpression (*) UP simpleName LEFT_PAR RIGHT_PAR , {IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE COMMA DOT UP DOT_DOT UP_UP LEFT_PAR LEFT_BRK RIGHT_BRA MINUS_GT }]
  [oclExpression ::= oclExpression (*) LEFT_PAR arguments RIGHT_PAR , {IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE COMMA DOT UP DOT_DOT UP_UP LEFT_PAR LEFT_BRK RIGHT_BRA MINUS_GT }]
  [oclExpression ::= oclExpression (*) MINUS_GT ITERATE LEFT_PAR variableDeclaration BAR oclExpression RIGHT_PAR , {IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE COMMA DOT UP DOT_DOT UP_UP LEFT_PAR LEFT_BRK RIGHT_BRA MINUS_GT }]
  [oclExpression ::= oclExpression (*) PLUS oclExpression , {IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE COMMA DOT UP DOT_DOT UP_UP LEFT_PAR LEFT_BRK RIGHT_BRA MINUS_GT }]
  [oclExpression ::= oclExpression (*) LE oclExpression , {IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE COMMA DOT UP DOT_DOT UP_UP LEFT_PAR LEFT_BRK RIGHT_BRA MINUS_GT }]
  [oclExpression ::= oclExpression (*) OR oclExpression , {IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE COMMA DOT UP DOT_DOT UP_UP LEFT_PAR LEFT_BRK RIGHT_BRA MINUS_GT }]
  [oclExpression ::= oclExpression (*) UP_UP simpleName LEFT_PAR RIGHT_PAR , {IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE COMMA DOT UP DOT_DOT UP_UP LEFT_PAR LEFT_BRK RIGHT_BRA MINUS_GT }]
  [oclExpression ::= oclExpression (*) MINUS_GT simpleName , {IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE COMMA DOT UP DOT_DOT UP_UP LEFT_PAR LEFT_BRK RIGHT_BRA MINUS_GT }]
  [oclExpression ::= oclExpression (*) TIMES oclExpression , {IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE COMMA DOT UP DOT_DOT UP_UP LEFT_PAR LEFT_BRK RIGHT_BRA MINUS_GT }]
  [oclExpression ::= oclExpression (*) LT oclExpression , {IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE COMMA DOT UP DOT_DOT UP_UP LEFT_PAR LEFT_BRK RIGHT_BRA MINUS_GT }]
  [oclExpression ::= oclExpression (*) NE oclExpression , {IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE COMMA DOT UP DOT_DOT UP_UP LEFT_PAR LEFT_BRK RIGHT_BRA MINUS_GT }]
  [oclExpression ::= oclExpression (*) LEFT_PAR variableDeclaration BAR oclExpression RIGHT_PAR , {IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE COMMA DOT UP DOT_DOT UP_UP LEFT_PAR LEFT_BRK RIGHT_BRA MINUS_GT }]
  [collectionRange ::= oclExpression (*) DOT_DOT oclExpression , {COMMA RIGHT_BRA }]
  [oclExpression ::= oclExpression (*) MINUS oclExpression , {IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE COMMA DOT UP DOT_DOT UP_UP LEFT_PAR LEFT_BRK RIGHT_BRA MINUS_GT }]
  [oclExpression ::= oclExpression (*) GE oclExpression , {IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE COMMA DOT UP DOT_DOT UP_UP LEFT_PAR LEFT_BRK RIGHT_BRA MINUS_GT }]
  [oclExpression ::= oclExpression (*) XOR oclExpression , {IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE COMMA DOT UP DOT_DOT UP_UP LEFT_PAR LEFT_BRK RIGHT_BRA MINUS_GT }]
  [oclExpression ::= oclExpression (*) UP simpleName LEFT_PAR oclMessageArgumentList RIGHT_PAR , {IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE COMMA DOT UP DOT_DOT UP_UP LEFT_PAR LEFT_BRK RIGHT_BRA MINUS_GT }]
  [oclExpression ::= oclExpression (*) DOT simpleName isMarkedPre , {IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE COMMA DOT UP DOT_DOT UP_UP LEFT_PAR LEFT_BRK RIGHT_BRA MINUS_GT }]
  [oclExpression ::= oclExpression (*) MINUS_GT ITERATE LEFT_PAR variableDeclaration SEMICOLON variableDeclaration BAR oclExpression RIGHT_PAR , {IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE COMMA DOT UP DOT_DOT UP_UP LEFT_PAR LEFT_BRK RIGHT_BRA MINUS_GT }]
  [collectionLiteralPart ::= oclExpression (*) , {COMMA RIGHT_BRA }]
  [oclExpression ::= oclExpression (*) DIVIDE oclExpression , {IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE COMMA DOT UP DOT_DOT UP_UP LEFT_PAR LEFT_BRK RIGHT_BRA MINUS_GT }]
  [oclExpression ::= oclExpression (*) GT oclExpression , {IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE COMMA DOT UP DOT_DOT UP_UP LEFT_PAR LEFT_BRK RIGHT_BRA MINUS_GT }]
  [oclExpression ::= oclExpression (*) AND oclExpression , {IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE COMMA DOT UP DOT_DOT UP_UP LEFT_PAR LEFT_BRK RIGHT_BRA MINUS_GT }]
  [oclExpression ::= oclExpression (*) UP_UP simpleName LEFT_PAR oclMessageArgumentList RIGHT_PAR , {IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE COMMA DOT UP DOT_DOT UP_UP LEFT_PAR LEFT_BRK RIGHT_BRA MINUS_GT }]
}
transition on DOT_DOT to state [157]
transition on XOR to state [74]
transition on EQ to state [73]
transition on DOT to state [72]
transition on MINUS to state [71]
transition on GE to state [70]
transition on LEFT_BRK to state [69]
transition on DIVIDE to state [68]
transition on LEFT_PAR to state [67]
transition on MINUS_GT to state [66]
transition on LE to state [65]
transition on GT to state [64]
transition on IMPLIES to state [63]
transition on UP to state [62]
transition on UP_UP to state [61]
transition on OR to state [60]
transition on PLUS to state [59]
transition on NE to state [58]
transition on LT to state [57]
transition on AND to state [56]
transition on TIMES to state [55]

-------------------
lalr_state [156]: {
  [collectionLiteralExp ::= collectionKind LEFT_BRA RIGHT_BRA (*) , {EOF ENDPACKAGE CONTEXT INIT DERIVE INV DEF PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE IN THEN ELSE ENDIF COMMA DOT COLON SEMICOLON BAR UP DOT_DOT UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR RIGHT_BRK RIGHT_BRA MINUS_GT }]
}

-------------------
lalr_state [157]: {
  [oclExpression ::= (*) oclExpression UP simpleName LEFT_PAR oclMessageArgumentList RIGHT_PAR , {IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE COMMA DOT UP UP_UP LEFT_PAR LEFT_BRK RIGHT_BRA MINUS_GT }]
  [oclExpression ::= (*) oclExpression EQ oclExpression , {IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE COMMA DOT UP UP_UP LEFT_PAR LEFT_BRK RIGHT_BRA MINUS_GT }]
  [oclExpression ::= (*) oclExpression TIMES oclExpression , {IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE COMMA DOT UP UP_UP LEFT_PAR LEFT_BRK RIGHT_BRA MINUS_GT }]
  [oclExpression ::= (*) oclExpression DOT simpleName isMarkedPre , {IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE COMMA DOT UP UP_UP LEFT_PAR LEFT_BRK RIGHT_BRA MINUS_GT }]
  [primitiveLiteralExp ::= (*) TRUE , {IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE COMMA DOT UP UP_UP LEFT_PAR LEFT_BRK RIGHT_BRA MINUS_GT }]
  [literalExp ::= (*) tupleLiteralExp , {IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE COMMA DOT UP UP_UP LEFT_PAR LEFT_BRK RIGHT_BRA MINUS_GT }]
  [oclExpression ::= (*) oclExpression IMPLIES oclExpression , {IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE COMMA DOT UP UP_UP LEFT_PAR LEFT_BRK RIGHT_BRA MINUS_GT }]
  [oclExpression ::= (*) oclExpression LT oclExpression , {IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE COMMA DOT UP UP_UP LEFT_PAR LEFT_BRK RIGHT_BRA MINUS_GT }]
  [oclExpression ::= (*) oclExpression MINUS_GT ITERATE LEFT_PAR variableDeclaration SEMICOLON variableDeclaration BAR oclExpression RIGHT_PAR , {IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE COMMA DOT UP UP_UP LEFT_PAR LEFT_BRK RIGHT_BRA MINUS_GT }]
  [tupleLiteralExp ::= (*) TUPLE LEFT_BRA variableDeclarationList RIGHT_BRA , {IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE COMMA DOT UP UP_UP LEFT_PAR LEFT_BRK RIGHT_BRA MINUS_GT }]
  [collectionKind ::= (*) SET , {LEFT_BRA }]
  [oclExpression ::= (*) oclExpression UP simpleName LEFT_PAR RIGHT_PAR , {IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE COMMA DOT UP UP_UP LEFT_PAR LEFT_BRK RIGHT_BRA MINUS_GT }]
  [oclExpression ::= (*) oclExpression NE oclExpression , {IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE COMMA DOT UP UP_UP LEFT_PAR LEFT_BRK RIGHT_BRA MINUS_GT }]
  [oclExpression ::= (*) oclExpression DIVIDE oclExpression , {IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE COMMA DOT UP UP_UP LEFT_PAR LEFT_BRK RIGHT_BRA MINUS_GT }]
  [oclExpression ::= (*) oclExpression LEFT_PAR arguments RIGHT_PAR , {IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE COMMA DOT UP UP_UP LEFT_PAR LEFT_BRK RIGHT_BRA MINUS_GT }]
  [primitiveLiteralExp ::= (*) FALSE , {IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE COMMA DOT UP UP_UP LEFT_PAR LEFT_BRK RIGHT_BRA MINUS_GT }]
  [literalExp ::= (*) primitiveLiteralExp , {IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE COMMA DOT UP UP_UP LEFT_PAR LEFT_BRK RIGHT_BRA MINUS_GT }]
  [oclExpression ::= (*) LET variableDeclarationList IN oclExpression , {IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE COMMA DOT UP UP_UP LEFT_PAR LEFT_BRK RIGHT_BRA MINUS_GT }]
  [oclExpression ::= (*) oclExpression GT oclExpression , {IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE COMMA DOT UP UP_UP LEFT_PAR LEFT_BRK RIGHT_BRA MINUS_GT }]
  [oclExpression ::= (*) oclExpression MINUS_GT ITERATE LEFT_PAR variableDeclaration BAR oclExpression RIGHT_PAR , {IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE COMMA DOT UP UP_UP LEFT_PAR LEFT_BRK RIGHT_BRA MINUS_GT }]
  [oclExpression ::= (*) literalExp , {IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE COMMA DOT UP UP_UP LEFT_PAR LEFT_BRK RIGHT_BRA MINUS_GT }]
  [primitiveLiteralExp ::= (*) INTEGER , {IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE COMMA DOT UP UP_UP LEFT_PAR LEFT_BRK RIGHT_BRA MINUS_GT }]
  [collectionKind ::= (*) BAG , {LEFT_BRA }]
  [oclExpression ::= (*) oclExpression AND oclExpression , {IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE COMMA DOT UP UP_UP LEFT_PAR LEFT_BRK RIGHT_BRA MINUS_GT }]
  [oclExpression ::= (*) oclExpression PLUS oclExpression , {IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE COMMA DOT UP UP_UP LEFT_PAR LEFT_BRK RIGHT_BRA MINUS_GT }]
  [oclExpression ::= (*) oclExpression LEFT_PAR variableDeclaration BAR oclExpression RIGHT_PAR , {IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE COMMA DOT UP UP_UP LEFT_PAR LEFT_BRK RIGHT_BRA MINUS_GT }]
  [pathName ::= (*) simpleName , {IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE COMMA DOT UP AT COLON_COLON UP_UP LEFT_PAR LEFT_BRK RIGHT_BRA MINUS_GT }]
  [oclExpression ::= (*) oclExpression UP_UP simpleName LEFT_PAR oclMessageArgumentList RIGHT_PAR , {IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE COMMA DOT UP UP_UP LEFT_PAR LEFT_BRK RIGHT_BRA MINUS_GT }]
  [oclExpression ::= (*) oclExpression LE oclExpression , {IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE COMMA DOT UP UP_UP LEFT_PAR LEFT_BRK RIGHT_BRA MINUS_GT }]
  [oclExpression ::= (*) NOT oclExpression , {IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE COMMA DOT UP UP_UP LEFT_PAR LEFT_BRK RIGHT_BRA MINUS_GT }]
  [oclExpression ::= (*) LEFT_PAR oclExpression RIGHT_PAR , {IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE COMMA DOT UP UP_UP LEFT_PAR LEFT_BRK RIGHT_BRA MINUS_GT }]
  [primitiveLiteralExp ::= (*) REAL , {IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE COMMA DOT UP UP_UP LEFT_PAR LEFT_BRK RIGHT_BRA MINUS_GT }]
  [collectionKind ::= (*) SEQUENCE , {LEFT_BRA }]
  [oclExpression ::= (*) oclExpression OR oclExpression , {IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE COMMA DOT UP UP_UP LEFT_PAR LEFT_BRK RIGHT_BRA MINUS_GT }]
  [oclExpression ::= (*) oclExpression MINUS oclExpression , {IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE COMMA DOT UP UP_UP LEFT_PAR LEFT_BRK RIGHT_BRA MINUS_GT }]
  [oclExpression ::= (*) oclExpression LEFT_BRK argumentList RIGHT_BRK isMarkedPre , {IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE COMMA DOT UP UP_UP LEFT_PAR LEFT_BRK RIGHT_BRA MINUS_GT }]
  [pathName ::= (*) pathName COLON_COLON simpleName , {IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE COMMA DOT UP AT COLON_COLON UP_UP LEFT_PAR LEFT_BRK RIGHT_BRA MINUS_GT }]
  [collectionLiteralExp ::= (*) collectionKind LEFT_BRA collectionLiteralParts RIGHT_BRA , {IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE COMMA DOT UP UP_UP LEFT_PAR LEFT_BRK RIGHT_BRA MINUS_GT }]
  [oclExpression ::= (*) oclExpression UP_UP simpleName LEFT_PAR RIGHT_PAR , {IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE COMMA DOT UP UP_UP LEFT_PAR LEFT_BRK RIGHT_BRA MINUS_GT }]
  [oclExpression ::= (*) oclExpression GE oclExpression , {IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE COMMA DOT UP UP_UP LEFT_PAR LEFT_BRK RIGHT_BRA MINUS_GT }]
  [oclExpression ::= (*) MINUS oclExpression , {IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE COMMA DOT UP UP_UP LEFT_PAR LEFT_BRK RIGHT_BRA MINUS_GT }]
  [oclExpression ::= (*) pathName isMarkedPre , {IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE COMMA DOT UP UP_UP LEFT_PAR LEFT_BRK RIGHT_BRA MINUS_GT }]
  [primitiveLiteralExp ::= (*) STRING , {IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE COMMA DOT UP UP_UP LEFT_PAR LEFT_BRK RIGHT_BRA MINUS_GT }]
  [collectionKind ::= (*) COLLECTION , {LEFT_BRA }]
  [literalExp ::= (*) collectionLiteralExp , {IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE COMMA DOT UP UP_UP LEFT_PAR LEFT_BRK RIGHT_BRA MINUS_GT }]
  [oclExpression ::= (*) oclExpression XOR oclExpression , {IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE COMMA DOT UP UP_UP LEFT_PAR LEFT_BRK RIGHT_BRA MINUS_GT }]
  [oclExpression ::= (*) IF oclExpression THEN oclExpression ELSE oclExpression ENDIF , {IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE COMMA DOT UP UP_UP LEFT_PAR LEFT_BRK RIGHT_BRA MINUS_GT }]
  [oclExpression ::= (*) oclExpression MINUS_GT simpleName , {IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE COMMA DOT UP UP_UP LEFT_PAR LEFT_BRK RIGHT_BRA MINUS_GT }]
  [collectionRange ::= oclExpression DOT_DOT (*) oclExpression , {COMMA RIGHT_BRA }]
  [simpleName ::= (*) SIMPLE_NAME , {IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE COMMA DOT UP AT COLON_COLON UP_UP LEFT_PAR LEFT_BRK RIGHT_BRA MINUS_GT }]
  [collectionLiteralExp ::= (*) collectionKind LEFT_BRA RIGHT_BRA , {IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE COMMA DOT UP UP_UP LEFT_PAR LEFT_BRK RIGHT_BRA MINUS_GT }]
}
transition on tupleLiteralExp to state [54]
transition on oclExpression to state [158]
transition on REAL to state [52]
transition on INTEGER to state [51]
transition on pathName to state [50]
transition on SIMPLE_NAME to state [12]
transition on LET to state [49]
transition on FALSE to state [48]
transition on MINUS to state [47]
transition on COLLECTION to state [28]
transition on SET to state [20]
transition on simpleName to state [26]
transition on collectionLiteralExp to state [46]
transition on LEFT_PAR to state [45]
transition on STRING to state [44]
transition on IF to state [43]
transition on TRUE to state [42]
transition on collectionKind to state [41]
transition on NOT to state [40]
transition on primitiveLiteralExp to state [39]
transition on TUPLE to state [38]
transition on literalExp to state [37]
transition on BAG to state [25]
transition on SEQUENCE to state [22]

-------------------
lalr_state [158]: {
  [oclExpression ::= oclExpression (*) LEFT_BRK argumentList RIGHT_BRK isMarkedPre , {IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE COMMA DOT UP UP_UP LEFT_PAR LEFT_BRK RIGHT_BRA MINUS_GT }]
  [oclExpression ::= oclExpression (*) EQ oclExpression , {IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE COMMA DOT UP UP_UP LEFT_PAR LEFT_BRK RIGHT_BRA MINUS_GT }]
  [oclExpression ::= oclExpression (*) IMPLIES oclExpression , {IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE COMMA DOT UP UP_UP LEFT_PAR LEFT_BRK RIGHT_BRA MINUS_GT }]
  [oclExpression ::= oclExpression (*) UP simpleName LEFT_PAR RIGHT_PAR , {IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE COMMA DOT UP UP_UP LEFT_PAR LEFT_BRK RIGHT_BRA MINUS_GT }]
  [oclExpression ::= oclExpression (*) LEFT_PAR arguments RIGHT_PAR , {IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE COMMA DOT UP UP_UP LEFT_PAR LEFT_BRK RIGHT_BRA MINUS_GT }]
  [oclExpression ::= oclExpression (*) MINUS_GT ITERATE LEFT_PAR variableDeclaration BAR oclExpression RIGHT_PAR , {IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE COMMA DOT UP UP_UP LEFT_PAR LEFT_BRK RIGHT_BRA MINUS_GT }]
  [oclExpression ::= oclExpression (*) PLUS oclExpression , {IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE COMMA DOT UP UP_UP LEFT_PAR LEFT_BRK RIGHT_BRA MINUS_GT }]
  [oclExpression ::= oclExpression (*) LE oclExpression , {IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE COMMA DOT UP UP_UP LEFT_PAR LEFT_BRK RIGHT_BRA MINUS_GT }]
  [oclExpression ::= oclExpression (*) OR oclExpression , {IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE COMMA DOT UP UP_UP LEFT_PAR LEFT_BRK RIGHT_BRA MINUS_GT }]
  [oclExpression ::= oclExpression (*) UP_UP simpleName LEFT_PAR RIGHT_PAR , {IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE COMMA DOT UP UP_UP LEFT_PAR LEFT_BRK RIGHT_BRA MINUS_GT }]
  [oclExpression ::= oclExpression (*) MINUS_GT simpleName , {IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE COMMA DOT UP UP_UP LEFT_PAR LEFT_BRK RIGHT_BRA MINUS_GT }]
  [oclExpression ::= oclExpression (*) TIMES oclExpression , {IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE COMMA DOT UP UP_UP LEFT_PAR LEFT_BRK RIGHT_BRA MINUS_GT }]
  [oclExpression ::= oclExpression (*) LT oclExpression , {IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE COMMA DOT UP UP_UP LEFT_PAR LEFT_BRK RIGHT_BRA MINUS_GT }]
  [oclExpression ::= oclExpression (*) NE oclExpression , {IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE COMMA DOT UP UP_UP LEFT_PAR LEFT_BRK RIGHT_BRA MINUS_GT }]
  [collectionRange ::= oclExpression DOT_DOT oclExpression (*) , {COMMA RIGHT_BRA }]
  [oclExpression ::= oclExpression (*) LEFT_PAR variableDeclaration BAR oclExpression RIGHT_PAR , {IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE COMMA DOT UP UP_UP LEFT_PAR LEFT_BRK RIGHT_BRA MINUS_GT }]
  [oclExpression ::= oclExpression (*) MINUS oclExpression , {IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE COMMA DOT UP UP_UP LEFT_PAR LEFT_BRK RIGHT_BRA MINUS_GT }]
  [oclExpression ::= oclExpression (*) GE oclExpression , {IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE COMMA DOT UP UP_UP LEFT_PAR LEFT_BRK RIGHT_BRA MINUS_GT }]
  [oclExpression ::= oclExpression (*) XOR oclExpression , {IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE COMMA DOT UP UP_UP LEFT_PAR LEFT_BRK RIGHT_BRA MINUS_GT }]
  [oclExpression ::= oclExpression (*) UP simpleName LEFT_PAR oclMessageArgumentList RIGHT_PAR , {IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE COMMA DOT UP UP_UP LEFT_PAR LEFT_BRK RIGHT_BRA MINUS_GT }]
  [oclExpression ::= oclExpression (*) DOT simpleName isMarkedPre , {IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE COMMA DOT UP UP_UP LEFT_PAR LEFT_BRK RIGHT_BRA MINUS_GT }]
  [oclExpression ::= oclExpression (*) MINUS_GT ITERATE LEFT_PAR variableDeclaration SEMICOLON variableDeclaration BAR oclExpression RIGHT_PAR , {IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE COMMA DOT UP UP_UP LEFT_PAR LEFT_BRK RIGHT_BRA MINUS_GT }]
  [oclExpression ::= oclExpression (*) DIVIDE oclExpression , {IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE COMMA DOT UP UP_UP LEFT_PAR LEFT_BRK RIGHT_BRA MINUS_GT }]
  [oclExpression ::= oclExpression (*) GT oclExpression , {IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE COMMA DOT UP UP_UP LEFT_PAR LEFT_BRK RIGHT_BRA MINUS_GT }]
  [oclExpression ::= oclExpression (*) AND oclExpression , {IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE COMMA DOT UP UP_UP LEFT_PAR LEFT_BRK RIGHT_BRA MINUS_GT }]
  [oclExpression ::= oclExpression (*) UP_UP simpleName LEFT_PAR oclMessageArgumentList RIGHT_PAR , {IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE COMMA DOT UP UP_UP LEFT_PAR LEFT_BRK RIGHT_BRA MINUS_GT }]
}
transition on XOR to state [74]
transition on EQ to state [73]
transition on DOT to state [72]
transition on MINUS to state [71]
transition on GE to state [70]
transition on LEFT_BRK to state [69]
transition on DIVIDE to state [68]
transition on LEFT_PAR to state [67]
transition on MINUS_GT to state [66]
transition on LE to state [65]
transition on GT to state [64]
transition on IMPLIES to state [63]
transition on UP to state [62]
transition on UP_UP to state [61]
transition on OR to state [60]
transition on PLUS to state [59]
transition on NE to state [58]
transition on LT to state [57]
transition on AND to state [56]
transition on TIMES to state [55]

-------------------
lalr_state [159]: {
  [oclExpression ::= (*) oclExpression UP simpleName LEFT_PAR oclMessageArgumentList RIGHT_PAR , {IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE COMMA DOT UP DOT_DOT UP_UP LEFT_PAR LEFT_BRK RIGHT_BRA MINUS_GT }]
  [oclExpression ::= (*) oclExpression EQ oclExpression , {IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE COMMA DOT UP DOT_DOT UP_UP LEFT_PAR LEFT_BRK RIGHT_BRA MINUS_GT }]
  [oclExpression ::= (*) oclExpression TIMES oclExpression , {IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE COMMA DOT UP DOT_DOT UP_UP LEFT_PAR LEFT_BRK RIGHT_BRA MINUS_GT }]
  [oclExpression ::= (*) oclExpression DOT simpleName isMarkedPre , {IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE COMMA DOT UP DOT_DOT UP_UP LEFT_PAR LEFT_BRK RIGHT_BRA MINUS_GT }]
  [primitiveLiteralExp ::= (*) TRUE , {IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE COMMA DOT UP DOT_DOT UP_UP LEFT_PAR LEFT_BRK RIGHT_BRA MINUS_GT }]
  [literalExp ::= (*) tupleLiteralExp , {IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE COMMA DOT UP DOT_DOT UP_UP LEFT_PAR LEFT_BRK RIGHT_BRA MINUS_GT }]
  [oclExpression ::= (*) oclExpression IMPLIES oclExpression , {IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE COMMA DOT UP DOT_DOT UP_UP LEFT_PAR LEFT_BRK RIGHT_BRA MINUS_GT }]
  [oclExpression ::= (*) oclExpression LT oclExpression , {IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE COMMA DOT UP DOT_DOT UP_UP LEFT_PAR LEFT_BRK RIGHT_BRA MINUS_GT }]
  [oclExpression ::= (*) oclExpression MINUS_GT ITERATE LEFT_PAR variableDeclaration SEMICOLON variableDeclaration BAR oclExpression RIGHT_PAR , {IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE COMMA DOT UP DOT_DOT UP_UP LEFT_PAR LEFT_BRK RIGHT_BRA MINUS_GT }]
  [tupleLiteralExp ::= (*) TUPLE LEFT_BRA variableDeclarationList RIGHT_BRA , {IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE COMMA DOT UP DOT_DOT UP_UP LEFT_PAR LEFT_BRK RIGHT_BRA MINUS_GT }]
  [collectionKind ::= (*) SET , {LEFT_BRA }]
  [oclExpression ::= (*) oclExpression UP simpleName LEFT_PAR RIGHT_PAR , {IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE COMMA DOT UP DOT_DOT UP_UP LEFT_PAR LEFT_BRK RIGHT_BRA MINUS_GT }]
  [oclExpression ::= (*) oclExpression NE oclExpression , {IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE COMMA DOT UP DOT_DOT UP_UP LEFT_PAR LEFT_BRK RIGHT_BRA MINUS_GT }]
  [oclExpression ::= (*) oclExpression DIVIDE oclExpression , {IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE COMMA DOT UP DOT_DOT UP_UP LEFT_PAR LEFT_BRK RIGHT_BRA MINUS_GT }]
  [oclExpression ::= (*) oclExpression LEFT_PAR arguments RIGHT_PAR , {IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE COMMA DOT UP DOT_DOT UP_UP LEFT_PAR LEFT_BRK RIGHT_BRA MINUS_GT }]
  [collectionLiteralParts ::= collectionLiteralParts COMMA (*) collectionLiteralPart , {COMMA RIGHT_BRA }]
  [primitiveLiteralExp ::= (*) FALSE , {IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE COMMA DOT UP DOT_DOT UP_UP LEFT_PAR LEFT_BRK RIGHT_BRA MINUS_GT }]
  [literalExp ::= (*) primitiveLiteralExp , {IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE COMMA DOT UP DOT_DOT UP_UP LEFT_PAR LEFT_BRK RIGHT_BRA MINUS_GT }]
  [oclExpression ::= (*) LET variableDeclarationList IN oclExpression , {IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE COMMA DOT UP DOT_DOT UP_UP LEFT_PAR LEFT_BRK RIGHT_BRA MINUS_GT }]
  [oclExpression ::= (*) oclExpression GT oclExpression , {IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE COMMA DOT UP DOT_DOT UP_UP LEFT_PAR LEFT_BRK RIGHT_BRA MINUS_GT }]
  [oclExpression ::= (*) oclExpression MINUS_GT ITERATE LEFT_PAR variableDeclaration BAR oclExpression RIGHT_PAR , {IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE COMMA DOT UP DOT_DOT UP_UP LEFT_PAR LEFT_BRK RIGHT_BRA MINUS_GT }]
  [oclExpression ::= (*) literalExp , {IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE COMMA DOT UP DOT_DOT UP_UP LEFT_PAR LEFT_BRK RIGHT_BRA MINUS_GT }]
  [primitiveLiteralExp ::= (*) INTEGER , {IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE COMMA DOT UP DOT_DOT UP_UP LEFT_PAR LEFT_BRK RIGHT_BRA MINUS_GT }]
  [collectionKind ::= (*) BAG , {LEFT_BRA }]
  [oclExpression ::= (*) oclExpression AND oclExpression , {IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE COMMA DOT UP DOT_DOT UP_UP LEFT_PAR LEFT_BRK RIGHT_BRA MINUS_GT }]
  [oclExpression ::= (*) oclExpression PLUS oclExpression , {IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE COMMA DOT UP DOT_DOT UP_UP LEFT_PAR LEFT_BRK RIGHT_BRA MINUS_GT }]
  [oclExpression ::= (*) oclExpression LEFT_PAR variableDeclaration BAR oclExpression RIGHT_PAR , {IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE COMMA DOT UP DOT_DOT UP_UP LEFT_PAR LEFT_BRK RIGHT_BRA MINUS_GT }]
  [pathName ::= (*) simpleName , {IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE COMMA DOT UP AT DOT_DOT COLON_COLON UP_UP LEFT_PAR LEFT_BRK RIGHT_BRA MINUS_GT }]
  [collectionLiteralPart ::= (*) oclExpression , {COMMA RIGHT_BRA }]
  [oclExpression ::= (*) oclExpression UP_UP simpleName LEFT_PAR oclMessageArgumentList RIGHT_PAR , {IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE COMMA DOT UP DOT_DOT UP_UP LEFT_PAR LEFT_BRK RIGHT_BRA MINUS_GT }]
  [oclExpression ::= (*) oclExpression LE oclExpression , {IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE COMMA DOT UP DOT_DOT UP_UP LEFT_PAR LEFT_BRK RIGHT_BRA MINUS_GT }]
  [oclExpression ::= (*) NOT oclExpression , {IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE COMMA DOT UP DOT_DOT UP_UP LEFT_PAR LEFT_BRK RIGHT_BRA MINUS_GT }]
  [oclExpression ::= (*) LEFT_PAR oclExpression RIGHT_PAR , {IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE COMMA DOT UP DOT_DOT UP_UP LEFT_PAR LEFT_BRK RIGHT_BRA MINUS_GT }]
  [primitiveLiteralExp ::= (*) REAL , {IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE COMMA DOT UP DOT_DOT UP_UP LEFT_PAR LEFT_BRK RIGHT_BRA MINUS_GT }]
  [collectionKind ::= (*) SEQUENCE , {LEFT_BRA }]
  [oclExpression ::= (*) oclExpression OR oclExpression , {IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE COMMA DOT UP DOT_DOT UP_UP LEFT_PAR LEFT_BRK RIGHT_BRA MINUS_GT }]
  [oclExpression ::= (*) oclExpression MINUS oclExpression , {IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE COMMA DOT UP DOT_DOT UP_UP LEFT_PAR LEFT_BRK RIGHT_BRA MINUS_GT }]
  [oclExpression ::= (*) oclExpression LEFT_BRK argumentList RIGHT_BRK isMarkedPre , {IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE COMMA DOT UP DOT_DOT UP_UP LEFT_PAR LEFT_BRK RIGHT_BRA MINUS_GT }]
  [pathName ::= (*) pathName COLON_COLON simpleName , {IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE COMMA DOT UP AT DOT_DOT COLON_COLON UP_UP LEFT_PAR LEFT_BRK RIGHT_BRA MINUS_GT }]
  [collectionLiteralPart ::= (*) collectionRange , {COMMA RIGHT_BRA }]
  [collectionLiteralExp ::= (*) collectionKind LEFT_BRA collectionLiteralParts RIGHT_BRA , {IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE COMMA DOT UP DOT_DOT UP_UP LEFT_PAR LEFT_BRK RIGHT_BRA MINUS_GT }]
  [oclExpression ::= (*) oclExpression UP_UP simpleName LEFT_PAR RIGHT_PAR , {IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE COMMA DOT UP DOT_DOT UP_UP LEFT_PAR LEFT_BRK RIGHT_BRA MINUS_GT }]
  [oclExpression ::= (*) oclExpression GE oclExpression , {IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE COMMA DOT UP DOT_DOT UP_UP LEFT_PAR LEFT_BRK RIGHT_BRA MINUS_GT }]
  [oclExpression ::= (*) MINUS oclExpression , {IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE COMMA DOT UP DOT_DOT UP_UP LEFT_PAR LEFT_BRK RIGHT_BRA MINUS_GT }]
  [oclExpression ::= (*) pathName isMarkedPre , {IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE COMMA DOT UP DOT_DOT UP_UP LEFT_PAR LEFT_BRK RIGHT_BRA MINUS_GT }]
  [primitiveLiteralExp ::= (*) STRING , {IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE COMMA DOT UP DOT_DOT UP_UP LEFT_PAR LEFT_BRK RIGHT_BRA MINUS_GT }]
  [collectionKind ::= (*) COLLECTION , {LEFT_BRA }]
  [literalExp ::= (*) collectionLiteralExp , {IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE COMMA DOT UP DOT_DOT UP_UP LEFT_PAR LEFT_BRK RIGHT_BRA MINUS_GT }]
  [oclExpression ::= (*) oclExpression XOR oclExpression , {IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE COMMA DOT UP DOT_DOT UP_UP LEFT_PAR LEFT_BRK RIGHT_BRA MINUS_GT }]
  [oclExpression ::= (*) IF oclExpression THEN oclExpression ELSE oclExpression ENDIF , {IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE COMMA DOT UP DOT_DOT UP_UP LEFT_PAR LEFT_BRK RIGHT_BRA MINUS_GT }]
  [oclExpression ::= (*) oclExpression MINUS_GT simpleName , {IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE COMMA DOT UP DOT_DOT UP_UP LEFT_PAR LEFT_BRK RIGHT_BRA MINUS_GT }]
  [simpleName ::= (*) SIMPLE_NAME , {IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE COMMA DOT UP AT DOT_DOT COLON_COLON UP_UP LEFT_PAR LEFT_BRK RIGHT_BRA MINUS_GT }]
  [collectionRange ::= (*) oclExpression DOT_DOT oclExpression , {COMMA RIGHT_BRA }]
  [collectionLiteralExp ::= (*) collectionKind LEFT_BRA RIGHT_BRA , {IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE COMMA DOT UP DOT_DOT UP_UP LEFT_PAR LEFT_BRK RIGHT_BRA MINUS_GT }]
}
transition on tupleLiteralExp to state [54]
transition on oclExpression to state [155]
transition on REAL to state [52]
transition on INTEGER to state [51]
transition on pathName to state [50]
transition on SIMPLE_NAME to state [12]
transition on LET to state [49]
transition on FALSE to state [48]
transition on MINUS to state [47]
transition on COLLECTION to state [28]
transition on SET to state [20]
transition on simpleName to state [26]
transition on collectionLiteralExp to state [46]
transition on LEFT_PAR to state [45]
transition on STRING to state [44]
transition on IF to state [43]
transition on TRUE to state [42]
transition on collectionKind to state [41]
transition on NOT to state [40]
transition on primitiveLiteralExp to state [39]
transition on TUPLE to state [38]
transition on literalExp to state [37]
transition on BAG to state [25]
transition on SEQUENCE to state [22]
transition on collectionLiteralPart to state [161]
transition on collectionRange to state [152]

-------------------
lalr_state [160]: {
  [collectionLiteralExp ::= collectionKind LEFT_BRA collectionLiteralParts RIGHT_BRA (*) , {EOF ENDPACKAGE CONTEXT INIT DERIVE INV DEF PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE IN THEN ELSE ENDIF COMMA DOT COLON SEMICOLON BAR UP DOT_DOT UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR RIGHT_BRK RIGHT_BRA MINUS_GT }]
}

-------------------
lalr_state [161]: {
  [collectionLiteralParts ::= collectionLiteralParts COMMA collectionLiteralPart (*) , {COMMA RIGHT_BRA }]
}

-------------------
lalr_state [162]: {
  [oclExpression ::= oclExpression (*) LEFT_BRK argumentList RIGHT_BRK isMarkedPre , {EOF ENDPACKAGE CONTEXT INIT DERIVE INV DEF PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE IN THEN ELSE ENDIF COMMA DOT COLON SEMICOLON BAR UP DOT_DOT UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR RIGHT_BRK RIGHT_BRA MINUS_GT }]
  [oclExpression ::= oclExpression (*) EQ oclExpression , {EOF ENDPACKAGE CONTEXT INIT DERIVE INV DEF PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE IN THEN ELSE ENDIF COMMA DOT COLON SEMICOLON BAR UP DOT_DOT UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR RIGHT_BRK RIGHT_BRA MINUS_GT }]
  [oclExpression ::= oclExpression (*) IMPLIES oclExpression , {EOF ENDPACKAGE CONTEXT INIT DERIVE INV DEF PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE IN THEN ELSE ENDIF COMMA DOT COLON SEMICOLON BAR UP DOT_DOT UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR RIGHT_BRK RIGHT_BRA MINUS_GT }]
  [oclExpression ::= oclExpression (*) UP simpleName LEFT_PAR RIGHT_PAR , {EOF ENDPACKAGE CONTEXT INIT DERIVE INV DEF PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE IN THEN ELSE ENDIF COMMA DOT COLON SEMICOLON BAR UP DOT_DOT UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR RIGHT_BRK RIGHT_BRA MINUS_GT }]
  [oclExpression ::= oclExpression (*) LEFT_PAR arguments RIGHT_PAR , {EOF ENDPACKAGE CONTEXT INIT DERIVE INV DEF PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE IN THEN ELSE ENDIF COMMA DOT COLON SEMICOLON BAR UP DOT_DOT UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR RIGHT_BRK RIGHT_BRA MINUS_GT }]
  [oclExpression ::= oclExpression (*) MINUS_GT ITERATE LEFT_PAR variableDeclaration BAR oclExpression RIGHT_PAR , {EOF ENDPACKAGE CONTEXT INIT DERIVE INV DEF PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE IN THEN ELSE ENDIF COMMA DOT COLON SEMICOLON BAR UP DOT_DOT UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR RIGHT_BRK RIGHT_BRA MINUS_GT }]
  [oclExpression ::= oclExpression (*) PLUS oclExpression , {EOF ENDPACKAGE CONTEXT INIT DERIVE INV DEF PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE IN THEN ELSE ENDIF COMMA DOT COLON SEMICOLON BAR UP DOT_DOT UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR RIGHT_BRK RIGHT_BRA MINUS_GT }]
  [oclExpression ::= oclExpression (*) LE oclExpression , {EOF ENDPACKAGE CONTEXT INIT DERIVE INV DEF PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE IN THEN ELSE ENDIF COMMA DOT COLON SEMICOLON BAR UP DOT_DOT UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR RIGHT_BRK RIGHT_BRA MINUS_GT }]
  [oclExpression ::= oclExpression (*) OR oclExpression , {EOF ENDPACKAGE CONTEXT INIT DERIVE INV DEF PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE IN THEN ELSE ENDIF COMMA DOT COLON SEMICOLON BAR UP DOT_DOT UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR RIGHT_BRK RIGHT_BRA MINUS_GT }]
  [oclExpression ::= oclExpression (*) UP_UP simpleName LEFT_PAR RIGHT_PAR , {EOF ENDPACKAGE CONTEXT INIT DERIVE INV DEF PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE IN THEN ELSE ENDIF COMMA DOT COLON SEMICOLON BAR UP DOT_DOT UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR RIGHT_BRK RIGHT_BRA MINUS_GT }]
  [oclExpression ::= oclExpression (*) MINUS_GT simpleName , {EOF ENDPACKAGE CONTEXT INIT DERIVE INV DEF PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE IN THEN ELSE ENDIF COMMA DOT COLON SEMICOLON BAR UP DOT_DOT UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR RIGHT_BRK RIGHT_BRA MINUS_GT }]
  [oclExpression ::= oclExpression (*) TIMES oclExpression , {EOF ENDPACKAGE CONTEXT INIT DERIVE INV DEF PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE IN THEN ELSE ENDIF COMMA DOT COLON SEMICOLON BAR UP DOT_DOT UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR RIGHT_BRK RIGHT_BRA MINUS_GT }]
  [oclExpression ::= oclExpression (*) LT oclExpression , {EOF ENDPACKAGE CONTEXT INIT DERIVE INV DEF PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE IN THEN ELSE ENDIF COMMA DOT COLON SEMICOLON BAR UP DOT_DOT UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR RIGHT_BRK RIGHT_BRA MINUS_GT }]
  [oclExpression ::= oclExpression (*) NE oclExpression , {EOF ENDPACKAGE CONTEXT INIT DERIVE INV DEF PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE IN THEN ELSE ENDIF COMMA DOT COLON SEMICOLON BAR UP DOT_DOT UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR RIGHT_BRK RIGHT_BRA MINUS_GT }]
  [oclExpression ::= NOT oclExpression (*) , {EOF ENDPACKAGE CONTEXT INIT DERIVE INV DEF PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE IN THEN ELSE ENDIF COMMA DOT COLON SEMICOLON BAR UP DOT_DOT UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR RIGHT_BRK RIGHT_BRA MINUS_GT }]
  [oclExpression ::= oclExpression (*) LEFT_PAR variableDeclaration BAR oclExpression RIGHT_PAR , {EOF ENDPACKAGE CONTEXT INIT DERIVE INV DEF PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE IN THEN ELSE ENDIF COMMA DOT COLON SEMICOLON BAR UP DOT_DOT UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR RIGHT_BRK RIGHT_BRA MINUS_GT }]
  [oclExpression ::= oclExpression (*) MINUS oclExpression , {EOF ENDPACKAGE CONTEXT INIT DERIVE INV DEF PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE IN THEN ELSE ENDIF COMMA DOT COLON SEMICOLON BAR UP DOT_DOT UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR RIGHT_BRK RIGHT_BRA MINUS_GT }]
  [oclExpression ::= oclExpression (*) GE oclExpression , {EOF ENDPACKAGE CONTEXT INIT DERIVE INV DEF PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE IN THEN ELSE ENDIF COMMA DOT COLON SEMICOLON BAR UP DOT_DOT UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR RIGHT_BRK RIGHT_BRA MINUS_GT }]
  [oclExpression ::= oclExpression (*) XOR oclExpression , {EOF ENDPACKAGE CONTEXT INIT DERIVE INV DEF PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE IN THEN ELSE ENDIF COMMA DOT COLON SEMICOLON BAR UP DOT_DOT UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR RIGHT_BRK RIGHT_BRA MINUS_GT }]
  [oclExpression ::= oclExpression (*) UP simpleName LEFT_PAR oclMessageArgumentList RIGHT_PAR , {EOF ENDPACKAGE CONTEXT INIT DERIVE INV DEF PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE IN THEN ELSE ENDIF COMMA DOT COLON SEMICOLON BAR UP DOT_DOT UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR RIGHT_BRK RIGHT_BRA MINUS_GT }]
  [oclExpression ::= oclExpression (*) DOT simpleName isMarkedPre , {EOF ENDPACKAGE CONTEXT INIT DERIVE INV DEF PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE IN THEN ELSE ENDIF COMMA DOT COLON SEMICOLON BAR UP DOT_DOT UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR RIGHT_BRK RIGHT_BRA MINUS_GT }]
  [oclExpression ::= oclExpression (*) MINUS_GT ITERATE LEFT_PAR variableDeclaration SEMICOLON variableDeclaration BAR oclExpression RIGHT_PAR , {EOF ENDPACKAGE CONTEXT INIT DERIVE INV DEF PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE IN THEN ELSE ENDIF COMMA DOT COLON SEMICOLON BAR UP DOT_DOT UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR RIGHT_BRK RIGHT_BRA MINUS_GT }]
  [oclExpression ::= oclExpression (*) DIVIDE oclExpression , {EOF ENDPACKAGE CONTEXT INIT DERIVE INV DEF PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE IN THEN ELSE ENDIF COMMA DOT COLON SEMICOLON BAR UP DOT_DOT UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR RIGHT_BRK RIGHT_BRA MINUS_GT }]
  [oclExpression ::= oclExpression (*) GT oclExpression , {EOF ENDPACKAGE CONTEXT INIT DERIVE INV DEF PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE IN THEN ELSE ENDIF COMMA DOT COLON SEMICOLON BAR UP DOT_DOT UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR RIGHT_BRK RIGHT_BRA MINUS_GT }]
  [oclExpression ::= oclExpression (*) AND oclExpression , {EOF ENDPACKAGE CONTEXT INIT DERIVE INV DEF PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE IN THEN ELSE ENDIF COMMA DOT COLON SEMICOLON BAR UP DOT_DOT UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR RIGHT_BRK RIGHT_BRA MINUS_GT }]
  [oclExpression ::= oclExpression (*) UP_UP simpleName LEFT_PAR oclMessageArgumentList RIGHT_PAR , {EOF ENDPACKAGE CONTEXT INIT DERIVE INV DEF PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE IN THEN ELSE ENDIF COMMA DOT COLON SEMICOLON BAR UP DOT_DOT UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR RIGHT_BRK RIGHT_BRA MINUS_GT }]
}
transition on XOR to state [74]
transition on EQ to state [73]
transition on DOT to state [72]
transition on MINUS to state [71]
transition on GE to state [70]
transition on LEFT_BRK to state [69]
transition on DIVIDE to state [68]
transition on LEFT_PAR to state [67]
transition on MINUS_GT to state [66]
transition on LE to state [65]
transition on GT to state [64]
transition on IMPLIES to state [63]
transition on UP to state [62]
transition on UP_UP to state [61]
transition on OR to state [60]
transition on PLUS to state [59]
transition on NE to state [58]
transition on LT to state [57]
transition on AND to state [56]
transition on TIMES to state [55]

-------------------
lalr_state [163]: {
  [variableDeclaration ::= (*) simpleName EQ oclExpression , {COMMA RIGHT_BRA }]
  [variableDeclarationList ::= (*) variableDeclarationList COMMA variableDeclaration , {COMMA RIGHT_BRA }]
  [tupleLiteralExp ::= TUPLE LEFT_BRA (*) variableDeclarationList RIGHT_BRA , {EOF ENDPACKAGE CONTEXT INIT DERIVE INV DEF PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE IN THEN ELSE ENDIF COMMA DOT COLON SEMICOLON BAR UP DOT_DOT UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR RIGHT_BRK RIGHT_BRA MINUS_GT }]
  [variableDeclaration ::= (*) simpleName COLON type , {COMMA RIGHT_BRA }]
  [simpleName ::= (*) SIMPLE_NAME , {EQ COMMA COLON RIGHT_BRA }]
  [variableDeclarationList ::= (*) variableDeclaration , {COMMA RIGHT_BRA }]
  [variableDeclaration ::= (*) simpleName , {COMMA RIGHT_BRA }]
  [variableDeclaration ::= (*) simpleName COLON type EQ oclExpression , {COMMA RIGHT_BRA }]
}
transition on SIMPLE_NAME to state [12]
transition on variableDeclaration to state [17]
transition on simpleName to state [16]
transition on variableDeclarationList to state [164]

-------------------
lalr_state [164]: {
  [variableDeclarationList ::= variableDeclarationList (*) COMMA variableDeclaration , {COMMA RIGHT_BRA }]
  [tupleLiteralExp ::= TUPLE LEFT_BRA variableDeclarationList (*) RIGHT_BRA , {EOF ENDPACKAGE CONTEXT INIT DERIVE INV DEF PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE IN THEN ELSE ENDIF COMMA DOT COLON SEMICOLON BAR UP DOT_DOT UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR RIGHT_BRK RIGHT_BRA MINUS_GT }]
}
transition on COMMA to state [33]
transition on RIGHT_BRA to state [165]

-------------------
lalr_state [165]: {
  [tupleLiteralExp ::= TUPLE LEFT_BRA variableDeclarationList RIGHT_BRA (*) , {EOF ENDPACKAGE CONTEXT INIT DERIVE INV DEF PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE IN THEN ELSE ENDIF COMMA DOT COLON SEMICOLON BAR UP DOT_DOT UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR RIGHT_BRK RIGHT_BRA MINUS_GT }]
}

-------------------
lalr_state [166]: {
  [collectionKind ::= (*) BAG , {LEFT_PAR }]
  [collectionType ::= collectionKind LEFT_PAR (*) type RIGHT_PAR , {INIT DERIVE PRE POST BODY EQ IN COMMA SEMICOLON BAR RIGHT_PAR RIGHT_BRA }]
  [collectionType ::= (*) collectionKind LEFT_PAR type RIGHT_PAR , {RIGHT_PAR }]
  [pathName ::= (*) simpleName , {COLON_COLON RIGHT_PAR }]
  [type ::= (*) pathName , {RIGHT_PAR }]
  [collectionKind ::= (*) COLLECTION , {LEFT_PAR }]
  [collectionKind ::= (*) SET , {LEFT_PAR }]
  [simpleName ::= (*) SIMPLE_NAME , {COLON_COLON RIGHT_PAR }]
  [type ::= (*) tupleType , {RIGHT_PAR }]
  [collectionKind ::= (*) SEQUENCE , {LEFT_PAR }]
  [tupleType ::= (*) TUPLE_TYPE LEFT_PAR variableDeclarationList RIGHT_PAR , {RIGHT_PAR }]
  [pathName ::= (*) pathName COLON_COLON simpleName , {COLON_COLON RIGHT_PAR }]
  [type ::= (*) collectionType , {RIGHT_PAR }]
}
transition on collectionType to state [30]
transition on TUPLE_TYPE to state [29]
transition on COLLECTION to state [28]
transition on type to state [167]
transition on simpleName to state [26]
transition on BAG to state [25]
transition on collectionKind to state [24]
transition on pathName to state [23]
transition on SEQUENCE to state [22]
transition on tupleType to state [21]
transition on SET to state [20]
transition on SIMPLE_NAME to state [12]

-------------------
lalr_state [167]: {
  [collectionType ::= collectionKind LEFT_PAR type (*) RIGHT_PAR , {INIT DERIVE PRE POST BODY EQ IN COMMA SEMICOLON BAR RIGHT_PAR RIGHT_BRA }]
}
transition on RIGHT_PAR to state [168]

-------------------
lalr_state [168]: {
  [collectionType ::= collectionKind LEFT_PAR type RIGHT_PAR (*) , {INIT DERIVE PRE POST BODY EQ IN COMMA SEMICOLON BAR RIGHT_PAR RIGHT_BRA }]
}

-------------------
lalr_state [169]: {
  [oclExpression ::= oclExpression (*) LEFT_BRK argumentList RIGHT_BRK isMarkedPre , {IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE IN COMMA DOT SEMICOLON BAR UP UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR RIGHT_BRA MINUS_GT }]
  [oclExpression ::= oclExpression (*) EQ oclExpression , {IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE IN COMMA DOT SEMICOLON BAR UP UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR RIGHT_BRA MINUS_GT }]
  [oclExpression ::= oclExpression (*) IMPLIES oclExpression , {IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE IN COMMA DOT SEMICOLON BAR UP UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR RIGHT_BRA MINUS_GT }]
  [oclExpression ::= oclExpression (*) UP simpleName LEFT_PAR RIGHT_PAR , {IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE IN COMMA DOT SEMICOLON BAR UP UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR RIGHT_BRA MINUS_GT }]
  [oclExpression ::= oclExpression (*) LEFT_PAR arguments RIGHT_PAR , {IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE IN COMMA DOT SEMICOLON BAR UP UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR RIGHT_BRA MINUS_GT }]
  [oclExpression ::= oclExpression (*) MINUS_GT ITERATE LEFT_PAR variableDeclaration BAR oclExpression RIGHT_PAR , {IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE IN COMMA DOT SEMICOLON BAR UP UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR RIGHT_BRA MINUS_GT }]
  [oclExpression ::= oclExpression (*) PLUS oclExpression , {IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE IN COMMA DOT SEMICOLON BAR UP UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR RIGHT_BRA MINUS_GT }]
  [oclExpression ::= oclExpression (*) LE oclExpression , {IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE IN COMMA DOT SEMICOLON BAR UP UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR RIGHT_BRA MINUS_GT }]
  [oclExpression ::= oclExpression (*) OR oclExpression , {IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE IN COMMA DOT SEMICOLON BAR UP UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR RIGHT_BRA MINUS_GT }]
  [oclExpression ::= oclExpression (*) UP_UP simpleName LEFT_PAR RIGHT_PAR , {IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE IN COMMA DOT SEMICOLON BAR UP UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR RIGHT_BRA MINUS_GT }]
  [oclExpression ::= oclExpression (*) MINUS_GT simpleName , {IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE IN COMMA DOT SEMICOLON BAR UP UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR RIGHT_BRA MINUS_GT }]
  [oclExpression ::= oclExpression (*) TIMES oclExpression , {IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE IN COMMA DOT SEMICOLON BAR UP UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR RIGHT_BRA MINUS_GT }]
  [oclExpression ::= oclExpression (*) LT oclExpression , {IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE IN COMMA DOT SEMICOLON BAR UP UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR RIGHT_BRA MINUS_GT }]
  [oclExpression ::= oclExpression (*) NE oclExpression , {IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE IN COMMA DOT SEMICOLON BAR UP UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR RIGHT_BRA MINUS_GT }]
  [oclExpression ::= oclExpression (*) LEFT_PAR variableDeclaration BAR oclExpression RIGHT_PAR , {IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE IN COMMA DOT SEMICOLON BAR UP UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR RIGHT_BRA MINUS_GT }]
  [oclExpression ::= oclExpression (*) MINUS oclExpression , {IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE IN COMMA DOT SEMICOLON BAR UP UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR RIGHT_BRA MINUS_GT }]
  [oclExpression ::= oclExpression (*) GE oclExpression , {IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE IN COMMA DOT SEMICOLON BAR UP UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR RIGHT_BRA MINUS_GT }]
  [oclExpression ::= oclExpression (*) XOR oclExpression , {IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE IN COMMA DOT SEMICOLON BAR UP UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR RIGHT_BRA MINUS_GT }]
  [variableDeclaration ::= simpleName EQ oclExpression (*) , {EQ IN COMMA SEMICOLON BAR RIGHT_PAR RIGHT_BRA }]
  [oclExpression ::= oclExpression (*) UP simpleName LEFT_PAR oclMessageArgumentList RIGHT_PAR , {IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE IN COMMA DOT SEMICOLON BAR UP UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR RIGHT_BRA MINUS_GT }]
  [oclExpression ::= oclExpression (*) DOT simpleName isMarkedPre , {IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE IN COMMA DOT SEMICOLON BAR UP UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR RIGHT_BRA MINUS_GT }]
  [oclExpression ::= oclExpression (*) MINUS_GT ITERATE LEFT_PAR variableDeclaration SEMICOLON variableDeclaration BAR oclExpression RIGHT_PAR , {IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE IN COMMA DOT SEMICOLON BAR UP UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR RIGHT_BRA MINUS_GT }]
  [oclExpression ::= oclExpression (*) DIVIDE oclExpression , {IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE IN COMMA DOT SEMICOLON BAR UP UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR RIGHT_BRA MINUS_GT }]
  [oclExpression ::= oclExpression (*) GT oclExpression , {IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE IN COMMA DOT SEMICOLON BAR UP UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR RIGHT_BRA MINUS_GT }]
  [oclExpression ::= oclExpression (*) AND oclExpression , {IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE IN COMMA DOT SEMICOLON BAR UP UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR RIGHT_BRA MINUS_GT }]
  [oclExpression ::= oclExpression (*) UP_UP simpleName LEFT_PAR oclMessageArgumentList RIGHT_PAR , {IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE IN COMMA DOT SEMICOLON BAR UP UP_UP LEFT_PAR LEFT_BRK RIGHT_PAR RIGHT_BRA MINUS_GT }]
}
transition on XOR to state [74]
transition on EQ to state [73]
transition on DOT to state [72]
transition on MINUS to state [71]
transition on GE to state [70]
transition on LEFT_BRK to state [69]
transition on DIVIDE to state [68]
transition on LEFT_PAR to state [67]
transition on MINUS_GT to state [66]
transition on LE to state [65]
transition on GT to state [64]
transition on IMPLIES to state [63]
transition on UP to state [62]
transition on UP_UP to state [61]
transition on OR to state [60]
transition on PLUS to state [59]
transition on NE to state [58]
transition on LT to state [57]
transition on AND to state [56]
transition on TIMES to state [55]

-------------------
lalr_state [170]: {
  [collectionKind ::= (*) BAG , {LEFT_PAR }]
  [collectionType ::= (*) collectionKind LEFT_PAR type RIGHT_PAR , {PRE POST BODY EQ }]
  [pathName ::= (*) simpleName , {PRE POST BODY EQ COLON_COLON }]
  [type ::= (*) pathName , {PRE POST BODY EQ }]
  [collectionKind ::= (*) COLLECTION , {LEFT_PAR }]
  [collectionKind ::= (*) SET , {LEFT_PAR }]
  [simpleName ::= (*) SIMPLE_NAME , {PRE POST BODY EQ COLON_COLON }]
  [type ::= (*) tupleType , {PRE POST BODY EQ }]
  [collectionKind ::= (*) SEQUENCE , {LEFT_PAR }]
  [tupleType ::= (*) TUPLE_TYPE LEFT_PAR variableDeclarationList RIGHT_PAR , {PRE POST BODY EQ }]
  [operation ::= simpleName LEFT_PAR RIGHT_PAR COLON (*) type , {PRE POST BODY EQ }]
  [pathName ::= (*) pathName COLON_COLON simpleName , {PRE POST BODY EQ COLON_COLON }]
  [type ::= (*) collectionType , {PRE POST BODY EQ }]
}
transition on collectionType to state [30]
transition on TUPLE_TYPE to state [29]
transition on COLLECTION to state [28]
transition on simpleName to state [26]
transition on type to state [171]
transition on BAG to state [25]
transition on collectionKind to state [24]
transition on pathName to state [23]
transition on SEQUENCE to state [22]
transition on tupleType to state [21]
transition on SET to state [20]
transition on SIMPLE_NAME to state [12]

-------------------
lalr_state [171]: {
  [operation ::= simpleName LEFT_PAR RIGHT_PAR COLON type (*) , {PRE POST BODY EQ }]
}

-------------------
lalr_state [172]: {
  [operation ::= simpleName LEFT_PAR variableDeclarationList RIGHT_PAR (*) , {PRE POST BODY EQ }]
  [operation ::= simpleName LEFT_PAR variableDeclarationList RIGHT_PAR (*) COLON type , {PRE POST BODY EQ }]
}
transition on COLON to state [173]

-------------------
lalr_state [173]: {
  [collectionKind ::= (*) BAG , {LEFT_PAR }]
  [collectionType ::= (*) collectionKind LEFT_PAR type RIGHT_PAR , {PRE POST BODY EQ }]
  [pathName ::= (*) simpleName , {PRE POST BODY EQ COLON_COLON }]
  [type ::= (*) pathName , {PRE POST BODY EQ }]
  [collectionKind ::= (*) COLLECTION , {LEFT_PAR }]
  [collectionKind ::= (*) SET , {LEFT_PAR }]
  [operation ::= simpleName LEFT_PAR variableDeclarationList RIGHT_PAR COLON (*) type , {PRE POST BODY EQ }]
  [simpleName ::= (*) SIMPLE_NAME , {PRE POST BODY EQ COLON_COLON }]
  [type ::= (*) tupleType , {PRE POST BODY EQ }]
  [collectionKind ::= (*) SEQUENCE , {LEFT_PAR }]
  [tupleType ::= (*) TUPLE_TYPE LEFT_PAR variableDeclarationList RIGHT_PAR , {PRE POST BODY EQ }]
  [pathName ::= (*) pathName COLON_COLON simpleName , {PRE POST BODY EQ COLON_COLON }]
  [type ::= (*) collectionType , {PRE POST BODY EQ }]
}
transition on collectionType to state [30]
transition on TUPLE_TYPE to state [29]
transition on COLLECTION to state [28]
transition on type to state [174]
transition on simpleName to state [26]
transition on BAG to state [25]
transition on collectionKind to state [24]
transition on pathName to state [23]
transition on SEQUENCE to state [22]
transition on tupleType to state [21]
transition on SET to state [20]
transition on SIMPLE_NAME to state [12]

-------------------
lalr_state [174]: {
  [operation ::= simpleName LEFT_PAR variableDeclarationList RIGHT_PAR COLON type (*) , {PRE POST BODY EQ }]
}

-------------------
lalr_state [175]: {
  [invOrDef ::= DEF (*) simpleName COLON defExpression , {EOF ENDPACKAGE CONTEXT INV DEF COLON }]
  [simpleName ::= (*) SIMPLE_NAME , {COLON }]
  [invOrDef ::= DEF (*) COLON defExpression , {EOF ENDPACKAGE CONTEXT INV DEF COLON }]
}
transition on SIMPLE_NAME to state [12]
transition on simpleName to state [230]
transition on COLON to state [229]

-------------------
lalr_state [176]: {
  [invOrDef ::= invOrDef (*) COLON defExpression , {EOF ENDPACKAGE CONTEXT INV DEF COLON }]
  [invOrDef ::= invOrDef (*) INV simpleName COLON oclExpression , {EOF ENDPACKAGE CONTEXT INV DEF COLON }]
  [invOrDef ::= invOrDef (*) DEF simpleName COLON defExpression , {EOF ENDPACKAGE CONTEXT INV DEF COLON }]
  [classifierContextDecl ::= CONTEXT pathName invOrDef (*) , {EOF ENDPACKAGE CONTEXT }]
  [invOrDef ::= invOrDef (*) INV COLON oclExpression , {EOF ENDPACKAGE CONTEXT INV DEF COLON }]
}
transition on INV to state [211]
transition on COLON to state [210]
transition on DEF to state [209]

-------------------
lalr_state [177]: {
  [propertyContextDecl ::= CONTEXT pathName simpleName (*) COLON type initOrDerValue , {EOF ENDPACKAGE CONTEXT }]
}
transition on COLON to state [194]

-------------------
lalr_state [178]: {
  [invOrDef ::= INV (*) COLON oclExpression , {EOF ENDPACKAGE CONTEXT INV DEF COLON }]
  [simpleName ::= (*) SIMPLE_NAME , {COLON }]
  [invOrDef ::= INV (*) simpleName COLON oclExpression , {EOF ENDPACKAGE CONTEXT INV DEF COLON }]
}
transition on SIMPLE_NAME to state [12]
transition on COLON to state [190]
transition on simpleName to state [189]

-------------------
lalr_state [179]: {
  [operation ::= pathName COLON_COLON (*) simpleName LEFT_PAR RIGHT_PAR , {PRE POST BODY EQ }]
  [operation ::= pathName COLON_COLON (*) simpleName LEFT_PAR variableDeclarationList RIGHT_PAR COLON type , {PRE POST BODY EQ }]
  [simpleName ::= (*) SIMPLE_NAME , {INV DEF COLON_COLON LEFT_PAR SIMPLE_NAME }]
  [operation ::= pathName COLON_COLON (*) simpleName LEFT_PAR RIGHT_PAR COLON type , {PRE POST BODY EQ }]
  [pathName ::= pathName COLON_COLON (*) simpleName , {INV DEF COLON_COLON SIMPLE_NAME }]
  [operation ::= pathName COLON_COLON (*) simpleName LEFT_PAR variableDeclarationList RIGHT_PAR , {PRE POST BODY EQ }]
}
transition on SIMPLE_NAME to state [12]
transition on simpleName to state [180]

-------------------
lalr_state [180]: {
  [operation ::= pathName COLON_COLON simpleName (*) LEFT_PAR RIGHT_PAR , {PRE POST BODY EQ }]
  [operation ::= pathName COLON_COLON simpleName (*) LEFT_PAR variableDeclarationList RIGHT_PAR COLON type , {PRE POST BODY EQ }]
  [operation ::= pathName COLON_COLON simpleName (*) LEFT_PAR RIGHT_PAR COLON type , {PRE POST BODY EQ }]
  [pathName ::= pathName COLON_COLON simpleName (*) , {INV DEF COLON_COLON SIMPLE_NAME }]
  [operation ::= pathName COLON_COLON simpleName (*) LEFT_PAR variableDeclarationList RIGHT_PAR , {PRE POST BODY EQ }]
}
transition on LEFT_PAR to state [181]

-------------------
lalr_state [181]: {
  [operation ::= pathName COLON_COLON simpleName LEFT_PAR (*) RIGHT_PAR COLON type , {PRE POST BODY EQ }]
  [variableDeclaration ::= (*) simpleName COLON type , {COMMA RIGHT_PAR }]
  [variableDeclarationList ::= (*) variableDeclaration , {COMMA RIGHT_PAR }]
  [simpleName ::= (*) SIMPLE_NAME , {EQ COMMA COLON RIGHT_PAR }]
  [variableDeclaration ::= (*) simpleName , {COMMA RIGHT_PAR }]
  [operation ::= pathName COLON_COLON simpleName LEFT_PAR (*) variableDeclarationList RIGHT_PAR , {PRE POST BODY EQ }]
  [variableDeclaration ::= (*) simpleName COLON type EQ oclExpression , {COMMA RIGHT_PAR }]
  [operation ::= pathName COLON_COLON simpleName LEFT_PAR (*) RIGHT_PAR , {PRE POST BODY EQ }]
  [operation ::= pathName COLON_COLON simpleName LEFT_PAR (*) variableDeclarationList RIGHT_PAR COLON type , {PRE POST BODY EQ }]
  [variableDeclaration ::= (*) simpleName EQ oclExpression , {COMMA RIGHT_PAR }]
  [variableDeclarationList ::= (*) variableDeclarationList COMMA variableDeclaration , {COMMA RIGHT_PAR }]
}
transition on SIMPLE_NAME to state [12]
transition on variableDeclaration to state [17]
transition on simpleName to state [16]
transition on RIGHT_PAR to state [183]
transition on variableDeclarationList to state [182]

-------------------
lalr_state [182]: {
  [operation ::= pathName COLON_COLON simpleName LEFT_PAR variableDeclarationList (*) RIGHT_PAR COLON type , {PRE POST BODY EQ }]
  [variableDeclarationList ::= variableDeclarationList (*) COMMA variableDeclaration , {COMMA RIGHT_PAR }]
  [operation ::= pathName COLON_COLON simpleName LEFT_PAR variableDeclarationList (*) RIGHT_PAR , {PRE POST BODY EQ }]
}
transition on RIGHT_PAR to state [186]
transition on COMMA to state [33]

-------------------
lalr_state [183]: {
  [operation ::= pathName COLON_COLON simpleName LEFT_PAR RIGHT_PAR (*) COLON type , {PRE POST BODY EQ }]
  [operation ::= pathName COLON_COLON simpleName LEFT_PAR RIGHT_PAR (*) , {PRE POST BODY EQ }]
}
transition on COLON to state [184]

-------------------
lalr_state [184]: {
  [collectionKind ::= (*) BAG , {LEFT_PAR }]
  [operation ::= pathName COLON_COLON simpleName LEFT_PAR RIGHT_PAR COLON (*) type , {PRE POST BODY EQ }]
  [collectionType ::= (*) collectionKind LEFT_PAR type RIGHT_PAR , {PRE POST BODY EQ }]
  [pathName ::= (*) simpleName , {PRE POST BODY EQ COLON_COLON }]
  [type ::= (*) pathName , {PRE POST BODY EQ }]
  [collectionKind ::= (*) COLLECTION , {LEFT_PAR }]
  [collectionKind ::= (*) SET , {LEFT_PAR }]
  [simpleName ::= (*) SIMPLE_NAME , {PRE POST BODY EQ COLON_COLON }]
  [type ::= (*) tupleType , {PRE POST BODY EQ }]
  [collectionKind ::= (*) SEQUENCE , {LEFT_PAR }]
  [tupleType ::= (*) TUPLE_TYPE LEFT_PAR variableDeclarationList RIGHT_PAR , {PRE POST BODY EQ }]
  [pathName ::= (*) pathName COLON_COLON simpleName , {PRE POST BODY EQ COLON_COLON }]
  [type ::= (*) collectionType , {PRE POST BODY EQ }]
}
transition on collectionType to state [30]
transition on TUPLE_TYPE to state [29]
transition on COLLECTION to state [28]
transition on type to state [185]
transition on simpleName to state [26]
transition on BAG to state [25]
transition on collectionKind to state [24]
transition on pathName to state [23]
transition on SEQUENCE to state [22]
transition on tupleType to state [21]
transition on SET to state [20]
transition on SIMPLE_NAME to state [12]

-------------------
lalr_state [185]: {
  [operation ::= pathName COLON_COLON simpleName LEFT_PAR RIGHT_PAR COLON type (*) , {PRE POST BODY EQ }]
}

-------------------
lalr_state [186]: {
  [operation ::= pathName COLON_COLON simpleName LEFT_PAR variableDeclarationList RIGHT_PAR (*) , {PRE POST BODY EQ }]
  [operation ::= pathName COLON_COLON simpleName LEFT_PAR variableDeclarationList RIGHT_PAR (*) COLON type , {PRE POST BODY EQ }]
}
transition on COLON to state [187]

-------------------
lalr_state [187]: {
  [collectionKind ::= (*) BAG , {LEFT_PAR }]
  [collectionType ::= (*) collectionKind LEFT_PAR type RIGHT_PAR , {PRE POST BODY EQ }]
  [pathName ::= (*) simpleName , {PRE POST BODY EQ COLON_COLON }]
  [type ::= (*) pathName , {PRE POST BODY EQ }]
  [collectionKind ::= (*) COLLECTION , {LEFT_PAR }]
  [collectionKind ::= (*) SET , {LEFT_PAR }]
  [simpleName ::= (*) SIMPLE_NAME , {PRE POST BODY EQ COLON_COLON }]
  [type ::= (*) tupleType , {PRE POST BODY EQ }]
  [collectionKind ::= (*) SEQUENCE , {LEFT_PAR }]
  [operation ::= pathName COLON_COLON simpleName LEFT_PAR variableDeclarationList RIGHT_PAR COLON (*) type , {PRE POST BODY EQ }]
  [tupleType ::= (*) TUPLE_TYPE LEFT_PAR variableDeclarationList RIGHT_PAR , {PRE POST BODY EQ }]
  [pathName ::= (*) pathName COLON_COLON simpleName , {PRE POST BODY EQ COLON_COLON }]
  [type ::= (*) collectionType , {PRE POST BODY EQ }]
}
transition on collectionType to state [30]
transition on TUPLE_TYPE to state [29]
transition on COLLECTION to state [28]
transition on simpleName to state [26]
transition on type to state [188]
transition on BAG to state [25]
transition on collectionKind to state [24]
transition on pathName to state [23]
transition on SEQUENCE to state [22]
transition on tupleType to state [21]
transition on SET to state [20]
transition on SIMPLE_NAME to state [12]

-------------------
lalr_state [188]: {
  [operation ::= pathName COLON_COLON simpleName LEFT_PAR variableDeclarationList RIGHT_PAR COLON type (*) , {PRE POST BODY EQ }]
}

-------------------
lalr_state [189]: {
  [invOrDef ::= INV simpleName (*) COLON oclExpression , {EOF ENDPACKAGE CONTEXT INV DEF COLON }]
}
transition on COLON to state [192]

-------------------
lalr_state [190]: {
  [oclExpression ::= (*) oclExpression UP simpleName LEFT_PAR oclMessageArgumentList RIGHT_PAR , {EOF ENDPACKAGE CONTEXT INV DEF IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE DOT COLON UP UP_UP LEFT_PAR LEFT_BRK MINUS_GT }]
  [oclExpression ::= (*) oclExpression EQ oclExpression , {EOF ENDPACKAGE CONTEXT INV DEF IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE DOT COLON UP UP_UP LEFT_PAR LEFT_BRK MINUS_GT }]
  [oclExpression ::= (*) oclExpression TIMES oclExpression , {EOF ENDPACKAGE CONTEXT INV DEF IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE DOT COLON UP UP_UP LEFT_PAR LEFT_BRK MINUS_GT }]
  [oclExpression ::= (*) oclExpression DOT simpleName isMarkedPre , {EOF ENDPACKAGE CONTEXT INV DEF IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE DOT COLON UP UP_UP LEFT_PAR LEFT_BRK MINUS_GT }]
  [primitiveLiteralExp ::= (*) TRUE , {EOF ENDPACKAGE CONTEXT INV DEF IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE DOT COLON UP UP_UP LEFT_PAR LEFT_BRK MINUS_GT }]
  [literalExp ::= (*) tupleLiteralExp , {EOF ENDPACKAGE CONTEXT INV DEF IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE DOT COLON UP UP_UP LEFT_PAR LEFT_BRK MINUS_GT }]
  [oclExpression ::= (*) oclExpression IMPLIES oclExpression , {EOF ENDPACKAGE CONTEXT INV DEF IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE DOT COLON UP UP_UP LEFT_PAR LEFT_BRK MINUS_GT }]
  [oclExpression ::= (*) oclExpression LT oclExpression , {EOF ENDPACKAGE CONTEXT INV DEF IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE DOT COLON UP UP_UP LEFT_PAR LEFT_BRK MINUS_GT }]
  [oclExpression ::= (*) oclExpression MINUS_GT ITERATE LEFT_PAR variableDeclaration SEMICOLON variableDeclaration BAR oclExpression RIGHT_PAR , {EOF ENDPACKAGE CONTEXT INV DEF IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE DOT COLON UP UP_UP LEFT_PAR LEFT_BRK MINUS_GT }]
  [tupleLiteralExp ::= (*) TUPLE LEFT_BRA variableDeclarationList RIGHT_BRA , {EOF ENDPACKAGE CONTEXT INV DEF IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE DOT COLON UP UP_UP LEFT_PAR LEFT_BRK MINUS_GT }]
  [collectionKind ::= (*) SET , {LEFT_BRA }]
  [oclExpression ::= (*) oclExpression UP simpleName LEFT_PAR RIGHT_PAR , {EOF ENDPACKAGE CONTEXT INV DEF IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE DOT COLON UP UP_UP LEFT_PAR LEFT_BRK MINUS_GT }]
  [oclExpression ::= (*) oclExpression NE oclExpression , {EOF ENDPACKAGE CONTEXT INV DEF IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE DOT COLON UP UP_UP LEFT_PAR LEFT_BRK MINUS_GT }]
  [oclExpression ::= (*) oclExpression DIVIDE oclExpression , {EOF ENDPACKAGE CONTEXT INV DEF IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE DOT COLON UP UP_UP LEFT_PAR LEFT_BRK MINUS_GT }]
  [oclExpression ::= (*) oclExpression LEFT_PAR arguments RIGHT_PAR , {EOF ENDPACKAGE CONTEXT INV DEF IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE DOT COLON UP UP_UP LEFT_PAR LEFT_BRK MINUS_GT }]
  [invOrDef ::= INV COLON (*) oclExpression , {EOF ENDPACKAGE CONTEXT INV DEF COLON }]
  [primitiveLiteralExp ::= (*) FALSE , {EOF ENDPACKAGE CONTEXT INV DEF IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE DOT COLON UP UP_UP LEFT_PAR LEFT_BRK MINUS_GT }]
  [literalExp ::= (*) primitiveLiteralExp , {EOF ENDPACKAGE CONTEXT INV DEF IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE DOT COLON UP UP_UP LEFT_PAR LEFT_BRK MINUS_GT }]
  [oclExpression ::= (*) LET variableDeclarationList IN oclExpression , {EOF ENDPACKAGE CONTEXT INV DEF IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE DOT COLON UP UP_UP LEFT_PAR LEFT_BRK MINUS_GT }]
  [oclExpression ::= (*) oclExpression GT oclExpression , {EOF ENDPACKAGE CONTEXT INV DEF IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE DOT COLON UP UP_UP LEFT_PAR LEFT_BRK MINUS_GT }]
  [oclExpression ::= (*) oclExpression MINUS_GT ITERATE LEFT_PAR variableDeclaration BAR oclExpression RIGHT_PAR , {EOF ENDPACKAGE CONTEXT INV DEF IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE DOT COLON UP UP_UP LEFT_PAR LEFT_BRK MINUS_GT }]
  [oclExpression ::= (*) literalExp , {EOF ENDPACKAGE CONTEXT INV DEF IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE DOT COLON UP UP_UP LEFT_PAR LEFT_BRK MINUS_GT }]
  [primitiveLiteralExp ::= (*) INTEGER , {EOF ENDPACKAGE CONTEXT INV DEF IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE DOT COLON UP UP_UP LEFT_PAR LEFT_BRK MINUS_GT }]
  [collectionKind ::= (*) BAG , {LEFT_BRA }]
  [oclExpression ::= (*) oclExpression AND oclExpression , {EOF ENDPACKAGE CONTEXT INV DEF IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE DOT COLON UP UP_UP LEFT_PAR LEFT_BRK MINUS_GT }]
  [oclExpression ::= (*) oclExpression PLUS oclExpression , {EOF ENDPACKAGE CONTEXT INV DEF IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE DOT COLON UP UP_UP LEFT_PAR LEFT_BRK MINUS_GT }]
  [oclExpression ::= (*) oclExpression LEFT_PAR variableDeclaration BAR oclExpression RIGHT_PAR , {EOF ENDPACKAGE CONTEXT INV DEF IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE DOT COLON UP UP_UP LEFT_PAR LEFT_BRK MINUS_GT }]
  [pathName ::= (*) simpleName , {EOF ENDPACKAGE CONTEXT INV DEF IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE DOT COLON UP AT COLON_COLON UP_UP LEFT_PAR LEFT_BRK MINUS_GT }]
  [oclExpression ::= (*) oclExpression UP_UP simpleName LEFT_PAR oclMessageArgumentList RIGHT_PAR , {EOF ENDPACKAGE CONTEXT INV DEF IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE DOT COLON UP UP_UP LEFT_PAR LEFT_BRK MINUS_GT }]
  [oclExpression ::= (*) oclExpression LE oclExpression , {EOF ENDPACKAGE CONTEXT INV DEF IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE DOT COLON UP UP_UP LEFT_PAR LEFT_BRK MINUS_GT }]
  [oclExpression ::= (*) NOT oclExpression , {EOF ENDPACKAGE CONTEXT INV DEF IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE DOT COLON UP UP_UP LEFT_PAR LEFT_BRK MINUS_GT }]
  [oclExpression ::= (*) LEFT_PAR oclExpression RIGHT_PAR , {EOF ENDPACKAGE CONTEXT INV DEF IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE DOT COLON UP UP_UP LEFT_PAR LEFT_BRK MINUS_GT }]
  [primitiveLiteralExp ::= (*) REAL , {EOF ENDPACKAGE CONTEXT INV DEF IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE DOT COLON UP UP_UP LEFT_PAR LEFT_BRK MINUS_GT }]
  [collectionKind ::= (*) SEQUENCE , {LEFT_BRA }]
  [oclExpression ::= (*) oclExpression OR oclExpression , {EOF ENDPACKAGE CONTEXT INV DEF IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE DOT COLON UP UP_UP LEFT_PAR LEFT_BRK MINUS_GT }]
  [oclExpression ::= (*) oclExpression MINUS oclExpression , {EOF ENDPACKAGE CONTEXT INV DEF IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE DOT COLON UP UP_UP LEFT_PAR LEFT_BRK MINUS_GT }]
  [oclExpression ::= (*) oclExpression LEFT_BRK argumentList RIGHT_BRK isMarkedPre , {EOF ENDPACKAGE CONTEXT INV DEF IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE DOT COLON UP UP_UP LEFT_PAR LEFT_BRK MINUS_GT }]
  [pathName ::= (*) pathName COLON_COLON simpleName , {EOF ENDPACKAGE CONTEXT INV DEF IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE DOT COLON UP AT COLON_COLON UP_UP LEFT_PAR LEFT_BRK MINUS_GT }]
  [collectionLiteralExp ::= (*) collectionKind LEFT_BRA collectionLiteralParts RIGHT_BRA , {EOF ENDPACKAGE CONTEXT INV DEF IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE DOT COLON UP UP_UP LEFT_PAR LEFT_BRK MINUS_GT }]
  [oclExpression ::= (*) oclExpression UP_UP simpleName LEFT_PAR RIGHT_PAR , {EOF ENDPACKAGE CONTEXT INV DEF IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE DOT COLON UP UP_UP LEFT_PAR LEFT_BRK MINUS_GT }]
  [oclExpression ::= (*) oclExpression GE oclExpression , {EOF ENDPACKAGE CONTEXT INV DEF IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE DOT COLON UP UP_UP LEFT_PAR LEFT_BRK MINUS_GT }]
  [oclExpression ::= (*) MINUS oclExpression , {EOF ENDPACKAGE CONTEXT INV DEF IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE DOT COLON UP UP_UP LEFT_PAR LEFT_BRK MINUS_GT }]
  [oclExpression ::= (*) pathName isMarkedPre , {EOF ENDPACKAGE CONTEXT INV DEF IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE DOT COLON UP UP_UP LEFT_PAR LEFT_BRK MINUS_GT }]
  [primitiveLiteralExp ::= (*) STRING , {EOF ENDPACKAGE CONTEXT INV DEF IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE DOT COLON UP UP_UP LEFT_PAR LEFT_BRK MINUS_GT }]
  [collectionKind ::= (*) COLLECTION , {LEFT_BRA }]
  [literalExp ::= (*) collectionLiteralExp , {EOF ENDPACKAGE CONTEXT INV DEF IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE DOT COLON UP UP_UP LEFT_PAR LEFT_BRK MINUS_GT }]
  [oclExpression ::= (*) oclExpression XOR oclExpression , {EOF ENDPACKAGE CONTEXT INV DEF IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE DOT COLON UP UP_UP LEFT_PAR LEFT_BRK MINUS_GT }]
  [oclExpression ::= (*) IF oclExpression THEN oclExpression ELSE oclExpression ENDIF , {EOF ENDPACKAGE CONTEXT INV DEF IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE DOT COLON UP UP_UP LEFT_PAR LEFT_BRK MINUS_GT }]
  [oclExpression ::= (*) oclExpression MINUS_GT simpleName , {EOF ENDPACKAGE CONTEXT INV DEF IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE DOT COLON UP UP_UP LEFT_PAR LEFT_BRK MINUS_GT }]
  [simpleName ::= (*) SIMPLE_NAME , {EOF ENDPACKAGE CONTEXT INV DEF IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE DOT COLON UP AT COLON_COLON UP_UP LEFT_PAR LEFT_BRK MINUS_GT }]
  [collectionLiteralExp ::= (*) collectionKind LEFT_BRA RIGHT_BRA , {EOF ENDPACKAGE CONTEXT INV DEF IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE DOT COLON UP UP_UP LEFT_PAR LEFT_BRK MINUS_GT }]
}
transition on tupleLiteralExp to state [54]
transition on oclExpression to state [191]
transition on REAL to state [52]
transition on INTEGER to state [51]
transition on pathName to state [50]
transition on SIMPLE_NAME to state [12]
transition on LET to state [49]
transition on FALSE to state [48]
transition on MINUS to state [47]
transition on COLLECTION to state [28]
transition on SET to state [20]
transition on simpleName to state [26]
transition on collectionLiteralExp to state [46]
transition on LEFT_PAR to state [45]
transition on STRING to state [44]
transition on IF to state [43]
transition on TRUE to state [42]
transition on collectionKind to state [41]
transition on NOT to state [40]
transition on primitiveLiteralExp to state [39]
transition on TUPLE to state [38]
transition on literalExp to state [37]
transition on BAG to state [25]
transition on SEQUENCE to state [22]

-------------------
lalr_state [191]: {
  [oclExpression ::= oclExpression (*) LEFT_BRK argumentList RIGHT_BRK isMarkedPre , {EOF ENDPACKAGE CONTEXT INV DEF IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE DOT COLON UP UP_UP LEFT_PAR LEFT_BRK MINUS_GT }]
  [oclExpression ::= oclExpression (*) EQ oclExpression , {EOF ENDPACKAGE CONTEXT INV DEF IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE DOT COLON UP UP_UP LEFT_PAR LEFT_BRK MINUS_GT }]
  [oclExpression ::= oclExpression (*) IMPLIES oclExpression , {EOF ENDPACKAGE CONTEXT INV DEF IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE DOT COLON UP UP_UP LEFT_PAR LEFT_BRK MINUS_GT }]
  [oclExpression ::= oclExpression (*) UP simpleName LEFT_PAR RIGHT_PAR , {EOF ENDPACKAGE CONTEXT INV DEF IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE DOT COLON UP UP_UP LEFT_PAR LEFT_BRK MINUS_GT }]
  [oclExpression ::= oclExpression (*) LEFT_PAR arguments RIGHT_PAR , {EOF ENDPACKAGE CONTEXT INV DEF IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE DOT COLON UP UP_UP LEFT_PAR LEFT_BRK MINUS_GT }]
  [oclExpression ::= oclExpression (*) MINUS_GT ITERATE LEFT_PAR variableDeclaration BAR oclExpression RIGHT_PAR , {EOF ENDPACKAGE CONTEXT INV DEF IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE DOT COLON UP UP_UP LEFT_PAR LEFT_BRK MINUS_GT }]
  [oclExpression ::= oclExpression (*) PLUS oclExpression , {EOF ENDPACKAGE CONTEXT INV DEF IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE DOT COLON UP UP_UP LEFT_PAR LEFT_BRK MINUS_GT }]
  [oclExpression ::= oclExpression (*) LE oclExpression , {EOF ENDPACKAGE CONTEXT INV DEF IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE DOT COLON UP UP_UP LEFT_PAR LEFT_BRK MINUS_GT }]
  [oclExpression ::= oclExpression (*) OR oclExpression , {EOF ENDPACKAGE CONTEXT INV DEF IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE DOT COLON UP UP_UP LEFT_PAR LEFT_BRK MINUS_GT }]
  [oclExpression ::= oclExpression (*) UP_UP simpleName LEFT_PAR RIGHT_PAR , {EOF ENDPACKAGE CONTEXT INV DEF IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE DOT COLON UP UP_UP LEFT_PAR LEFT_BRK MINUS_GT }]
  [oclExpression ::= oclExpression (*) MINUS_GT simpleName , {EOF ENDPACKAGE CONTEXT INV DEF IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE DOT COLON UP UP_UP LEFT_PAR LEFT_BRK MINUS_GT }]
  [oclExpression ::= oclExpression (*) TIMES oclExpression , {EOF ENDPACKAGE CONTEXT INV DEF IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE DOT COLON UP UP_UP LEFT_PAR LEFT_BRK MINUS_GT }]
  [oclExpression ::= oclExpression (*) LT oclExpression , {EOF ENDPACKAGE CONTEXT INV DEF IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE DOT COLON UP UP_UP LEFT_PAR LEFT_BRK MINUS_GT }]
  [oclExpression ::= oclExpression (*) NE oclExpression , {EOF ENDPACKAGE CONTEXT INV DEF IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE DOT COLON UP UP_UP LEFT_PAR LEFT_BRK MINUS_GT }]
  [oclExpression ::= oclExpression (*) LEFT_PAR variableDeclaration BAR oclExpression RIGHT_PAR , {EOF ENDPACKAGE CONTEXT INV DEF IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE DOT COLON UP UP_UP LEFT_PAR LEFT_BRK MINUS_GT }]
  [oclExpression ::= oclExpression (*) MINUS oclExpression , {EOF ENDPACKAGE CONTEXT INV DEF IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE DOT COLON UP UP_UP LEFT_PAR LEFT_BRK MINUS_GT }]
  [oclExpression ::= oclExpression (*) GE oclExpression , {EOF ENDPACKAGE CONTEXT INV DEF IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE DOT COLON UP UP_UP LEFT_PAR LEFT_BRK MINUS_GT }]
  [oclExpression ::= oclExpression (*) XOR oclExpression , {EOF ENDPACKAGE CONTEXT INV DEF IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE DOT COLON UP UP_UP LEFT_PAR LEFT_BRK MINUS_GT }]
  [oclExpression ::= oclExpression (*) UP simpleName LEFT_PAR oclMessageArgumentList RIGHT_PAR , {EOF ENDPACKAGE CONTEXT INV DEF IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE DOT COLON UP UP_UP LEFT_PAR LEFT_BRK MINUS_GT }]
  [oclExpression ::= oclExpression (*) DOT simpleName isMarkedPre , {EOF ENDPACKAGE CONTEXT INV DEF IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE DOT COLON UP UP_UP LEFT_PAR LEFT_BRK MINUS_GT }]
  [oclExpression ::= oclExpression (*) MINUS_GT ITERATE LEFT_PAR variableDeclaration SEMICOLON variableDeclaration BAR oclExpression RIGHT_PAR , {EOF ENDPACKAGE CONTEXT INV DEF IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE DOT COLON UP UP_UP LEFT_PAR LEFT_BRK MINUS_GT }]
  [oclExpression ::= oclExpression (*) DIVIDE oclExpression , {EOF ENDPACKAGE CONTEXT INV DEF IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE DOT COLON UP UP_UP LEFT_PAR LEFT_BRK MINUS_GT }]
  [oclExpression ::= oclExpression (*) GT oclExpression , {EOF ENDPACKAGE CONTEXT INV DEF IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE DOT COLON UP UP_UP LEFT_PAR LEFT_BRK MINUS_GT }]
  [oclExpression ::= oclExpression (*) AND oclExpression , {EOF ENDPACKAGE CONTEXT INV DEF IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE DOT COLON UP UP_UP LEFT_PAR LEFT_BRK MINUS_GT }]
  [oclExpression ::= oclExpression (*) UP_UP simpleName LEFT_PAR oclMessageArgumentList RIGHT_PAR , {EOF ENDPACKAGE CONTEXT INV DEF IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE DOT COLON UP UP_UP LEFT_PAR LEFT_BRK MINUS_GT }]
  [invOrDef ::= INV COLON oclExpression (*) , {EOF ENDPACKAGE CONTEXT INV DEF COLON }]
}
transition on XOR to state [74]
transition on EQ to state [73]
transition on DOT to state [72]
transition on MINUS to state [71]
transition on GE to state [70]
transition on LEFT_BRK to state [69]
transition on DIVIDE to state [68]
transition on LEFT_PAR to state [67]
transition on MINUS_GT to state [66]
transition on LE to state [65]
transition on GT to state [64]
transition on IMPLIES to state [63]
transition on UP to state [62]
transition on UP_UP to state [61]
transition on OR to state [60]
transition on PLUS to state [59]
transition on NE to state [58]
transition on LT to state [57]
transition on AND to state [56]
transition on TIMES to state [55]

-------------------
lalr_state [192]: {
  [oclExpression ::= (*) oclExpression UP simpleName LEFT_PAR oclMessageArgumentList RIGHT_PAR , {EOF ENDPACKAGE CONTEXT INV DEF IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE DOT COLON UP UP_UP LEFT_PAR LEFT_BRK MINUS_GT }]
  [oclExpression ::= (*) oclExpression EQ oclExpression , {EOF ENDPACKAGE CONTEXT INV DEF IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE DOT COLON UP UP_UP LEFT_PAR LEFT_BRK MINUS_GT }]
  [oclExpression ::= (*) oclExpression TIMES oclExpression , {EOF ENDPACKAGE CONTEXT INV DEF IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE DOT COLON UP UP_UP LEFT_PAR LEFT_BRK MINUS_GT }]
  [oclExpression ::= (*) oclExpression DOT simpleName isMarkedPre , {EOF ENDPACKAGE CONTEXT INV DEF IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE DOT COLON UP UP_UP LEFT_PAR LEFT_BRK MINUS_GT }]
  [invOrDef ::= INV simpleName COLON (*) oclExpression , {EOF ENDPACKAGE CONTEXT INV DEF COLON }]
  [primitiveLiteralExp ::= (*) TRUE , {EOF ENDPACKAGE CONTEXT INV DEF IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE DOT COLON UP UP_UP LEFT_PAR LEFT_BRK MINUS_GT }]
  [literalExp ::= (*) tupleLiteralExp , {EOF ENDPACKAGE CONTEXT INV DEF IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE DOT COLON UP UP_UP LEFT_PAR LEFT_BRK MINUS_GT }]
  [oclExpression ::= (*) oclExpression IMPLIES oclExpression , {EOF ENDPACKAGE CONTEXT INV DEF IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE DOT COLON UP UP_UP LEFT_PAR LEFT_BRK MINUS_GT }]
  [oclExpression ::= (*) oclExpression LT oclExpression , {EOF ENDPACKAGE CONTEXT INV DEF IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE DOT COLON UP UP_UP LEFT_PAR LEFT_BRK MINUS_GT }]
  [oclExpression ::= (*) oclExpression MINUS_GT ITERATE LEFT_PAR variableDeclaration SEMICOLON variableDeclaration BAR oclExpression RIGHT_PAR , {EOF ENDPACKAGE CONTEXT INV DEF IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE DOT COLON UP UP_UP LEFT_PAR LEFT_BRK MINUS_GT }]
  [tupleLiteralExp ::= (*) TUPLE LEFT_BRA variableDeclarationList RIGHT_BRA , {EOF ENDPACKAGE CONTEXT INV DEF IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE DOT COLON UP UP_UP LEFT_PAR LEFT_BRK MINUS_GT }]
  [collectionKind ::= (*) SET , {LEFT_BRA }]
  [oclExpression ::= (*) oclExpression UP simpleName LEFT_PAR RIGHT_PAR , {EOF ENDPACKAGE CONTEXT INV DEF IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE DOT COLON UP UP_UP LEFT_PAR LEFT_BRK MINUS_GT }]
  [oclExpression ::= (*) oclExpression NE oclExpression , {EOF ENDPACKAGE CONTEXT INV DEF IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE DOT COLON UP UP_UP LEFT_PAR LEFT_BRK MINUS_GT }]
  [oclExpression ::= (*) oclExpression DIVIDE oclExpression , {EOF ENDPACKAGE CONTEXT INV DEF IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE DOT COLON UP UP_UP LEFT_PAR LEFT_BRK MINUS_GT }]
  [oclExpression ::= (*) oclExpression LEFT_PAR arguments RIGHT_PAR , {EOF ENDPACKAGE CONTEXT INV DEF IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE DOT COLON UP UP_UP LEFT_PAR LEFT_BRK MINUS_GT }]
  [primitiveLiteralExp ::= (*) FALSE , {EOF ENDPACKAGE CONTEXT INV DEF IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE DOT COLON UP UP_UP LEFT_PAR LEFT_BRK MINUS_GT }]
  [literalExp ::= (*) primitiveLiteralExp , {EOF ENDPACKAGE CONTEXT INV DEF IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE DOT COLON UP UP_UP LEFT_PAR LEFT_BRK MINUS_GT }]
  [oclExpression ::= (*) LET variableDeclarationList IN oclExpression , {EOF ENDPACKAGE CONTEXT INV DEF IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE DOT COLON UP UP_UP LEFT_PAR LEFT_BRK MINUS_GT }]
  [oclExpression ::= (*) oclExpression GT oclExpression , {EOF ENDPACKAGE CONTEXT INV DEF IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE DOT COLON UP UP_UP LEFT_PAR LEFT_BRK MINUS_GT }]
  [oclExpression ::= (*) oclExpression MINUS_GT ITERATE LEFT_PAR variableDeclaration BAR oclExpression RIGHT_PAR , {EOF ENDPACKAGE CONTEXT INV DEF IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE DOT COLON UP UP_UP LEFT_PAR LEFT_BRK MINUS_GT }]
  [oclExpression ::= (*) literalExp , {EOF ENDPACKAGE CONTEXT INV DEF IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE DOT COLON UP UP_UP LEFT_PAR LEFT_BRK MINUS_GT }]
  [primitiveLiteralExp ::= (*) INTEGER , {EOF ENDPACKAGE CONTEXT INV DEF IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE DOT COLON UP UP_UP LEFT_PAR LEFT_BRK MINUS_GT }]
  [collectionKind ::= (*) BAG , {LEFT_BRA }]
  [oclExpression ::= (*) oclExpression AND oclExpression , {EOF ENDPACKAGE CONTEXT INV DEF IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE DOT COLON UP UP_UP LEFT_PAR LEFT_BRK MINUS_GT }]
  [oclExpression ::= (*) oclExpression PLUS oclExpression , {EOF ENDPACKAGE CONTEXT INV DEF IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE DOT COLON UP UP_UP LEFT_PAR LEFT_BRK MINUS_GT }]
  [oclExpression ::= (*) oclExpression LEFT_PAR variableDeclaration BAR oclExpression RIGHT_PAR , {EOF ENDPACKAGE CONTEXT INV DEF IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE DOT COLON UP UP_UP LEFT_PAR LEFT_BRK MINUS_GT }]
  [pathName ::= (*) simpleName , {EOF ENDPACKAGE CONTEXT INV DEF IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE DOT COLON UP AT COLON_COLON UP_UP LEFT_PAR LEFT_BRK MINUS_GT }]
  [oclExpression ::= (*) oclExpression UP_UP simpleName LEFT_PAR oclMessageArgumentList RIGHT_PAR , {EOF ENDPACKAGE CONTEXT INV DEF IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE DOT COLON UP UP_UP LEFT_PAR LEFT_BRK MINUS_GT }]
  [oclExpression ::= (*) oclExpression LE oclExpression , {EOF ENDPACKAGE CONTEXT INV DEF IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE DOT COLON UP UP_UP LEFT_PAR LEFT_BRK MINUS_GT }]
  [oclExpression ::= (*) NOT oclExpression , {EOF ENDPACKAGE CONTEXT INV DEF IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE DOT COLON UP UP_UP LEFT_PAR LEFT_BRK MINUS_GT }]
  [oclExpression ::= (*) LEFT_PAR oclExpression RIGHT_PAR , {EOF ENDPACKAGE CONTEXT INV DEF IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE DOT COLON UP UP_UP LEFT_PAR LEFT_BRK MINUS_GT }]
  [primitiveLiteralExp ::= (*) REAL , {EOF ENDPACKAGE CONTEXT INV DEF IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE DOT COLON UP UP_UP LEFT_PAR LEFT_BRK MINUS_GT }]
  [collectionKind ::= (*) SEQUENCE , {LEFT_BRA }]
  [oclExpression ::= (*) oclExpression OR oclExpression , {EOF ENDPACKAGE CONTEXT INV DEF IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE DOT COLON UP UP_UP LEFT_PAR LEFT_BRK MINUS_GT }]
  [oclExpression ::= (*) oclExpression MINUS oclExpression , {EOF ENDPACKAGE CONTEXT INV DEF IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE DOT COLON UP UP_UP LEFT_PAR LEFT_BRK MINUS_GT }]
  [oclExpression ::= (*) oclExpression LEFT_BRK argumentList RIGHT_BRK isMarkedPre , {EOF ENDPACKAGE CONTEXT INV DEF IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE DOT COLON UP UP_UP LEFT_PAR LEFT_BRK MINUS_GT }]
  [pathName ::= (*) pathName COLON_COLON simpleName , {EOF ENDPACKAGE CONTEXT INV DEF IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE DOT COLON UP AT COLON_COLON UP_UP LEFT_PAR LEFT_BRK MINUS_GT }]
  [collectionLiteralExp ::= (*) collectionKind LEFT_BRA collectionLiteralParts RIGHT_BRA , {EOF ENDPACKAGE CONTEXT INV DEF IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE DOT COLON UP UP_UP LEFT_PAR LEFT_BRK MINUS_GT }]
  [oclExpression ::= (*) oclExpression UP_UP simpleName LEFT_PAR RIGHT_PAR , {EOF ENDPACKAGE CONTEXT INV DEF IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE DOT COLON UP UP_UP LEFT_PAR LEFT_BRK MINUS_GT }]
  [oclExpression ::= (*) oclExpression GE oclExpression , {EOF ENDPACKAGE CONTEXT INV DEF IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE DOT COLON UP UP_UP LEFT_PAR LEFT_BRK MINUS_GT }]
  [oclExpression ::= (*) MINUS oclExpression , {EOF ENDPACKAGE CONTEXT INV DEF IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE DOT COLON UP UP_UP LEFT_PAR LEFT_BRK MINUS_GT }]
  [oclExpression ::= (*) pathName isMarkedPre , {EOF ENDPACKAGE CONTEXT INV DEF IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE DOT COLON UP UP_UP LEFT_PAR LEFT_BRK MINUS_GT }]
  [primitiveLiteralExp ::= (*) STRING , {EOF ENDPACKAGE CONTEXT INV DEF IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE DOT COLON UP UP_UP LEFT_PAR LEFT_BRK MINUS_GT }]
  [collectionKind ::= (*) COLLECTION , {LEFT_BRA }]
  [literalExp ::= (*) collectionLiteralExp , {EOF ENDPACKAGE CONTEXT INV DEF IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE DOT COLON UP UP_UP LEFT_PAR LEFT_BRK MINUS_GT }]
  [oclExpression ::= (*) oclExpression XOR oclExpression , {EOF ENDPACKAGE CONTEXT INV DEF IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE DOT COLON UP UP_UP LEFT_PAR LEFT_BRK MINUS_GT }]
  [oclExpression ::= (*) IF oclExpression THEN oclExpression ELSE oclExpression ENDIF , {EOF ENDPACKAGE CONTEXT INV DEF IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE DOT COLON UP UP_UP LEFT_PAR LEFT_BRK MINUS_GT }]
  [oclExpression ::= (*) oclExpression MINUS_GT simpleName , {EOF ENDPACKAGE CONTEXT INV DEF IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE DOT COLON UP UP_UP LEFT_PAR LEFT_BRK MINUS_GT }]
  [simpleName ::= (*) SIMPLE_NAME , {EOF ENDPACKAGE CONTEXT INV DEF IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE DOT COLON UP AT COLON_COLON UP_UP LEFT_PAR LEFT_BRK MINUS_GT }]
  [collectionLiteralExp ::= (*) collectionKind LEFT_BRA RIGHT_BRA , {EOF ENDPACKAGE CONTEXT INV DEF IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE DOT COLON UP UP_UP LEFT_PAR LEFT_BRK MINUS_GT }]
}
transition on tupleLiteralExp to state [54]
transition on oclExpression to state [193]
transition on REAL to state [52]
transition on INTEGER to state [51]
transition on pathName to state [50]
transition on SIMPLE_NAME to state [12]
transition on LET to state [49]
transition on FALSE to state [48]
transition on MINUS to state [47]
transition on COLLECTION to state [28]
transition on SET to state [20]
transition on simpleName to state [26]
transition on collectionLiteralExp to state [46]
transition on LEFT_PAR to state [45]
transition on STRING to state [44]
transition on IF to state [43]
transition on TRUE to state [42]
transition on collectionKind to state [41]
transition on NOT to state [40]
transition on primitiveLiteralExp to state [39]
transition on TUPLE to state [38]
transition on literalExp to state [37]
transition on BAG to state [25]
transition on SEQUENCE to state [22]

-------------------
lalr_state [193]: {
  [oclExpression ::= oclExpression (*) LEFT_BRK argumentList RIGHT_BRK isMarkedPre , {EOF ENDPACKAGE CONTEXT INV DEF IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE DOT COLON UP UP_UP LEFT_PAR LEFT_BRK MINUS_GT }]
  [oclExpression ::= oclExpression (*) EQ oclExpression , {EOF ENDPACKAGE CONTEXT INV DEF IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE DOT COLON UP UP_UP LEFT_PAR LEFT_BRK MINUS_GT }]
  [oclExpression ::= oclExpression (*) IMPLIES oclExpression , {EOF ENDPACKAGE CONTEXT INV DEF IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE DOT COLON UP UP_UP LEFT_PAR LEFT_BRK MINUS_GT }]
  [oclExpression ::= oclExpression (*) UP simpleName LEFT_PAR RIGHT_PAR , {EOF ENDPACKAGE CONTEXT INV DEF IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE DOT COLON UP UP_UP LEFT_PAR LEFT_BRK MINUS_GT }]
  [oclExpression ::= oclExpression (*) LEFT_PAR arguments RIGHT_PAR , {EOF ENDPACKAGE CONTEXT INV DEF IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE DOT COLON UP UP_UP LEFT_PAR LEFT_BRK MINUS_GT }]
  [oclExpression ::= oclExpression (*) MINUS_GT ITERATE LEFT_PAR variableDeclaration BAR oclExpression RIGHT_PAR , {EOF ENDPACKAGE CONTEXT INV DEF IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE DOT COLON UP UP_UP LEFT_PAR LEFT_BRK MINUS_GT }]
  [oclExpression ::= oclExpression (*) PLUS oclExpression , {EOF ENDPACKAGE CONTEXT INV DEF IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE DOT COLON UP UP_UP LEFT_PAR LEFT_BRK MINUS_GT }]
  [oclExpression ::= oclExpression (*) LE oclExpression , {EOF ENDPACKAGE CONTEXT INV DEF IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE DOT COLON UP UP_UP LEFT_PAR LEFT_BRK MINUS_GT }]
  [oclExpression ::= oclExpression (*) OR oclExpression , {EOF ENDPACKAGE CONTEXT INV DEF IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE DOT COLON UP UP_UP LEFT_PAR LEFT_BRK MINUS_GT }]
  [oclExpression ::= oclExpression (*) UP_UP simpleName LEFT_PAR RIGHT_PAR , {EOF ENDPACKAGE CONTEXT INV DEF IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE DOT COLON UP UP_UP LEFT_PAR LEFT_BRK MINUS_GT }]
  [oclExpression ::= oclExpression (*) MINUS_GT simpleName , {EOF ENDPACKAGE CONTEXT INV DEF IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE DOT COLON UP UP_UP LEFT_PAR LEFT_BRK MINUS_GT }]
  [oclExpression ::= oclExpression (*) TIMES oclExpression , {EOF ENDPACKAGE CONTEXT INV DEF IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE DOT COLON UP UP_UP LEFT_PAR LEFT_BRK MINUS_GT }]
  [oclExpression ::= oclExpression (*) LT oclExpression , {EOF ENDPACKAGE CONTEXT INV DEF IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE DOT COLON UP UP_UP LEFT_PAR LEFT_BRK MINUS_GT }]
  [oclExpression ::= oclExpression (*) NE oclExpression , {EOF ENDPACKAGE CONTEXT INV DEF IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE DOT COLON UP UP_UP LEFT_PAR LEFT_BRK MINUS_GT }]
  [invOrDef ::= INV simpleName COLON oclExpression (*) , {EOF ENDPACKAGE CONTEXT INV DEF COLON }]
  [oclExpression ::= oclExpression (*) LEFT_PAR variableDeclaration BAR oclExpression RIGHT_PAR , {EOF ENDPACKAGE CONTEXT INV DEF IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE DOT COLON UP UP_UP LEFT_PAR LEFT_BRK MINUS_GT }]
  [oclExpression ::= oclExpression (*) MINUS oclExpression , {EOF ENDPACKAGE CONTEXT INV DEF IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE DOT COLON UP UP_UP LEFT_PAR LEFT_BRK MINUS_GT }]
  [oclExpression ::= oclExpression (*) GE oclExpression , {EOF ENDPACKAGE CONTEXT INV DEF IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE DOT COLON UP UP_UP LEFT_PAR LEFT_BRK MINUS_GT }]
  [oclExpression ::= oclExpression (*) XOR oclExpression , {EOF ENDPACKAGE CONTEXT INV DEF IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE DOT COLON UP UP_UP LEFT_PAR LEFT_BRK MINUS_GT }]
  [oclExpression ::= oclExpression (*) UP simpleName LEFT_PAR oclMessageArgumentList RIGHT_PAR , {EOF ENDPACKAGE CONTEXT INV DEF IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE DOT COLON UP UP_UP LEFT_PAR LEFT_BRK MINUS_GT }]
  [oclExpression ::= oclExpression (*) DOT simpleName isMarkedPre , {EOF ENDPACKAGE CONTEXT INV DEF IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE DOT COLON UP UP_UP LEFT_PAR LEFT_BRK MINUS_GT }]
  [oclExpression ::= oclExpression (*) MINUS_GT ITERATE LEFT_PAR variableDeclaration SEMICOLON variableDeclaration BAR oclExpression RIGHT_PAR , {EOF ENDPACKAGE CONTEXT INV DEF IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE DOT COLON UP UP_UP LEFT_PAR LEFT_BRK MINUS_GT }]
  [oclExpression ::= oclExpression (*) DIVIDE oclExpression , {EOF ENDPACKAGE CONTEXT INV DEF IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE DOT COLON UP UP_UP LEFT_PAR LEFT_BRK MINUS_GT }]
  [oclExpression ::= oclExpression (*) GT oclExpression , {EOF ENDPACKAGE CONTEXT INV DEF IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE DOT COLON UP UP_UP LEFT_PAR LEFT_BRK MINUS_GT }]
  [oclExpression ::= oclExpression (*) AND oclExpression , {EOF ENDPACKAGE CONTEXT INV DEF IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE DOT COLON UP UP_UP LEFT_PAR LEFT_BRK MINUS_GT }]
  [oclExpression ::= oclExpression (*) UP_UP simpleName LEFT_PAR oclMessageArgumentList RIGHT_PAR , {EOF ENDPACKAGE CONTEXT INV DEF IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE DOT COLON UP UP_UP LEFT_PAR LEFT_BRK MINUS_GT }]
}
transition on XOR to state [74]
transition on EQ to state [73]
transition on DOT to state [72]
transition on MINUS to state [71]
transition on GE to state [70]
transition on LEFT_BRK to state [69]
transition on DIVIDE to state [68]
transition on LEFT_PAR to state [67]
transition on MINUS_GT to state [66]
transition on LE to state [65]
transition on GT to state [64]
transition on IMPLIES to state [63]
transition on UP to state [62]
transition on UP_UP to state [61]
transition on OR to state [60]
transition on PLUS to state [59]
transition on NE to state [58]
transition on LT to state [57]
transition on AND to state [56]
transition on TIMES to state [55]

-------------------
lalr_state [194]: {
  [propertyContextDecl ::= CONTEXT pathName simpleName COLON (*) type initOrDerValue , {EOF ENDPACKAGE CONTEXT }]
  [collectionKind ::= (*) BAG , {LEFT_PAR }]
  [collectionType ::= (*) collectionKind LEFT_PAR type RIGHT_PAR , {INIT DERIVE }]
  [pathName ::= (*) simpleName , {INIT DERIVE COLON_COLON }]
  [type ::= (*) pathName , {INIT DERIVE }]
  [collectionKind ::= (*) COLLECTION , {LEFT_PAR }]
  [collectionKind ::= (*) SET , {LEFT_PAR }]
  [simpleName ::= (*) SIMPLE_NAME , {INIT DERIVE COLON_COLON }]
  [type ::= (*) tupleType , {INIT DERIVE }]
  [collectionKind ::= (*) SEQUENCE , {LEFT_PAR }]
  [tupleType ::= (*) TUPLE_TYPE LEFT_PAR variableDeclarationList RIGHT_PAR , {INIT DERIVE }]
  [pathName ::= (*) pathName COLON_COLON simpleName , {INIT DERIVE COLON_COLON }]
  [type ::= (*) collectionType , {INIT DERIVE }]
}
transition on collectionType to state [30]
transition on TUPLE_TYPE to state [29]
transition on COLLECTION to state [28]
transition on type to state [195]
transition on simpleName to state [26]
transition on BAG to state [25]
transition on collectionKind to state [24]
transition on pathName to state [23]
transition on SEQUENCE to state [22]
transition on tupleType to state [21]
transition on SET to state [20]
transition on SIMPLE_NAME to state [12]

-------------------
lalr_state [195]: {
  [initOrDerValue ::= (*) DERIVE COLON oclExpression , {EOF ENDPACKAGE CONTEXT INIT DERIVE }]
  [initOrDerValue ::= (*) initOrDerValue DERIVE COLON oclExpression , {EOF ENDPACKAGE CONTEXT INIT DERIVE }]
  [propertyContextDecl ::= CONTEXT pathName simpleName COLON type (*) initOrDerValue , {EOF ENDPACKAGE CONTEXT }]
  [initOrDerValue ::= (*) INIT COLON oclExpression , {EOF ENDPACKAGE CONTEXT INIT DERIVE }]
  [initOrDerValue ::= (*) initOrDerValue INIT COLON oclExpression , {EOF ENDPACKAGE CONTEXT INIT DERIVE }]
}
transition on DERIVE to state [198]
transition on initOrDerValue to state [197]
transition on INIT to state [196]

-------------------
lalr_state [196]: {
  [initOrDerValue ::= INIT (*) COLON oclExpression , {EOF ENDPACKAGE CONTEXT INIT DERIVE }]
}
transition on COLON to state [207]

-------------------
lalr_state [197]: {
  [propertyContextDecl ::= CONTEXT pathName simpleName COLON type initOrDerValue (*) , {EOF ENDPACKAGE CONTEXT }]
  [initOrDerValue ::= initOrDerValue (*) DERIVE COLON oclExpression , {EOF ENDPACKAGE CONTEXT INIT DERIVE }]
  [initOrDerValue ::= initOrDerValue (*) INIT COLON oclExpression , {EOF ENDPACKAGE CONTEXT INIT DERIVE }]
}
transition on DERIVE to state [202]
transition on INIT to state [201]

-------------------
lalr_state [198]: {
  [initOrDerValue ::= DERIVE (*) COLON oclExpression , {EOF ENDPACKAGE CONTEXT INIT DERIVE }]
}
transition on COLON to state [199]

-------------------
lalr_state [199]: {
  [oclExpression ::= (*) oclExpression UP simpleName LEFT_PAR oclMessageArgumentList RIGHT_PAR , {EOF ENDPACKAGE CONTEXT INIT DERIVE IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE DOT UP UP_UP LEFT_PAR LEFT_BRK MINUS_GT }]
  [oclExpression ::= (*) oclExpression EQ oclExpression , {EOF ENDPACKAGE CONTEXT INIT DERIVE IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE DOT UP UP_UP LEFT_PAR LEFT_BRK MINUS_GT }]
  [oclExpression ::= (*) oclExpression TIMES oclExpression , {EOF ENDPACKAGE CONTEXT INIT DERIVE IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE DOT UP UP_UP LEFT_PAR LEFT_BRK MINUS_GT }]
  [oclExpression ::= (*) oclExpression DOT simpleName isMarkedPre , {EOF ENDPACKAGE CONTEXT INIT DERIVE IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE DOT UP UP_UP LEFT_PAR LEFT_BRK MINUS_GT }]
  [primitiveLiteralExp ::= (*) TRUE , {EOF ENDPACKAGE CONTEXT INIT DERIVE IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE DOT UP UP_UP LEFT_PAR LEFT_BRK MINUS_GT }]
  [literalExp ::= (*) tupleLiteralExp , {EOF ENDPACKAGE CONTEXT INIT DERIVE IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE DOT UP UP_UP LEFT_PAR LEFT_BRK MINUS_GT }]
  [oclExpression ::= (*) oclExpression IMPLIES oclExpression , {EOF ENDPACKAGE CONTEXT INIT DERIVE IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE DOT UP UP_UP LEFT_PAR LEFT_BRK MINUS_GT }]
  [oclExpression ::= (*) oclExpression LT oclExpression , {EOF ENDPACKAGE CONTEXT INIT DERIVE IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE DOT UP UP_UP LEFT_PAR LEFT_BRK MINUS_GT }]
  [oclExpression ::= (*) oclExpression MINUS_GT ITERATE LEFT_PAR variableDeclaration SEMICOLON variableDeclaration BAR oclExpression RIGHT_PAR , {EOF ENDPACKAGE CONTEXT INIT DERIVE IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE DOT UP UP_UP LEFT_PAR LEFT_BRK MINUS_GT }]
  [initOrDerValue ::= DERIVE COLON (*) oclExpression , {EOF ENDPACKAGE CONTEXT INIT DERIVE }]
  [tupleLiteralExp ::= (*) TUPLE LEFT_BRA variableDeclarationList RIGHT_BRA , {EOF ENDPACKAGE CONTEXT INIT DERIVE IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE DOT UP UP_UP LEFT_PAR LEFT_BRK MINUS_GT }]
  [collectionKind ::= (*) SET , {LEFT_BRA }]
  [oclExpression ::= (*) oclExpression UP simpleName LEFT_PAR RIGHT_PAR , {EOF ENDPACKAGE CONTEXT INIT DERIVE IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE DOT UP UP_UP LEFT_PAR LEFT_BRK MINUS_GT }]
  [oclExpression ::= (*) oclExpression NE oclExpression , {EOF ENDPACKAGE CONTEXT INIT DERIVE IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE DOT UP UP_UP LEFT_PAR LEFT_BRK MINUS_GT }]
  [oclExpression ::= (*) oclExpression DIVIDE oclExpression , {EOF ENDPACKAGE CONTEXT INIT DERIVE IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE DOT UP UP_UP LEFT_PAR LEFT_BRK MINUS_GT }]
  [oclExpression ::= (*) oclExpression LEFT_PAR arguments RIGHT_PAR , {EOF ENDPACKAGE CONTEXT INIT DERIVE IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE DOT UP UP_UP LEFT_PAR LEFT_BRK MINUS_GT }]
  [primitiveLiteralExp ::= (*) FALSE , {EOF ENDPACKAGE CONTEXT INIT DERIVE IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE DOT UP UP_UP LEFT_PAR LEFT_BRK MINUS_GT }]
  [literalExp ::= (*) primitiveLiteralExp , {EOF ENDPACKAGE CONTEXT INIT DERIVE IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE DOT UP UP_UP LEFT_PAR LEFT_BRK MINUS_GT }]
  [oclExpression ::= (*) LET variableDeclarationList IN oclExpression , {EOF ENDPACKAGE CONTEXT INIT DERIVE IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE DOT UP UP_UP LEFT_PAR LEFT_BRK MINUS_GT }]
  [oclExpression ::= (*) oclExpression GT oclExpression , {EOF ENDPACKAGE CONTEXT INIT DERIVE IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE DOT UP UP_UP LEFT_PAR LEFT_BRK MINUS_GT }]
  [oclExpression ::= (*) oclExpression MINUS_GT ITERATE LEFT_PAR variableDeclaration BAR oclExpression RIGHT_PAR , {EOF ENDPACKAGE CONTEXT INIT DERIVE IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE DOT UP UP_UP LEFT_PAR LEFT_BRK MINUS_GT }]
  [oclExpression ::= (*) literalExp , {EOF ENDPACKAGE CONTEXT INIT DERIVE IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE DOT UP UP_UP LEFT_PAR LEFT_BRK MINUS_GT }]
  [primitiveLiteralExp ::= (*) INTEGER , {EOF ENDPACKAGE CONTEXT INIT DERIVE IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE DOT UP UP_UP LEFT_PAR LEFT_BRK MINUS_GT }]
  [collectionKind ::= (*) BAG , {LEFT_BRA }]
  [oclExpression ::= (*) oclExpression AND oclExpression , {EOF ENDPACKAGE CONTEXT INIT DERIVE IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE DOT UP UP_UP LEFT_PAR LEFT_BRK MINUS_GT }]
  [oclExpression ::= (*) oclExpression PLUS oclExpression , {EOF ENDPACKAGE CONTEXT INIT DERIVE IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE DOT UP UP_UP LEFT_PAR LEFT_BRK MINUS_GT }]
  [oclExpression ::= (*) oclExpression LEFT_PAR variableDeclaration BAR oclExpression RIGHT_PAR , {EOF ENDPACKAGE CONTEXT INIT DERIVE IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE DOT UP UP_UP LEFT_PAR LEFT_BRK MINUS_GT }]
  [pathName ::= (*) simpleName , {EOF ENDPACKAGE CONTEXT INIT DERIVE IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE DOT UP AT COLON_COLON UP_UP LEFT_PAR LEFT_BRK MINUS_GT }]
  [oclExpression ::= (*) oclExpression UP_UP simpleName LEFT_PAR oclMessageArgumentList RIGHT_PAR , {EOF ENDPACKAGE CONTEXT INIT DERIVE IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE DOT UP UP_UP LEFT_PAR LEFT_BRK MINUS_GT }]
  [oclExpression ::= (*) oclExpression LE oclExpression , {EOF ENDPACKAGE CONTEXT INIT DERIVE IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE DOT UP UP_UP LEFT_PAR LEFT_BRK MINUS_GT }]
  [oclExpression ::= (*) NOT oclExpression , {EOF ENDPACKAGE CONTEXT INIT DERIVE IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE DOT UP UP_UP LEFT_PAR LEFT_BRK MINUS_GT }]
  [oclExpression ::= (*) LEFT_PAR oclExpression RIGHT_PAR , {EOF ENDPACKAGE CONTEXT INIT DERIVE IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE DOT UP UP_UP LEFT_PAR LEFT_BRK MINUS_GT }]
  [primitiveLiteralExp ::= (*) REAL , {EOF ENDPACKAGE CONTEXT INIT DERIVE IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE DOT UP UP_UP LEFT_PAR LEFT_BRK MINUS_GT }]
  [collectionKind ::= (*) SEQUENCE , {LEFT_BRA }]
  [oclExpression ::= (*) oclExpression OR oclExpression , {EOF ENDPACKAGE CONTEXT INIT DERIVE IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE DOT UP UP_UP LEFT_PAR LEFT_BRK MINUS_GT }]
  [oclExpression ::= (*) oclExpression MINUS oclExpression , {EOF ENDPACKAGE CONTEXT INIT DERIVE IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE DOT UP UP_UP LEFT_PAR LEFT_BRK MINUS_GT }]
  [oclExpression ::= (*) oclExpression LEFT_BRK argumentList RIGHT_BRK isMarkedPre , {EOF ENDPACKAGE CONTEXT INIT DERIVE IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE DOT UP UP_UP LEFT_PAR LEFT_BRK MINUS_GT }]
  [pathName ::= (*) pathName COLON_COLON simpleName , {EOF ENDPACKAGE CONTEXT INIT DERIVE IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE DOT UP AT COLON_COLON UP_UP LEFT_PAR LEFT_BRK MINUS_GT }]
  [collectionLiteralExp ::= (*) collectionKind LEFT_BRA collectionLiteralParts RIGHT_BRA , {EOF ENDPACKAGE CONTEXT INIT DERIVE IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE DOT UP UP_UP LEFT_PAR LEFT_BRK MINUS_GT }]
  [oclExpression ::= (*) oclExpression UP_UP simpleName LEFT_PAR RIGHT_PAR , {EOF ENDPACKAGE CONTEXT INIT DERIVE IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE DOT UP UP_UP LEFT_PAR LEFT_BRK MINUS_GT }]
  [oclExpression ::= (*) oclExpression GE oclExpression , {EOF ENDPACKAGE CONTEXT INIT DERIVE IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE DOT UP UP_UP LEFT_PAR LEFT_BRK MINUS_GT }]
  [oclExpression ::= (*) MINUS oclExpression , {EOF ENDPACKAGE CONTEXT INIT DERIVE IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE DOT UP UP_UP LEFT_PAR LEFT_BRK MINUS_GT }]
  [oclExpression ::= (*) pathName isMarkedPre , {EOF ENDPACKAGE CONTEXT INIT DERIVE IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE DOT UP UP_UP LEFT_PAR LEFT_BRK MINUS_GT }]
  [primitiveLiteralExp ::= (*) STRING , {EOF ENDPACKAGE CONTEXT INIT DERIVE IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE DOT UP UP_UP LEFT_PAR LEFT_BRK MINUS_GT }]
  [collectionKind ::= (*) COLLECTION , {LEFT_BRA }]
  [literalExp ::= (*) collectionLiteralExp , {EOF ENDPACKAGE CONTEXT INIT DERIVE IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE DOT UP UP_UP LEFT_PAR LEFT_BRK MINUS_GT }]
  [oclExpression ::= (*) oclExpression XOR oclExpression , {EOF ENDPACKAGE CONTEXT INIT DERIVE IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE DOT UP UP_UP LEFT_PAR LEFT_BRK MINUS_GT }]
  [oclExpression ::= (*) IF oclExpression THEN oclExpression ELSE oclExpression ENDIF , {EOF ENDPACKAGE CONTEXT INIT DERIVE IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE DOT UP UP_UP LEFT_PAR LEFT_BRK MINUS_GT }]
  [oclExpression ::= (*) oclExpression MINUS_GT simpleName , {EOF ENDPACKAGE CONTEXT INIT DERIVE IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE DOT UP UP_UP LEFT_PAR LEFT_BRK MINUS_GT }]
  [simpleName ::= (*) SIMPLE_NAME , {EOF ENDPACKAGE CONTEXT INIT DERIVE IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE DOT UP AT COLON_COLON UP_UP LEFT_PAR LEFT_BRK MINUS_GT }]
  [collectionLiteralExp ::= (*) collectionKind LEFT_BRA RIGHT_BRA , {EOF ENDPACKAGE CONTEXT INIT DERIVE IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE DOT UP UP_UP LEFT_PAR LEFT_BRK MINUS_GT }]
}
transition on tupleLiteralExp to state [54]
transition on oclExpression to state [200]
transition on REAL to state [52]
transition on INTEGER to state [51]
transition on pathName to state [50]
transition on SIMPLE_NAME to state [12]
transition on LET to state [49]
transition on FALSE to state [48]
transition on MINUS to state [47]
transition on COLLECTION to state [28]
transition on SET to state [20]
transition on simpleName to state [26]
transition on collectionLiteralExp to state [46]
transition on LEFT_PAR to state [45]
transition on STRING to state [44]
transition on IF to state [43]
transition on TRUE to state [42]
transition on collectionKind to state [41]
transition on NOT to state [40]
transition on primitiveLiteralExp to state [39]
transition on TUPLE to state [38]
transition on literalExp to state [37]
transition on BAG to state [25]
transition on SEQUENCE to state [22]

-------------------
lalr_state [200]: {
  [oclExpression ::= oclExpression (*) LEFT_BRK argumentList RIGHT_BRK isMarkedPre , {EOF ENDPACKAGE CONTEXT INIT DERIVE IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE DOT UP UP_UP LEFT_PAR LEFT_BRK MINUS_GT }]
  [oclExpression ::= oclExpression (*) EQ oclExpression , {EOF ENDPACKAGE CONTEXT INIT DERIVE IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE DOT UP UP_UP LEFT_PAR LEFT_BRK MINUS_GT }]
  [oclExpression ::= oclExpression (*) IMPLIES oclExpression , {EOF ENDPACKAGE CONTEXT INIT DERIVE IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE DOT UP UP_UP LEFT_PAR LEFT_BRK MINUS_GT }]
  [oclExpression ::= oclExpression (*) UP simpleName LEFT_PAR RIGHT_PAR , {EOF ENDPACKAGE CONTEXT INIT DERIVE IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE DOT UP UP_UP LEFT_PAR LEFT_BRK MINUS_GT }]
  [oclExpression ::= oclExpression (*) LEFT_PAR arguments RIGHT_PAR , {EOF ENDPACKAGE CONTEXT INIT DERIVE IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE DOT UP UP_UP LEFT_PAR LEFT_BRK MINUS_GT }]
  [oclExpression ::= oclExpression (*) MINUS_GT ITERATE LEFT_PAR variableDeclaration BAR oclExpression RIGHT_PAR , {EOF ENDPACKAGE CONTEXT INIT DERIVE IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE DOT UP UP_UP LEFT_PAR LEFT_BRK MINUS_GT }]
  [oclExpression ::= oclExpression (*) PLUS oclExpression , {EOF ENDPACKAGE CONTEXT INIT DERIVE IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE DOT UP UP_UP LEFT_PAR LEFT_BRK MINUS_GT }]
  [oclExpression ::= oclExpression (*) LE oclExpression , {EOF ENDPACKAGE CONTEXT INIT DERIVE IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE DOT UP UP_UP LEFT_PAR LEFT_BRK MINUS_GT }]
  [oclExpression ::= oclExpression (*) OR oclExpression , {EOF ENDPACKAGE CONTEXT INIT DERIVE IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE DOT UP UP_UP LEFT_PAR LEFT_BRK MINUS_GT }]
  [oclExpression ::= oclExpression (*) UP_UP simpleName LEFT_PAR RIGHT_PAR , {EOF ENDPACKAGE CONTEXT INIT DERIVE IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE DOT UP UP_UP LEFT_PAR LEFT_BRK MINUS_GT }]
  [oclExpression ::= oclExpression (*) MINUS_GT simpleName , {EOF ENDPACKAGE CONTEXT INIT DERIVE IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE DOT UP UP_UP LEFT_PAR LEFT_BRK MINUS_GT }]
  [oclExpression ::= oclExpression (*) TIMES oclExpression , {EOF ENDPACKAGE CONTEXT INIT DERIVE IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE DOT UP UP_UP LEFT_PAR LEFT_BRK MINUS_GT }]
  [oclExpression ::= oclExpression (*) LT oclExpression , {EOF ENDPACKAGE CONTEXT INIT DERIVE IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE DOT UP UP_UP LEFT_PAR LEFT_BRK MINUS_GT }]
  [oclExpression ::= oclExpression (*) NE oclExpression , {EOF ENDPACKAGE CONTEXT INIT DERIVE IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE DOT UP UP_UP LEFT_PAR LEFT_BRK MINUS_GT }]
  [oclExpression ::= oclExpression (*) LEFT_PAR variableDeclaration BAR oclExpression RIGHT_PAR , {EOF ENDPACKAGE CONTEXT INIT DERIVE IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE DOT UP UP_UP LEFT_PAR LEFT_BRK MINUS_GT }]
  [oclExpression ::= oclExpression (*) MINUS oclExpression , {EOF ENDPACKAGE CONTEXT INIT DERIVE IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE DOT UP UP_UP LEFT_PAR LEFT_BRK MINUS_GT }]
  [oclExpression ::= oclExpression (*) GE oclExpression , {EOF ENDPACKAGE CONTEXT INIT DERIVE IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE DOT UP UP_UP LEFT_PAR LEFT_BRK MINUS_GT }]
  [oclExpression ::= oclExpression (*) XOR oclExpression , {EOF ENDPACKAGE CONTEXT INIT DERIVE IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE DOT UP UP_UP LEFT_PAR LEFT_BRK MINUS_GT }]
  [oclExpression ::= oclExpression (*) UP simpleName LEFT_PAR oclMessageArgumentList RIGHT_PAR , {EOF ENDPACKAGE CONTEXT INIT DERIVE IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE DOT UP UP_UP LEFT_PAR LEFT_BRK MINUS_GT }]
  [oclExpression ::= oclExpression (*) DOT simpleName isMarkedPre , {EOF ENDPACKAGE CONTEXT INIT DERIVE IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE DOT UP UP_UP LEFT_PAR LEFT_BRK MINUS_GT }]
  [oclExpression ::= oclExpression (*) MINUS_GT ITERATE LEFT_PAR variableDeclaration SEMICOLON variableDeclaration BAR oclExpression RIGHT_PAR , {EOF ENDPACKAGE CONTEXT INIT DERIVE IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE DOT UP UP_UP LEFT_PAR LEFT_BRK MINUS_GT }]
  [oclExpression ::= oclExpression (*) DIVIDE oclExpression , {EOF ENDPACKAGE CONTEXT INIT DERIVE IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE DOT UP UP_UP LEFT_PAR LEFT_BRK MINUS_GT }]
  [oclExpression ::= oclExpression (*) GT oclExpression , {EOF ENDPACKAGE CONTEXT INIT DERIVE IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE DOT UP UP_UP LEFT_PAR LEFT_BRK MINUS_GT }]
  [oclExpression ::= oclExpression (*) AND oclExpression , {EOF ENDPACKAGE CONTEXT INIT DERIVE IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE DOT UP UP_UP LEFT_PAR LEFT_BRK MINUS_GT }]
  [oclExpression ::= oclExpression (*) UP_UP simpleName LEFT_PAR oclMessageArgumentList RIGHT_PAR , {EOF ENDPACKAGE CONTEXT INIT DERIVE IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE DOT UP UP_UP LEFT_PAR LEFT_BRK MINUS_GT }]
  [initOrDerValue ::= DERIVE COLON oclExpression (*) , {EOF ENDPACKAGE CONTEXT INIT DERIVE }]
}
transition on XOR to state [74]
transition on EQ to state [73]
transition on DOT to state [72]
transition on MINUS to state [71]
transition on GE to state [70]
transition on LEFT_BRK to state [69]
transition on DIVIDE to state [68]
transition on LEFT_PAR to state [67]
transition on MINUS_GT to state [66]
transition on LE to state [65]
transition on GT to state [64]
transition on IMPLIES to state [63]
transition on UP to state [62]
transition on UP_UP to state [61]
transition on OR to state [60]
transition on PLUS to state [59]
transition on NE to state [58]
transition on LT to state [57]
transition on AND to state [56]
transition on TIMES to state [55]

-------------------
lalr_state [201]: {
  [initOrDerValue ::= initOrDerValue INIT (*) COLON oclExpression , {EOF ENDPACKAGE CONTEXT INIT DERIVE }]
}
transition on COLON to state [205]

-------------------
lalr_state [202]: {
  [initOrDerValue ::= initOrDerValue DERIVE (*) COLON oclExpression , {EOF ENDPACKAGE CONTEXT INIT DERIVE }]
}
transition on COLON to state [203]

-------------------
lalr_state [203]: {
  [oclExpression ::= (*) oclExpression UP simpleName LEFT_PAR oclMessageArgumentList RIGHT_PAR , {EOF ENDPACKAGE CONTEXT INIT DERIVE IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE DOT UP UP_UP LEFT_PAR LEFT_BRK MINUS_GT }]
  [oclExpression ::= (*) oclExpression EQ oclExpression , {EOF ENDPACKAGE CONTEXT INIT DERIVE IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE DOT UP UP_UP LEFT_PAR LEFT_BRK MINUS_GT }]
  [oclExpression ::= (*) oclExpression TIMES oclExpression , {EOF ENDPACKAGE CONTEXT INIT DERIVE IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE DOT UP UP_UP LEFT_PAR LEFT_BRK MINUS_GT }]
  [oclExpression ::= (*) oclExpression DOT simpleName isMarkedPre , {EOF ENDPACKAGE CONTEXT INIT DERIVE IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE DOT UP UP_UP LEFT_PAR LEFT_BRK MINUS_GT }]
  [primitiveLiteralExp ::= (*) TRUE , {EOF ENDPACKAGE CONTEXT INIT DERIVE IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE DOT UP UP_UP LEFT_PAR LEFT_BRK MINUS_GT }]
  [literalExp ::= (*) tupleLiteralExp , {EOF ENDPACKAGE CONTEXT INIT DERIVE IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE DOT UP UP_UP LEFT_PAR LEFT_BRK MINUS_GT }]
  [oclExpression ::= (*) oclExpression IMPLIES oclExpression , {EOF ENDPACKAGE CONTEXT INIT DERIVE IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE DOT UP UP_UP LEFT_PAR LEFT_BRK MINUS_GT }]
  [oclExpression ::= (*) oclExpression LT oclExpression , {EOF ENDPACKAGE CONTEXT INIT DERIVE IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE DOT UP UP_UP LEFT_PAR LEFT_BRK MINUS_GT }]
  [oclExpression ::= (*) oclExpression MINUS_GT ITERATE LEFT_PAR variableDeclaration SEMICOLON variableDeclaration BAR oclExpression RIGHT_PAR , {EOF ENDPACKAGE CONTEXT INIT DERIVE IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE DOT UP UP_UP LEFT_PAR LEFT_BRK MINUS_GT }]
  [tupleLiteralExp ::= (*) TUPLE LEFT_BRA variableDeclarationList RIGHT_BRA , {EOF ENDPACKAGE CONTEXT INIT DERIVE IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE DOT UP UP_UP LEFT_PAR LEFT_BRK MINUS_GT }]
  [collectionKind ::= (*) SET , {LEFT_BRA }]
  [oclExpression ::= (*) oclExpression UP simpleName LEFT_PAR RIGHT_PAR , {EOF ENDPACKAGE CONTEXT INIT DERIVE IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE DOT UP UP_UP LEFT_PAR LEFT_BRK MINUS_GT }]
  [oclExpression ::= (*) oclExpression NE oclExpression , {EOF ENDPACKAGE CONTEXT INIT DERIVE IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE DOT UP UP_UP LEFT_PAR LEFT_BRK MINUS_GT }]
  [oclExpression ::= (*) oclExpression DIVIDE oclExpression , {EOF ENDPACKAGE CONTEXT INIT DERIVE IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE DOT UP UP_UP LEFT_PAR LEFT_BRK MINUS_GT }]
  [oclExpression ::= (*) oclExpression LEFT_PAR arguments RIGHT_PAR , {EOF ENDPACKAGE CONTEXT INIT DERIVE IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE DOT UP UP_UP LEFT_PAR LEFT_BRK MINUS_GT }]
  [primitiveLiteralExp ::= (*) FALSE , {EOF ENDPACKAGE CONTEXT INIT DERIVE IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE DOT UP UP_UP LEFT_PAR LEFT_BRK MINUS_GT }]
  [literalExp ::= (*) primitiveLiteralExp , {EOF ENDPACKAGE CONTEXT INIT DERIVE IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE DOT UP UP_UP LEFT_PAR LEFT_BRK MINUS_GT }]
  [oclExpression ::= (*) LET variableDeclarationList IN oclExpression , {EOF ENDPACKAGE CONTEXT INIT DERIVE IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE DOT UP UP_UP LEFT_PAR LEFT_BRK MINUS_GT }]
  [oclExpression ::= (*) oclExpression GT oclExpression , {EOF ENDPACKAGE CONTEXT INIT DERIVE IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE DOT UP UP_UP LEFT_PAR LEFT_BRK MINUS_GT }]
  [oclExpression ::= (*) oclExpression MINUS_GT ITERATE LEFT_PAR variableDeclaration BAR oclExpression RIGHT_PAR , {EOF ENDPACKAGE CONTEXT INIT DERIVE IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE DOT UP UP_UP LEFT_PAR LEFT_BRK MINUS_GT }]
  [oclExpression ::= (*) literalExp , {EOF ENDPACKAGE CONTEXT INIT DERIVE IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE DOT UP UP_UP LEFT_PAR LEFT_BRK MINUS_GT }]
  [primitiveLiteralExp ::= (*) INTEGER , {EOF ENDPACKAGE CONTEXT INIT DERIVE IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE DOT UP UP_UP LEFT_PAR LEFT_BRK MINUS_GT }]
  [collectionKind ::= (*) BAG , {LEFT_BRA }]
  [oclExpression ::= (*) oclExpression AND oclExpression , {EOF ENDPACKAGE CONTEXT INIT DERIVE IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE DOT UP UP_UP LEFT_PAR LEFT_BRK MINUS_GT }]
  [oclExpression ::= (*) oclExpression PLUS oclExpression , {EOF ENDPACKAGE CONTEXT INIT DERIVE IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE DOT UP UP_UP LEFT_PAR LEFT_BRK MINUS_GT }]
  [oclExpression ::= (*) oclExpression LEFT_PAR variableDeclaration BAR oclExpression RIGHT_PAR , {EOF ENDPACKAGE CONTEXT INIT DERIVE IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE DOT UP UP_UP LEFT_PAR LEFT_BRK MINUS_GT }]
  [pathName ::= (*) simpleName , {EOF ENDPACKAGE CONTEXT INIT DERIVE IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE DOT UP AT COLON_COLON UP_UP LEFT_PAR LEFT_BRK MINUS_GT }]
  [oclExpression ::= (*) oclExpression UP_UP simpleName LEFT_PAR oclMessageArgumentList RIGHT_PAR , {EOF ENDPACKAGE CONTEXT INIT DERIVE IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE DOT UP UP_UP LEFT_PAR LEFT_BRK MINUS_GT }]
  [oclExpression ::= (*) oclExpression LE oclExpression , {EOF ENDPACKAGE CONTEXT INIT DERIVE IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE DOT UP UP_UP LEFT_PAR LEFT_BRK MINUS_GT }]
  [oclExpression ::= (*) NOT oclExpression , {EOF ENDPACKAGE CONTEXT INIT DERIVE IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE DOT UP UP_UP LEFT_PAR LEFT_BRK MINUS_GT }]
  [oclExpression ::= (*) LEFT_PAR oclExpression RIGHT_PAR , {EOF ENDPACKAGE CONTEXT INIT DERIVE IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE DOT UP UP_UP LEFT_PAR LEFT_BRK MINUS_GT }]
  [initOrDerValue ::= initOrDerValue DERIVE COLON (*) oclExpression , {EOF ENDPACKAGE CONTEXT INIT DERIVE }]
  [primitiveLiteralExp ::= (*) REAL , {EOF ENDPACKAGE CONTEXT INIT DERIVE IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE DOT UP UP_UP LEFT_PAR LEFT_BRK MINUS_GT }]
  [collectionKind ::= (*) SEQUENCE , {LEFT_BRA }]
  [oclExpression ::= (*) oclExpression OR oclExpression , {EOF ENDPACKAGE CONTEXT INIT DERIVE IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE DOT UP UP_UP LEFT_PAR LEFT_BRK MINUS_GT }]
  [oclExpression ::= (*) oclExpression MINUS oclExpression , {EOF ENDPACKAGE CONTEXT INIT DERIVE IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE DOT UP UP_UP LEFT_PAR LEFT_BRK MINUS_GT }]
  [oclExpression ::= (*) oclExpression LEFT_BRK argumentList RIGHT_BRK isMarkedPre , {EOF ENDPACKAGE CONTEXT INIT DERIVE IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE DOT UP UP_UP LEFT_PAR LEFT_BRK MINUS_GT }]
  [pathName ::= (*) pathName COLON_COLON simpleName , {EOF ENDPACKAGE CONTEXT INIT DERIVE IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE DOT UP AT COLON_COLON UP_UP LEFT_PAR LEFT_BRK MINUS_GT }]
  [collectionLiteralExp ::= (*) collectionKind LEFT_BRA collectionLiteralParts RIGHT_BRA , {EOF ENDPACKAGE CONTEXT INIT DERIVE IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE DOT UP UP_UP LEFT_PAR LEFT_BRK MINUS_GT }]
  [oclExpression ::= (*) oclExpression UP_UP simpleName LEFT_PAR RIGHT_PAR , {EOF ENDPACKAGE CONTEXT INIT DERIVE IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE DOT UP UP_UP LEFT_PAR LEFT_BRK MINUS_GT }]
  [oclExpression ::= (*) oclExpression GE oclExpression , {EOF ENDPACKAGE CONTEXT INIT DERIVE IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE DOT UP UP_UP LEFT_PAR LEFT_BRK MINUS_GT }]
  [oclExpression ::= (*) MINUS oclExpression , {EOF ENDPACKAGE CONTEXT INIT DERIVE IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE DOT UP UP_UP LEFT_PAR LEFT_BRK MINUS_GT }]
  [oclExpression ::= (*) pathName isMarkedPre , {EOF ENDPACKAGE CONTEXT INIT DERIVE IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE DOT UP UP_UP LEFT_PAR LEFT_BRK MINUS_GT }]
  [primitiveLiteralExp ::= (*) STRING , {EOF ENDPACKAGE CONTEXT INIT DERIVE IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE DOT UP UP_UP LEFT_PAR LEFT_BRK MINUS_GT }]
  [collectionKind ::= (*) COLLECTION , {LEFT_BRA }]
  [literalExp ::= (*) collectionLiteralExp , {EOF ENDPACKAGE CONTEXT INIT DERIVE IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE DOT UP UP_UP LEFT_PAR LEFT_BRK MINUS_GT }]
  [oclExpression ::= (*) oclExpression XOR oclExpression , {EOF ENDPACKAGE CONTEXT INIT DERIVE IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE DOT UP UP_UP LEFT_PAR LEFT_BRK MINUS_GT }]
  [oclExpression ::= (*) IF oclExpression THEN oclExpression ELSE oclExpression ENDIF , {EOF ENDPACKAGE CONTEXT INIT DERIVE IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE DOT UP UP_UP LEFT_PAR LEFT_BRK MINUS_GT }]
  [oclExpression ::= (*) oclExpression MINUS_GT simpleName , {EOF ENDPACKAGE CONTEXT INIT DERIVE IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE DOT UP UP_UP LEFT_PAR LEFT_BRK MINUS_GT }]
  [simpleName ::= (*) SIMPLE_NAME , {EOF ENDPACKAGE CONTEXT INIT DERIVE IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE DOT UP AT COLON_COLON UP_UP LEFT_PAR LEFT_BRK MINUS_GT }]
  [collectionLiteralExp ::= (*) collectionKind LEFT_BRA RIGHT_BRA , {EOF ENDPACKAGE CONTEXT INIT DERIVE IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE DOT UP UP_UP LEFT_PAR LEFT_BRK MINUS_GT }]
}
transition on tupleLiteralExp to state [54]
transition on oclExpression to state [204]
transition on REAL to state [52]
transition on INTEGER to state [51]
transition on pathName to state [50]
transition on SIMPLE_NAME to state [12]
transition on LET to state [49]
transition on FALSE to state [48]
transition on MINUS to state [47]
transition on COLLECTION to state [28]
transition on SET to state [20]
transition on simpleName to state [26]
transition on collectionLiteralExp to state [46]
transition on LEFT_PAR to state [45]
transition on STRING to state [44]
transition on IF to state [43]
transition on TRUE to state [42]
transition on collectionKind to state [41]
transition on NOT to state [40]
transition on primitiveLiteralExp to state [39]
transition on TUPLE to state [38]
transition on literalExp to state [37]
transition on BAG to state [25]
transition on SEQUENCE to state [22]

-------------------
lalr_state [204]: {
  [oclExpression ::= oclExpression (*) LEFT_BRK argumentList RIGHT_BRK isMarkedPre , {EOF ENDPACKAGE CONTEXT INIT DERIVE IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE DOT UP UP_UP LEFT_PAR LEFT_BRK MINUS_GT }]
  [oclExpression ::= oclExpression (*) EQ oclExpression , {EOF ENDPACKAGE CONTEXT INIT DERIVE IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE DOT UP UP_UP LEFT_PAR LEFT_BRK MINUS_GT }]
  [oclExpression ::= oclExpression (*) IMPLIES oclExpression , {EOF ENDPACKAGE CONTEXT INIT DERIVE IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE DOT UP UP_UP LEFT_PAR LEFT_BRK MINUS_GT }]
  [oclExpression ::= oclExpression (*) UP simpleName LEFT_PAR RIGHT_PAR , {EOF ENDPACKAGE CONTEXT INIT DERIVE IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE DOT UP UP_UP LEFT_PAR LEFT_BRK MINUS_GT }]
  [oclExpression ::= oclExpression (*) LEFT_PAR arguments RIGHT_PAR , {EOF ENDPACKAGE CONTEXT INIT DERIVE IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE DOT UP UP_UP LEFT_PAR LEFT_BRK MINUS_GT }]
  [oclExpression ::= oclExpression (*) MINUS_GT ITERATE LEFT_PAR variableDeclaration BAR oclExpression RIGHT_PAR , {EOF ENDPACKAGE CONTEXT INIT DERIVE IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE DOT UP UP_UP LEFT_PAR LEFT_BRK MINUS_GT }]
  [oclExpression ::= oclExpression (*) PLUS oclExpression , {EOF ENDPACKAGE CONTEXT INIT DERIVE IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE DOT UP UP_UP LEFT_PAR LEFT_BRK MINUS_GT }]
  [oclExpression ::= oclExpression (*) LE oclExpression , {EOF ENDPACKAGE CONTEXT INIT DERIVE IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE DOT UP UP_UP LEFT_PAR LEFT_BRK MINUS_GT }]
  [oclExpression ::= oclExpression (*) OR oclExpression , {EOF ENDPACKAGE CONTEXT INIT DERIVE IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE DOT UP UP_UP LEFT_PAR LEFT_BRK MINUS_GT }]
  [oclExpression ::= oclExpression (*) UP_UP simpleName LEFT_PAR RIGHT_PAR , {EOF ENDPACKAGE CONTEXT INIT DERIVE IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE DOT UP UP_UP LEFT_PAR LEFT_BRK MINUS_GT }]
  [oclExpression ::= oclExpression (*) MINUS_GT simpleName , {EOF ENDPACKAGE CONTEXT INIT DERIVE IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE DOT UP UP_UP LEFT_PAR LEFT_BRK MINUS_GT }]
  [oclExpression ::= oclExpression (*) TIMES oclExpression , {EOF ENDPACKAGE CONTEXT INIT DERIVE IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE DOT UP UP_UP LEFT_PAR LEFT_BRK MINUS_GT }]
  [oclExpression ::= oclExpression (*) LT oclExpression , {EOF ENDPACKAGE CONTEXT INIT DERIVE IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE DOT UP UP_UP LEFT_PAR LEFT_BRK MINUS_GT }]
  [oclExpression ::= oclExpression (*) NE oclExpression , {EOF ENDPACKAGE CONTEXT INIT DERIVE IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE DOT UP UP_UP LEFT_PAR LEFT_BRK MINUS_GT }]
  [oclExpression ::= oclExpression (*) LEFT_PAR variableDeclaration BAR oclExpression RIGHT_PAR , {EOF ENDPACKAGE CONTEXT INIT DERIVE IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE DOT UP UP_UP LEFT_PAR LEFT_BRK MINUS_GT }]
  [oclExpression ::= oclExpression (*) MINUS oclExpression , {EOF ENDPACKAGE CONTEXT INIT DERIVE IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE DOT UP UP_UP LEFT_PAR LEFT_BRK MINUS_GT }]
  [oclExpression ::= oclExpression (*) GE oclExpression , {EOF ENDPACKAGE CONTEXT INIT DERIVE IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE DOT UP UP_UP LEFT_PAR LEFT_BRK MINUS_GT }]
  [oclExpression ::= oclExpression (*) XOR oclExpression , {EOF ENDPACKAGE CONTEXT INIT DERIVE IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE DOT UP UP_UP LEFT_PAR LEFT_BRK MINUS_GT }]
  [oclExpression ::= oclExpression (*) UP simpleName LEFT_PAR oclMessageArgumentList RIGHT_PAR , {EOF ENDPACKAGE CONTEXT INIT DERIVE IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE DOT UP UP_UP LEFT_PAR LEFT_BRK MINUS_GT }]
  [initOrDerValue ::= initOrDerValue DERIVE COLON oclExpression (*) , {EOF ENDPACKAGE CONTEXT INIT DERIVE }]
  [oclExpression ::= oclExpression (*) DOT simpleName isMarkedPre , {EOF ENDPACKAGE CONTEXT INIT DERIVE IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE DOT UP UP_UP LEFT_PAR LEFT_BRK MINUS_GT }]
  [oclExpression ::= oclExpression (*) MINUS_GT ITERATE LEFT_PAR variableDeclaration SEMICOLON variableDeclaration BAR oclExpression RIGHT_PAR , {EOF ENDPACKAGE CONTEXT INIT DERIVE IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE DOT UP UP_UP LEFT_PAR LEFT_BRK MINUS_GT }]
  [oclExpression ::= oclExpression (*) DIVIDE oclExpression , {EOF ENDPACKAGE CONTEXT INIT DERIVE IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE DOT UP UP_UP LEFT_PAR LEFT_BRK MINUS_GT }]
  [oclExpression ::= oclExpression (*) GT oclExpression , {EOF ENDPACKAGE CONTEXT INIT DERIVE IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE DOT UP UP_UP LEFT_PAR LEFT_BRK MINUS_GT }]
  [oclExpression ::= oclExpression (*) AND oclExpression , {EOF ENDPACKAGE CONTEXT INIT DERIVE IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE DOT UP UP_UP LEFT_PAR LEFT_BRK MINUS_GT }]
  [oclExpression ::= oclExpression (*) UP_UP simpleName LEFT_PAR oclMessageArgumentList RIGHT_PAR , {EOF ENDPACKAGE CONTEXT INIT DERIVE IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE DOT UP UP_UP LEFT_PAR LEFT_BRK MINUS_GT }]
}
transition on XOR to state [74]
transition on EQ to state [73]
transition on DOT to state [72]
transition on MINUS to state [71]
transition on GE to state [70]
transition on LEFT_BRK to state [69]
transition on DIVIDE to state [68]
transition on LEFT_PAR to state [67]
transition on MINUS_GT to state [66]
transition on LE to state [65]
transition on GT to state [64]
transition on IMPLIES to state [63]
transition on UP to state [62]
transition on UP_UP to state [61]
transition on OR to state [60]
transition on PLUS to state [59]
transition on NE to state [58]
transition on LT to state [57]
transition on AND to state [56]
transition on TIMES to state [55]

-------------------
lalr_state [205]: {
  [oclExpression ::= (*) oclExpression UP simpleName LEFT_PAR oclMessageArgumentList RIGHT_PAR , {EOF ENDPACKAGE CONTEXT INIT DERIVE IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE DOT UP UP_UP LEFT_PAR LEFT_BRK MINUS_GT }]
  [oclExpression ::= (*) oclExpression EQ oclExpression , {EOF ENDPACKAGE CONTEXT INIT DERIVE IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE DOT UP UP_UP LEFT_PAR LEFT_BRK MINUS_GT }]
  [oclExpression ::= (*) oclExpression TIMES oclExpression , {EOF ENDPACKAGE CONTEXT INIT DERIVE IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE DOT UP UP_UP LEFT_PAR LEFT_BRK MINUS_GT }]
  [oclExpression ::= (*) oclExpression DOT simpleName isMarkedPre , {EOF ENDPACKAGE CONTEXT INIT DERIVE IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE DOT UP UP_UP LEFT_PAR LEFT_BRK MINUS_GT }]
  [primitiveLiteralExp ::= (*) TRUE , {EOF ENDPACKAGE CONTEXT INIT DERIVE IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE DOT UP UP_UP LEFT_PAR LEFT_BRK MINUS_GT }]
  [literalExp ::= (*) tupleLiteralExp , {EOF ENDPACKAGE CONTEXT INIT DERIVE IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE DOT UP UP_UP LEFT_PAR LEFT_BRK MINUS_GT }]
  [oclExpression ::= (*) oclExpression IMPLIES oclExpression , {EOF ENDPACKAGE CONTEXT INIT DERIVE IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE DOT UP UP_UP LEFT_PAR LEFT_BRK MINUS_GT }]
  [oclExpression ::= (*) oclExpression LT oclExpression , {EOF ENDPACKAGE CONTEXT INIT DERIVE IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE DOT UP UP_UP LEFT_PAR LEFT_BRK MINUS_GT }]
  [oclExpression ::= (*) oclExpression MINUS_GT ITERATE LEFT_PAR variableDeclaration SEMICOLON variableDeclaration BAR oclExpression RIGHT_PAR , {EOF ENDPACKAGE CONTEXT INIT DERIVE IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE DOT UP UP_UP LEFT_PAR LEFT_BRK MINUS_GT }]
  [tupleLiteralExp ::= (*) TUPLE LEFT_BRA variableDeclarationList RIGHT_BRA , {EOF ENDPACKAGE CONTEXT INIT DERIVE IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE DOT UP UP_UP LEFT_PAR LEFT_BRK MINUS_GT }]
  [collectionKind ::= (*) SET , {LEFT_BRA }]
  [oclExpression ::= (*) oclExpression UP simpleName LEFT_PAR RIGHT_PAR , {EOF ENDPACKAGE CONTEXT INIT DERIVE IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE DOT UP UP_UP LEFT_PAR LEFT_BRK MINUS_GT }]
  [oclExpression ::= (*) oclExpression NE oclExpression , {EOF ENDPACKAGE CONTEXT INIT DERIVE IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE DOT UP UP_UP LEFT_PAR LEFT_BRK MINUS_GT }]
  [oclExpression ::= (*) oclExpression DIVIDE oclExpression , {EOF ENDPACKAGE CONTEXT INIT DERIVE IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE DOT UP UP_UP LEFT_PAR LEFT_BRK MINUS_GT }]
  [oclExpression ::= (*) oclExpression LEFT_PAR arguments RIGHT_PAR , {EOF ENDPACKAGE CONTEXT INIT DERIVE IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE DOT UP UP_UP LEFT_PAR LEFT_BRK MINUS_GT }]
  [primitiveLiteralExp ::= (*) FALSE , {EOF ENDPACKAGE CONTEXT INIT DERIVE IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE DOT UP UP_UP LEFT_PAR LEFT_BRK MINUS_GT }]
  [literalExp ::= (*) primitiveLiteralExp , {EOF ENDPACKAGE CONTEXT INIT DERIVE IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE DOT UP UP_UP LEFT_PAR LEFT_BRK MINUS_GT }]
  [oclExpression ::= (*) LET variableDeclarationList IN oclExpression , {EOF ENDPACKAGE CONTEXT INIT DERIVE IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE DOT UP UP_UP LEFT_PAR LEFT_BRK MINUS_GT }]
  [oclExpression ::= (*) oclExpression GT oclExpression , {EOF ENDPACKAGE CONTEXT INIT DERIVE IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE DOT UP UP_UP LEFT_PAR LEFT_BRK MINUS_GT }]
  [oclExpression ::= (*) oclExpression MINUS_GT ITERATE LEFT_PAR variableDeclaration BAR oclExpression RIGHT_PAR , {EOF ENDPACKAGE CONTEXT INIT DERIVE IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE DOT UP UP_UP LEFT_PAR LEFT_BRK MINUS_GT }]
  [oclExpression ::= (*) literalExp , {EOF ENDPACKAGE CONTEXT INIT DERIVE IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE DOT UP UP_UP LEFT_PAR LEFT_BRK MINUS_GT }]
  [initOrDerValue ::= initOrDerValue INIT COLON (*) oclExpression , {EOF ENDPACKAGE CONTEXT INIT DERIVE }]
  [primitiveLiteralExp ::= (*) INTEGER , {EOF ENDPACKAGE CONTEXT INIT DERIVE IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE DOT UP UP_UP LEFT_PAR LEFT_BRK MINUS_GT }]
  [collectionKind ::= (*) BAG , {LEFT_BRA }]
  [oclExpression ::= (*) oclExpression AND oclExpression , {EOF ENDPACKAGE CONTEXT INIT DERIVE IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE DOT UP UP_UP LEFT_PAR LEFT_BRK MINUS_GT }]
  [oclExpression ::= (*) oclExpression PLUS oclExpression , {EOF ENDPACKAGE CONTEXT INIT DERIVE IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE DOT UP UP_UP LEFT_PAR LEFT_BRK MINUS_GT }]
  [oclExpression ::= (*) oclExpression LEFT_PAR variableDeclaration BAR oclExpression RIGHT_PAR , {EOF ENDPACKAGE CONTEXT INIT DERIVE IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE DOT UP UP_UP LEFT_PAR LEFT_BRK MINUS_GT }]
  [pathName ::= (*) simpleName , {EOF ENDPACKAGE CONTEXT INIT DERIVE IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE DOT UP AT COLON_COLON UP_UP LEFT_PAR LEFT_BRK MINUS_GT }]
  [oclExpression ::= (*) oclExpression UP_UP simpleName LEFT_PAR oclMessageArgumentList RIGHT_PAR , {EOF ENDPACKAGE CONTEXT INIT DERIVE IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE DOT UP UP_UP LEFT_PAR LEFT_BRK MINUS_GT }]
  [oclExpression ::= (*) oclExpression LE oclExpression , {EOF ENDPACKAGE CONTEXT INIT DERIVE IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE DOT UP UP_UP LEFT_PAR LEFT_BRK MINUS_GT }]
  [oclExpression ::= (*) NOT oclExpression , {EOF ENDPACKAGE CONTEXT INIT DERIVE IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE DOT UP UP_UP LEFT_PAR LEFT_BRK MINUS_GT }]
  [oclExpression ::= (*) LEFT_PAR oclExpression RIGHT_PAR , {EOF ENDPACKAGE CONTEXT INIT DERIVE IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE DOT UP UP_UP LEFT_PAR LEFT_BRK MINUS_GT }]
  [primitiveLiteralExp ::= (*) REAL , {EOF ENDPACKAGE CONTEXT INIT DERIVE IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE DOT UP UP_UP LEFT_PAR LEFT_BRK MINUS_GT }]
  [collectionKind ::= (*) SEQUENCE , {LEFT_BRA }]
  [oclExpression ::= (*) oclExpression OR oclExpression , {EOF ENDPACKAGE CONTEXT INIT DERIVE IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE DOT UP UP_UP LEFT_PAR LEFT_BRK MINUS_GT }]
  [oclExpression ::= (*) oclExpression MINUS oclExpression , {EOF ENDPACKAGE CONTEXT INIT DERIVE IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE DOT UP UP_UP LEFT_PAR LEFT_BRK MINUS_GT }]
  [oclExpression ::= (*) oclExpression LEFT_BRK argumentList RIGHT_BRK isMarkedPre , {EOF ENDPACKAGE CONTEXT INIT DERIVE IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE DOT UP UP_UP LEFT_PAR LEFT_BRK MINUS_GT }]
  [pathName ::= (*) pathName COLON_COLON simpleName , {EOF ENDPACKAGE CONTEXT INIT DERIVE IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE DOT UP AT COLON_COLON UP_UP LEFT_PAR LEFT_BRK MINUS_GT }]
  [collectionLiteralExp ::= (*) collectionKind LEFT_BRA collectionLiteralParts RIGHT_BRA , {EOF ENDPACKAGE CONTEXT INIT DERIVE IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE DOT UP UP_UP LEFT_PAR LEFT_BRK MINUS_GT }]
  [oclExpression ::= (*) oclExpression UP_UP simpleName LEFT_PAR RIGHT_PAR , {EOF ENDPACKAGE CONTEXT INIT DERIVE IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE DOT UP UP_UP LEFT_PAR LEFT_BRK MINUS_GT }]
  [oclExpression ::= (*) oclExpression GE oclExpression , {EOF ENDPACKAGE CONTEXT INIT DERIVE IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE DOT UP UP_UP LEFT_PAR LEFT_BRK MINUS_GT }]
  [oclExpression ::= (*) MINUS oclExpression , {EOF ENDPACKAGE CONTEXT INIT DERIVE IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE DOT UP UP_UP LEFT_PAR LEFT_BRK MINUS_GT }]
  [oclExpression ::= (*) pathName isMarkedPre , {EOF ENDPACKAGE CONTEXT INIT DERIVE IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE DOT UP UP_UP LEFT_PAR LEFT_BRK MINUS_GT }]
  [primitiveLiteralExp ::= (*) STRING , {EOF ENDPACKAGE CONTEXT INIT DERIVE IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE DOT UP UP_UP LEFT_PAR LEFT_BRK MINUS_GT }]
  [collectionKind ::= (*) COLLECTION , {LEFT_BRA }]
  [literalExp ::= (*) collectionLiteralExp , {EOF ENDPACKAGE CONTEXT INIT DERIVE IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE DOT UP UP_UP LEFT_PAR LEFT_BRK MINUS_GT }]
  [oclExpression ::= (*) oclExpression XOR oclExpression , {EOF ENDPACKAGE CONTEXT INIT DERIVE IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE DOT UP UP_UP LEFT_PAR LEFT_BRK MINUS_GT }]
  [oclExpression ::= (*) IF oclExpression THEN oclExpression ELSE oclExpression ENDIF , {EOF ENDPACKAGE CONTEXT INIT DERIVE IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE DOT UP UP_UP LEFT_PAR LEFT_BRK MINUS_GT }]
  [oclExpression ::= (*) oclExpression MINUS_GT simpleName , {EOF ENDPACKAGE CONTEXT INIT DERIVE IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE DOT UP UP_UP LEFT_PAR LEFT_BRK MINUS_GT }]
  [simpleName ::= (*) SIMPLE_NAME , {EOF ENDPACKAGE CONTEXT INIT DERIVE IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE DOT UP AT COLON_COLON UP_UP LEFT_PAR LEFT_BRK MINUS_GT }]
  [collectionLiteralExp ::= (*) collectionKind LEFT_BRA RIGHT_BRA , {EOF ENDPACKAGE CONTEXT INIT DERIVE IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE DOT UP UP_UP LEFT_PAR LEFT_BRK MINUS_GT }]
}
transition on tupleLiteralExp to state [54]
transition on oclExpression to state [206]
transition on REAL to state [52]
transition on INTEGER to state [51]
transition on pathName to state [50]
transition on SIMPLE_NAME to state [12]
transition on LET to state [49]
transition on FALSE to state [48]
transition on MINUS to state [47]
transition on COLLECTION to state [28]
transition on SET to state [20]
transition on simpleName to state [26]
transition on collectionLiteralExp to state [46]
transition on LEFT_PAR to state [45]
transition on STRING to state [44]
transition on IF to state [43]
transition on TRUE to state [42]
transition on collectionKind to state [41]
transition on NOT to state [40]
transition on primitiveLiteralExp to state [39]
transition on TUPLE to state [38]
transition on literalExp to state [37]
transition on BAG to state [25]
transition on SEQUENCE to state [22]

-------------------
lalr_state [206]: {
  [oclExpression ::= oclExpression (*) LEFT_BRK argumentList RIGHT_BRK isMarkedPre , {EOF ENDPACKAGE CONTEXT INIT DERIVE IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE DOT UP UP_UP LEFT_PAR LEFT_BRK MINUS_GT }]
  [oclExpression ::= oclExpression (*) EQ oclExpression , {EOF ENDPACKAGE CONTEXT INIT DERIVE IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE DOT UP UP_UP LEFT_PAR LEFT_BRK MINUS_GT }]
  [oclExpression ::= oclExpression (*) IMPLIES oclExpression , {EOF ENDPACKAGE CONTEXT INIT DERIVE IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE DOT UP UP_UP LEFT_PAR LEFT_BRK MINUS_GT }]
  [oclExpression ::= oclExpression (*) UP simpleName LEFT_PAR RIGHT_PAR , {EOF ENDPACKAGE CONTEXT INIT DERIVE IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE DOT UP UP_UP LEFT_PAR LEFT_BRK MINUS_GT }]
  [oclExpression ::= oclExpression (*) LEFT_PAR arguments RIGHT_PAR , {EOF ENDPACKAGE CONTEXT INIT DERIVE IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE DOT UP UP_UP LEFT_PAR LEFT_BRK MINUS_GT }]
  [oclExpression ::= oclExpression (*) MINUS_GT ITERATE LEFT_PAR variableDeclaration BAR oclExpression RIGHT_PAR , {EOF ENDPACKAGE CONTEXT INIT DERIVE IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE DOT UP UP_UP LEFT_PAR LEFT_BRK MINUS_GT }]
  [oclExpression ::= oclExpression (*) PLUS oclExpression , {EOF ENDPACKAGE CONTEXT INIT DERIVE IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE DOT UP UP_UP LEFT_PAR LEFT_BRK MINUS_GT }]
  [oclExpression ::= oclExpression (*) LE oclExpression , {EOF ENDPACKAGE CONTEXT INIT DERIVE IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE DOT UP UP_UP LEFT_PAR LEFT_BRK MINUS_GT }]
  [oclExpression ::= oclExpression (*) OR oclExpression , {EOF ENDPACKAGE CONTEXT INIT DERIVE IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE DOT UP UP_UP LEFT_PAR LEFT_BRK MINUS_GT }]
  [oclExpression ::= oclExpression (*) UP_UP simpleName LEFT_PAR RIGHT_PAR , {EOF ENDPACKAGE CONTEXT INIT DERIVE IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE DOT UP UP_UP LEFT_PAR LEFT_BRK MINUS_GT }]
  [initOrDerValue ::= initOrDerValue INIT COLON oclExpression (*) , {EOF ENDPACKAGE CONTEXT INIT DERIVE }]
  [oclExpression ::= oclExpression (*) MINUS_GT simpleName , {EOF ENDPACKAGE CONTEXT INIT DERIVE IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE DOT UP UP_UP LEFT_PAR LEFT_BRK MINUS_GT }]
  [oclExpression ::= oclExpression (*) TIMES oclExpression , {EOF ENDPACKAGE CONTEXT INIT DERIVE IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE DOT UP UP_UP LEFT_PAR LEFT_BRK MINUS_GT }]
  [oclExpression ::= oclExpression (*) LT oclExpression , {EOF ENDPACKAGE CONTEXT INIT DERIVE IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE DOT UP UP_UP LEFT_PAR LEFT_BRK MINUS_GT }]
  [oclExpression ::= oclExpression (*) NE oclExpression , {EOF ENDPACKAGE CONTEXT INIT DERIVE IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE DOT UP UP_UP LEFT_PAR LEFT_BRK MINUS_GT }]
  [oclExpression ::= oclExpression (*) LEFT_PAR variableDeclaration BAR oclExpression RIGHT_PAR , {EOF ENDPACKAGE CONTEXT INIT DERIVE IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE DOT UP UP_UP LEFT_PAR LEFT_BRK MINUS_GT }]
  [oclExpression ::= oclExpression (*) MINUS oclExpression , {EOF ENDPACKAGE CONTEXT INIT DERIVE IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE DOT UP UP_UP LEFT_PAR LEFT_BRK MINUS_GT }]
  [oclExpression ::= oclExpression (*) GE oclExpression , {EOF ENDPACKAGE CONTEXT INIT DERIVE IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE DOT UP UP_UP LEFT_PAR LEFT_BRK MINUS_GT }]
  [oclExpression ::= oclExpression (*) XOR oclExpression , {EOF ENDPACKAGE CONTEXT INIT DERIVE IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE DOT UP UP_UP LEFT_PAR LEFT_BRK MINUS_GT }]
  [oclExpression ::= oclExpression (*) UP simpleName LEFT_PAR oclMessageArgumentList RIGHT_PAR , {EOF ENDPACKAGE CONTEXT INIT DERIVE IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE DOT UP UP_UP LEFT_PAR LEFT_BRK MINUS_GT }]
  [oclExpression ::= oclExpression (*) DOT simpleName isMarkedPre , {EOF ENDPACKAGE CONTEXT INIT DERIVE IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE DOT UP UP_UP LEFT_PAR LEFT_BRK MINUS_GT }]
  [oclExpression ::= oclExpression (*) MINUS_GT ITERATE LEFT_PAR variableDeclaration SEMICOLON variableDeclaration BAR oclExpression RIGHT_PAR , {EOF ENDPACKAGE CONTEXT INIT DERIVE IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE DOT UP UP_UP LEFT_PAR LEFT_BRK MINUS_GT }]
  [oclExpression ::= oclExpression (*) DIVIDE oclExpression , {EOF ENDPACKAGE CONTEXT INIT DERIVE IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE DOT UP UP_UP LEFT_PAR LEFT_BRK MINUS_GT }]
  [oclExpression ::= oclExpression (*) GT oclExpression , {EOF ENDPACKAGE CONTEXT INIT DERIVE IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE DOT UP UP_UP LEFT_PAR LEFT_BRK MINUS_GT }]
  [oclExpression ::= oclExpression (*) AND oclExpression , {EOF ENDPACKAGE CONTEXT INIT DERIVE IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE DOT UP UP_UP LEFT_PAR LEFT_BRK MINUS_GT }]
  [oclExpression ::= oclExpression (*) UP_UP simpleName LEFT_PAR oclMessageArgumentList RIGHT_PAR , {EOF ENDPACKAGE CONTEXT INIT DERIVE IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE DOT UP UP_UP LEFT_PAR LEFT_BRK MINUS_GT }]
}
transition on XOR to state [74]
transition on EQ to state [73]
transition on DOT to state [72]
transition on MINUS to state [71]
transition on GE to state [70]
transition on LEFT_BRK to state [69]
transition on DIVIDE to state [68]
transition on LEFT_PAR to state [67]
transition on MINUS_GT to state [66]
transition on LE to state [65]
transition on GT to state [64]
transition on IMPLIES to state [63]
transition on UP to state [62]
transition on UP_UP to state [61]
transition on OR to state [60]
transition on PLUS to state [59]
transition on NE to state [58]
transition on LT to state [57]
transition on AND to state [56]
transition on TIMES to state [55]

-------------------
lalr_state [207]: {
  [oclExpression ::= (*) oclExpression UP simpleName LEFT_PAR oclMessageArgumentList RIGHT_PAR , {EOF ENDPACKAGE CONTEXT INIT DERIVE IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE DOT UP UP_UP LEFT_PAR LEFT_BRK MINUS_GT }]
  [oclExpression ::= (*) oclExpression EQ oclExpression , {EOF ENDPACKAGE CONTEXT INIT DERIVE IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE DOT UP UP_UP LEFT_PAR LEFT_BRK MINUS_GT }]
  [oclExpression ::= (*) oclExpression TIMES oclExpression , {EOF ENDPACKAGE CONTEXT INIT DERIVE IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE DOT UP UP_UP LEFT_PAR LEFT_BRK MINUS_GT }]
  [oclExpression ::= (*) oclExpression DOT simpleName isMarkedPre , {EOF ENDPACKAGE CONTEXT INIT DERIVE IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE DOT UP UP_UP LEFT_PAR LEFT_BRK MINUS_GT }]
  [primitiveLiteralExp ::= (*) TRUE , {EOF ENDPACKAGE CONTEXT INIT DERIVE IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE DOT UP UP_UP LEFT_PAR LEFT_BRK MINUS_GT }]
  [literalExp ::= (*) tupleLiteralExp , {EOF ENDPACKAGE CONTEXT INIT DERIVE IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE DOT UP UP_UP LEFT_PAR LEFT_BRK MINUS_GT }]
  [oclExpression ::= (*) oclExpression IMPLIES oclExpression , {EOF ENDPACKAGE CONTEXT INIT DERIVE IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE DOT UP UP_UP LEFT_PAR LEFT_BRK MINUS_GT }]
  [oclExpression ::= (*) oclExpression LT oclExpression , {EOF ENDPACKAGE CONTEXT INIT DERIVE IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE DOT UP UP_UP LEFT_PAR LEFT_BRK MINUS_GT }]
  [oclExpression ::= (*) oclExpression MINUS_GT ITERATE LEFT_PAR variableDeclaration SEMICOLON variableDeclaration BAR oclExpression RIGHT_PAR , {EOF ENDPACKAGE CONTEXT INIT DERIVE IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE DOT UP UP_UP LEFT_PAR LEFT_BRK MINUS_GT }]
  [tupleLiteralExp ::= (*) TUPLE LEFT_BRA variableDeclarationList RIGHT_BRA , {EOF ENDPACKAGE CONTEXT INIT DERIVE IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE DOT UP UP_UP LEFT_PAR LEFT_BRK MINUS_GT }]
  [collectionKind ::= (*) SET , {LEFT_BRA }]
  [oclExpression ::= (*) oclExpression UP simpleName LEFT_PAR RIGHT_PAR , {EOF ENDPACKAGE CONTEXT INIT DERIVE IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE DOT UP UP_UP LEFT_PAR LEFT_BRK MINUS_GT }]
  [oclExpression ::= (*) oclExpression NE oclExpression , {EOF ENDPACKAGE CONTEXT INIT DERIVE IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE DOT UP UP_UP LEFT_PAR LEFT_BRK MINUS_GT }]
  [oclExpression ::= (*) oclExpression DIVIDE oclExpression , {EOF ENDPACKAGE CONTEXT INIT DERIVE IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE DOT UP UP_UP LEFT_PAR LEFT_BRK MINUS_GT }]
  [oclExpression ::= (*) oclExpression LEFT_PAR arguments RIGHT_PAR , {EOF ENDPACKAGE CONTEXT INIT DERIVE IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE DOT UP UP_UP LEFT_PAR LEFT_BRK MINUS_GT }]
  [primitiveLiteralExp ::= (*) FALSE , {EOF ENDPACKAGE CONTEXT INIT DERIVE IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE DOT UP UP_UP LEFT_PAR LEFT_BRK MINUS_GT }]
  [literalExp ::= (*) primitiveLiteralExp , {EOF ENDPACKAGE CONTEXT INIT DERIVE IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE DOT UP UP_UP LEFT_PAR LEFT_BRK MINUS_GT }]
  [oclExpression ::= (*) LET variableDeclarationList IN oclExpression , {EOF ENDPACKAGE CONTEXT INIT DERIVE IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE DOT UP UP_UP LEFT_PAR LEFT_BRK MINUS_GT }]
  [oclExpression ::= (*) oclExpression GT oclExpression , {EOF ENDPACKAGE CONTEXT INIT DERIVE IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE DOT UP UP_UP LEFT_PAR LEFT_BRK MINUS_GT }]
  [oclExpression ::= (*) oclExpression MINUS_GT ITERATE LEFT_PAR variableDeclaration BAR oclExpression RIGHT_PAR , {EOF ENDPACKAGE CONTEXT INIT DERIVE IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE DOT UP UP_UP LEFT_PAR LEFT_BRK MINUS_GT }]
  [oclExpression ::= (*) literalExp , {EOF ENDPACKAGE CONTEXT INIT DERIVE IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE DOT UP UP_UP LEFT_PAR LEFT_BRK MINUS_GT }]
  [primitiveLiteralExp ::= (*) INTEGER , {EOF ENDPACKAGE CONTEXT INIT DERIVE IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE DOT UP UP_UP LEFT_PAR LEFT_BRK MINUS_GT }]
  [collectionKind ::= (*) BAG , {LEFT_BRA }]
  [oclExpression ::= (*) oclExpression AND oclExpression , {EOF ENDPACKAGE CONTEXT INIT DERIVE IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE DOT UP UP_UP LEFT_PAR LEFT_BRK MINUS_GT }]
  [oclExpression ::= (*) oclExpression PLUS oclExpression , {EOF ENDPACKAGE CONTEXT INIT DERIVE IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE DOT UP UP_UP LEFT_PAR LEFT_BRK MINUS_GT }]
  [oclExpression ::= (*) oclExpression LEFT_PAR variableDeclaration BAR oclExpression RIGHT_PAR , {EOF ENDPACKAGE CONTEXT INIT DERIVE IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE DOT UP UP_UP LEFT_PAR LEFT_BRK MINUS_GT }]
  [pathName ::= (*) simpleName , {EOF ENDPACKAGE CONTEXT INIT DERIVE IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE DOT UP AT COLON_COLON UP_UP LEFT_PAR LEFT_BRK MINUS_GT }]
  [oclExpression ::= (*) oclExpression UP_UP simpleName LEFT_PAR oclMessageArgumentList RIGHT_PAR , {EOF ENDPACKAGE CONTEXT INIT DERIVE IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE DOT UP UP_UP LEFT_PAR LEFT_BRK MINUS_GT }]
  [oclExpression ::= (*) oclExpression LE oclExpression , {EOF ENDPACKAGE CONTEXT INIT DERIVE IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE DOT UP UP_UP LEFT_PAR LEFT_BRK MINUS_GT }]
  [oclExpression ::= (*) NOT oclExpression , {EOF ENDPACKAGE CONTEXT INIT DERIVE IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE DOT UP UP_UP LEFT_PAR LEFT_BRK MINUS_GT }]
  [oclExpression ::= (*) LEFT_PAR oclExpression RIGHT_PAR , {EOF ENDPACKAGE CONTEXT INIT DERIVE IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE DOT UP UP_UP LEFT_PAR LEFT_BRK MINUS_GT }]
  [primitiveLiteralExp ::= (*) REAL , {EOF ENDPACKAGE CONTEXT INIT DERIVE IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE DOT UP UP_UP LEFT_PAR LEFT_BRK MINUS_GT }]
  [collectionKind ::= (*) SEQUENCE , {LEFT_BRA }]
  [oclExpression ::= (*) oclExpression OR oclExpression , {EOF ENDPACKAGE CONTEXT INIT DERIVE IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE DOT UP UP_UP LEFT_PAR LEFT_BRK MINUS_GT }]
  [oclExpression ::= (*) oclExpression MINUS oclExpression , {EOF ENDPACKAGE CONTEXT INIT DERIVE IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE DOT UP UP_UP LEFT_PAR LEFT_BRK MINUS_GT }]
  [oclExpression ::= (*) oclExpression LEFT_BRK argumentList RIGHT_BRK isMarkedPre , {EOF ENDPACKAGE CONTEXT INIT DERIVE IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE DOT UP UP_UP LEFT_PAR LEFT_BRK MINUS_GT }]
  [pathName ::= (*) pathName COLON_COLON simpleName , {EOF ENDPACKAGE CONTEXT INIT DERIVE IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE DOT UP AT COLON_COLON UP_UP LEFT_PAR LEFT_BRK MINUS_GT }]
  [collectionLiteralExp ::= (*) collectionKind LEFT_BRA collectionLiteralParts RIGHT_BRA , {EOF ENDPACKAGE CONTEXT INIT DERIVE IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE DOT UP UP_UP LEFT_PAR LEFT_BRK MINUS_GT }]
  [oclExpression ::= (*) oclExpression UP_UP simpleName LEFT_PAR RIGHT_PAR , {EOF ENDPACKAGE CONTEXT INIT DERIVE IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE DOT UP UP_UP LEFT_PAR LEFT_BRK MINUS_GT }]
  [oclExpression ::= (*) oclExpression GE oclExpression , {EOF ENDPACKAGE CONTEXT INIT DERIVE IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE DOT UP UP_UP LEFT_PAR LEFT_BRK MINUS_GT }]
  [oclExpression ::= (*) MINUS oclExpression , {EOF ENDPACKAGE CONTEXT INIT DERIVE IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE DOT UP UP_UP LEFT_PAR LEFT_BRK MINUS_GT }]
  [oclExpression ::= (*) pathName isMarkedPre , {EOF ENDPACKAGE CONTEXT INIT DERIVE IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE DOT UP UP_UP LEFT_PAR LEFT_BRK MINUS_GT }]
  [primitiveLiteralExp ::= (*) STRING , {EOF ENDPACKAGE CONTEXT INIT DERIVE IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE DOT UP UP_UP LEFT_PAR LEFT_BRK MINUS_GT }]
  [collectionKind ::= (*) COLLECTION , {LEFT_BRA }]
  [literalExp ::= (*) collectionLiteralExp , {EOF ENDPACKAGE CONTEXT INIT DERIVE IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE DOT UP UP_UP LEFT_PAR LEFT_BRK MINUS_GT }]
  [oclExpression ::= (*) oclExpression XOR oclExpression , {EOF ENDPACKAGE CONTEXT INIT DERIVE IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE DOT UP UP_UP LEFT_PAR LEFT_BRK MINUS_GT }]
  [oclExpression ::= (*) IF oclExpression THEN oclExpression ELSE oclExpression ENDIF , {EOF ENDPACKAGE CONTEXT INIT DERIVE IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE DOT UP UP_UP LEFT_PAR LEFT_BRK MINUS_GT }]
  [oclExpression ::= (*) oclExpression MINUS_GT simpleName , {EOF ENDPACKAGE CONTEXT INIT DERIVE IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE DOT UP UP_UP LEFT_PAR LEFT_BRK MINUS_GT }]
  [simpleName ::= (*) SIMPLE_NAME , {EOF ENDPACKAGE CONTEXT INIT DERIVE IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE DOT UP AT COLON_COLON UP_UP LEFT_PAR LEFT_BRK MINUS_GT }]
  [initOrDerValue ::= INIT COLON (*) oclExpression , {EOF ENDPACKAGE CONTEXT INIT DERIVE }]
  [collectionLiteralExp ::= (*) collectionKind LEFT_BRA RIGHT_BRA , {EOF ENDPACKAGE CONTEXT INIT DERIVE IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE DOT UP UP_UP LEFT_PAR LEFT_BRK MINUS_GT }]
}
transition on tupleLiteralExp to state [54]
transition on oclExpression to state [208]
transition on REAL to state [52]
transition on INTEGER to state [51]
transition on pathName to state [50]
transition on SIMPLE_NAME to state [12]
transition on LET to state [49]
transition on FALSE to state [48]
transition on MINUS to state [47]
transition on COLLECTION to state [28]
transition on SET to state [20]
transition on simpleName to state [26]
transition on collectionLiteralExp to state [46]
transition on LEFT_PAR to state [45]
transition on STRING to state [44]
transition on IF to state [43]
transition on TRUE to state [42]
transition on collectionKind to state [41]
transition on NOT to state [40]
transition on primitiveLiteralExp to state [39]
transition on TUPLE to state [38]
transition on literalExp to state [37]
transition on BAG to state [25]
transition on SEQUENCE to state [22]

-------------------
lalr_state [208]: {
  [oclExpression ::= oclExpression (*) LEFT_BRK argumentList RIGHT_BRK isMarkedPre , {EOF ENDPACKAGE CONTEXT INIT DERIVE IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE DOT UP UP_UP LEFT_PAR LEFT_BRK MINUS_GT }]
  [oclExpression ::= oclExpression (*) EQ oclExpression , {EOF ENDPACKAGE CONTEXT INIT DERIVE IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE DOT UP UP_UP LEFT_PAR LEFT_BRK MINUS_GT }]
  [oclExpression ::= oclExpression (*) IMPLIES oclExpression , {EOF ENDPACKAGE CONTEXT INIT DERIVE IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE DOT UP UP_UP LEFT_PAR LEFT_BRK MINUS_GT }]
  [oclExpression ::= oclExpression (*) UP simpleName LEFT_PAR RIGHT_PAR , {EOF ENDPACKAGE CONTEXT INIT DERIVE IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE DOT UP UP_UP LEFT_PAR LEFT_BRK MINUS_GT }]
  [oclExpression ::= oclExpression (*) LEFT_PAR arguments RIGHT_PAR , {EOF ENDPACKAGE CONTEXT INIT DERIVE IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE DOT UP UP_UP LEFT_PAR LEFT_BRK MINUS_GT }]
  [oclExpression ::= oclExpression (*) MINUS_GT ITERATE LEFT_PAR variableDeclaration BAR oclExpression RIGHT_PAR , {EOF ENDPACKAGE CONTEXT INIT DERIVE IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE DOT UP UP_UP LEFT_PAR LEFT_BRK MINUS_GT }]
  [oclExpression ::= oclExpression (*) PLUS oclExpression , {EOF ENDPACKAGE CONTEXT INIT DERIVE IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE DOT UP UP_UP LEFT_PAR LEFT_BRK MINUS_GT }]
  [oclExpression ::= oclExpression (*) LE oclExpression , {EOF ENDPACKAGE CONTEXT INIT DERIVE IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE DOT UP UP_UP LEFT_PAR LEFT_BRK MINUS_GT }]
  [oclExpression ::= oclExpression (*) OR oclExpression , {EOF ENDPACKAGE CONTEXT INIT DERIVE IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE DOT UP UP_UP LEFT_PAR LEFT_BRK MINUS_GT }]
  [oclExpression ::= oclExpression (*) UP_UP simpleName LEFT_PAR RIGHT_PAR , {EOF ENDPACKAGE CONTEXT INIT DERIVE IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE DOT UP UP_UP LEFT_PAR LEFT_BRK MINUS_GT }]
  [oclExpression ::= oclExpression (*) MINUS_GT simpleName , {EOF ENDPACKAGE CONTEXT INIT DERIVE IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE DOT UP UP_UP LEFT_PAR LEFT_BRK MINUS_GT }]
  [oclExpression ::= oclExpression (*) TIMES oclExpression , {EOF ENDPACKAGE CONTEXT INIT DERIVE IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE DOT UP UP_UP LEFT_PAR LEFT_BRK MINUS_GT }]
  [oclExpression ::= oclExpression (*) LT oclExpression , {EOF ENDPACKAGE CONTEXT INIT DERIVE IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE DOT UP UP_UP LEFT_PAR LEFT_BRK MINUS_GT }]
  [oclExpression ::= oclExpression (*) NE oclExpression , {EOF ENDPACKAGE CONTEXT INIT DERIVE IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE DOT UP UP_UP LEFT_PAR LEFT_BRK MINUS_GT }]
  [initOrDerValue ::= INIT COLON oclExpression (*) , {EOF ENDPACKAGE CONTEXT INIT DERIVE }]
  [oclExpression ::= oclExpression (*) LEFT_PAR variableDeclaration BAR oclExpression RIGHT_PAR , {EOF ENDPACKAGE CONTEXT INIT DERIVE IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE DOT UP UP_UP LEFT_PAR LEFT_BRK MINUS_GT }]
  [oclExpression ::= oclExpression (*) MINUS oclExpression , {EOF ENDPACKAGE CONTEXT INIT DERIVE IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE DOT UP UP_UP LEFT_PAR LEFT_BRK MINUS_GT }]
  [oclExpression ::= oclExpression (*) GE oclExpression , {EOF ENDPACKAGE CONTEXT INIT DERIVE IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE DOT UP UP_UP LEFT_PAR LEFT_BRK MINUS_GT }]
  [oclExpression ::= oclExpression (*) XOR oclExpression , {EOF ENDPACKAGE CONTEXT INIT DERIVE IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE DOT UP UP_UP LEFT_PAR LEFT_BRK MINUS_GT }]
  [oclExpression ::= oclExpression (*) UP simpleName LEFT_PAR oclMessageArgumentList RIGHT_PAR , {EOF ENDPACKAGE CONTEXT INIT DERIVE IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE DOT UP UP_UP LEFT_PAR LEFT_BRK MINUS_GT }]
  [oclExpression ::= oclExpression (*) DOT simpleName isMarkedPre , {EOF ENDPACKAGE CONTEXT INIT DERIVE IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE DOT UP UP_UP LEFT_PAR LEFT_BRK MINUS_GT }]
  [oclExpression ::= oclExpression (*) MINUS_GT ITERATE LEFT_PAR variableDeclaration SEMICOLON variableDeclaration BAR oclExpression RIGHT_PAR , {EOF ENDPACKAGE CONTEXT INIT DERIVE IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE DOT UP UP_UP LEFT_PAR LEFT_BRK MINUS_GT }]
  [oclExpression ::= oclExpression (*) DIVIDE oclExpression , {EOF ENDPACKAGE CONTEXT INIT DERIVE IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE DOT UP UP_UP LEFT_PAR LEFT_BRK MINUS_GT }]
  [oclExpression ::= oclExpression (*) GT oclExpression , {EOF ENDPACKAGE CONTEXT INIT DERIVE IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE DOT UP UP_UP LEFT_PAR LEFT_BRK MINUS_GT }]
  [oclExpression ::= oclExpression (*) AND oclExpression , {EOF ENDPACKAGE CONTEXT INIT DERIVE IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE DOT UP UP_UP LEFT_PAR LEFT_BRK MINUS_GT }]
  [oclExpression ::= oclExpression (*) UP_UP simpleName LEFT_PAR oclMessageArgumentList RIGHT_PAR , {EOF ENDPACKAGE CONTEXT INIT DERIVE IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE DOT UP UP_UP LEFT_PAR LEFT_BRK MINUS_GT }]
}
transition on XOR to state [74]
transition on EQ to state [73]
transition on DOT to state [72]
transition on MINUS to state [71]
transition on GE to state [70]
transition on LEFT_BRK to state [69]
transition on DIVIDE to state [68]
transition on LEFT_PAR to state [67]
transition on MINUS_GT to state [66]
transition on LE to state [65]
transition on GT to state [64]
transition on IMPLIES to state [63]
transition on UP to state [62]
transition on UP_UP to state [61]
transition on OR to state [60]
transition on PLUS to state [59]
transition on NE to state [58]
transition on LT to state [57]
transition on AND to state [56]
transition on TIMES to state [55]

-------------------
lalr_state [209]: {
  [invOrDef ::= invOrDef DEF (*) simpleName COLON defExpression , {EOF ENDPACKAGE CONTEXT INV DEF COLON }]
  [simpleName ::= (*) SIMPLE_NAME , {COLON }]
}
transition on SIMPLE_NAME to state [12]
transition on simpleName to state [226]

-------------------
lalr_state [210]: {
  [operation ::= (*) pathName COLON_COLON simpleName LEFT_PAR RIGHT_PAR , {EQ }]
  [variableDeclaration ::= (*) simpleName , {EQ }]
  [defExpression ::= (*) operation EQ oclExpression , {EOF ENDPACKAGE CONTEXT INV DEF COLON }]
  [simpleName ::= (*) SIMPLE_NAME , {EQ COLON COLON_COLON LEFT_PAR }]
  [operation ::= (*) pathName COLON_COLON simpleName LEFT_PAR variableDeclarationList RIGHT_PAR , {EQ }]
  [operation ::= (*) simpleName LEFT_PAR RIGHT_PAR COLON type , {EQ }]
  [variableDeclaration ::= (*) simpleName COLON type , {EQ }]
  [invOrDef ::= invOrDef COLON (*) defExpression , {EOF ENDPACKAGE CONTEXT INV DEF COLON }]
  [pathName ::= (*) simpleName , {COLON_COLON }]
  [operation ::= (*) simpleName LEFT_PAR variableDeclarationList RIGHT_PAR COLON type , {EQ }]
  [operation ::= (*) pathName COLON_COLON simpleName LEFT_PAR RIGHT_PAR COLON type , {EQ }]
  [operation ::= (*) simpleName LEFT_PAR RIGHT_PAR , {EQ }]
  [variableDeclaration ::= (*) simpleName EQ oclExpression , {EQ }]
  [defExpression ::= (*) variableDeclaration EQ oclExpression , {EOF ENDPACKAGE CONTEXT INV DEF COLON }]
  [pathName ::= (*) pathName COLON_COLON simpleName , {COLON_COLON }]
  [operation ::= (*) pathName COLON_COLON simpleName LEFT_PAR variableDeclarationList RIGHT_PAR COLON type , {EQ }]
  [operation ::= (*) simpleName LEFT_PAR variableDeclarationList RIGHT_PAR , {EQ }]
  [variableDeclaration ::= (*) simpleName COLON type EQ oclExpression , {EQ }]
}
transition on SIMPLE_NAME to state [12]
transition on variableDeclaration to state [221]
transition on simpleName to state [220]
transition on pathName to state [219]
transition on defExpression to state [218]
transition on operation to state [217]

-------------------
lalr_state [211]: {
  [invOrDef ::= invOrDef INV (*) simpleName COLON oclExpression , {EOF ENDPACKAGE CONTEXT INV DEF COLON }]
  [simpleName ::= (*) SIMPLE_NAME , {COLON }]
  [invOrDef ::= invOrDef INV (*) COLON oclExpression , {EOF ENDPACKAGE CONTEXT INV DEF COLON }]
}
transition on SIMPLE_NAME to state [12]
transition on simpleName to state [213]
transition on COLON to state [212]

-------------------
lalr_state [212]: {
  [oclExpression ::= (*) oclExpression UP simpleName LEFT_PAR oclMessageArgumentList RIGHT_PAR , {EOF ENDPACKAGE CONTEXT INV DEF IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE DOT COLON UP UP_UP LEFT_PAR LEFT_BRK MINUS_GT }]
  [oclExpression ::= (*) oclExpression EQ oclExpression , {EOF ENDPACKAGE CONTEXT INV DEF IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE DOT COLON UP UP_UP LEFT_PAR LEFT_BRK MINUS_GT }]
  [oclExpression ::= (*) oclExpression TIMES oclExpression , {EOF ENDPACKAGE CONTEXT INV DEF IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE DOT COLON UP UP_UP LEFT_PAR LEFT_BRK MINUS_GT }]
  [oclExpression ::= (*) oclExpression DOT simpleName isMarkedPre , {EOF ENDPACKAGE CONTEXT INV DEF IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE DOT COLON UP UP_UP LEFT_PAR LEFT_BRK MINUS_GT }]
  [primitiveLiteralExp ::= (*) TRUE , {EOF ENDPACKAGE CONTEXT INV DEF IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE DOT COLON UP UP_UP LEFT_PAR LEFT_BRK MINUS_GT }]
  [literalExp ::= (*) tupleLiteralExp , {EOF ENDPACKAGE CONTEXT INV DEF IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE DOT COLON UP UP_UP LEFT_PAR LEFT_BRK MINUS_GT }]
  [oclExpression ::= (*) oclExpression IMPLIES oclExpression , {EOF ENDPACKAGE CONTEXT INV DEF IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE DOT COLON UP UP_UP LEFT_PAR LEFT_BRK MINUS_GT }]
  [oclExpression ::= (*) oclExpression LT oclExpression , {EOF ENDPACKAGE CONTEXT INV DEF IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE DOT COLON UP UP_UP LEFT_PAR LEFT_BRK MINUS_GT }]
  [oclExpression ::= (*) oclExpression MINUS_GT ITERATE LEFT_PAR variableDeclaration SEMICOLON variableDeclaration BAR oclExpression RIGHT_PAR , {EOF ENDPACKAGE CONTEXT INV DEF IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE DOT COLON UP UP_UP LEFT_PAR LEFT_BRK MINUS_GT }]
  [invOrDef ::= invOrDef INV COLON (*) oclExpression , {EOF ENDPACKAGE CONTEXT INV DEF COLON }]
  [tupleLiteralExp ::= (*) TUPLE LEFT_BRA variableDeclarationList RIGHT_BRA , {EOF ENDPACKAGE CONTEXT INV DEF IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE DOT COLON UP UP_UP LEFT_PAR LEFT_BRK MINUS_GT }]
  [collectionKind ::= (*) SET , {LEFT_BRA }]
  [oclExpression ::= (*) oclExpression UP simpleName LEFT_PAR RIGHT_PAR , {EOF ENDPACKAGE CONTEXT INV DEF IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE DOT COLON UP UP_UP LEFT_PAR LEFT_BRK MINUS_GT }]
  [oclExpression ::= (*) oclExpression NE oclExpression , {EOF ENDPACKAGE CONTEXT INV DEF IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE DOT COLON UP UP_UP LEFT_PAR LEFT_BRK MINUS_GT }]
  [oclExpression ::= (*) oclExpression DIVIDE oclExpression , {EOF ENDPACKAGE CONTEXT INV DEF IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE DOT COLON UP UP_UP LEFT_PAR LEFT_BRK MINUS_GT }]
  [oclExpression ::= (*) oclExpression LEFT_PAR arguments RIGHT_PAR , {EOF ENDPACKAGE CONTEXT INV DEF IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE DOT COLON UP UP_UP LEFT_PAR LEFT_BRK MINUS_GT }]
  [primitiveLiteralExp ::= (*) FALSE , {EOF ENDPACKAGE CONTEXT INV DEF IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE DOT COLON UP UP_UP LEFT_PAR LEFT_BRK MINUS_GT }]
  [literalExp ::= (*) primitiveLiteralExp , {EOF ENDPACKAGE CONTEXT INV DEF IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE DOT COLON UP UP_UP LEFT_PAR LEFT_BRK MINUS_GT }]
  [oclExpression ::= (*) LET variableDeclarationList IN oclExpression , {EOF ENDPACKAGE CONTEXT INV DEF IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE DOT COLON UP UP_UP LEFT_PAR LEFT_BRK MINUS_GT }]
  [oclExpression ::= (*) oclExpression GT oclExpression , {EOF ENDPACKAGE CONTEXT INV DEF IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE DOT COLON UP UP_UP LEFT_PAR LEFT_BRK MINUS_GT }]
  [oclExpression ::= (*) oclExpression MINUS_GT ITERATE LEFT_PAR variableDeclaration BAR oclExpression RIGHT_PAR , {EOF ENDPACKAGE CONTEXT INV DEF IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE DOT COLON UP UP_UP LEFT_PAR LEFT_BRK MINUS_GT }]
  [oclExpression ::= (*) literalExp , {EOF ENDPACKAGE CONTEXT INV DEF IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE DOT COLON UP UP_UP LEFT_PAR LEFT_BRK MINUS_GT }]
  [primitiveLiteralExp ::= (*) INTEGER , {EOF ENDPACKAGE CONTEXT INV DEF IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE DOT COLON UP UP_UP LEFT_PAR LEFT_BRK MINUS_GT }]
  [collectionKind ::= (*) BAG , {LEFT_BRA }]
  [oclExpression ::= (*) oclExpression AND oclExpression , {EOF ENDPACKAGE CONTEXT INV DEF IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE DOT COLON UP UP_UP LEFT_PAR LEFT_BRK MINUS_GT }]
  [oclExpression ::= (*) oclExpression PLUS oclExpression , {EOF ENDPACKAGE CONTEXT INV DEF IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE DOT COLON UP UP_UP LEFT_PAR LEFT_BRK MINUS_GT }]
  [oclExpression ::= (*) oclExpression LEFT_PAR variableDeclaration BAR oclExpression RIGHT_PAR , {EOF ENDPACKAGE CONTEXT INV DEF IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE DOT COLON UP UP_UP LEFT_PAR LEFT_BRK MINUS_GT }]
  [pathName ::= (*) simpleName , {EOF ENDPACKAGE CONTEXT INV DEF IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE DOT COLON UP AT COLON_COLON UP_UP LEFT_PAR LEFT_BRK MINUS_GT }]
  [oclExpression ::= (*) oclExpression UP_UP simpleName LEFT_PAR oclMessageArgumentList RIGHT_PAR , {EOF ENDPACKAGE CONTEXT INV DEF IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE DOT COLON UP UP_UP LEFT_PAR LEFT_BRK MINUS_GT }]
  [oclExpression ::= (*) oclExpression LE oclExpression , {EOF ENDPACKAGE CONTEXT INV DEF IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE DOT COLON UP UP_UP LEFT_PAR LEFT_BRK MINUS_GT }]
  [oclExpression ::= (*) NOT oclExpression , {EOF ENDPACKAGE CONTEXT INV DEF IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE DOT COLON UP UP_UP LEFT_PAR LEFT_BRK MINUS_GT }]
  [oclExpression ::= (*) LEFT_PAR oclExpression RIGHT_PAR , {EOF ENDPACKAGE CONTEXT INV DEF IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE DOT COLON UP UP_UP LEFT_PAR LEFT_BRK MINUS_GT }]
  [primitiveLiteralExp ::= (*) REAL , {EOF ENDPACKAGE CONTEXT INV DEF IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE DOT COLON UP UP_UP LEFT_PAR LEFT_BRK MINUS_GT }]
  [collectionKind ::= (*) SEQUENCE , {LEFT_BRA }]
  [oclExpression ::= (*) oclExpression OR oclExpression , {EOF ENDPACKAGE CONTEXT INV DEF IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE DOT COLON UP UP_UP LEFT_PAR LEFT_BRK MINUS_GT }]
  [oclExpression ::= (*) oclExpression MINUS oclExpression , {EOF ENDPACKAGE CONTEXT INV DEF IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE DOT COLON UP UP_UP LEFT_PAR LEFT_BRK MINUS_GT }]
  [oclExpression ::= (*) oclExpression LEFT_BRK argumentList RIGHT_BRK isMarkedPre , {EOF ENDPACKAGE CONTEXT INV DEF IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE DOT COLON UP UP_UP LEFT_PAR LEFT_BRK MINUS_GT }]
  [pathName ::= (*) pathName COLON_COLON simpleName , {EOF ENDPACKAGE CONTEXT INV DEF IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE DOT COLON UP AT COLON_COLON UP_UP LEFT_PAR LEFT_BRK MINUS_GT }]
  [collectionLiteralExp ::= (*) collectionKind LEFT_BRA collectionLiteralParts RIGHT_BRA , {EOF ENDPACKAGE CONTEXT INV DEF IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE DOT COLON UP UP_UP LEFT_PAR LEFT_BRK MINUS_GT }]
  [oclExpression ::= (*) oclExpression UP_UP simpleName LEFT_PAR RIGHT_PAR , {EOF ENDPACKAGE CONTEXT INV DEF IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE DOT COLON UP UP_UP LEFT_PAR LEFT_BRK MINUS_GT }]
  [oclExpression ::= (*) oclExpression GE oclExpression , {EOF ENDPACKAGE CONTEXT INV DEF IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE DOT COLON UP UP_UP LEFT_PAR LEFT_BRK MINUS_GT }]
  [oclExpression ::= (*) MINUS oclExpression , {EOF ENDPACKAGE CONTEXT INV DEF IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE DOT COLON UP UP_UP LEFT_PAR LEFT_BRK MINUS_GT }]
  [oclExpression ::= (*) pathName isMarkedPre , {EOF ENDPACKAGE CONTEXT INV DEF IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE DOT COLON UP UP_UP LEFT_PAR LEFT_BRK MINUS_GT }]
  [primitiveLiteralExp ::= (*) STRING , {EOF ENDPACKAGE CONTEXT INV DEF IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE DOT COLON UP UP_UP LEFT_PAR LEFT_BRK MINUS_GT }]
  [collectionKind ::= (*) COLLECTION , {LEFT_BRA }]
  [literalExp ::= (*) collectionLiteralExp , {EOF ENDPACKAGE CONTEXT INV DEF IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE DOT COLON UP UP_UP LEFT_PAR LEFT_BRK MINUS_GT }]
  [oclExpression ::= (*) oclExpression XOR oclExpression , {EOF ENDPACKAGE CONTEXT INV DEF IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE DOT COLON UP UP_UP LEFT_PAR LEFT_BRK MINUS_GT }]
  [oclExpression ::= (*) IF oclExpression THEN oclExpression ELSE oclExpression ENDIF , {EOF ENDPACKAGE CONTEXT INV DEF IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE DOT COLON UP UP_UP LEFT_PAR LEFT_BRK MINUS_GT }]
  [oclExpression ::= (*) oclExpression MINUS_GT simpleName , {EOF ENDPACKAGE CONTEXT INV DEF IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE DOT COLON UP UP_UP LEFT_PAR LEFT_BRK MINUS_GT }]
  [simpleName ::= (*) SIMPLE_NAME , {EOF ENDPACKAGE CONTEXT INV DEF IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE DOT COLON UP AT COLON_COLON UP_UP LEFT_PAR LEFT_BRK MINUS_GT }]
  [collectionLiteralExp ::= (*) collectionKind LEFT_BRA RIGHT_BRA , {EOF ENDPACKAGE CONTEXT INV DEF IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE DOT COLON UP UP_UP LEFT_PAR LEFT_BRK MINUS_GT }]
}
transition on tupleLiteralExp to state [54]
transition on oclExpression to state [216]
transition on REAL to state [52]
transition on INTEGER to state [51]
transition on pathName to state [50]
transition on SIMPLE_NAME to state [12]
transition on LET to state [49]
transition on FALSE to state [48]
transition on MINUS to state [47]
transition on COLLECTION to state [28]
transition on SET to state [20]
transition on simpleName to state [26]
transition on collectionLiteralExp to state [46]
transition on LEFT_PAR to state [45]
transition on STRING to state [44]
transition on IF to state [43]
transition on TRUE to state [42]
transition on collectionKind to state [41]
transition on NOT to state [40]
transition on primitiveLiteralExp to state [39]
transition on TUPLE to state [38]
transition on literalExp to state [37]
transition on BAG to state [25]
transition on SEQUENCE to state [22]

-------------------
lalr_state [213]: {
  [invOrDef ::= invOrDef INV simpleName (*) COLON oclExpression , {EOF ENDPACKAGE CONTEXT INV DEF COLON }]
}
transition on COLON to state [214]

-------------------
lalr_state [214]: {
  [oclExpression ::= (*) oclExpression UP simpleName LEFT_PAR oclMessageArgumentList RIGHT_PAR , {EOF ENDPACKAGE CONTEXT INV DEF IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE DOT COLON UP UP_UP LEFT_PAR LEFT_BRK MINUS_GT }]
  [oclExpression ::= (*) oclExpression EQ oclExpression , {EOF ENDPACKAGE CONTEXT INV DEF IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE DOT COLON UP UP_UP LEFT_PAR LEFT_BRK MINUS_GT }]
  [oclExpression ::= (*) oclExpression TIMES oclExpression , {EOF ENDPACKAGE CONTEXT INV DEF IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE DOT COLON UP UP_UP LEFT_PAR LEFT_BRK MINUS_GT }]
  [oclExpression ::= (*) oclExpression DOT simpleName isMarkedPre , {EOF ENDPACKAGE CONTEXT INV DEF IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE DOT COLON UP UP_UP LEFT_PAR LEFT_BRK MINUS_GT }]
  [primitiveLiteralExp ::= (*) TRUE , {EOF ENDPACKAGE CONTEXT INV DEF IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE DOT COLON UP UP_UP LEFT_PAR LEFT_BRK MINUS_GT }]
  [literalExp ::= (*) tupleLiteralExp , {EOF ENDPACKAGE CONTEXT INV DEF IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE DOT COLON UP UP_UP LEFT_PAR LEFT_BRK MINUS_GT }]
  [oclExpression ::= (*) oclExpression IMPLIES oclExpression , {EOF ENDPACKAGE CONTEXT INV DEF IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE DOT COLON UP UP_UP LEFT_PAR LEFT_BRK MINUS_GT }]
  [oclExpression ::= (*) oclExpression LT oclExpression , {EOF ENDPACKAGE CONTEXT INV DEF IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE DOT COLON UP UP_UP LEFT_PAR LEFT_BRK MINUS_GT }]
  [oclExpression ::= (*) oclExpression MINUS_GT ITERATE LEFT_PAR variableDeclaration SEMICOLON variableDeclaration BAR oclExpression RIGHT_PAR , {EOF ENDPACKAGE CONTEXT INV DEF IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE DOT COLON UP UP_UP LEFT_PAR LEFT_BRK MINUS_GT }]
  [tupleLiteralExp ::= (*) TUPLE LEFT_BRA variableDeclarationList RIGHT_BRA , {EOF ENDPACKAGE CONTEXT INV DEF IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE DOT COLON UP UP_UP LEFT_PAR LEFT_BRK MINUS_GT }]
  [collectionKind ::= (*) SET , {LEFT_BRA }]
  [oclExpression ::= (*) oclExpression UP simpleName LEFT_PAR RIGHT_PAR , {EOF ENDPACKAGE CONTEXT INV DEF IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE DOT COLON UP UP_UP LEFT_PAR LEFT_BRK MINUS_GT }]
  [oclExpression ::= (*) oclExpression NE oclExpression , {EOF ENDPACKAGE CONTEXT INV DEF IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE DOT COLON UP UP_UP LEFT_PAR LEFT_BRK MINUS_GT }]
  [oclExpression ::= (*) oclExpression DIVIDE oclExpression , {EOF ENDPACKAGE CONTEXT INV DEF IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE DOT COLON UP UP_UP LEFT_PAR LEFT_BRK MINUS_GT }]
  [oclExpression ::= (*) oclExpression LEFT_PAR arguments RIGHT_PAR , {EOF ENDPACKAGE CONTEXT INV DEF IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE DOT COLON UP UP_UP LEFT_PAR LEFT_BRK MINUS_GT }]
  [primitiveLiteralExp ::= (*) FALSE , {EOF ENDPACKAGE CONTEXT INV DEF IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE DOT COLON UP UP_UP LEFT_PAR LEFT_BRK MINUS_GT }]
  [literalExp ::= (*) primitiveLiteralExp , {EOF ENDPACKAGE CONTEXT INV DEF IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE DOT COLON UP UP_UP LEFT_PAR LEFT_BRK MINUS_GT }]
  [oclExpression ::= (*) LET variableDeclarationList IN oclExpression , {EOF ENDPACKAGE CONTEXT INV DEF IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE DOT COLON UP UP_UP LEFT_PAR LEFT_BRK MINUS_GT }]
  [oclExpression ::= (*) oclExpression GT oclExpression , {EOF ENDPACKAGE CONTEXT INV DEF IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE DOT COLON UP UP_UP LEFT_PAR LEFT_BRK MINUS_GT }]
  [oclExpression ::= (*) oclExpression MINUS_GT ITERATE LEFT_PAR variableDeclaration BAR oclExpression RIGHT_PAR , {EOF ENDPACKAGE CONTEXT INV DEF IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE DOT COLON UP UP_UP LEFT_PAR LEFT_BRK MINUS_GT }]
  [oclExpression ::= (*) literalExp , {EOF ENDPACKAGE CONTEXT INV DEF IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE DOT COLON UP UP_UP LEFT_PAR LEFT_BRK MINUS_GT }]
  [primitiveLiteralExp ::= (*) INTEGER , {EOF ENDPACKAGE CONTEXT INV DEF IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE DOT COLON UP UP_UP LEFT_PAR LEFT_BRK MINUS_GT }]
  [collectionKind ::= (*) BAG , {LEFT_BRA }]
  [oclExpression ::= (*) oclExpression AND oclExpression , {EOF ENDPACKAGE CONTEXT INV DEF IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE DOT COLON UP UP_UP LEFT_PAR LEFT_BRK MINUS_GT }]
  [oclExpression ::= (*) oclExpression PLUS oclExpression , {EOF ENDPACKAGE CONTEXT INV DEF IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE DOT COLON UP UP_UP LEFT_PAR LEFT_BRK MINUS_GT }]
  [oclExpression ::= (*) oclExpression LEFT_PAR variableDeclaration BAR oclExpression RIGHT_PAR , {EOF ENDPACKAGE CONTEXT INV DEF IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE DOT COLON UP UP_UP LEFT_PAR LEFT_BRK MINUS_GT }]
  [pathName ::= (*) simpleName , {EOF ENDPACKAGE CONTEXT INV DEF IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE DOT COLON UP AT COLON_COLON UP_UP LEFT_PAR LEFT_BRK MINUS_GT }]
  [oclExpression ::= (*) oclExpression UP_UP simpleName LEFT_PAR oclMessageArgumentList RIGHT_PAR , {EOF ENDPACKAGE CONTEXT INV DEF IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE DOT COLON UP UP_UP LEFT_PAR LEFT_BRK MINUS_GT }]
  [oclExpression ::= (*) oclExpression LE oclExpression , {EOF ENDPACKAGE CONTEXT INV DEF IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE DOT COLON UP UP_UP LEFT_PAR LEFT_BRK MINUS_GT }]
  [oclExpression ::= (*) NOT oclExpression , {EOF ENDPACKAGE CONTEXT INV DEF IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE DOT COLON UP UP_UP LEFT_PAR LEFT_BRK MINUS_GT }]
  [oclExpression ::= (*) LEFT_PAR oclExpression RIGHT_PAR , {EOF ENDPACKAGE CONTEXT INV DEF IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE DOT COLON UP UP_UP LEFT_PAR LEFT_BRK MINUS_GT }]
  [primitiveLiteralExp ::= (*) REAL , {EOF ENDPACKAGE CONTEXT INV DEF IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE DOT COLON UP UP_UP LEFT_PAR LEFT_BRK MINUS_GT }]
  [collectionKind ::= (*) SEQUENCE , {LEFT_BRA }]
  [oclExpression ::= (*) oclExpression OR oclExpression , {EOF ENDPACKAGE CONTEXT INV DEF IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE DOT COLON UP UP_UP LEFT_PAR LEFT_BRK MINUS_GT }]
  [oclExpression ::= (*) oclExpression MINUS oclExpression , {EOF ENDPACKAGE CONTEXT INV DEF IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE DOT COLON UP UP_UP LEFT_PAR LEFT_BRK MINUS_GT }]
  [oclExpression ::= (*) oclExpression LEFT_BRK argumentList RIGHT_BRK isMarkedPre , {EOF ENDPACKAGE CONTEXT INV DEF IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE DOT COLON UP UP_UP LEFT_PAR LEFT_BRK MINUS_GT }]
  [pathName ::= (*) pathName COLON_COLON simpleName , {EOF ENDPACKAGE CONTEXT INV DEF IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE DOT COLON UP AT COLON_COLON UP_UP LEFT_PAR LEFT_BRK MINUS_GT }]
  [collectionLiteralExp ::= (*) collectionKind LEFT_BRA collectionLiteralParts RIGHT_BRA , {EOF ENDPACKAGE CONTEXT INV DEF IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE DOT COLON UP UP_UP LEFT_PAR LEFT_BRK MINUS_GT }]
  [oclExpression ::= (*) oclExpression UP_UP simpleName LEFT_PAR RIGHT_PAR , {EOF ENDPACKAGE CONTEXT INV DEF IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE DOT COLON UP UP_UP LEFT_PAR LEFT_BRK MINUS_GT }]
  [oclExpression ::= (*) oclExpression GE oclExpression , {EOF ENDPACKAGE CONTEXT INV DEF IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE DOT COLON UP UP_UP LEFT_PAR LEFT_BRK MINUS_GT }]
  [oclExpression ::= (*) MINUS oclExpression , {EOF ENDPACKAGE CONTEXT INV DEF IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE DOT COLON UP UP_UP LEFT_PAR LEFT_BRK MINUS_GT }]
  [oclExpression ::= (*) pathName isMarkedPre , {EOF ENDPACKAGE CONTEXT INV DEF IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE DOT COLON UP UP_UP LEFT_PAR LEFT_BRK MINUS_GT }]
  [primitiveLiteralExp ::= (*) STRING , {EOF ENDPACKAGE CONTEXT INV DEF IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE DOT COLON UP UP_UP LEFT_PAR LEFT_BRK MINUS_GT }]
  [collectionKind ::= (*) COLLECTION , {LEFT_BRA }]
  [literalExp ::= (*) collectionLiteralExp , {EOF ENDPACKAGE CONTEXT INV DEF IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE DOT COLON UP UP_UP LEFT_PAR LEFT_BRK MINUS_GT }]
  [oclExpression ::= (*) oclExpression XOR oclExpression , {EOF ENDPACKAGE CONTEXT INV DEF IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE DOT COLON UP UP_UP LEFT_PAR LEFT_BRK MINUS_GT }]
  [oclExpression ::= (*) IF oclExpression THEN oclExpression ELSE oclExpression ENDIF , {EOF ENDPACKAGE CONTEXT INV DEF IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE DOT COLON UP UP_UP LEFT_PAR LEFT_BRK MINUS_GT }]
  [oclExpression ::= (*) oclExpression MINUS_GT simpleName , {EOF ENDPACKAGE CONTEXT INV DEF IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE DOT COLON UP UP_UP LEFT_PAR LEFT_BRK MINUS_GT }]
  [invOrDef ::= invOrDef INV simpleName COLON (*) oclExpression , {EOF ENDPACKAGE CONTEXT INV DEF COLON }]
  [simpleName ::= (*) SIMPLE_NAME , {EOF ENDPACKAGE CONTEXT INV DEF IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE DOT COLON UP AT COLON_COLON UP_UP LEFT_PAR LEFT_BRK MINUS_GT }]
  [collectionLiteralExp ::= (*) collectionKind LEFT_BRA RIGHT_BRA , {EOF ENDPACKAGE CONTEXT INV DEF IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE DOT COLON UP UP_UP LEFT_PAR LEFT_BRK MINUS_GT }]
}
transition on tupleLiteralExp to state [54]
transition on oclExpression to state [215]
transition on REAL to state [52]
transition on INTEGER to state [51]
transition on pathName to state [50]
transition on SIMPLE_NAME to state [12]
transition on LET to state [49]
transition on FALSE to state [48]
transition on MINUS to state [47]
transition on COLLECTION to state [28]
transition on SET to state [20]
transition on simpleName to state [26]
transition on collectionLiteralExp to state [46]
transition on LEFT_PAR to state [45]
transition on STRING to state [44]
transition on IF to state [43]
transition on TRUE to state [42]
transition on collectionKind to state [41]
transition on NOT to state [40]
transition on primitiveLiteralExp to state [39]
transition on TUPLE to state [38]
transition on literalExp to state [37]
transition on BAG to state [25]
transition on SEQUENCE to state [22]

-------------------
lalr_state [215]: {
  [oclExpression ::= oclExpression (*) LEFT_BRK argumentList RIGHT_BRK isMarkedPre , {EOF ENDPACKAGE CONTEXT INV DEF IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE DOT COLON UP UP_UP LEFT_PAR LEFT_BRK MINUS_GT }]
  [oclExpression ::= oclExpression (*) EQ oclExpression , {EOF ENDPACKAGE CONTEXT INV DEF IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE DOT COLON UP UP_UP LEFT_PAR LEFT_BRK MINUS_GT }]
  [oclExpression ::= oclExpression (*) IMPLIES oclExpression , {EOF ENDPACKAGE CONTEXT INV DEF IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE DOT COLON UP UP_UP LEFT_PAR LEFT_BRK MINUS_GT }]
  [oclExpression ::= oclExpression (*) UP simpleName LEFT_PAR RIGHT_PAR , {EOF ENDPACKAGE CONTEXT INV DEF IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE DOT COLON UP UP_UP LEFT_PAR LEFT_BRK MINUS_GT }]
  [invOrDef ::= invOrDef INV simpleName COLON oclExpression (*) , {EOF ENDPACKAGE CONTEXT INV DEF COLON }]
  [oclExpression ::= oclExpression (*) LEFT_PAR arguments RIGHT_PAR , {EOF ENDPACKAGE CONTEXT INV DEF IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE DOT COLON UP UP_UP LEFT_PAR LEFT_BRK MINUS_GT }]
  [oclExpression ::= oclExpression (*) MINUS_GT ITERATE LEFT_PAR variableDeclaration BAR oclExpression RIGHT_PAR , {EOF ENDPACKAGE CONTEXT INV DEF IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE DOT COLON UP UP_UP LEFT_PAR LEFT_BRK MINUS_GT }]
  [oclExpression ::= oclExpression (*) PLUS oclExpression , {EOF ENDPACKAGE CONTEXT INV DEF IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE DOT COLON UP UP_UP LEFT_PAR LEFT_BRK MINUS_GT }]
  [oclExpression ::= oclExpression (*) LE oclExpression , {EOF ENDPACKAGE CONTEXT INV DEF IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE DOT COLON UP UP_UP LEFT_PAR LEFT_BRK MINUS_GT }]
  [oclExpression ::= oclExpression (*) OR oclExpression , {EOF ENDPACKAGE CONTEXT INV DEF IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE DOT COLON UP UP_UP LEFT_PAR LEFT_BRK MINUS_GT }]
  [oclExpression ::= oclExpression (*) UP_UP simpleName LEFT_PAR RIGHT_PAR , {EOF ENDPACKAGE CONTEXT INV DEF IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE DOT COLON UP UP_UP LEFT_PAR LEFT_BRK MINUS_GT }]
  [oclExpression ::= oclExpression (*) MINUS_GT simpleName , {EOF ENDPACKAGE CONTEXT INV DEF IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE DOT COLON UP UP_UP LEFT_PAR LEFT_BRK MINUS_GT }]
  [oclExpression ::= oclExpression (*) TIMES oclExpression , {EOF ENDPACKAGE CONTEXT INV DEF IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE DOT COLON UP UP_UP LEFT_PAR LEFT_BRK MINUS_GT }]
  [oclExpression ::= oclExpression (*) LT oclExpression , {EOF ENDPACKAGE CONTEXT INV DEF IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE DOT COLON UP UP_UP LEFT_PAR LEFT_BRK MINUS_GT }]
  [oclExpression ::= oclExpression (*) NE oclExpression , {EOF ENDPACKAGE CONTEXT INV DEF IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE DOT COLON UP UP_UP LEFT_PAR LEFT_BRK MINUS_GT }]
  [oclExpression ::= oclExpression (*) LEFT_PAR variableDeclaration BAR oclExpression RIGHT_PAR , {EOF ENDPACKAGE CONTEXT INV DEF IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE DOT COLON UP UP_UP LEFT_PAR LEFT_BRK MINUS_GT }]
  [oclExpression ::= oclExpression (*) MINUS oclExpression , {EOF ENDPACKAGE CONTEXT INV DEF IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE DOT COLON UP UP_UP LEFT_PAR LEFT_BRK MINUS_GT }]
  [oclExpression ::= oclExpression (*) GE oclExpression , {EOF ENDPACKAGE CONTEXT INV DEF IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE DOT COLON UP UP_UP LEFT_PAR LEFT_BRK MINUS_GT }]
  [oclExpression ::= oclExpression (*) XOR oclExpression , {EOF ENDPACKAGE CONTEXT INV DEF IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE DOT COLON UP UP_UP LEFT_PAR LEFT_BRK MINUS_GT }]
  [oclExpression ::= oclExpression (*) UP simpleName LEFT_PAR oclMessageArgumentList RIGHT_PAR , {EOF ENDPACKAGE CONTEXT INV DEF IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE DOT COLON UP UP_UP LEFT_PAR LEFT_BRK MINUS_GT }]
  [oclExpression ::= oclExpression (*) DOT simpleName isMarkedPre , {EOF ENDPACKAGE CONTEXT INV DEF IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE DOT COLON UP UP_UP LEFT_PAR LEFT_BRK MINUS_GT }]
  [oclExpression ::= oclExpression (*) MINUS_GT ITERATE LEFT_PAR variableDeclaration SEMICOLON variableDeclaration BAR oclExpression RIGHT_PAR , {EOF ENDPACKAGE CONTEXT INV DEF IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE DOT COLON UP UP_UP LEFT_PAR LEFT_BRK MINUS_GT }]
  [oclExpression ::= oclExpression (*) DIVIDE oclExpression , {EOF ENDPACKAGE CONTEXT INV DEF IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE DOT COLON UP UP_UP LEFT_PAR LEFT_BRK MINUS_GT }]
  [oclExpression ::= oclExpression (*) GT oclExpression , {EOF ENDPACKAGE CONTEXT INV DEF IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE DOT COLON UP UP_UP LEFT_PAR LEFT_BRK MINUS_GT }]
  [oclExpression ::= oclExpression (*) AND oclExpression , {EOF ENDPACKAGE CONTEXT INV DEF IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE DOT COLON UP UP_UP LEFT_PAR LEFT_BRK MINUS_GT }]
  [oclExpression ::= oclExpression (*) UP_UP simpleName LEFT_PAR oclMessageArgumentList RIGHT_PAR , {EOF ENDPACKAGE CONTEXT INV DEF IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE DOT COLON UP UP_UP LEFT_PAR LEFT_BRK MINUS_GT }]
}
transition on XOR to state [74]
transition on EQ to state [73]
transition on DOT to state [72]
transition on MINUS to state [71]
transition on GE to state [70]
transition on LEFT_BRK to state [69]
transition on DIVIDE to state [68]
transition on LEFT_PAR to state [67]
transition on MINUS_GT to state [66]
transition on LE to state [65]
transition on GT to state [64]
transition on IMPLIES to state [63]
transition on UP to state [62]
transition on UP_UP to state [61]
transition on OR to state [60]
transition on PLUS to state [59]
transition on NE to state [58]
transition on LT to state [57]
transition on AND to state [56]
transition on TIMES to state [55]

-------------------
lalr_state [216]: {
  [oclExpression ::= oclExpression (*) LEFT_BRK argumentList RIGHT_BRK isMarkedPre , {EOF ENDPACKAGE CONTEXT INV DEF IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE DOT COLON UP UP_UP LEFT_PAR LEFT_BRK MINUS_GT }]
  [oclExpression ::= oclExpression (*) EQ oclExpression , {EOF ENDPACKAGE CONTEXT INV DEF IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE DOT COLON UP UP_UP LEFT_PAR LEFT_BRK MINUS_GT }]
  [oclExpression ::= oclExpression (*) IMPLIES oclExpression , {EOF ENDPACKAGE CONTEXT INV DEF IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE DOT COLON UP UP_UP LEFT_PAR LEFT_BRK MINUS_GT }]
  [oclExpression ::= oclExpression (*) UP simpleName LEFT_PAR RIGHT_PAR , {EOF ENDPACKAGE CONTEXT INV DEF IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE DOT COLON UP UP_UP LEFT_PAR LEFT_BRK MINUS_GT }]
  [oclExpression ::= oclExpression (*) LEFT_PAR arguments RIGHT_PAR , {EOF ENDPACKAGE CONTEXT INV DEF IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE DOT COLON UP UP_UP LEFT_PAR LEFT_BRK MINUS_GT }]
  [oclExpression ::= oclExpression (*) MINUS_GT ITERATE LEFT_PAR variableDeclaration BAR oclExpression RIGHT_PAR , {EOF ENDPACKAGE CONTEXT INV DEF IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE DOT COLON UP UP_UP LEFT_PAR LEFT_BRK MINUS_GT }]
  [oclExpression ::= oclExpression (*) PLUS oclExpression , {EOF ENDPACKAGE CONTEXT INV DEF IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE DOT COLON UP UP_UP LEFT_PAR LEFT_BRK MINUS_GT }]
  [oclExpression ::= oclExpression (*) LE oclExpression , {EOF ENDPACKAGE CONTEXT INV DEF IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE DOT COLON UP UP_UP LEFT_PAR LEFT_BRK MINUS_GT }]
  [oclExpression ::= oclExpression (*) OR oclExpression , {EOF ENDPACKAGE CONTEXT INV DEF IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE DOT COLON UP UP_UP LEFT_PAR LEFT_BRK MINUS_GT }]
  [oclExpression ::= oclExpression (*) UP_UP simpleName LEFT_PAR RIGHT_PAR , {EOF ENDPACKAGE CONTEXT INV DEF IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE DOT COLON UP UP_UP LEFT_PAR LEFT_BRK MINUS_GT }]
  [oclExpression ::= oclExpression (*) MINUS_GT simpleName , {EOF ENDPACKAGE CONTEXT INV DEF IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE DOT COLON UP UP_UP LEFT_PAR LEFT_BRK MINUS_GT }]
  [oclExpression ::= oclExpression (*) TIMES oclExpression , {EOF ENDPACKAGE CONTEXT INV DEF IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE DOT COLON UP UP_UP LEFT_PAR LEFT_BRK MINUS_GT }]
  [oclExpression ::= oclExpression (*) LT oclExpression , {EOF ENDPACKAGE CONTEXT INV DEF IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE DOT COLON UP UP_UP LEFT_PAR LEFT_BRK MINUS_GT }]
  [oclExpression ::= oclExpression (*) NE oclExpression , {EOF ENDPACKAGE CONTEXT INV DEF IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE DOT COLON UP UP_UP LEFT_PAR LEFT_BRK MINUS_GT }]
  [invOrDef ::= invOrDef INV COLON oclExpression (*) , {EOF ENDPACKAGE CONTEXT INV DEF COLON }]
  [oclExpression ::= oclExpression (*) LEFT_PAR variableDeclaration BAR oclExpression RIGHT_PAR , {EOF ENDPACKAGE CONTEXT INV DEF IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE DOT COLON UP UP_UP LEFT_PAR LEFT_BRK MINUS_GT }]
  [oclExpression ::= oclExpression (*) MINUS oclExpression , {EOF ENDPACKAGE CONTEXT INV DEF IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE DOT COLON UP UP_UP LEFT_PAR LEFT_BRK MINUS_GT }]
  [oclExpression ::= oclExpression (*) GE oclExpression , {EOF ENDPACKAGE CONTEXT INV DEF IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE DOT COLON UP UP_UP LEFT_PAR LEFT_BRK MINUS_GT }]
  [oclExpression ::= oclExpression (*) XOR oclExpression , {EOF ENDPACKAGE CONTEXT INV DEF IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE DOT COLON UP UP_UP LEFT_PAR LEFT_BRK MINUS_GT }]
  [oclExpression ::= oclExpression (*) UP simpleName LEFT_PAR oclMessageArgumentList RIGHT_PAR , {EOF ENDPACKAGE CONTEXT INV DEF IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE DOT COLON UP UP_UP LEFT_PAR LEFT_BRK MINUS_GT }]
  [oclExpression ::= oclExpression (*) DOT simpleName isMarkedPre , {EOF ENDPACKAGE CONTEXT INV DEF IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE DOT COLON UP UP_UP LEFT_PAR LEFT_BRK MINUS_GT }]
  [oclExpression ::= oclExpression (*) MINUS_GT ITERATE LEFT_PAR variableDeclaration SEMICOLON variableDeclaration BAR oclExpression RIGHT_PAR , {EOF ENDPACKAGE CONTEXT INV DEF IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE DOT COLON UP UP_UP LEFT_PAR LEFT_BRK MINUS_GT }]
  [oclExpression ::= oclExpression (*) DIVIDE oclExpression , {EOF ENDPACKAGE CONTEXT INV DEF IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE DOT COLON UP UP_UP LEFT_PAR LEFT_BRK MINUS_GT }]
  [oclExpression ::= oclExpression (*) GT oclExpression , {EOF ENDPACKAGE CONTEXT INV DEF IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE DOT COLON UP UP_UP LEFT_PAR LEFT_BRK MINUS_GT }]
  [oclExpression ::= oclExpression (*) AND oclExpression , {EOF ENDPACKAGE CONTEXT INV DEF IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE DOT COLON UP UP_UP LEFT_PAR LEFT_BRK MINUS_GT }]
  [oclExpression ::= oclExpression (*) UP_UP simpleName LEFT_PAR oclMessageArgumentList RIGHT_PAR , {EOF ENDPACKAGE CONTEXT INV DEF IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE DOT COLON UP UP_UP LEFT_PAR LEFT_BRK MINUS_GT }]
}
transition on XOR to state [74]
transition on EQ to state [73]
transition on DOT to state [72]
transition on MINUS to state [71]
transition on GE to state [70]
transition on LEFT_BRK to state [69]
transition on DIVIDE to state [68]
transition on LEFT_PAR to state [67]
transition on MINUS_GT to state [66]
transition on LE to state [65]
transition on GT to state [64]
transition on IMPLIES to state [63]
transition on UP to state [62]
transition on UP_UP to state [61]
transition on OR to state [60]
transition on PLUS to state [59]
transition on NE to state [58]
transition on LT to state [57]
transition on AND to state [56]
transition on TIMES to state [55]

-------------------
lalr_state [217]: {
  [defExpression ::= operation (*) EQ oclExpression , {EOF ENDPACKAGE CONTEXT INV DEF COLON }]
}
transition on EQ to state [224]

-------------------
lalr_state [218]: {
  [invOrDef ::= invOrDef COLON defExpression (*) , {EOF ENDPACKAGE CONTEXT INV DEF COLON }]
}

-------------------
lalr_state [219]: {
  [operation ::= pathName (*) COLON_COLON simpleName LEFT_PAR variableDeclarationList RIGHT_PAR , {EQ }]
  [operation ::= pathName (*) COLON_COLON simpleName LEFT_PAR RIGHT_PAR , {EQ }]
  [operation ::= pathName (*) COLON_COLON simpleName LEFT_PAR variableDeclarationList RIGHT_PAR COLON type , {EQ }]
  [operation ::= pathName (*) COLON_COLON simpleName LEFT_PAR RIGHT_PAR COLON type , {EQ }]
  [pathName ::= pathName (*) COLON_COLON simpleName , {COLON_COLON }]
}
transition on COLON_COLON to state [179]

-------------------
lalr_state [220]: {
  [pathName ::= simpleName (*) , {COLON_COLON }]
  [variableDeclaration ::= simpleName (*) COLON type , {EQ }]
  [operation ::= simpleName (*) LEFT_PAR variableDeclarationList RIGHT_PAR , {EQ }]
  [variableDeclaration ::= simpleName (*) , {EQ }]
  [variableDeclaration ::= simpleName (*) COLON type EQ oclExpression , {EQ }]
  [operation ::= simpleName (*) LEFT_PAR RIGHT_PAR , {EQ }]
  [operation ::= simpleName (*) LEFT_PAR variableDeclarationList RIGHT_PAR COLON type , {EQ }]
  [variableDeclaration ::= simpleName (*) EQ oclExpression , {EQ }]
  [operation ::= simpleName (*) LEFT_PAR RIGHT_PAR COLON type , {EQ }]
}
transition on COLON to state [19]
transition on EQ to state [18]
transition on LEFT_PAR to state [13]

-------------------
lalr_state [221]: {
  [defExpression ::= variableDeclaration (*) EQ oclExpression , {EOF ENDPACKAGE CONTEXT INV DEF COLON }]
}
transition on EQ to state [222]

-------------------
lalr_state [222]: {
  [oclExpression ::= (*) oclExpression UP simpleName LEFT_PAR oclMessageArgumentList RIGHT_PAR , {EOF ENDPACKAGE CONTEXT INV DEF IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE DOT COLON UP UP_UP LEFT_PAR LEFT_BRK MINUS_GT }]
  [oclExpression ::= (*) oclExpression EQ oclExpression , {EOF ENDPACKAGE CONTEXT INV DEF IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE DOT COLON UP UP_UP LEFT_PAR LEFT_BRK MINUS_GT }]
  [oclExpression ::= (*) oclExpression TIMES oclExpression , {EOF ENDPACKAGE CONTEXT INV DEF IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE DOT COLON UP UP_UP LEFT_PAR LEFT_BRK MINUS_GT }]
  [oclExpression ::= (*) oclExpression DOT simpleName isMarkedPre , {EOF ENDPACKAGE CONTEXT INV DEF IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE DOT COLON UP UP_UP LEFT_PAR LEFT_BRK MINUS_GT }]
  [primitiveLiteralExp ::= (*) TRUE , {EOF ENDPACKAGE CONTEXT INV DEF IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE DOT COLON UP UP_UP LEFT_PAR LEFT_BRK MINUS_GT }]
  [literalExp ::= (*) tupleLiteralExp , {EOF ENDPACKAGE CONTEXT INV DEF IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE DOT COLON UP UP_UP LEFT_PAR LEFT_BRK MINUS_GT }]
  [oclExpression ::= (*) oclExpression IMPLIES oclExpression , {EOF ENDPACKAGE CONTEXT INV DEF IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE DOT COLON UP UP_UP LEFT_PAR LEFT_BRK MINUS_GT }]
  [oclExpression ::= (*) oclExpression LT oclExpression , {EOF ENDPACKAGE CONTEXT INV DEF IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE DOT COLON UP UP_UP LEFT_PAR LEFT_BRK MINUS_GT }]
  [oclExpression ::= (*) oclExpression MINUS_GT ITERATE LEFT_PAR variableDeclaration SEMICOLON variableDeclaration BAR oclExpression RIGHT_PAR , {EOF ENDPACKAGE CONTEXT INV DEF IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE DOT COLON UP UP_UP LEFT_PAR LEFT_BRK MINUS_GT }]
  [tupleLiteralExp ::= (*) TUPLE LEFT_BRA variableDeclarationList RIGHT_BRA , {EOF ENDPACKAGE CONTEXT INV DEF IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE DOT COLON UP UP_UP LEFT_PAR LEFT_BRK MINUS_GT }]
  [collectionKind ::= (*) SET , {LEFT_BRA }]
  [oclExpression ::= (*) oclExpression UP simpleName LEFT_PAR RIGHT_PAR , {EOF ENDPACKAGE CONTEXT INV DEF IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE DOT COLON UP UP_UP LEFT_PAR LEFT_BRK MINUS_GT }]
  [oclExpression ::= (*) oclExpression NE oclExpression , {EOF ENDPACKAGE CONTEXT INV DEF IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE DOT COLON UP UP_UP LEFT_PAR LEFT_BRK MINUS_GT }]
  [oclExpression ::= (*) oclExpression DIVIDE oclExpression , {EOF ENDPACKAGE CONTEXT INV DEF IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE DOT COLON UP UP_UP LEFT_PAR LEFT_BRK MINUS_GT }]
  [oclExpression ::= (*) oclExpression LEFT_PAR arguments RIGHT_PAR , {EOF ENDPACKAGE CONTEXT INV DEF IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE DOT COLON UP UP_UP LEFT_PAR LEFT_BRK MINUS_GT }]
  [primitiveLiteralExp ::= (*) FALSE , {EOF ENDPACKAGE CONTEXT INV DEF IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE DOT COLON UP UP_UP LEFT_PAR LEFT_BRK MINUS_GT }]
  [literalExp ::= (*) primitiveLiteralExp , {EOF ENDPACKAGE CONTEXT INV DEF IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE DOT COLON UP UP_UP LEFT_PAR LEFT_BRK MINUS_GT }]
  [oclExpression ::= (*) LET variableDeclarationList IN oclExpression , {EOF ENDPACKAGE CONTEXT INV DEF IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE DOT COLON UP UP_UP LEFT_PAR LEFT_BRK MINUS_GT }]
  [oclExpression ::= (*) oclExpression GT oclExpression , {EOF ENDPACKAGE CONTEXT INV DEF IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE DOT COLON UP UP_UP LEFT_PAR LEFT_BRK MINUS_GT }]
  [oclExpression ::= (*) oclExpression MINUS_GT ITERATE LEFT_PAR variableDeclaration BAR oclExpression RIGHT_PAR , {EOF ENDPACKAGE CONTEXT INV DEF IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE DOT COLON UP UP_UP LEFT_PAR LEFT_BRK MINUS_GT }]
  [oclExpression ::= (*) literalExp , {EOF ENDPACKAGE CONTEXT INV DEF IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE DOT COLON UP UP_UP LEFT_PAR LEFT_BRK MINUS_GT }]
  [primitiveLiteralExp ::= (*) INTEGER , {EOF ENDPACKAGE CONTEXT INV DEF IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE DOT COLON UP UP_UP LEFT_PAR LEFT_BRK MINUS_GT }]
  [collectionKind ::= (*) BAG , {LEFT_BRA }]
  [oclExpression ::= (*) oclExpression AND oclExpression , {EOF ENDPACKAGE CONTEXT INV DEF IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE DOT COLON UP UP_UP LEFT_PAR LEFT_BRK MINUS_GT }]
  [oclExpression ::= (*) oclExpression PLUS oclExpression , {EOF ENDPACKAGE CONTEXT INV DEF IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE DOT COLON UP UP_UP LEFT_PAR LEFT_BRK MINUS_GT }]
  [oclExpression ::= (*) oclExpression LEFT_PAR variableDeclaration BAR oclExpression RIGHT_PAR , {EOF ENDPACKAGE CONTEXT INV DEF IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE DOT COLON UP UP_UP LEFT_PAR LEFT_BRK MINUS_GT }]
  [pathName ::= (*) simpleName , {EOF ENDPACKAGE CONTEXT INV DEF IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE DOT COLON UP AT COLON_COLON UP_UP LEFT_PAR LEFT_BRK MINUS_GT }]
  [oclExpression ::= (*) oclExpression UP_UP simpleName LEFT_PAR oclMessageArgumentList RIGHT_PAR , {EOF ENDPACKAGE CONTEXT INV DEF IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE DOT COLON UP UP_UP LEFT_PAR LEFT_BRK MINUS_GT }]
  [oclExpression ::= (*) oclExpression LE oclExpression , {EOF ENDPACKAGE CONTEXT INV DEF IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE DOT COLON UP UP_UP LEFT_PAR LEFT_BRK MINUS_GT }]
  [oclExpression ::= (*) NOT oclExpression , {EOF ENDPACKAGE CONTEXT INV DEF IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE DOT COLON UP UP_UP LEFT_PAR LEFT_BRK MINUS_GT }]
  [oclExpression ::= (*) LEFT_PAR oclExpression RIGHT_PAR , {EOF ENDPACKAGE CONTEXT INV DEF IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE DOT COLON UP UP_UP LEFT_PAR LEFT_BRK MINUS_GT }]
  [primitiveLiteralExp ::= (*) REAL , {EOF ENDPACKAGE CONTEXT INV DEF IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE DOT COLON UP UP_UP LEFT_PAR LEFT_BRK MINUS_GT }]
  [collectionKind ::= (*) SEQUENCE , {LEFT_BRA }]
  [oclExpression ::= (*) oclExpression OR oclExpression , {EOF ENDPACKAGE CONTEXT INV DEF IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE DOT COLON UP UP_UP LEFT_PAR LEFT_BRK MINUS_GT }]
  [oclExpression ::= (*) oclExpression MINUS oclExpression , {EOF ENDPACKAGE CONTEXT INV DEF IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE DOT COLON UP UP_UP LEFT_PAR LEFT_BRK MINUS_GT }]
  [oclExpression ::= (*) oclExpression LEFT_BRK argumentList RIGHT_BRK isMarkedPre , {EOF ENDPACKAGE CONTEXT INV DEF IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE DOT COLON UP UP_UP LEFT_PAR LEFT_BRK MINUS_GT }]
  [pathName ::= (*) pathName COLON_COLON simpleName , {EOF ENDPACKAGE CONTEXT INV DEF IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE DOT COLON UP AT COLON_COLON UP_UP LEFT_PAR LEFT_BRK MINUS_GT }]
  [collectionLiteralExp ::= (*) collectionKind LEFT_BRA collectionLiteralParts RIGHT_BRA , {EOF ENDPACKAGE CONTEXT INV DEF IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE DOT COLON UP UP_UP LEFT_PAR LEFT_BRK MINUS_GT }]
  [oclExpression ::= (*) oclExpression UP_UP simpleName LEFT_PAR RIGHT_PAR , {EOF ENDPACKAGE CONTEXT INV DEF IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE DOT COLON UP UP_UP LEFT_PAR LEFT_BRK MINUS_GT }]
  [oclExpression ::= (*) oclExpression GE oclExpression , {EOF ENDPACKAGE CONTEXT INV DEF IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE DOT COLON UP UP_UP LEFT_PAR LEFT_BRK MINUS_GT }]
  [oclExpression ::= (*) MINUS oclExpression , {EOF ENDPACKAGE CONTEXT INV DEF IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE DOT COLON UP UP_UP LEFT_PAR LEFT_BRK MINUS_GT }]
  [oclExpression ::= (*) pathName isMarkedPre , {EOF ENDPACKAGE CONTEXT INV DEF IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE DOT COLON UP UP_UP LEFT_PAR LEFT_BRK MINUS_GT }]
  [defExpression ::= variableDeclaration EQ (*) oclExpression , {EOF ENDPACKAGE CONTEXT INV DEF COLON }]
  [primitiveLiteralExp ::= (*) STRING , {EOF ENDPACKAGE CONTEXT INV DEF IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE DOT COLON UP UP_UP LEFT_PAR LEFT_BRK MINUS_GT }]
  [collectionKind ::= (*) COLLECTION , {LEFT_BRA }]
  [literalExp ::= (*) collectionLiteralExp , {EOF ENDPACKAGE CONTEXT INV DEF IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE DOT COLON UP UP_UP LEFT_PAR LEFT_BRK MINUS_GT }]
  [oclExpression ::= (*) oclExpression XOR oclExpression , {EOF ENDPACKAGE CONTEXT INV DEF IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE DOT COLON UP UP_UP LEFT_PAR LEFT_BRK MINUS_GT }]
  [oclExpression ::= (*) IF oclExpression THEN oclExpression ELSE oclExpression ENDIF , {EOF ENDPACKAGE CONTEXT INV DEF IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE DOT COLON UP UP_UP LEFT_PAR LEFT_BRK MINUS_GT }]
  [oclExpression ::= (*) oclExpression MINUS_GT simpleName , {EOF ENDPACKAGE CONTEXT INV DEF IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE DOT COLON UP UP_UP LEFT_PAR LEFT_BRK MINUS_GT }]
  [simpleName ::= (*) SIMPLE_NAME , {EOF ENDPACKAGE CONTEXT INV DEF IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE DOT COLON UP AT COLON_COLON UP_UP LEFT_PAR LEFT_BRK MINUS_GT }]
  [collectionLiteralExp ::= (*) collectionKind LEFT_BRA RIGHT_BRA , {EOF ENDPACKAGE CONTEXT INV DEF IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE DOT COLON UP UP_UP LEFT_PAR LEFT_BRK MINUS_GT }]
}
transition on tupleLiteralExp to state [54]
transition on oclExpression to state [223]
transition on REAL to state [52]
transition on INTEGER to state [51]
transition on pathName to state [50]
transition on SIMPLE_NAME to state [12]
transition on LET to state [49]
transition on FALSE to state [48]
transition on MINUS to state [47]
transition on COLLECTION to state [28]
transition on SET to state [20]
transition on simpleName to state [26]
transition on collectionLiteralExp to state [46]
transition on LEFT_PAR to state [45]
transition on STRING to state [44]
transition on IF to state [43]
transition on TRUE to state [42]
transition on collectionKind to state [41]
transition on NOT to state [40]
transition on primitiveLiteralExp to state [39]
transition on TUPLE to state [38]
transition on literalExp to state [37]
transition on BAG to state [25]
transition on SEQUENCE to state [22]

-------------------
lalr_state [223]: {
  [oclExpression ::= oclExpression (*) LEFT_BRK argumentList RIGHT_BRK isMarkedPre , {EOF ENDPACKAGE CONTEXT INV DEF IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE DOT COLON UP UP_UP LEFT_PAR LEFT_BRK MINUS_GT }]
  [oclExpression ::= oclExpression (*) EQ oclExpression , {EOF ENDPACKAGE CONTEXT INV DEF IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE DOT COLON UP UP_UP LEFT_PAR LEFT_BRK MINUS_GT }]
  [oclExpression ::= oclExpression (*) IMPLIES oclExpression , {EOF ENDPACKAGE CONTEXT INV DEF IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE DOT COLON UP UP_UP LEFT_PAR LEFT_BRK MINUS_GT }]
  [oclExpression ::= oclExpression (*) UP simpleName LEFT_PAR RIGHT_PAR , {EOF ENDPACKAGE CONTEXT INV DEF IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE DOT COLON UP UP_UP LEFT_PAR LEFT_BRK MINUS_GT }]
  [oclExpression ::= oclExpression (*) LEFT_PAR arguments RIGHT_PAR , {EOF ENDPACKAGE CONTEXT INV DEF IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE DOT COLON UP UP_UP LEFT_PAR LEFT_BRK MINUS_GT }]
  [oclExpression ::= oclExpression (*) MINUS_GT ITERATE LEFT_PAR variableDeclaration BAR oclExpression RIGHT_PAR , {EOF ENDPACKAGE CONTEXT INV DEF IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE DOT COLON UP UP_UP LEFT_PAR LEFT_BRK MINUS_GT }]
  [oclExpression ::= oclExpression (*) PLUS oclExpression , {EOF ENDPACKAGE CONTEXT INV DEF IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE DOT COLON UP UP_UP LEFT_PAR LEFT_BRK MINUS_GT }]
  [oclExpression ::= oclExpression (*) LE oclExpression , {EOF ENDPACKAGE CONTEXT INV DEF IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE DOT COLON UP UP_UP LEFT_PAR LEFT_BRK MINUS_GT }]
  [oclExpression ::= oclExpression (*) OR oclExpression , {EOF ENDPACKAGE CONTEXT INV DEF IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE DOT COLON UP UP_UP LEFT_PAR LEFT_BRK MINUS_GT }]
  [oclExpression ::= oclExpression (*) UP_UP simpleName LEFT_PAR RIGHT_PAR , {EOF ENDPACKAGE CONTEXT INV DEF IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE DOT COLON UP UP_UP LEFT_PAR LEFT_BRK MINUS_GT }]
  [oclExpression ::= oclExpression (*) MINUS_GT simpleName , {EOF ENDPACKAGE CONTEXT INV DEF IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE DOT COLON UP UP_UP LEFT_PAR LEFT_BRK MINUS_GT }]
  [oclExpression ::= oclExpression (*) TIMES oclExpression , {EOF ENDPACKAGE CONTEXT INV DEF IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE DOT COLON UP UP_UP LEFT_PAR LEFT_BRK MINUS_GT }]
  [oclExpression ::= oclExpression (*) LT oclExpression , {EOF ENDPACKAGE CONTEXT INV DEF IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE DOT COLON UP UP_UP LEFT_PAR LEFT_BRK MINUS_GT }]
  [oclExpression ::= oclExpression (*) NE oclExpression , {EOF ENDPACKAGE CONTEXT INV DEF IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE DOT COLON UP UP_UP LEFT_PAR LEFT_BRK MINUS_GT }]
  [oclExpression ::= oclExpression (*) LEFT_PAR variableDeclaration BAR oclExpression RIGHT_PAR , {EOF ENDPACKAGE CONTEXT INV DEF IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE DOT COLON UP UP_UP LEFT_PAR LEFT_BRK MINUS_GT }]
  [oclExpression ::= oclExpression (*) MINUS oclExpression , {EOF ENDPACKAGE CONTEXT INV DEF IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE DOT COLON UP UP_UP LEFT_PAR LEFT_BRK MINUS_GT }]
  [oclExpression ::= oclExpression (*) GE oclExpression , {EOF ENDPACKAGE CONTEXT INV DEF IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE DOT COLON UP UP_UP LEFT_PAR LEFT_BRK MINUS_GT }]
  [oclExpression ::= oclExpression (*) XOR oclExpression , {EOF ENDPACKAGE CONTEXT INV DEF IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE DOT COLON UP UP_UP LEFT_PAR LEFT_BRK MINUS_GT }]
  [oclExpression ::= oclExpression (*) UP simpleName LEFT_PAR oclMessageArgumentList RIGHT_PAR , {EOF ENDPACKAGE CONTEXT INV DEF IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE DOT COLON UP UP_UP LEFT_PAR LEFT_BRK MINUS_GT }]
  [defExpression ::= variableDeclaration EQ oclExpression (*) , {EOF ENDPACKAGE CONTEXT INV DEF COLON }]
  [oclExpression ::= oclExpression (*) DOT simpleName isMarkedPre , {EOF ENDPACKAGE CONTEXT INV DEF IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE DOT COLON UP UP_UP LEFT_PAR LEFT_BRK MINUS_GT }]
  [oclExpression ::= oclExpression (*) MINUS_GT ITERATE LEFT_PAR variableDeclaration SEMICOLON variableDeclaration BAR oclExpression RIGHT_PAR , {EOF ENDPACKAGE CONTEXT INV DEF IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE DOT COLON UP UP_UP LEFT_PAR LEFT_BRK MINUS_GT }]
  [oclExpression ::= oclExpression (*) DIVIDE oclExpression , {EOF ENDPACKAGE CONTEXT INV DEF IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE DOT COLON UP UP_UP LEFT_PAR LEFT_BRK MINUS_GT }]
  [oclExpression ::= oclExpression (*) GT oclExpression , {EOF ENDPACKAGE CONTEXT INV DEF IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE DOT COLON UP UP_UP LEFT_PAR LEFT_BRK MINUS_GT }]
  [oclExpression ::= oclExpression (*) AND oclExpression , {EOF ENDPACKAGE CONTEXT INV DEF IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE DOT COLON UP UP_UP LEFT_PAR LEFT_BRK MINUS_GT }]
  [oclExpression ::= oclExpression (*) UP_UP simpleName LEFT_PAR oclMessageArgumentList RIGHT_PAR , {EOF ENDPACKAGE CONTEXT INV DEF IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE DOT COLON UP UP_UP LEFT_PAR LEFT_BRK MINUS_GT }]
}
transition on XOR to state [74]
transition on EQ to state [73]
transition on DOT to state [72]
transition on MINUS to state [71]
transition on GE to state [70]
transition on LEFT_BRK to state [69]
transition on DIVIDE to state [68]
transition on LEFT_PAR to state [67]
transition on MINUS_GT to state [66]
transition on LE to state [65]
transition on GT to state [64]
transition on IMPLIES to state [63]
transition on UP to state [62]
transition on UP_UP to state [61]
transition on OR to state [60]
transition on PLUS to state [59]
transition on NE to state [58]
transition on LT to state [57]
transition on AND to state [56]
transition on TIMES to state [55]

-------------------
lalr_state [224]: {
  [oclExpression ::= (*) oclExpression UP simpleName LEFT_PAR oclMessageArgumentList RIGHT_PAR , {EOF ENDPACKAGE CONTEXT INV DEF IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE DOT COLON UP UP_UP LEFT_PAR LEFT_BRK MINUS_GT }]
  [oclExpression ::= (*) oclExpression EQ oclExpression , {EOF ENDPACKAGE CONTEXT INV DEF IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE DOT COLON UP UP_UP LEFT_PAR LEFT_BRK MINUS_GT }]
  [oclExpression ::= (*) oclExpression TIMES oclExpression , {EOF ENDPACKAGE CONTEXT INV DEF IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE DOT COLON UP UP_UP LEFT_PAR LEFT_BRK MINUS_GT }]
  [oclExpression ::= (*) oclExpression DOT simpleName isMarkedPre , {EOF ENDPACKAGE CONTEXT INV DEF IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE DOT COLON UP UP_UP LEFT_PAR LEFT_BRK MINUS_GT }]
  [defExpression ::= operation EQ (*) oclExpression , {EOF ENDPACKAGE CONTEXT INV DEF COLON }]
  [primitiveLiteralExp ::= (*) TRUE , {EOF ENDPACKAGE CONTEXT INV DEF IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE DOT COLON UP UP_UP LEFT_PAR LEFT_BRK MINUS_GT }]
  [literalExp ::= (*) tupleLiteralExp , {EOF ENDPACKAGE CONTEXT INV DEF IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE DOT COLON UP UP_UP LEFT_PAR LEFT_BRK MINUS_GT }]
  [oclExpression ::= (*) oclExpression IMPLIES oclExpression , {EOF ENDPACKAGE CONTEXT INV DEF IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE DOT COLON UP UP_UP LEFT_PAR LEFT_BRK MINUS_GT }]
  [oclExpression ::= (*) oclExpression LT oclExpression , {EOF ENDPACKAGE CONTEXT INV DEF IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE DOT COLON UP UP_UP LEFT_PAR LEFT_BRK MINUS_GT }]
  [oclExpression ::= (*) oclExpression MINUS_GT ITERATE LEFT_PAR variableDeclaration SEMICOLON variableDeclaration BAR oclExpression RIGHT_PAR , {EOF ENDPACKAGE CONTEXT INV DEF IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE DOT COLON UP UP_UP LEFT_PAR LEFT_BRK MINUS_GT }]
  [tupleLiteralExp ::= (*) TUPLE LEFT_BRA variableDeclarationList RIGHT_BRA , {EOF ENDPACKAGE CONTEXT INV DEF IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE DOT COLON UP UP_UP LEFT_PAR LEFT_BRK MINUS_GT }]
  [collectionKind ::= (*) SET , {LEFT_BRA }]
  [oclExpression ::= (*) oclExpression UP simpleName LEFT_PAR RIGHT_PAR , {EOF ENDPACKAGE CONTEXT INV DEF IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE DOT COLON UP UP_UP LEFT_PAR LEFT_BRK MINUS_GT }]
  [oclExpression ::= (*) oclExpression NE oclExpression , {EOF ENDPACKAGE CONTEXT INV DEF IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE DOT COLON UP UP_UP LEFT_PAR LEFT_BRK MINUS_GT }]
  [oclExpression ::= (*) oclExpression DIVIDE oclExpression , {EOF ENDPACKAGE CONTEXT INV DEF IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE DOT COLON UP UP_UP LEFT_PAR LEFT_BRK MINUS_GT }]
  [oclExpression ::= (*) oclExpression LEFT_PAR arguments RIGHT_PAR , {EOF ENDPACKAGE CONTEXT INV DEF IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE DOT COLON UP UP_UP LEFT_PAR LEFT_BRK MINUS_GT }]
  [primitiveLiteralExp ::= (*) FALSE , {EOF ENDPACKAGE CONTEXT INV DEF IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE DOT COLON UP UP_UP LEFT_PAR LEFT_BRK MINUS_GT }]
  [literalExp ::= (*) primitiveLiteralExp , {EOF ENDPACKAGE CONTEXT INV DEF IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE DOT COLON UP UP_UP LEFT_PAR LEFT_BRK MINUS_GT }]
  [oclExpression ::= (*) LET variableDeclarationList IN oclExpression , {EOF ENDPACKAGE CONTEXT INV DEF IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE DOT COLON UP UP_UP LEFT_PAR LEFT_BRK MINUS_GT }]
  [oclExpression ::= (*) oclExpression GT oclExpression , {EOF ENDPACKAGE CONTEXT INV DEF IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE DOT COLON UP UP_UP LEFT_PAR LEFT_BRK MINUS_GT }]
  [oclExpression ::= (*) oclExpression MINUS_GT ITERATE LEFT_PAR variableDeclaration BAR oclExpression RIGHT_PAR , {EOF ENDPACKAGE CONTEXT INV DEF IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE DOT COLON UP UP_UP LEFT_PAR LEFT_BRK MINUS_GT }]
  [oclExpression ::= (*) literalExp , {EOF ENDPACKAGE CONTEXT INV DEF IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE DOT COLON UP UP_UP LEFT_PAR LEFT_BRK MINUS_GT }]
  [primitiveLiteralExp ::= (*) INTEGER , {EOF ENDPACKAGE CONTEXT INV DEF IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE DOT COLON UP UP_UP LEFT_PAR LEFT_BRK MINUS_GT }]
  [collectionKind ::= (*) BAG , {LEFT_BRA }]
  [oclExpression ::= (*) oclExpression AND oclExpression , {EOF ENDPACKAGE CONTEXT INV DEF IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE DOT COLON UP UP_UP LEFT_PAR LEFT_BRK MINUS_GT }]
  [oclExpression ::= (*) oclExpression PLUS oclExpression , {EOF ENDPACKAGE CONTEXT INV DEF IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE DOT COLON UP UP_UP LEFT_PAR LEFT_BRK MINUS_GT }]
  [oclExpression ::= (*) oclExpression LEFT_PAR variableDeclaration BAR oclExpression RIGHT_PAR , {EOF ENDPACKAGE CONTEXT INV DEF IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE DOT COLON UP UP_UP LEFT_PAR LEFT_BRK MINUS_GT }]
  [pathName ::= (*) simpleName , {EOF ENDPACKAGE CONTEXT INV DEF IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE DOT COLON UP AT COLON_COLON UP_UP LEFT_PAR LEFT_BRK MINUS_GT }]
  [oclExpression ::= (*) oclExpression UP_UP simpleName LEFT_PAR oclMessageArgumentList RIGHT_PAR , {EOF ENDPACKAGE CONTEXT INV DEF IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE DOT COLON UP UP_UP LEFT_PAR LEFT_BRK MINUS_GT }]
  [oclExpression ::= (*) oclExpression LE oclExpression , {EOF ENDPACKAGE CONTEXT INV DEF IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE DOT COLON UP UP_UP LEFT_PAR LEFT_BRK MINUS_GT }]
  [oclExpression ::= (*) NOT oclExpression , {EOF ENDPACKAGE CONTEXT INV DEF IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE DOT COLON UP UP_UP LEFT_PAR LEFT_BRK MINUS_GT }]
  [oclExpression ::= (*) LEFT_PAR oclExpression RIGHT_PAR , {EOF ENDPACKAGE CONTEXT INV DEF IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE DOT COLON UP UP_UP LEFT_PAR LEFT_BRK MINUS_GT }]
  [primitiveLiteralExp ::= (*) REAL , {EOF ENDPACKAGE CONTEXT INV DEF IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE DOT COLON UP UP_UP LEFT_PAR LEFT_BRK MINUS_GT }]
  [collectionKind ::= (*) SEQUENCE , {LEFT_BRA }]
  [oclExpression ::= (*) oclExpression OR oclExpression , {EOF ENDPACKAGE CONTEXT INV DEF IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE DOT COLON UP UP_UP LEFT_PAR LEFT_BRK MINUS_GT }]
  [oclExpression ::= (*) oclExpression MINUS oclExpression , {EOF ENDPACKAGE CONTEXT INV DEF IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE DOT COLON UP UP_UP LEFT_PAR LEFT_BRK MINUS_GT }]
  [oclExpression ::= (*) oclExpression LEFT_BRK argumentList RIGHT_BRK isMarkedPre , {EOF ENDPACKAGE CONTEXT INV DEF IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE DOT COLON UP UP_UP LEFT_PAR LEFT_BRK MINUS_GT }]
  [pathName ::= (*) pathName COLON_COLON simpleName , {EOF ENDPACKAGE CONTEXT INV DEF IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE DOT COLON UP AT COLON_COLON UP_UP LEFT_PAR LEFT_BRK MINUS_GT }]
  [collectionLiteralExp ::= (*) collectionKind LEFT_BRA collectionLiteralParts RIGHT_BRA , {EOF ENDPACKAGE CONTEXT INV DEF IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE DOT COLON UP UP_UP LEFT_PAR LEFT_BRK MINUS_GT }]
  [oclExpression ::= (*) oclExpression UP_UP simpleName LEFT_PAR RIGHT_PAR , {EOF ENDPACKAGE CONTEXT INV DEF IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE DOT COLON UP UP_UP LEFT_PAR LEFT_BRK MINUS_GT }]
  [oclExpression ::= (*) oclExpression GE oclExpression , {EOF ENDPACKAGE CONTEXT INV DEF IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE DOT COLON UP UP_UP LEFT_PAR LEFT_BRK MINUS_GT }]
  [oclExpression ::= (*) MINUS oclExpression , {EOF ENDPACKAGE CONTEXT INV DEF IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE DOT COLON UP UP_UP LEFT_PAR LEFT_BRK MINUS_GT }]
  [oclExpression ::= (*) pathName isMarkedPre , {EOF ENDPACKAGE CONTEXT INV DEF IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE DOT COLON UP UP_UP LEFT_PAR LEFT_BRK MINUS_GT }]
  [primitiveLiteralExp ::= (*) STRING , {EOF ENDPACKAGE CONTEXT INV DEF IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE DOT COLON UP UP_UP LEFT_PAR LEFT_BRK MINUS_GT }]
  [collectionKind ::= (*) COLLECTION , {LEFT_BRA }]
  [literalExp ::= (*) collectionLiteralExp , {EOF ENDPACKAGE CONTEXT INV DEF IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE DOT COLON UP UP_UP LEFT_PAR LEFT_BRK MINUS_GT }]
  [oclExpression ::= (*) oclExpression XOR oclExpression , {EOF ENDPACKAGE CONTEXT INV DEF IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE DOT COLON UP UP_UP LEFT_PAR LEFT_BRK MINUS_GT }]
  [oclExpression ::= (*) IF oclExpression THEN oclExpression ELSE oclExpression ENDIF , {EOF ENDPACKAGE CONTEXT INV DEF IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE DOT COLON UP UP_UP LEFT_PAR LEFT_BRK MINUS_GT }]
  [oclExpression ::= (*) oclExpression MINUS_GT simpleName , {EOF ENDPACKAGE CONTEXT INV DEF IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE DOT COLON UP UP_UP LEFT_PAR LEFT_BRK MINUS_GT }]
  [simpleName ::= (*) SIMPLE_NAME , {EOF ENDPACKAGE CONTEXT INV DEF IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE DOT COLON UP AT COLON_COLON UP_UP LEFT_PAR LEFT_BRK MINUS_GT }]
  [collectionLiteralExp ::= (*) collectionKind LEFT_BRA RIGHT_BRA , {EOF ENDPACKAGE CONTEXT INV DEF IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE DOT COLON UP UP_UP LEFT_PAR LEFT_BRK MINUS_GT }]
}
transition on tupleLiteralExp to state [54]
transition on oclExpression to state [225]
transition on REAL to state [52]
transition on INTEGER to state [51]
transition on pathName to state [50]
transition on SIMPLE_NAME to state [12]
transition on LET to state [49]
transition on FALSE to state [48]
transition on MINUS to state [47]
transition on COLLECTION to state [28]
transition on SET to state [20]
transition on simpleName to state [26]
transition on collectionLiteralExp to state [46]
transition on LEFT_PAR to state [45]
transition on STRING to state [44]
transition on IF to state [43]
transition on TRUE to state [42]
transition on collectionKind to state [41]
transition on NOT to state [40]
transition on primitiveLiteralExp to state [39]
transition on TUPLE to state [38]
transition on literalExp to state [37]
transition on BAG to state [25]
transition on SEQUENCE to state [22]

-------------------
lalr_state [225]: {
  [oclExpression ::= oclExpression (*) LEFT_BRK argumentList RIGHT_BRK isMarkedPre , {EOF ENDPACKAGE CONTEXT INV DEF IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE DOT COLON UP UP_UP LEFT_PAR LEFT_BRK MINUS_GT }]
  [oclExpression ::= oclExpression (*) EQ oclExpression , {EOF ENDPACKAGE CONTEXT INV DEF IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE DOT COLON UP UP_UP LEFT_PAR LEFT_BRK MINUS_GT }]
  [oclExpression ::= oclExpression (*) IMPLIES oclExpression , {EOF ENDPACKAGE CONTEXT INV DEF IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE DOT COLON UP UP_UP LEFT_PAR LEFT_BRK MINUS_GT }]
  [oclExpression ::= oclExpression (*) UP simpleName LEFT_PAR RIGHT_PAR , {EOF ENDPACKAGE CONTEXT INV DEF IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE DOT COLON UP UP_UP LEFT_PAR LEFT_BRK MINUS_GT }]
  [defExpression ::= operation EQ oclExpression (*) , {EOF ENDPACKAGE CONTEXT INV DEF COLON }]
  [oclExpression ::= oclExpression (*) LEFT_PAR arguments RIGHT_PAR , {EOF ENDPACKAGE CONTEXT INV DEF IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE DOT COLON UP UP_UP LEFT_PAR LEFT_BRK MINUS_GT }]
  [oclExpression ::= oclExpression (*) MINUS_GT ITERATE LEFT_PAR variableDeclaration BAR oclExpression RIGHT_PAR , {EOF ENDPACKAGE CONTEXT INV DEF IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE DOT COLON UP UP_UP LEFT_PAR LEFT_BRK MINUS_GT }]
  [oclExpression ::= oclExpression (*) PLUS oclExpression , {EOF ENDPACKAGE CONTEXT INV DEF IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE DOT COLON UP UP_UP LEFT_PAR LEFT_BRK MINUS_GT }]
  [oclExpression ::= oclExpression (*) LE oclExpression , {EOF ENDPACKAGE CONTEXT INV DEF IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE DOT COLON UP UP_UP LEFT_PAR LEFT_BRK MINUS_GT }]
  [oclExpression ::= oclExpression (*) OR oclExpression , {EOF ENDPACKAGE CONTEXT INV DEF IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE DOT COLON UP UP_UP LEFT_PAR LEFT_BRK MINUS_GT }]
  [oclExpression ::= oclExpression (*) UP_UP simpleName LEFT_PAR RIGHT_PAR , {EOF ENDPACKAGE CONTEXT INV DEF IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE DOT COLON UP UP_UP LEFT_PAR LEFT_BRK MINUS_GT }]
  [oclExpression ::= oclExpression (*) MINUS_GT simpleName , {EOF ENDPACKAGE CONTEXT INV DEF IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE DOT COLON UP UP_UP LEFT_PAR LEFT_BRK MINUS_GT }]
  [oclExpression ::= oclExpression (*) TIMES oclExpression , {EOF ENDPACKAGE CONTEXT INV DEF IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE DOT COLON UP UP_UP LEFT_PAR LEFT_BRK MINUS_GT }]
  [oclExpression ::= oclExpression (*) LT oclExpression , {EOF ENDPACKAGE CONTEXT INV DEF IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE DOT COLON UP UP_UP LEFT_PAR LEFT_BRK MINUS_GT }]
  [oclExpression ::= oclExpression (*) NE oclExpression , {EOF ENDPACKAGE CONTEXT INV DEF IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE DOT COLON UP UP_UP LEFT_PAR LEFT_BRK MINUS_GT }]
  [oclExpression ::= oclExpression (*) LEFT_PAR variableDeclaration BAR oclExpression RIGHT_PAR , {EOF ENDPACKAGE CONTEXT INV DEF IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE DOT COLON UP UP_UP LEFT_PAR LEFT_BRK MINUS_GT }]
  [oclExpression ::= oclExpression (*) MINUS oclExpression , {EOF ENDPACKAGE CONTEXT INV DEF IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE DOT COLON UP UP_UP LEFT_PAR LEFT_BRK MINUS_GT }]
  [oclExpression ::= oclExpression (*) GE oclExpression , {EOF ENDPACKAGE CONTEXT INV DEF IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE DOT COLON UP UP_UP LEFT_PAR LEFT_BRK MINUS_GT }]
  [oclExpression ::= oclExpression (*) XOR oclExpression , {EOF ENDPACKAGE CONTEXT INV DEF IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE DOT COLON UP UP_UP LEFT_PAR LEFT_BRK MINUS_GT }]
  [oclExpression ::= oclExpression (*) UP simpleName LEFT_PAR oclMessageArgumentList RIGHT_PAR , {EOF ENDPACKAGE CONTEXT INV DEF IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE DOT COLON UP UP_UP LEFT_PAR LEFT_BRK MINUS_GT }]
  [oclExpression ::= oclExpression (*) DOT simpleName isMarkedPre , {EOF ENDPACKAGE CONTEXT INV DEF IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE DOT COLON UP UP_UP LEFT_PAR LEFT_BRK MINUS_GT }]
  [oclExpression ::= oclExpression (*) MINUS_GT ITERATE LEFT_PAR variableDeclaration SEMICOLON variableDeclaration BAR oclExpression RIGHT_PAR , {EOF ENDPACKAGE CONTEXT INV DEF IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE DOT COLON UP UP_UP LEFT_PAR LEFT_BRK MINUS_GT }]
  [oclExpression ::= oclExpression (*) DIVIDE oclExpression , {EOF ENDPACKAGE CONTEXT INV DEF IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE DOT COLON UP UP_UP LEFT_PAR LEFT_BRK MINUS_GT }]
  [oclExpression ::= oclExpression (*) GT oclExpression , {EOF ENDPACKAGE CONTEXT INV DEF IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE DOT COLON UP UP_UP LEFT_PAR LEFT_BRK MINUS_GT }]
  [oclExpression ::= oclExpression (*) AND oclExpression , {EOF ENDPACKAGE CONTEXT INV DEF IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE DOT COLON UP UP_UP LEFT_PAR LEFT_BRK MINUS_GT }]
  [oclExpression ::= oclExpression (*) UP_UP simpleName LEFT_PAR oclMessageArgumentList RIGHT_PAR , {EOF ENDPACKAGE CONTEXT INV DEF IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE DOT COLON UP UP_UP LEFT_PAR LEFT_BRK MINUS_GT }]
}
transition on XOR to state [74]
transition on EQ to state [73]
transition on DOT to state [72]
transition on MINUS to state [71]
transition on GE to state [70]
transition on LEFT_BRK to state [69]
transition on DIVIDE to state [68]
transition on LEFT_PAR to state [67]
transition on MINUS_GT to state [66]
transition on LE to state [65]
transition on GT to state [64]
transition on IMPLIES to state [63]
transition on UP to state [62]
transition on UP_UP to state [61]
transition on OR to state [60]
transition on PLUS to state [59]
transition on NE to state [58]
transition on LT to state [57]
transition on AND to state [56]
transition on TIMES to state [55]

-------------------
lalr_state [226]: {
  [invOrDef ::= invOrDef DEF simpleName (*) COLON defExpression , {EOF ENDPACKAGE CONTEXT INV DEF COLON }]
}
transition on COLON to state [227]

-------------------
lalr_state [227]: {
  [operation ::= (*) pathName COLON_COLON simpleName LEFT_PAR RIGHT_PAR , {EQ }]
  [variableDeclaration ::= (*) simpleName , {EQ }]
  [defExpression ::= (*) operation EQ oclExpression , {EOF ENDPACKAGE CONTEXT INV DEF COLON }]
  [simpleName ::= (*) SIMPLE_NAME , {EQ COLON COLON_COLON LEFT_PAR }]
  [operation ::= (*) pathName COLON_COLON simpleName LEFT_PAR variableDeclarationList RIGHT_PAR , {EQ }]
  [operation ::= (*) simpleName LEFT_PAR RIGHT_PAR COLON type , {EQ }]
  [variableDeclaration ::= (*) simpleName COLON type , {EQ }]
  [pathName ::= (*) simpleName , {COLON_COLON }]
  [operation ::= (*) simpleName LEFT_PAR variableDeclarationList RIGHT_PAR COLON type , {EQ }]
  [operation ::= (*) pathName COLON_COLON simpleName LEFT_PAR RIGHT_PAR COLON type , {EQ }]
  [operation ::= (*) simpleName LEFT_PAR RIGHT_PAR , {EQ }]
  [variableDeclaration ::= (*) simpleName EQ oclExpression , {EQ }]
  [defExpression ::= (*) variableDeclaration EQ oclExpression , {EOF ENDPACKAGE CONTEXT INV DEF COLON }]
  [pathName ::= (*) pathName COLON_COLON simpleName , {COLON_COLON }]
  [operation ::= (*) pathName COLON_COLON simpleName LEFT_PAR variableDeclarationList RIGHT_PAR COLON type , {EQ }]
  [operation ::= (*) simpleName LEFT_PAR variableDeclarationList RIGHT_PAR , {EQ }]
  [invOrDef ::= invOrDef DEF simpleName COLON (*) defExpression , {EOF ENDPACKAGE CONTEXT INV DEF COLON }]
  [variableDeclaration ::= (*) simpleName COLON type EQ oclExpression , {EQ }]
}
transition on SIMPLE_NAME to state [12]
transition on variableDeclaration to state [221]
transition on simpleName to state [220]
transition on pathName to state [219]
transition on defExpression to state [228]
transition on operation to state [217]

-------------------
lalr_state [228]: {
  [invOrDef ::= invOrDef DEF simpleName COLON defExpression (*) , {EOF ENDPACKAGE CONTEXT INV DEF COLON }]
}

-------------------
lalr_state [229]: {
  [operation ::= (*) pathName COLON_COLON simpleName LEFT_PAR RIGHT_PAR , {EQ }]
  [variableDeclaration ::= (*) simpleName , {EQ }]
  [defExpression ::= (*) operation EQ oclExpression , {EOF ENDPACKAGE CONTEXT INV DEF COLON }]
  [simpleName ::= (*) SIMPLE_NAME , {EQ COLON COLON_COLON LEFT_PAR }]
  [operation ::= (*) pathName COLON_COLON simpleName LEFT_PAR variableDeclarationList RIGHT_PAR , {EQ }]
  [operation ::= (*) simpleName LEFT_PAR RIGHT_PAR COLON type , {EQ }]
  [variableDeclaration ::= (*) simpleName COLON type , {EQ }]
  [pathName ::= (*) simpleName , {COLON_COLON }]
  [operation ::= (*) simpleName LEFT_PAR variableDeclarationList RIGHT_PAR COLON type , {EQ }]
  [operation ::= (*) pathName COLON_COLON simpleName LEFT_PAR RIGHT_PAR COLON type , {EQ }]
  [operation ::= (*) simpleName LEFT_PAR RIGHT_PAR , {EQ }]
  [variableDeclaration ::= (*) simpleName EQ oclExpression , {EQ }]
  [invOrDef ::= DEF COLON (*) defExpression , {EOF ENDPACKAGE CONTEXT INV DEF COLON }]
  [defExpression ::= (*) variableDeclaration EQ oclExpression , {EOF ENDPACKAGE CONTEXT INV DEF COLON }]
  [pathName ::= (*) pathName COLON_COLON simpleName , {COLON_COLON }]
  [operation ::= (*) pathName COLON_COLON simpleName LEFT_PAR variableDeclarationList RIGHT_PAR COLON type , {EQ }]
  [operation ::= (*) simpleName LEFT_PAR variableDeclarationList RIGHT_PAR , {EQ }]
  [variableDeclaration ::= (*) simpleName COLON type EQ oclExpression , {EQ }]
}
transition on SIMPLE_NAME to state [12]
transition on variableDeclaration to state [221]
transition on simpleName to state [220]
transition on pathName to state [219]
transition on defExpression to state [233]
transition on operation to state [217]

-------------------
lalr_state [230]: {
  [invOrDef ::= DEF simpleName (*) COLON defExpression , {EOF ENDPACKAGE CONTEXT INV DEF COLON }]
}
transition on COLON to state [231]

-------------------
lalr_state [231]: {
  [operation ::= (*) pathName COLON_COLON simpleName LEFT_PAR RIGHT_PAR , {EQ }]
  [variableDeclaration ::= (*) simpleName , {EQ }]
  [defExpression ::= (*) operation EQ oclExpression , {EOF ENDPACKAGE CONTEXT INV DEF COLON }]
  [simpleName ::= (*) SIMPLE_NAME , {EQ COLON COLON_COLON LEFT_PAR }]
  [operation ::= (*) pathName COLON_COLON simpleName LEFT_PAR variableDeclarationList RIGHT_PAR , {EQ }]
  [operation ::= (*) simpleName LEFT_PAR RIGHT_PAR COLON type , {EQ }]
  [invOrDef ::= DEF simpleName COLON (*) defExpression , {EOF ENDPACKAGE CONTEXT INV DEF COLON }]
  [variableDeclaration ::= (*) simpleName COLON type , {EQ }]
  [pathName ::= (*) simpleName , {COLON_COLON }]
  [operation ::= (*) simpleName LEFT_PAR variableDeclarationList RIGHT_PAR COLON type , {EQ }]
  [operation ::= (*) pathName COLON_COLON simpleName LEFT_PAR RIGHT_PAR COLON type , {EQ }]
  [operation ::= (*) simpleName LEFT_PAR RIGHT_PAR , {EQ }]
  [variableDeclaration ::= (*) simpleName EQ oclExpression , {EQ }]
  [defExpression ::= (*) variableDeclaration EQ oclExpression , {EOF ENDPACKAGE CONTEXT INV DEF COLON }]
  [pathName ::= (*) pathName COLON_COLON simpleName , {COLON_COLON }]
  [operation ::= (*) pathName COLON_COLON simpleName LEFT_PAR variableDeclarationList RIGHT_PAR COLON type , {EQ }]
  [operation ::= (*) simpleName LEFT_PAR variableDeclarationList RIGHT_PAR , {EQ }]
  [variableDeclaration ::= (*) simpleName COLON type EQ oclExpression , {EQ }]
}
transition on SIMPLE_NAME to state [12]
transition on variableDeclaration to state [221]
transition on simpleName to state [220]
transition on pathName to state [219]
transition on defExpression to state [232]
transition on operation to state [217]

-------------------
lalr_state [232]: {
  [invOrDef ::= DEF simpleName COLON defExpression (*) , {EOF ENDPACKAGE CONTEXT INV DEF COLON }]
}

-------------------
lalr_state [233]: {
  [invOrDef ::= DEF COLON defExpression (*) , {EOF ENDPACKAGE CONTEXT INV DEF COLON }]
}

-------------------
lalr_state [234]: {
  [prePostOrBodyDecl ::= BODY (*) simpleName COLON oclExpression , {EOF ENDPACKAGE CONTEXT PRE POST BODY }]
  [simpleName ::= (*) SIMPLE_NAME , {COLON }]
  [prePostOrBodyDecl ::= BODY (*) COLON oclExpression , {EOF ENDPACKAGE CONTEXT PRE POST BODY }]
}
transition on SIMPLE_NAME to state [12]
transition on simpleName to state [267]
transition on COLON to state [266]

-------------------
lalr_state [235]: {
  [prePostOrBodyDecl ::= PRE (*) COLON oclExpression , {EOF ENDPACKAGE CONTEXT PRE POST BODY }]
  [simpleName ::= (*) SIMPLE_NAME , {COLON }]
  [prePostOrBodyDecl ::= PRE (*) simpleName COLON oclExpression , {EOF ENDPACKAGE CONTEXT PRE POST BODY }]
}
transition on SIMPLE_NAME to state [12]
transition on COLON to state [262]
transition on simpleName to state [261]

-------------------
lalr_state [236]: {
  [prePostOrBodyDecl ::= prePostOrBodyDecl (*) BODY simpleName COLON oclExpression , {EOF ENDPACKAGE CONTEXT PRE POST BODY }]
  [prePostOrBodyDecl ::= prePostOrBodyDecl (*) PRE COLON oclExpression , {EOF ENDPACKAGE CONTEXT PRE POST BODY }]
  [prePostOrBodyDecl ::= prePostOrBodyDecl (*) POST COLON oclExpression , {EOF ENDPACKAGE CONTEXT PRE POST BODY }]
  [prePostOrBodyDecl ::= prePostOrBodyDecl (*) PRE simpleName COLON oclExpression , {EOF ENDPACKAGE CONTEXT PRE POST BODY }]
  [prePostOrBodyDecl ::= prePostOrBodyDecl (*) BODY COLON oclExpression , {EOF ENDPACKAGE CONTEXT PRE POST BODY }]
  [prePostOrBodyDecl ::= prePostOrBodyDecl (*) POST simpleName COLON oclExpression , {EOF ENDPACKAGE CONTEXT PRE POST BODY }]
  [operationContextDecl ::= CONTEXT operation prePostOrBodyDecl (*) , {EOF ENDPACKAGE CONTEXT }]
}
transition on POST to state [245]
transition on BODY to state [244]
transition on PRE to state [243]

-------------------
lalr_state [237]: {
  [prePostOrBodyDecl ::= POST (*) simpleName COLON oclExpression , {EOF ENDPACKAGE CONTEXT PRE POST BODY }]
  [simpleName ::= (*) SIMPLE_NAME , {COLON }]
  [prePostOrBodyDecl ::= POST (*) COLON oclExpression , {EOF ENDPACKAGE CONTEXT PRE POST BODY }]
}
transition on SIMPLE_NAME to state [12]
transition on simpleName to state [239]
transition on COLON to state [238]

-------------------
lalr_state [238]: {
  [oclExpression ::= (*) oclExpression UP simpleName LEFT_PAR oclMessageArgumentList RIGHT_PAR , {EOF ENDPACKAGE CONTEXT PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE DOT UP UP_UP LEFT_PAR LEFT_BRK MINUS_GT }]
  [oclExpression ::= (*) oclExpression EQ oclExpression , {EOF ENDPACKAGE CONTEXT PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE DOT UP UP_UP LEFT_PAR LEFT_BRK MINUS_GT }]
  [oclExpression ::= (*) oclExpression TIMES oclExpression , {EOF ENDPACKAGE CONTEXT PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE DOT UP UP_UP LEFT_PAR LEFT_BRK MINUS_GT }]
  [oclExpression ::= (*) oclExpression DOT simpleName isMarkedPre , {EOF ENDPACKAGE CONTEXT PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE DOT UP UP_UP LEFT_PAR LEFT_BRK MINUS_GT }]
  [primitiveLiteralExp ::= (*) TRUE , {EOF ENDPACKAGE CONTEXT PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE DOT UP UP_UP LEFT_PAR LEFT_BRK MINUS_GT }]
  [literalExp ::= (*) tupleLiteralExp , {EOF ENDPACKAGE CONTEXT PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE DOT UP UP_UP LEFT_PAR LEFT_BRK MINUS_GT }]
  [oclExpression ::= (*) oclExpression IMPLIES oclExpression , {EOF ENDPACKAGE CONTEXT PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE DOT UP UP_UP LEFT_PAR LEFT_BRK MINUS_GT }]
  [oclExpression ::= (*) oclExpression LT oclExpression , {EOF ENDPACKAGE CONTEXT PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE DOT UP UP_UP LEFT_PAR LEFT_BRK MINUS_GT }]
  [oclExpression ::= (*) oclExpression MINUS_GT ITERATE LEFT_PAR variableDeclaration SEMICOLON variableDeclaration BAR oclExpression RIGHT_PAR , {EOF ENDPACKAGE CONTEXT PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE DOT UP UP_UP LEFT_PAR LEFT_BRK MINUS_GT }]
  [prePostOrBodyDecl ::= POST COLON (*) oclExpression , {EOF ENDPACKAGE CONTEXT PRE POST BODY }]
  [tupleLiteralExp ::= (*) TUPLE LEFT_BRA variableDeclarationList RIGHT_BRA , {EOF ENDPACKAGE CONTEXT PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE DOT UP UP_UP LEFT_PAR LEFT_BRK MINUS_GT }]
  [collectionKind ::= (*) SET , {LEFT_BRA }]
  [oclExpression ::= (*) oclExpression UP simpleName LEFT_PAR RIGHT_PAR , {EOF ENDPACKAGE CONTEXT PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE DOT UP UP_UP LEFT_PAR LEFT_BRK MINUS_GT }]
  [oclExpression ::= (*) oclExpression NE oclExpression , {EOF ENDPACKAGE CONTEXT PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE DOT UP UP_UP LEFT_PAR LEFT_BRK MINUS_GT }]
  [oclExpression ::= (*) oclExpression DIVIDE oclExpression , {EOF ENDPACKAGE CONTEXT PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE DOT UP UP_UP LEFT_PAR LEFT_BRK MINUS_GT }]
  [oclExpression ::= (*) oclExpression LEFT_PAR arguments RIGHT_PAR , {EOF ENDPACKAGE CONTEXT PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE DOT UP UP_UP LEFT_PAR LEFT_BRK MINUS_GT }]
  [primitiveLiteralExp ::= (*) FALSE , {EOF ENDPACKAGE CONTEXT PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE DOT UP UP_UP LEFT_PAR LEFT_BRK MINUS_GT }]
  [literalExp ::= (*) primitiveLiteralExp , {EOF ENDPACKAGE CONTEXT PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE DOT UP UP_UP LEFT_PAR LEFT_BRK MINUS_GT }]
  [oclExpression ::= (*) LET variableDeclarationList IN oclExpression , {EOF ENDPACKAGE CONTEXT PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE DOT UP UP_UP LEFT_PAR LEFT_BRK MINUS_GT }]
  [oclExpression ::= (*) oclExpression GT oclExpression , {EOF ENDPACKAGE CONTEXT PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE DOT UP UP_UP LEFT_PAR LEFT_BRK MINUS_GT }]
  [oclExpression ::= (*) oclExpression MINUS_GT ITERATE LEFT_PAR variableDeclaration BAR oclExpression RIGHT_PAR , {EOF ENDPACKAGE CONTEXT PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE DOT UP UP_UP LEFT_PAR LEFT_BRK MINUS_GT }]
  [oclExpression ::= (*) literalExp , {EOF ENDPACKAGE CONTEXT PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE DOT UP UP_UP LEFT_PAR LEFT_BRK MINUS_GT }]
  [primitiveLiteralExp ::= (*) INTEGER , {EOF ENDPACKAGE CONTEXT PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE DOT UP UP_UP LEFT_PAR LEFT_BRK MINUS_GT }]
  [collectionKind ::= (*) BAG , {LEFT_BRA }]
  [oclExpression ::= (*) oclExpression AND oclExpression , {EOF ENDPACKAGE CONTEXT PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE DOT UP UP_UP LEFT_PAR LEFT_BRK MINUS_GT }]
  [oclExpression ::= (*) oclExpression PLUS oclExpression , {EOF ENDPACKAGE CONTEXT PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE DOT UP UP_UP LEFT_PAR LEFT_BRK MINUS_GT }]
  [oclExpression ::= (*) oclExpression LEFT_PAR variableDeclaration BAR oclExpression RIGHT_PAR , {EOF ENDPACKAGE CONTEXT PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE DOT UP UP_UP LEFT_PAR LEFT_BRK MINUS_GT }]
  [pathName ::= (*) simpleName , {EOF ENDPACKAGE CONTEXT PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE DOT UP AT COLON_COLON UP_UP LEFT_PAR LEFT_BRK MINUS_GT }]
  [oclExpression ::= (*) oclExpression UP_UP simpleName LEFT_PAR oclMessageArgumentList RIGHT_PAR , {EOF ENDPACKAGE CONTEXT PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE DOT UP UP_UP LEFT_PAR LEFT_BRK MINUS_GT }]
  [oclExpression ::= (*) oclExpression LE oclExpression , {EOF ENDPACKAGE CONTEXT PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE DOT UP UP_UP LEFT_PAR LEFT_BRK MINUS_GT }]
  [oclExpression ::= (*) NOT oclExpression , {EOF ENDPACKAGE CONTEXT PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE DOT UP UP_UP LEFT_PAR LEFT_BRK MINUS_GT }]
  [oclExpression ::= (*) LEFT_PAR oclExpression RIGHT_PAR , {EOF ENDPACKAGE CONTEXT PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE DOT UP UP_UP LEFT_PAR LEFT_BRK MINUS_GT }]
  [primitiveLiteralExp ::= (*) REAL , {EOF ENDPACKAGE CONTEXT PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE DOT UP UP_UP LEFT_PAR LEFT_BRK MINUS_GT }]
  [collectionKind ::= (*) SEQUENCE , {LEFT_BRA }]
  [oclExpression ::= (*) oclExpression OR oclExpression , {EOF ENDPACKAGE CONTEXT PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE DOT UP UP_UP LEFT_PAR LEFT_BRK MINUS_GT }]
  [oclExpression ::= (*) oclExpression MINUS oclExpression , {EOF ENDPACKAGE CONTEXT PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE DOT UP UP_UP LEFT_PAR LEFT_BRK MINUS_GT }]
  [oclExpression ::= (*) oclExpression LEFT_BRK argumentList RIGHT_BRK isMarkedPre , {EOF ENDPACKAGE CONTEXT PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE DOT UP UP_UP LEFT_PAR LEFT_BRK MINUS_GT }]
  [pathName ::= (*) pathName COLON_COLON simpleName , {EOF ENDPACKAGE CONTEXT PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE DOT UP AT COLON_COLON UP_UP LEFT_PAR LEFT_BRK MINUS_GT }]
  [collectionLiteralExp ::= (*) collectionKind LEFT_BRA collectionLiteralParts RIGHT_BRA , {EOF ENDPACKAGE CONTEXT PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE DOT UP UP_UP LEFT_PAR LEFT_BRK MINUS_GT }]
  [oclExpression ::= (*) oclExpression UP_UP simpleName LEFT_PAR RIGHT_PAR , {EOF ENDPACKAGE CONTEXT PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE DOT UP UP_UP LEFT_PAR LEFT_BRK MINUS_GT }]
  [oclExpression ::= (*) oclExpression GE oclExpression , {EOF ENDPACKAGE CONTEXT PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE DOT UP UP_UP LEFT_PAR LEFT_BRK MINUS_GT }]
  [oclExpression ::= (*) MINUS oclExpression , {EOF ENDPACKAGE CONTEXT PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE DOT UP UP_UP LEFT_PAR LEFT_BRK MINUS_GT }]
  [oclExpression ::= (*) pathName isMarkedPre , {EOF ENDPACKAGE CONTEXT PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE DOT UP UP_UP LEFT_PAR LEFT_BRK MINUS_GT }]
  [primitiveLiteralExp ::= (*) STRING , {EOF ENDPACKAGE CONTEXT PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE DOT UP UP_UP LEFT_PAR LEFT_BRK MINUS_GT }]
  [collectionKind ::= (*) COLLECTION , {LEFT_BRA }]
  [literalExp ::= (*) collectionLiteralExp , {EOF ENDPACKAGE CONTEXT PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE DOT UP UP_UP LEFT_PAR LEFT_BRK MINUS_GT }]
  [oclExpression ::= (*) oclExpression XOR oclExpression , {EOF ENDPACKAGE CONTEXT PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE DOT UP UP_UP LEFT_PAR LEFT_BRK MINUS_GT }]
  [oclExpression ::= (*) IF oclExpression THEN oclExpression ELSE oclExpression ENDIF , {EOF ENDPACKAGE CONTEXT PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE DOT UP UP_UP LEFT_PAR LEFT_BRK MINUS_GT }]
  [oclExpression ::= (*) oclExpression MINUS_GT simpleName , {EOF ENDPACKAGE CONTEXT PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE DOT UP UP_UP LEFT_PAR LEFT_BRK MINUS_GT }]
  [simpleName ::= (*) SIMPLE_NAME , {EOF ENDPACKAGE CONTEXT PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE DOT UP AT COLON_COLON UP_UP LEFT_PAR LEFT_BRK MINUS_GT }]
  [collectionLiteralExp ::= (*) collectionKind LEFT_BRA RIGHT_BRA , {EOF ENDPACKAGE CONTEXT PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE DOT UP UP_UP LEFT_PAR LEFT_BRK MINUS_GT }]
}
transition on tupleLiteralExp to state [54]
transition on oclExpression to state [242]
transition on REAL to state [52]
transition on INTEGER to state [51]
transition on pathName to state [50]
transition on SIMPLE_NAME to state [12]
transition on LET to state [49]
transition on FALSE to state [48]
transition on MINUS to state [47]
transition on COLLECTION to state [28]
transition on SET to state [20]
transition on simpleName to state [26]
transition on collectionLiteralExp to state [46]
transition on LEFT_PAR to state [45]
transition on STRING to state [44]
transition on IF to state [43]
transition on TRUE to state [42]
transition on collectionKind to state [41]
transition on NOT to state [40]
transition on primitiveLiteralExp to state [39]
transition on TUPLE to state [38]
transition on literalExp to state [37]
transition on BAG to state [25]
transition on SEQUENCE to state [22]

-------------------
lalr_state [239]: {
  [prePostOrBodyDecl ::= POST simpleName (*) COLON oclExpression , {EOF ENDPACKAGE CONTEXT PRE POST BODY }]
}
transition on COLON to state [240]

-------------------
lalr_state [240]: {
  [oclExpression ::= (*) oclExpression UP simpleName LEFT_PAR oclMessageArgumentList RIGHT_PAR , {EOF ENDPACKAGE CONTEXT PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE DOT UP UP_UP LEFT_PAR LEFT_BRK MINUS_GT }]
  [oclExpression ::= (*) oclExpression EQ oclExpression , {EOF ENDPACKAGE CONTEXT PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE DOT UP UP_UP LEFT_PAR LEFT_BRK MINUS_GT }]
  [oclExpression ::= (*) oclExpression TIMES oclExpression , {EOF ENDPACKAGE CONTEXT PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE DOT UP UP_UP LEFT_PAR LEFT_BRK MINUS_GT }]
  [oclExpression ::= (*) oclExpression DOT simpleName isMarkedPre , {EOF ENDPACKAGE CONTEXT PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE DOT UP UP_UP LEFT_PAR LEFT_BRK MINUS_GT }]
  [primitiveLiteralExp ::= (*) TRUE , {EOF ENDPACKAGE CONTEXT PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE DOT UP UP_UP LEFT_PAR LEFT_BRK MINUS_GT }]
  [literalExp ::= (*) tupleLiteralExp , {EOF ENDPACKAGE CONTEXT PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE DOT UP UP_UP LEFT_PAR LEFT_BRK MINUS_GT }]
  [oclExpression ::= (*) oclExpression IMPLIES oclExpression , {EOF ENDPACKAGE CONTEXT PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE DOT UP UP_UP LEFT_PAR LEFT_BRK MINUS_GT }]
  [oclExpression ::= (*) oclExpression LT oclExpression , {EOF ENDPACKAGE CONTEXT PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE DOT UP UP_UP LEFT_PAR LEFT_BRK MINUS_GT }]
  [oclExpression ::= (*) oclExpression MINUS_GT ITERATE LEFT_PAR variableDeclaration SEMICOLON variableDeclaration BAR oclExpression RIGHT_PAR , {EOF ENDPACKAGE CONTEXT PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE DOT UP UP_UP LEFT_PAR LEFT_BRK MINUS_GT }]
  [tupleLiteralExp ::= (*) TUPLE LEFT_BRA variableDeclarationList RIGHT_BRA , {EOF ENDPACKAGE CONTEXT PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE DOT UP UP_UP LEFT_PAR LEFT_BRK MINUS_GT }]
  [collectionKind ::= (*) SET , {LEFT_BRA }]
  [oclExpression ::= (*) oclExpression UP simpleName LEFT_PAR RIGHT_PAR , {EOF ENDPACKAGE CONTEXT PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE DOT UP UP_UP LEFT_PAR LEFT_BRK MINUS_GT }]
  [oclExpression ::= (*) oclExpression NE oclExpression , {EOF ENDPACKAGE CONTEXT PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE DOT UP UP_UP LEFT_PAR LEFT_BRK MINUS_GT }]
  [oclExpression ::= (*) oclExpression DIVIDE oclExpression , {EOF ENDPACKAGE CONTEXT PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE DOT UP UP_UP LEFT_PAR LEFT_BRK MINUS_GT }]
  [oclExpression ::= (*) oclExpression LEFT_PAR arguments RIGHT_PAR , {EOF ENDPACKAGE CONTEXT PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE DOT UP UP_UP LEFT_PAR LEFT_BRK MINUS_GT }]
  [primitiveLiteralExp ::= (*) FALSE , {EOF ENDPACKAGE CONTEXT PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE DOT UP UP_UP LEFT_PAR LEFT_BRK MINUS_GT }]
  [literalExp ::= (*) primitiveLiteralExp , {EOF ENDPACKAGE CONTEXT PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE DOT UP UP_UP LEFT_PAR LEFT_BRK MINUS_GT }]
  [oclExpression ::= (*) LET variableDeclarationList IN oclExpression , {EOF ENDPACKAGE CONTEXT PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE DOT UP UP_UP LEFT_PAR LEFT_BRK MINUS_GT }]
  [oclExpression ::= (*) oclExpression GT oclExpression , {EOF ENDPACKAGE CONTEXT PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE DOT UP UP_UP LEFT_PAR LEFT_BRK MINUS_GT }]
  [oclExpression ::= (*) oclExpression MINUS_GT ITERATE LEFT_PAR variableDeclaration BAR oclExpression RIGHT_PAR , {EOF ENDPACKAGE CONTEXT PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE DOT UP UP_UP LEFT_PAR LEFT_BRK MINUS_GT }]
  [oclExpression ::= (*) literalExp , {EOF ENDPACKAGE CONTEXT PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE DOT UP UP_UP LEFT_PAR LEFT_BRK MINUS_GT }]
  [primitiveLiteralExp ::= (*) INTEGER , {EOF ENDPACKAGE CONTEXT PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE DOT UP UP_UP LEFT_PAR LEFT_BRK MINUS_GT }]
  [collectionKind ::= (*) BAG , {LEFT_BRA }]
  [oclExpression ::= (*) oclExpression AND oclExpression , {EOF ENDPACKAGE CONTEXT PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE DOT UP UP_UP LEFT_PAR LEFT_BRK MINUS_GT }]
  [oclExpression ::= (*) oclExpression PLUS oclExpression , {EOF ENDPACKAGE CONTEXT PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE DOT UP UP_UP LEFT_PAR LEFT_BRK MINUS_GT }]
  [oclExpression ::= (*) oclExpression LEFT_PAR variableDeclaration BAR oclExpression RIGHT_PAR , {EOF ENDPACKAGE CONTEXT PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE DOT UP UP_UP LEFT_PAR LEFT_BRK MINUS_GT }]
  [pathName ::= (*) simpleName , {EOF ENDPACKAGE CONTEXT PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE DOT UP AT COLON_COLON UP_UP LEFT_PAR LEFT_BRK MINUS_GT }]
  [oclExpression ::= (*) oclExpression UP_UP simpleName LEFT_PAR oclMessageArgumentList RIGHT_PAR , {EOF ENDPACKAGE CONTEXT PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE DOT UP UP_UP LEFT_PAR LEFT_BRK MINUS_GT }]
  [oclExpression ::= (*) oclExpression LE oclExpression , {EOF ENDPACKAGE CONTEXT PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE DOT UP UP_UP LEFT_PAR LEFT_BRK MINUS_GT }]
  [oclExpression ::= (*) NOT oclExpression , {EOF ENDPACKAGE CONTEXT PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE DOT UP UP_UP LEFT_PAR LEFT_BRK MINUS_GT }]
  [oclExpression ::= (*) LEFT_PAR oclExpression RIGHT_PAR , {EOF ENDPACKAGE CONTEXT PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE DOT UP UP_UP LEFT_PAR LEFT_BRK MINUS_GT }]
  [primitiveLiteralExp ::= (*) REAL , {EOF ENDPACKAGE CONTEXT PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE DOT UP UP_UP LEFT_PAR LEFT_BRK MINUS_GT }]
  [collectionKind ::= (*) SEQUENCE , {LEFT_BRA }]
  [oclExpression ::= (*) oclExpression OR oclExpression , {EOF ENDPACKAGE CONTEXT PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE DOT UP UP_UP LEFT_PAR LEFT_BRK MINUS_GT }]
  [oclExpression ::= (*) oclExpression MINUS oclExpression , {EOF ENDPACKAGE CONTEXT PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE DOT UP UP_UP LEFT_PAR LEFT_BRK MINUS_GT }]
  [oclExpression ::= (*) oclExpression LEFT_BRK argumentList RIGHT_BRK isMarkedPre , {EOF ENDPACKAGE CONTEXT PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE DOT UP UP_UP LEFT_PAR LEFT_BRK MINUS_GT }]
  [pathName ::= (*) pathName COLON_COLON simpleName , {EOF ENDPACKAGE CONTEXT PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE DOT UP AT COLON_COLON UP_UP LEFT_PAR LEFT_BRK MINUS_GT }]
  [collectionLiteralExp ::= (*) collectionKind LEFT_BRA collectionLiteralParts RIGHT_BRA , {EOF ENDPACKAGE CONTEXT PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE DOT UP UP_UP LEFT_PAR LEFT_BRK MINUS_GT }]
  [oclExpression ::= (*) oclExpression UP_UP simpleName LEFT_PAR RIGHT_PAR , {EOF ENDPACKAGE CONTEXT PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE DOT UP UP_UP LEFT_PAR LEFT_BRK MINUS_GT }]
  [oclExpression ::= (*) oclExpression GE oclExpression , {EOF ENDPACKAGE CONTEXT PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE DOT UP UP_UP LEFT_PAR LEFT_BRK MINUS_GT }]
  [oclExpression ::= (*) MINUS oclExpression , {EOF ENDPACKAGE CONTEXT PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE DOT UP UP_UP LEFT_PAR LEFT_BRK MINUS_GT }]
  [oclExpression ::= (*) pathName isMarkedPre , {EOF ENDPACKAGE CONTEXT PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE DOT UP UP_UP LEFT_PAR LEFT_BRK MINUS_GT }]
  [primitiveLiteralExp ::= (*) STRING , {EOF ENDPACKAGE CONTEXT PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE DOT UP UP_UP LEFT_PAR LEFT_BRK MINUS_GT }]
  [collectionKind ::= (*) COLLECTION , {LEFT_BRA }]
  [literalExp ::= (*) collectionLiteralExp , {EOF ENDPACKAGE CONTEXT PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE DOT UP UP_UP LEFT_PAR LEFT_BRK MINUS_GT }]
  [oclExpression ::= (*) oclExpression XOR oclExpression , {EOF ENDPACKAGE CONTEXT PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE DOT UP UP_UP LEFT_PAR LEFT_BRK MINUS_GT }]
  [oclExpression ::= (*) IF oclExpression THEN oclExpression ELSE oclExpression ENDIF , {EOF ENDPACKAGE CONTEXT PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE DOT UP UP_UP LEFT_PAR LEFT_BRK MINUS_GT }]
  [oclExpression ::= (*) oclExpression MINUS_GT simpleName , {EOF ENDPACKAGE CONTEXT PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE DOT UP UP_UP LEFT_PAR LEFT_BRK MINUS_GT }]
  [prePostOrBodyDecl ::= POST simpleName COLON (*) oclExpression , {EOF ENDPACKAGE CONTEXT PRE POST BODY }]
  [simpleName ::= (*) SIMPLE_NAME , {EOF ENDPACKAGE CONTEXT PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE DOT UP AT COLON_COLON UP_UP LEFT_PAR LEFT_BRK MINUS_GT }]
  [collectionLiteralExp ::= (*) collectionKind LEFT_BRA RIGHT_BRA , {EOF ENDPACKAGE CONTEXT PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE DOT UP UP_UP LEFT_PAR LEFT_BRK MINUS_GT }]
}
transition on tupleLiteralExp to state [54]
transition on oclExpression to state [241]
transition on REAL to state [52]
transition on INTEGER to state [51]
transition on pathName to state [50]
transition on SIMPLE_NAME to state [12]
transition on LET to state [49]
transition on FALSE to state [48]
transition on MINUS to state [47]
transition on COLLECTION to state [28]
transition on SET to state [20]
transition on simpleName to state [26]
transition on collectionLiteralExp to state [46]
transition on LEFT_PAR to state [45]
transition on STRING to state [44]
transition on IF to state [43]
transition on TRUE to state [42]
transition on collectionKind to state [41]
transition on NOT to state [40]
transition on primitiveLiteralExp to state [39]
transition on TUPLE to state [38]
transition on literalExp to state [37]
transition on BAG to state [25]
transition on SEQUENCE to state [22]

-------------------
lalr_state [241]: {
  [oclExpression ::= oclExpression (*) LEFT_BRK argumentList RIGHT_BRK isMarkedPre , {EOF ENDPACKAGE CONTEXT PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE DOT UP UP_UP LEFT_PAR LEFT_BRK MINUS_GT }]
  [oclExpression ::= oclExpression (*) EQ oclExpression , {EOF ENDPACKAGE CONTEXT PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE DOT UP UP_UP LEFT_PAR LEFT_BRK MINUS_GT }]
  [oclExpression ::= oclExpression (*) IMPLIES oclExpression , {EOF ENDPACKAGE CONTEXT PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE DOT UP UP_UP LEFT_PAR LEFT_BRK MINUS_GT }]
  [oclExpression ::= oclExpression (*) UP simpleName LEFT_PAR RIGHT_PAR , {EOF ENDPACKAGE CONTEXT PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE DOT UP UP_UP LEFT_PAR LEFT_BRK MINUS_GT }]
  [oclExpression ::= oclExpression (*) LEFT_PAR arguments RIGHT_PAR , {EOF ENDPACKAGE CONTEXT PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE DOT UP UP_UP LEFT_PAR LEFT_BRK MINUS_GT }]
  [oclExpression ::= oclExpression (*) MINUS_GT ITERATE LEFT_PAR variableDeclaration BAR oclExpression RIGHT_PAR , {EOF ENDPACKAGE CONTEXT PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE DOT UP UP_UP LEFT_PAR LEFT_BRK MINUS_GT }]
  [oclExpression ::= oclExpression (*) PLUS oclExpression , {EOF ENDPACKAGE CONTEXT PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE DOT UP UP_UP LEFT_PAR LEFT_BRK MINUS_GT }]
  [oclExpression ::= oclExpression (*) LE oclExpression , {EOF ENDPACKAGE CONTEXT PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE DOT UP UP_UP LEFT_PAR LEFT_BRK MINUS_GT }]
  [oclExpression ::= oclExpression (*) OR oclExpression , {EOF ENDPACKAGE CONTEXT PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE DOT UP UP_UP LEFT_PAR LEFT_BRK MINUS_GT }]
  [oclExpression ::= oclExpression (*) UP_UP simpleName LEFT_PAR RIGHT_PAR , {EOF ENDPACKAGE CONTEXT PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE DOT UP UP_UP LEFT_PAR LEFT_BRK MINUS_GT }]
  [oclExpression ::= oclExpression (*) MINUS_GT simpleName , {EOF ENDPACKAGE CONTEXT PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE DOT UP UP_UP LEFT_PAR LEFT_BRK MINUS_GT }]
  [oclExpression ::= oclExpression (*) TIMES oclExpression , {EOF ENDPACKAGE CONTEXT PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE DOT UP UP_UP LEFT_PAR LEFT_BRK MINUS_GT }]
  [oclExpression ::= oclExpression (*) LT oclExpression , {EOF ENDPACKAGE CONTEXT PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE DOT UP UP_UP LEFT_PAR LEFT_BRK MINUS_GT }]
  [oclExpression ::= oclExpression (*) NE oclExpression , {EOF ENDPACKAGE CONTEXT PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE DOT UP UP_UP LEFT_PAR LEFT_BRK MINUS_GT }]
  [oclExpression ::= oclExpression (*) LEFT_PAR variableDeclaration BAR oclExpression RIGHT_PAR , {EOF ENDPACKAGE CONTEXT PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE DOT UP UP_UP LEFT_PAR LEFT_BRK MINUS_GT }]
  [oclExpression ::= oclExpression (*) MINUS oclExpression , {EOF ENDPACKAGE CONTEXT PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE DOT UP UP_UP LEFT_PAR LEFT_BRK MINUS_GT }]
  [oclExpression ::= oclExpression (*) GE oclExpression , {EOF ENDPACKAGE CONTEXT PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE DOT UP UP_UP LEFT_PAR LEFT_BRK MINUS_GT }]
  [oclExpression ::= oclExpression (*) XOR oclExpression , {EOF ENDPACKAGE CONTEXT PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE DOT UP UP_UP LEFT_PAR LEFT_BRK MINUS_GT }]
  [oclExpression ::= oclExpression (*) UP simpleName LEFT_PAR oclMessageArgumentList RIGHT_PAR , {EOF ENDPACKAGE CONTEXT PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE DOT UP UP_UP LEFT_PAR LEFT_BRK MINUS_GT }]
  [prePostOrBodyDecl ::= POST simpleName COLON oclExpression (*) , {EOF ENDPACKAGE CONTEXT PRE POST BODY }]
  [oclExpression ::= oclExpression (*) DOT simpleName isMarkedPre , {EOF ENDPACKAGE CONTEXT PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE DOT UP UP_UP LEFT_PAR LEFT_BRK MINUS_GT }]
  [oclExpression ::= oclExpression (*) MINUS_GT ITERATE LEFT_PAR variableDeclaration SEMICOLON variableDeclaration BAR oclExpression RIGHT_PAR , {EOF ENDPACKAGE CONTEXT PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE DOT UP UP_UP LEFT_PAR LEFT_BRK MINUS_GT }]
  [oclExpression ::= oclExpression (*) DIVIDE oclExpression , {EOF ENDPACKAGE CONTEXT PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE DOT UP UP_UP LEFT_PAR LEFT_BRK MINUS_GT }]
  [oclExpression ::= oclExpression (*) GT oclExpression , {EOF ENDPACKAGE CONTEXT PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE DOT UP UP_UP LEFT_PAR LEFT_BRK MINUS_GT }]
  [oclExpression ::= oclExpression (*) AND oclExpression , {EOF ENDPACKAGE CONTEXT PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE DOT UP UP_UP LEFT_PAR LEFT_BRK MINUS_GT }]
  [oclExpression ::= oclExpression (*) UP_UP simpleName LEFT_PAR oclMessageArgumentList RIGHT_PAR , {EOF ENDPACKAGE CONTEXT PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE DOT UP UP_UP LEFT_PAR LEFT_BRK MINUS_GT }]
}
transition on XOR to state [74]
transition on EQ to state [73]
transition on DOT to state [72]
transition on MINUS to state [71]
transition on GE to state [70]
transition on LEFT_BRK to state [69]
transition on DIVIDE to state [68]
transition on LEFT_PAR to state [67]
transition on MINUS_GT to state [66]
transition on LE to state [65]
transition on GT to state [64]
transition on IMPLIES to state [63]
transition on UP to state [62]
transition on UP_UP to state [61]
transition on OR to state [60]
transition on PLUS to state [59]
transition on NE to state [58]
transition on LT to state [57]
transition on AND to state [56]
transition on TIMES to state [55]

-------------------
lalr_state [242]: {
  [oclExpression ::= oclExpression (*) LEFT_BRK argumentList RIGHT_BRK isMarkedPre , {EOF ENDPACKAGE CONTEXT PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE DOT UP UP_UP LEFT_PAR LEFT_BRK MINUS_GT }]
  [oclExpression ::= oclExpression (*) EQ oclExpression , {EOF ENDPACKAGE CONTEXT PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE DOT UP UP_UP LEFT_PAR LEFT_BRK MINUS_GT }]
  [oclExpression ::= oclExpression (*) IMPLIES oclExpression , {EOF ENDPACKAGE CONTEXT PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE DOT UP UP_UP LEFT_PAR LEFT_BRK MINUS_GT }]
  [oclExpression ::= oclExpression (*) UP simpleName LEFT_PAR RIGHT_PAR , {EOF ENDPACKAGE CONTEXT PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE DOT UP UP_UP LEFT_PAR LEFT_BRK MINUS_GT }]
  [oclExpression ::= oclExpression (*) LEFT_PAR arguments RIGHT_PAR , {EOF ENDPACKAGE CONTEXT PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE DOT UP UP_UP LEFT_PAR LEFT_BRK MINUS_GT }]
  [oclExpression ::= oclExpression (*) MINUS_GT ITERATE LEFT_PAR variableDeclaration BAR oclExpression RIGHT_PAR , {EOF ENDPACKAGE CONTEXT PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE DOT UP UP_UP LEFT_PAR LEFT_BRK MINUS_GT }]
  [prePostOrBodyDecl ::= POST COLON oclExpression (*) , {EOF ENDPACKAGE CONTEXT PRE POST BODY }]
  [oclExpression ::= oclExpression (*) PLUS oclExpression , {EOF ENDPACKAGE CONTEXT PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE DOT UP UP_UP LEFT_PAR LEFT_BRK MINUS_GT }]
  [oclExpression ::= oclExpression (*) LE oclExpression , {EOF ENDPACKAGE CONTEXT PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE DOT UP UP_UP LEFT_PAR LEFT_BRK MINUS_GT }]
  [oclExpression ::= oclExpression (*) OR oclExpression , {EOF ENDPACKAGE CONTEXT PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE DOT UP UP_UP LEFT_PAR LEFT_BRK MINUS_GT }]
  [oclExpression ::= oclExpression (*) UP_UP simpleName LEFT_PAR RIGHT_PAR , {EOF ENDPACKAGE CONTEXT PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE DOT UP UP_UP LEFT_PAR LEFT_BRK MINUS_GT }]
  [oclExpression ::= oclExpression (*) MINUS_GT simpleName , {EOF ENDPACKAGE CONTEXT PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE DOT UP UP_UP LEFT_PAR LEFT_BRK MINUS_GT }]
  [oclExpression ::= oclExpression (*) TIMES oclExpression , {EOF ENDPACKAGE CONTEXT PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE DOT UP UP_UP LEFT_PAR LEFT_BRK MINUS_GT }]
  [oclExpression ::= oclExpression (*) LT oclExpression , {EOF ENDPACKAGE CONTEXT PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE DOT UP UP_UP LEFT_PAR LEFT_BRK MINUS_GT }]
  [oclExpression ::= oclExpression (*) NE oclExpression , {EOF ENDPACKAGE CONTEXT PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE DOT UP UP_UP LEFT_PAR LEFT_BRK MINUS_GT }]
  [oclExpression ::= oclExpression (*) LEFT_PAR variableDeclaration BAR oclExpression RIGHT_PAR , {EOF ENDPACKAGE CONTEXT PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE DOT UP UP_UP LEFT_PAR LEFT_BRK MINUS_GT }]
  [oclExpression ::= oclExpression (*) MINUS oclExpression , {EOF ENDPACKAGE CONTEXT PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE DOT UP UP_UP LEFT_PAR LEFT_BRK MINUS_GT }]
  [oclExpression ::= oclExpression (*) GE oclExpression , {EOF ENDPACKAGE CONTEXT PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE DOT UP UP_UP LEFT_PAR LEFT_BRK MINUS_GT }]
  [oclExpression ::= oclExpression (*) XOR oclExpression , {EOF ENDPACKAGE CONTEXT PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE DOT UP UP_UP LEFT_PAR LEFT_BRK MINUS_GT }]
  [oclExpression ::= oclExpression (*) UP simpleName LEFT_PAR oclMessageArgumentList RIGHT_PAR , {EOF ENDPACKAGE CONTEXT PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE DOT UP UP_UP LEFT_PAR LEFT_BRK MINUS_GT }]
  [oclExpression ::= oclExpression (*) DOT simpleName isMarkedPre , {EOF ENDPACKAGE CONTEXT PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE DOT UP UP_UP LEFT_PAR LEFT_BRK MINUS_GT }]
  [oclExpression ::= oclExpression (*) MINUS_GT ITERATE LEFT_PAR variableDeclaration SEMICOLON variableDeclaration BAR oclExpression RIGHT_PAR , {EOF ENDPACKAGE CONTEXT PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE DOT UP UP_UP LEFT_PAR LEFT_BRK MINUS_GT }]
  [oclExpression ::= oclExpression (*) DIVIDE oclExpression , {EOF ENDPACKAGE CONTEXT PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE DOT UP UP_UP LEFT_PAR LEFT_BRK MINUS_GT }]
  [oclExpression ::= oclExpression (*) GT oclExpression , {EOF ENDPACKAGE CONTEXT PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE DOT UP UP_UP LEFT_PAR LEFT_BRK MINUS_GT }]
  [oclExpression ::= oclExpression (*) AND oclExpression , {EOF ENDPACKAGE CONTEXT PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE DOT UP UP_UP LEFT_PAR LEFT_BRK MINUS_GT }]
  [oclExpression ::= oclExpression (*) UP_UP simpleName LEFT_PAR oclMessageArgumentList RIGHT_PAR , {EOF ENDPACKAGE CONTEXT PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE DOT UP UP_UP LEFT_PAR LEFT_BRK MINUS_GT }]
}
transition on XOR to state [74]
transition on EQ to state [73]
transition on DOT to state [72]
transition on MINUS to state [71]
transition on GE to state [70]
transition on LEFT_BRK to state [69]
transition on DIVIDE to state [68]
transition on LEFT_PAR to state [67]
transition on MINUS_GT to state [66]
transition on LE to state [65]
transition on GT to state [64]
transition on IMPLIES to state [63]
transition on UP to state [62]
transition on UP_UP to state [61]
transition on OR to state [60]
transition on PLUS to state [59]
transition on NE to state [58]
transition on LT to state [57]
transition on AND to state [56]
transition on TIMES to state [55]

-------------------
lalr_state [243]: {
  [prePostOrBodyDecl ::= prePostOrBodyDecl PRE (*) COLON oclExpression , {EOF ENDPACKAGE CONTEXT PRE POST BODY }]
  [prePostOrBodyDecl ::= prePostOrBodyDecl PRE (*) simpleName COLON oclExpression , {EOF ENDPACKAGE CONTEXT PRE POST BODY }]
  [simpleName ::= (*) SIMPLE_NAME , {COLON }]
}
transition on SIMPLE_NAME to state [12]
transition on COLON to state [257]
transition on simpleName to state [256]

-------------------
lalr_state [244]: {
  [prePostOrBodyDecl ::= prePostOrBodyDecl BODY (*) simpleName COLON oclExpression , {EOF ENDPACKAGE CONTEXT PRE POST BODY }]
  [simpleName ::= (*) SIMPLE_NAME , {COLON }]
  [prePostOrBodyDecl ::= prePostOrBodyDecl BODY (*) COLON oclExpression , {EOF ENDPACKAGE CONTEXT PRE POST BODY }]
}
transition on SIMPLE_NAME to state [12]
transition on simpleName to state [252]
transition on COLON to state [251]

-------------------
lalr_state [245]: {
  [prePostOrBodyDecl ::= prePostOrBodyDecl POST (*) COLON oclExpression , {EOF ENDPACKAGE CONTEXT PRE POST BODY }]
  [simpleName ::= (*) SIMPLE_NAME , {COLON }]
  [prePostOrBodyDecl ::= prePostOrBodyDecl POST (*) simpleName COLON oclExpression , {EOF ENDPACKAGE CONTEXT PRE POST BODY }]
}
transition on SIMPLE_NAME to state [12]
transition on COLON to state [247]
transition on simpleName to state [246]

-------------------
lalr_state [246]: {
  [prePostOrBodyDecl ::= prePostOrBodyDecl POST simpleName (*) COLON oclExpression , {EOF ENDPACKAGE CONTEXT PRE POST BODY }]
}
transition on COLON to state [249]

-------------------
lalr_state [247]: {
  [oclExpression ::= (*) oclExpression UP simpleName LEFT_PAR oclMessageArgumentList RIGHT_PAR , {EOF ENDPACKAGE CONTEXT PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE DOT UP UP_UP LEFT_PAR LEFT_BRK MINUS_GT }]
  [oclExpression ::= (*) oclExpression EQ oclExpression , {EOF ENDPACKAGE CONTEXT PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE DOT UP UP_UP LEFT_PAR LEFT_BRK MINUS_GT }]
  [oclExpression ::= (*) oclExpression TIMES oclExpression , {EOF ENDPACKAGE CONTEXT PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE DOT UP UP_UP LEFT_PAR LEFT_BRK MINUS_GT }]
  [oclExpression ::= (*) oclExpression DOT simpleName isMarkedPre , {EOF ENDPACKAGE CONTEXT PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE DOT UP UP_UP LEFT_PAR LEFT_BRK MINUS_GT }]
  [primitiveLiteralExp ::= (*) TRUE , {EOF ENDPACKAGE CONTEXT PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE DOT UP UP_UP LEFT_PAR LEFT_BRK MINUS_GT }]
  [literalExp ::= (*) tupleLiteralExp , {EOF ENDPACKAGE CONTEXT PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE DOT UP UP_UP LEFT_PAR LEFT_BRK MINUS_GT }]
  [oclExpression ::= (*) oclExpression IMPLIES oclExpression , {EOF ENDPACKAGE CONTEXT PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE DOT UP UP_UP LEFT_PAR LEFT_BRK MINUS_GT }]
  [oclExpression ::= (*) oclExpression LT oclExpression , {EOF ENDPACKAGE CONTEXT PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE DOT UP UP_UP LEFT_PAR LEFT_BRK MINUS_GT }]
  [oclExpression ::= (*) oclExpression MINUS_GT ITERATE LEFT_PAR variableDeclaration SEMICOLON variableDeclaration BAR oclExpression RIGHT_PAR , {EOF ENDPACKAGE CONTEXT PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE DOT UP UP_UP LEFT_PAR LEFT_BRK MINUS_GT }]
  [tupleLiteralExp ::= (*) TUPLE LEFT_BRA variableDeclarationList RIGHT_BRA , {EOF ENDPACKAGE CONTEXT PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE DOT UP UP_UP LEFT_PAR LEFT_BRK MINUS_GT }]
  [collectionKind ::= (*) SET , {LEFT_BRA }]
  [oclExpression ::= (*) oclExpression UP simpleName LEFT_PAR RIGHT_PAR , {EOF ENDPACKAGE CONTEXT PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE DOT UP UP_UP LEFT_PAR LEFT_BRK MINUS_GT }]
  [oclExpression ::= (*) oclExpression NE oclExpression , {EOF ENDPACKAGE CONTEXT PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE DOT UP UP_UP LEFT_PAR LEFT_BRK MINUS_GT }]
  [oclExpression ::= (*) oclExpression DIVIDE oclExpression , {EOF ENDPACKAGE CONTEXT PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE DOT UP UP_UP LEFT_PAR LEFT_BRK MINUS_GT }]
  [oclExpression ::= (*) oclExpression LEFT_PAR arguments RIGHT_PAR , {EOF ENDPACKAGE CONTEXT PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE DOT UP UP_UP LEFT_PAR LEFT_BRK MINUS_GT }]
  [primitiveLiteralExp ::= (*) FALSE , {EOF ENDPACKAGE CONTEXT PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE DOT UP UP_UP LEFT_PAR LEFT_BRK MINUS_GT }]
  [literalExp ::= (*) primitiveLiteralExp , {EOF ENDPACKAGE CONTEXT PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE DOT UP UP_UP LEFT_PAR LEFT_BRK MINUS_GT }]
  [oclExpression ::= (*) LET variableDeclarationList IN oclExpression , {EOF ENDPACKAGE CONTEXT PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE DOT UP UP_UP LEFT_PAR LEFT_BRK MINUS_GT }]
  [oclExpression ::= (*) oclExpression GT oclExpression , {EOF ENDPACKAGE CONTEXT PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE DOT UP UP_UP LEFT_PAR LEFT_BRK MINUS_GT }]
  [oclExpression ::= (*) oclExpression MINUS_GT ITERATE LEFT_PAR variableDeclaration BAR oclExpression RIGHT_PAR , {EOF ENDPACKAGE CONTEXT PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE DOT UP UP_UP LEFT_PAR LEFT_BRK MINUS_GT }]
  [oclExpression ::= (*) literalExp , {EOF ENDPACKAGE CONTEXT PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE DOT UP UP_UP LEFT_PAR LEFT_BRK MINUS_GT }]
  [primitiveLiteralExp ::= (*) INTEGER , {EOF ENDPACKAGE CONTEXT PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE DOT UP UP_UP LEFT_PAR LEFT_BRK MINUS_GT }]
  [collectionKind ::= (*) BAG , {LEFT_BRA }]
  [oclExpression ::= (*) oclExpression AND oclExpression , {EOF ENDPACKAGE CONTEXT PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE DOT UP UP_UP LEFT_PAR LEFT_BRK MINUS_GT }]
  [oclExpression ::= (*) oclExpression PLUS oclExpression , {EOF ENDPACKAGE CONTEXT PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE DOT UP UP_UP LEFT_PAR LEFT_BRK MINUS_GT }]
  [prePostOrBodyDecl ::= prePostOrBodyDecl POST COLON (*) oclExpression , {EOF ENDPACKAGE CONTEXT PRE POST BODY }]
  [oclExpression ::= (*) oclExpression LEFT_PAR variableDeclaration BAR oclExpression RIGHT_PAR , {EOF ENDPACKAGE CONTEXT PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE DOT UP UP_UP LEFT_PAR LEFT_BRK MINUS_GT }]
  [pathName ::= (*) simpleName , {EOF ENDPACKAGE CONTEXT PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE DOT UP AT COLON_COLON UP_UP LEFT_PAR LEFT_BRK MINUS_GT }]
  [oclExpression ::= (*) oclExpression UP_UP simpleName LEFT_PAR oclMessageArgumentList RIGHT_PAR , {EOF ENDPACKAGE CONTEXT PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE DOT UP UP_UP LEFT_PAR LEFT_BRK MINUS_GT }]
  [oclExpression ::= (*) oclExpression LE oclExpression , {EOF ENDPACKAGE CONTEXT PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE DOT UP UP_UP LEFT_PAR LEFT_BRK MINUS_GT }]
  [oclExpression ::= (*) NOT oclExpression , {EOF ENDPACKAGE CONTEXT PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE DOT UP UP_UP LEFT_PAR LEFT_BRK MINUS_GT }]
  [oclExpression ::= (*) LEFT_PAR oclExpression RIGHT_PAR , {EOF ENDPACKAGE CONTEXT PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE DOT UP UP_UP LEFT_PAR LEFT_BRK MINUS_GT }]
  [primitiveLiteralExp ::= (*) REAL , {EOF ENDPACKAGE CONTEXT PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE DOT UP UP_UP LEFT_PAR LEFT_BRK MINUS_GT }]
  [collectionKind ::= (*) SEQUENCE , {LEFT_BRA }]
  [oclExpression ::= (*) oclExpression OR oclExpression , {EOF ENDPACKAGE CONTEXT PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE DOT UP UP_UP LEFT_PAR LEFT_BRK MINUS_GT }]
  [oclExpression ::= (*) oclExpression MINUS oclExpression , {EOF ENDPACKAGE CONTEXT PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE DOT UP UP_UP LEFT_PAR LEFT_BRK MINUS_GT }]
  [oclExpression ::= (*) oclExpression LEFT_BRK argumentList RIGHT_BRK isMarkedPre , {EOF ENDPACKAGE CONTEXT PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE DOT UP UP_UP LEFT_PAR LEFT_BRK MINUS_GT }]
  [pathName ::= (*) pathName COLON_COLON simpleName , {EOF ENDPACKAGE CONTEXT PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE DOT UP AT COLON_COLON UP_UP LEFT_PAR LEFT_BRK MINUS_GT }]
  [collectionLiteralExp ::= (*) collectionKind LEFT_BRA collectionLiteralParts RIGHT_BRA , {EOF ENDPACKAGE CONTEXT PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE DOT UP UP_UP LEFT_PAR LEFT_BRK MINUS_GT }]
  [oclExpression ::= (*) oclExpression UP_UP simpleName LEFT_PAR RIGHT_PAR , {EOF ENDPACKAGE CONTEXT PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE DOT UP UP_UP LEFT_PAR LEFT_BRK MINUS_GT }]
  [oclExpression ::= (*) oclExpression GE oclExpression , {EOF ENDPACKAGE CONTEXT PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE DOT UP UP_UP LEFT_PAR LEFT_BRK MINUS_GT }]
  [oclExpression ::= (*) MINUS oclExpression , {EOF ENDPACKAGE CONTEXT PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE DOT UP UP_UP LEFT_PAR LEFT_BRK MINUS_GT }]
  [oclExpression ::= (*) pathName isMarkedPre , {EOF ENDPACKAGE CONTEXT PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE DOT UP UP_UP LEFT_PAR LEFT_BRK MINUS_GT }]
  [primitiveLiteralExp ::= (*) STRING , {EOF ENDPACKAGE CONTEXT PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE DOT UP UP_UP LEFT_PAR LEFT_BRK MINUS_GT }]
  [collectionKind ::= (*) COLLECTION , {LEFT_BRA }]
  [literalExp ::= (*) collectionLiteralExp , {EOF ENDPACKAGE CONTEXT PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE DOT UP UP_UP LEFT_PAR LEFT_BRK MINUS_GT }]
  [oclExpression ::= (*) oclExpression XOR oclExpression , {EOF ENDPACKAGE CONTEXT PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE DOT UP UP_UP LEFT_PAR LEFT_BRK MINUS_GT }]
  [oclExpression ::= (*) IF oclExpression THEN oclExpression ELSE oclExpression ENDIF , {EOF ENDPACKAGE CONTEXT PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE DOT UP UP_UP LEFT_PAR LEFT_BRK MINUS_GT }]
  [oclExpression ::= (*) oclExpression MINUS_GT simpleName , {EOF ENDPACKAGE CONTEXT PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE DOT UP UP_UP LEFT_PAR LEFT_BRK MINUS_GT }]
  [simpleName ::= (*) SIMPLE_NAME , {EOF ENDPACKAGE CONTEXT PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE DOT UP AT COLON_COLON UP_UP LEFT_PAR LEFT_BRK MINUS_GT }]
  [collectionLiteralExp ::= (*) collectionKind LEFT_BRA RIGHT_BRA , {EOF ENDPACKAGE CONTEXT PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE DOT UP UP_UP LEFT_PAR LEFT_BRK MINUS_GT }]
}
transition on tupleLiteralExp to state [54]
transition on oclExpression to state [248]
transition on REAL to state [52]
transition on INTEGER to state [51]
transition on pathName to state [50]
transition on SIMPLE_NAME to state [12]
transition on LET to state [49]
transition on FALSE to state [48]
transition on MINUS to state [47]
transition on COLLECTION to state [28]
transition on SET to state [20]
transition on simpleName to state [26]
transition on collectionLiteralExp to state [46]
transition on LEFT_PAR to state [45]
transition on STRING to state [44]
transition on IF to state [43]
transition on TRUE to state [42]
transition on collectionKind to state [41]
transition on NOT to state [40]
transition on primitiveLiteralExp to state [39]
transition on TUPLE to state [38]
transition on literalExp to state [37]
transition on BAG to state [25]
transition on SEQUENCE to state [22]

-------------------
lalr_state [248]: {
  [oclExpression ::= oclExpression (*) LEFT_BRK argumentList RIGHT_BRK isMarkedPre , {EOF ENDPACKAGE CONTEXT PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE DOT UP UP_UP LEFT_PAR LEFT_BRK MINUS_GT }]
  [oclExpression ::= oclExpression (*) EQ oclExpression , {EOF ENDPACKAGE CONTEXT PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE DOT UP UP_UP LEFT_PAR LEFT_BRK MINUS_GT }]
  [oclExpression ::= oclExpression (*) IMPLIES oclExpression , {EOF ENDPACKAGE CONTEXT PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE DOT UP UP_UP LEFT_PAR LEFT_BRK MINUS_GT }]
  [oclExpression ::= oclExpression (*) UP simpleName LEFT_PAR RIGHT_PAR , {EOF ENDPACKAGE CONTEXT PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE DOT UP UP_UP LEFT_PAR LEFT_BRK MINUS_GT }]
  [oclExpression ::= oclExpression (*) LEFT_PAR arguments RIGHT_PAR , {EOF ENDPACKAGE CONTEXT PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE DOT UP UP_UP LEFT_PAR LEFT_BRK MINUS_GT }]
  [oclExpression ::= oclExpression (*) MINUS_GT ITERATE LEFT_PAR variableDeclaration BAR oclExpression RIGHT_PAR , {EOF ENDPACKAGE CONTEXT PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE DOT UP UP_UP LEFT_PAR LEFT_BRK MINUS_GT }]
  [oclExpression ::= oclExpression (*) PLUS oclExpression , {EOF ENDPACKAGE CONTEXT PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE DOT UP UP_UP LEFT_PAR LEFT_BRK MINUS_GT }]
  [oclExpression ::= oclExpression (*) LE oclExpression , {EOF ENDPACKAGE CONTEXT PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE DOT UP UP_UP LEFT_PAR LEFT_BRK MINUS_GT }]
  [oclExpression ::= oclExpression (*) OR oclExpression , {EOF ENDPACKAGE CONTEXT PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE DOT UP UP_UP LEFT_PAR LEFT_BRK MINUS_GT }]
  [oclExpression ::= oclExpression (*) UP_UP simpleName LEFT_PAR RIGHT_PAR , {EOF ENDPACKAGE CONTEXT PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE DOT UP UP_UP LEFT_PAR LEFT_BRK MINUS_GT }]
  [oclExpression ::= oclExpression (*) MINUS_GT simpleName , {EOF ENDPACKAGE CONTEXT PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE DOT UP UP_UP LEFT_PAR LEFT_BRK MINUS_GT }]
  [oclExpression ::= oclExpression (*) TIMES oclExpression , {EOF ENDPACKAGE CONTEXT PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE DOT UP UP_UP LEFT_PAR LEFT_BRK MINUS_GT }]
  [oclExpression ::= oclExpression (*) LT oclExpression , {EOF ENDPACKAGE CONTEXT PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE DOT UP UP_UP LEFT_PAR LEFT_BRK MINUS_GT }]
  [oclExpression ::= oclExpression (*) NE oclExpression , {EOF ENDPACKAGE CONTEXT PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE DOT UP UP_UP LEFT_PAR LEFT_BRK MINUS_GT }]
  [oclExpression ::= oclExpression (*) LEFT_PAR variableDeclaration BAR oclExpression RIGHT_PAR , {EOF ENDPACKAGE CONTEXT PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE DOT UP UP_UP LEFT_PAR LEFT_BRK MINUS_GT }]
  [prePostOrBodyDecl ::= prePostOrBodyDecl POST COLON oclExpression (*) , {EOF ENDPACKAGE CONTEXT PRE POST BODY }]
  [oclExpression ::= oclExpression (*) MINUS oclExpression , {EOF ENDPACKAGE CONTEXT PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE DOT UP UP_UP LEFT_PAR LEFT_BRK MINUS_GT }]
  [oclExpression ::= oclExpression (*) GE oclExpression , {EOF ENDPACKAGE CONTEXT PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE DOT UP UP_UP LEFT_PAR LEFT_BRK MINUS_GT }]
  [oclExpression ::= oclExpression (*) XOR oclExpression , {EOF ENDPACKAGE CONTEXT PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE DOT UP UP_UP LEFT_PAR LEFT_BRK MINUS_GT }]
  [oclExpression ::= oclExpression (*) UP simpleName LEFT_PAR oclMessageArgumentList RIGHT_PAR , {EOF ENDPACKAGE CONTEXT PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE DOT UP UP_UP LEFT_PAR LEFT_BRK MINUS_GT }]
  [oclExpression ::= oclExpression (*) DOT simpleName isMarkedPre , {EOF ENDPACKAGE CONTEXT PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE DOT UP UP_UP LEFT_PAR LEFT_BRK MINUS_GT }]
  [oclExpression ::= oclExpression (*) MINUS_GT ITERATE LEFT_PAR variableDeclaration SEMICOLON variableDeclaration BAR oclExpression RIGHT_PAR , {EOF ENDPACKAGE CONTEXT PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE DOT UP UP_UP LEFT_PAR LEFT_BRK MINUS_GT }]
  [oclExpression ::= oclExpression (*) DIVIDE oclExpression , {EOF ENDPACKAGE CONTEXT PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE DOT UP UP_UP LEFT_PAR LEFT_BRK MINUS_GT }]
  [oclExpression ::= oclExpression (*) GT oclExpression , {EOF ENDPACKAGE CONTEXT PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE DOT UP UP_UP LEFT_PAR LEFT_BRK MINUS_GT }]
  [oclExpression ::= oclExpression (*) AND oclExpression , {EOF ENDPACKAGE CONTEXT PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE DOT UP UP_UP LEFT_PAR LEFT_BRK MINUS_GT }]
  [oclExpression ::= oclExpression (*) UP_UP simpleName LEFT_PAR oclMessageArgumentList RIGHT_PAR , {EOF ENDPACKAGE CONTEXT PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE DOT UP UP_UP LEFT_PAR LEFT_BRK MINUS_GT }]
}
transition on XOR to state [74]
transition on EQ to state [73]
transition on DOT to state [72]
transition on MINUS to state [71]
transition on GE to state [70]
transition on LEFT_BRK to state [69]
transition on DIVIDE to state [68]
transition on LEFT_PAR to state [67]
transition on MINUS_GT to state [66]
transition on LE to state [65]
transition on GT to state [64]
transition on IMPLIES to state [63]
transition on UP to state [62]
transition on UP_UP to state [61]
transition on OR to state [60]
transition on PLUS to state [59]
transition on NE to state [58]
transition on LT to state [57]
transition on AND to state [56]
transition on TIMES to state [55]

-------------------
lalr_state [249]: {
  [oclExpression ::= (*) oclExpression UP simpleName LEFT_PAR oclMessageArgumentList RIGHT_PAR , {EOF ENDPACKAGE CONTEXT PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE DOT UP UP_UP LEFT_PAR LEFT_BRK MINUS_GT }]
  [oclExpression ::= (*) oclExpression EQ oclExpression , {EOF ENDPACKAGE CONTEXT PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE DOT UP UP_UP LEFT_PAR LEFT_BRK MINUS_GT }]
  [oclExpression ::= (*) oclExpression TIMES oclExpression , {EOF ENDPACKAGE CONTEXT PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE DOT UP UP_UP LEFT_PAR LEFT_BRK MINUS_GT }]
  [oclExpression ::= (*) oclExpression DOT simpleName isMarkedPre , {EOF ENDPACKAGE CONTEXT PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE DOT UP UP_UP LEFT_PAR LEFT_BRK MINUS_GT }]
  [primitiveLiteralExp ::= (*) TRUE , {EOF ENDPACKAGE CONTEXT PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE DOT UP UP_UP LEFT_PAR LEFT_BRK MINUS_GT }]
  [literalExp ::= (*) tupleLiteralExp , {EOF ENDPACKAGE CONTEXT PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE DOT UP UP_UP LEFT_PAR LEFT_BRK MINUS_GT }]
  [oclExpression ::= (*) oclExpression IMPLIES oclExpression , {EOF ENDPACKAGE CONTEXT PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE DOT UP UP_UP LEFT_PAR LEFT_BRK MINUS_GT }]
  [oclExpression ::= (*) oclExpression LT oclExpression , {EOF ENDPACKAGE CONTEXT PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE DOT UP UP_UP LEFT_PAR LEFT_BRK MINUS_GT }]
  [oclExpression ::= (*) oclExpression MINUS_GT ITERATE LEFT_PAR variableDeclaration SEMICOLON variableDeclaration BAR oclExpression RIGHT_PAR , {EOF ENDPACKAGE CONTEXT PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE DOT UP UP_UP LEFT_PAR LEFT_BRK MINUS_GT }]
  [tupleLiteralExp ::= (*) TUPLE LEFT_BRA variableDeclarationList RIGHT_BRA , {EOF ENDPACKAGE CONTEXT PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE DOT UP UP_UP LEFT_PAR LEFT_BRK MINUS_GT }]
  [collectionKind ::= (*) SET , {LEFT_BRA }]
  [oclExpression ::= (*) oclExpression UP simpleName LEFT_PAR RIGHT_PAR , {EOF ENDPACKAGE CONTEXT PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE DOT UP UP_UP LEFT_PAR LEFT_BRK MINUS_GT }]
  [oclExpression ::= (*) oclExpression NE oclExpression , {EOF ENDPACKAGE CONTEXT PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE DOT UP UP_UP LEFT_PAR LEFT_BRK MINUS_GT }]
  [oclExpression ::= (*) oclExpression DIVIDE oclExpression , {EOF ENDPACKAGE CONTEXT PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE DOT UP UP_UP LEFT_PAR LEFT_BRK MINUS_GT }]
  [prePostOrBodyDecl ::= prePostOrBodyDecl POST simpleName COLON (*) oclExpression , {EOF ENDPACKAGE CONTEXT PRE POST BODY }]
  [oclExpression ::= (*) oclExpression LEFT_PAR arguments RIGHT_PAR , {EOF ENDPACKAGE CONTEXT PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE DOT UP UP_UP LEFT_PAR LEFT_BRK MINUS_GT }]
  [primitiveLiteralExp ::= (*) FALSE , {EOF ENDPACKAGE CONTEXT PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE DOT UP UP_UP LEFT_PAR LEFT_BRK MINUS_GT }]
  [literalExp ::= (*) primitiveLiteralExp , {EOF ENDPACKAGE CONTEXT PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE DOT UP UP_UP LEFT_PAR LEFT_BRK MINUS_GT }]
  [oclExpression ::= (*) LET variableDeclarationList IN oclExpression , {EOF ENDPACKAGE CONTEXT PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE DOT UP UP_UP LEFT_PAR LEFT_BRK MINUS_GT }]
  [oclExpression ::= (*) oclExpression GT oclExpression , {EOF ENDPACKAGE CONTEXT PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE DOT UP UP_UP LEFT_PAR LEFT_BRK MINUS_GT }]
  [oclExpression ::= (*) oclExpression MINUS_GT ITERATE LEFT_PAR variableDeclaration BAR oclExpression RIGHT_PAR , {EOF ENDPACKAGE CONTEXT PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE DOT UP UP_UP LEFT_PAR LEFT_BRK MINUS_GT }]
  [oclExpression ::= (*) literalExp , {EOF ENDPACKAGE CONTEXT PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE DOT UP UP_UP LEFT_PAR LEFT_BRK MINUS_GT }]
  [primitiveLiteralExp ::= (*) INTEGER , {EOF ENDPACKAGE CONTEXT PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE DOT UP UP_UP LEFT_PAR LEFT_BRK MINUS_GT }]
  [collectionKind ::= (*) BAG , {LEFT_BRA }]
  [oclExpression ::= (*) oclExpression AND oclExpression , {EOF ENDPACKAGE CONTEXT PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE DOT UP UP_UP LEFT_PAR LEFT_BRK MINUS_GT }]
  [oclExpression ::= (*) oclExpression PLUS oclExpression , {EOF ENDPACKAGE CONTEXT PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE DOT UP UP_UP LEFT_PAR LEFT_BRK MINUS_GT }]
  [oclExpression ::= (*) oclExpression LEFT_PAR variableDeclaration BAR oclExpression RIGHT_PAR , {EOF ENDPACKAGE CONTEXT PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE DOT UP UP_UP LEFT_PAR LEFT_BRK MINUS_GT }]
  [pathName ::= (*) simpleName , {EOF ENDPACKAGE CONTEXT PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE DOT UP AT COLON_COLON UP_UP LEFT_PAR LEFT_BRK MINUS_GT }]
  [oclExpression ::= (*) oclExpression UP_UP simpleName LEFT_PAR oclMessageArgumentList RIGHT_PAR , {EOF ENDPACKAGE CONTEXT PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE DOT UP UP_UP LEFT_PAR LEFT_BRK MINUS_GT }]
  [oclExpression ::= (*) oclExpression LE oclExpression , {EOF ENDPACKAGE CONTEXT PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE DOT UP UP_UP LEFT_PAR LEFT_BRK MINUS_GT }]
  [oclExpression ::= (*) NOT oclExpression , {EOF ENDPACKAGE CONTEXT PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE DOT UP UP_UP LEFT_PAR LEFT_BRK MINUS_GT }]
  [oclExpression ::= (*) LEFT_PAR oclExpression RIGHT_PAR , {EOF ENDPACKAGE CONTEXT PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE DOT UP UP_UP LEFT_PAR LEFT_BRK MINUS_GT }]
  [primitiveLiteralExp ::= (*) REAL , {EOF ENDPACKAGE CONTEXT PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE DOT UP UP_UP LEFT_PAR LEFT_BRK MINUS_GT }]
  [collectionKind ::= (*) SEQUENCE , {LEFT_BRA }]
  [oclExpression ::= (*) oclExpression OR oclExpression , {EOF ENDPACKAGE CONTEXT PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE DOT UP UP_UP LEFT_PAR LEFT_BRK MINUS_GT }]
  [oclExpression ::= (*) oclExpression MINUS oclExpression , {EOF ENDPACKAGE CONTEXT PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE DOT UP UP_UP LEFT_PAR LEFT_BRK MINUS_GT }]
  [oclExpression ::= (*) oclExpression LEFT_BRK argumentList RIGHT_BRK isMarkedPre , {EOF ENDPACKAGE CONTEXT PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE DOT UP UP_UP LEFT_PAR LEFT_BRK MINUS_GT }]
  [pathName ::= (*) pathName COLON_COLON simpleName , {EOF ENDPACKAGE CONTEXT PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE DOT UP AT COLON_COLON UP_UP LEFT_PAR LEFT_BRK MINUS_GT }]
  [collectionLiteralExp ::= (*) collectionKind LEFT_BRA collectionLiteralParts RIGHT_BRA , {EOF ENDPACKAGE CONTEXT PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE DOT UP UP_UP LEFT_PAR LEFT_BRK MINUS_GT }]
  [oclExpression ::= (*) oclExpression UP_UP simpleName LEFT_PAR RIGHT_PAR , {EOF ENDPACKAGE CONTEXT PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE DOT UP UP_UP LEFT_PAR LEFT_BRK MINUS_GT }]
  [oclExpression ::= (*) oclExpression GE oclExpression , {EOF ENDPACKAGE CONTEXT PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE DOT UP UP_UP LEFT_PAR LEFT_BRK MINUS_GT }]
  [oclExpression ::= (*) MINUS oclExpression , {EOF ENDPACKAGE CONTEXT PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE DOT UP UP_UP LEFT_PAR LEFT_BRK MINUS_GT }]
  [oclExpression ::= (*) pathName isMarkedPre , {EOF ENDPACKAGE CONTEXT PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE DOT UP UP_UP LEFT_PAR LEFT_BRK MINUS_GT }]
  [primitiveLiteralExp ::= (*) STRING , {EOF ENDPACKAGE CONTEXT PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE DOT UP UP_UP LEFT_PAR LEFT_BRK MINUS_GT }]
  [collectionKind ::= (*) COLLECTION , {LEFT_BRA }]
  [literalExp ::= (*) collectionLiteralExp , {EOF ENDPACKAGE CONTEXT PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE DOT UP UP_UP LEFT_PAR LEFT_BRK MINUS_GT }]
  [oclExpression ::= (*) oclExpression XOR oclExpression , {EOF ENDPACKAGE CONTEXT PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE DOT UP UP_UP LEFT_PAR LEFT_BRK MINUS_GT }]
  [oclExpression ::= (*) IF oclExpression THEN oclExpression ELSE oclExpression ENDIF , {EOF ENDPACKAGE CONTEXT PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE DOT UP UP_UP LEFT_PAR LEFT_BRK MINUS_GT }]
  [oclExpression ::= (*) oclExpression MINUS_GT simpleName , {EOF ENDPACKAGE CONTEXT PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE DOT UP UP_UP LEFT_PAR LEFT_BRK MINUS_GT }]
  [simpleName ::= (*) SIMPLE_NAME , {EOF ENDPACKAGE CONTEXT PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE DOT UP AT COLON_COLON UP_UP LEFT_PAR LEFT_BRK MINUS_GT }]
  [collectionLiteralExp ::= (*) collectionKind LEFT_BRA RIGHT_BRA , {EOF ENDPACKAGE CONTEXT PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE DOT UP UP_UP LEFT_PAR LEFT_BRK MINUS_GT }]
}
transition on tupleLiteralExp to state [54]
transition on oclExpression to state [250]
transition on REAL to state [52]
transition on INTEGER to state [51]
transition on pathName to state [50]
transition on SIMPLE_NAME to state [12]
transition on LET to state [49]
transition on FALSE to state [48]
transition on MINUS to state [47]
transition on COLLECTION to state [28]
transition on SET to state [20]
transition on simpleName to state [26]
transition on collectionLiteralExp to state [46]
transition on LEFT_PAR to state [45]
transition on STRING to state [44]
transition on IF to state [43]
transition on TRUE to state [42]
transition on collectionKind to state [41]
transition on NOT to state [40]
transition on primitiveLiteralExp to state [39]
transition on TUPLE to state [38]
transition on literalExp to state [37]
transition on BAG to state [25]
transition on SEQUENCE to state [22]

-------------------
lalr_state [250]: {
  [oclExpression ::= oclExpression (*) LEFT_BRK argumentList RIGHT_BRK isMarkedPre , {EOF ENDPACKAGE CONTEXT PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE DOT UP UP_UP LEFT_PAR LEFT_BRK MINUS_GT }]
  [oclExpression ::= oclExpression (*) EQ oclExpression , {EOF ENDPACKAGE CONTEXT PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE DOT UP UP_UP LEFT_PAR LEFT_BRK MINUS_GT }]
  [oclExpression ::= oclExpression (*) IMPLIES oclExpression , {EOF ENDPACKAGE CONTEXT PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE DOT UP UP_UP LEFT_PAR LEFT_BRK MINUS_GT }]
  [oclExpression ::= oclExpression (*) UP simpleName LEFT_PAR RIGHT_PAR , {EOF ENDPACKAGE CONTEXT PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE DOT UP UP_UP LEFT_PAR LEFT_BRK MINUS_GT }]
  [prePostOrBodyDecl ::= prePostOrBodyDecl POST simpleName COLON oclExpression (*) , {EOF ENDPACKAGE CONTEXT PRE POST BODY }]
  [oclExpression ::= oclExpression (*) LEFT_PAR arguments RIGHT_PAR , {EOF ENDPACKAGE CONTEXT PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE DOT UP UP_UP LEFT_PAR LEFT_BRK MINUS_GT }]
  [oclExpression ::= oclExpression (*) MINUS_GT ITERATE LEFT_PAR variableDeclaration BAR oclExpression RIGHT_PAR , {EOF ENDPACKAGE CONTEXT PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE DOT UP UP_UP LEFT_PAR LEFT_BRK MINUS_GT }]
  [oclExpression ::= oclExpression (*) PLUS oclExpression , {EOF ENDPACKAGE CONTEXT PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE DOT UP UP_UP LEFT_PAR LEFT_BRK MINUS_GT }]
  [oclExpression ::= oclExpression (*) LE oclExpression , {EOF ENDPACKAGE CONTEXT PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE DOT UP UP_UP LEFT_PAR LEFT_BRK MINUS_GT }]
  [oclExpression ::= oclExpression (*) OR oclExpression , {EOF ENDPACKAGE CONTEXT PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE DOT UP UP_UP LEFT_PAR LEFT_BRK MINUS_GT }]
  [oclExpression ::= oclExpression (*) UP_UP simpleName LEFT_PAR RIGHT_PAR , {EOF ENDPACKAGE CONTEXT PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE DOT UP UP_UP LEFT_PAR LEFT_BRK MINUS_GT }]
  [oclExpression ::= oclExpression (*) MINUS_GT simpleName , {EOF ENDPACKAGE CONTEXT PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE DOT UP UP_UP LEFT_PAR LEFT_BRK MINUS_GT }]
  [oclExpression ::= oclExpression (*) TIMES oclExpression , {EOF ENDPACKAGE CONTEXT PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE DOT UP UP_UP LEFT_PAR LEFT_BRK MINUS_GT }]
  [oclExpression ::= oclExpression (*) LT oclExpression , {EOF ENDPACKAGE CONTEXT PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE DOT UP UP_UP LEFT_PAR LEFT_BRK MINUS_GT }]
  [oclExpression ::= oclExpression (*) NE oclExpression , {EOF ENDPACKAGE CONTEXT PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE DOT UP UP_UP LEFT_PAR LEFT_BRK MINUS_GT }]
  [oclExpression ::= oclExpression (*) LEFT_PAR variableDeclaration BAR oclExpression RIGHT_PAR , {EOF ENDPACKAGE CONTEXT PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE DOT UP UP_UP LEFT_PAR LEFT_BRK MINUS_GT }]
  [oclExpression ::= oclExpression (*) MINUS oclExpression , {EOF ENDPACKAGE CONTEXT PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE DOT UP UP_UP LEFT_PAR LEFT_BRK MINUS_GT }]
  [oclExpression ::= oclExpression (*) GE oclExpression , {EOF ENDPACKAGE CONTEXT PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE DOT UP UP_UP LEFT_PAR LEFT_BRK MINUS_GT }]
  [oclExpression ::= oclExpression (*) XOR oclExpression , {EOF ENDPACKAGE CONTEXT PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE DOT UP UP_UP LEFT_PAR LEFT_BRK MINUS_GT }]
  [oclExpression ::= oclExpression (*) UP simpleName LEFT_PAR oclMessageArgumentList RIGHT_PAR , {EOF ENDPACKAGE CONTEXT PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE DOT UP UP_UP LEFT_PAR LEFT_BRK MINUS_GT }]
  [oclExpression ::= oclExpression (*) DOT simpleName isMarkedPre , {EOF ENDPACKAGE CONTEXT PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE DOT UP UP_UP LEFT_PAR LEFT_BRK MINUS_GT }]
  [oclExpression ::= oclExpression (*) MINUS_GT ITERATE LEFT_PAR variableDeclaration SEMICOLON variableDeclaration BAR oclExpression RIGHT_PAR , {EOF ENDPACKAGE CONTEXT PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE DOT UP UP_UP LEFT_PAR LEFT_BRK MINUS_GT }]
  [oclExpression ::= oclExpression (*) DIVIDE oclExpression , {EOF ENDPACKAGE CONTEXT PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE DOT UP UP_UP LEFT_PAR LEFT_BRK MINUS_GT }]
  [oclExpression ::= oclExpression (*) GT oclExpression , {EOF ENDPACKAGE CONTEXT PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE DOT UP UP_UP LEFT_PAR LEFT_BRK MINUS_GT }]
  [oclExpression ::= oclExpression (*) AND oclExpression , {EOF ENDPACKAGE CONTEXT PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE DOT UP UP_UP LEFT_PAR LEFT_BRK MINUS_GT }]
  [oclExpression ::= oclExpression (*) UP_UP simpleName LEFT_PAR oclMessageArgumentList RIGHT_PAR , {EOF ENDPACKAGE CONTEXT PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE DOT UP UP_UP LEFT_PAR LEFT_BRK MINUS_GT }]
}
transition on XOR to state [74]
transition on EQ to state [73]
transition on DOT to state [72]
transition on MINUS to state [71]
transition on GE to state [70]
transition on LEFT_BRK to state [69]
transition on DIVIDE to state [68]
transition on LEFT_PAR to state [67]
transition on MINUS_GT to state [66]
transition on LE to state [65]
transition on GT to state [64]
transition on IMPLIES to state [63]
transition on UP to state [62]
transition on UP_UP to state [61]
transition on OR to state [60]
transition on PLUS to state [59]
transition on NE to state [58]
transition on LT to state [57]
transition on AND to state [56]
transition on TIMES to state [55]

-------------------
lalr_state [251]: {
  [oclExpression ::= (*) oclExpression UP simpleName LEFT_PAR oclMessageArgumentList RIGHT_PAR , {EOF ENDPACKAGE CONTEXT PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE DOT UP UP_UP LEFT_PAR LEFT_BRK MINUS_GT }]
  [oclExpression ::= (*) oclExpression EQ oclExpression , {EOF ENDPACKAGE CONTEXT PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE DOT UP UP_UP LEFT_PAR LEFT_BRK MINUS_GT }]
  [oclExpression ::= (*) oclExpression TIMES oclExpression , {EOF ENDPACKAGE CONTEXT PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE DOT UP UP_UP LEFT_PAR LEFT_BRK MINUS_GT }]
  [oclExpression ::= (*) oclExpression DOT simpleName isMarkedPre , {EOF ENDPACKAGE CONTEXT PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE DOT UP UP_UP LEFT_PAR LEFT_BRK MINUS_GT }]
  [primitiveLiteralExp ::= (*) TRUE , {EOF ENDPACKAGE CONTEXT PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE DOT UP UP_UP LEFT_PAR LEFT_BRK MINUS_GT }]
  [literalExp ::= (*) tupleLiteralExp , {EOF ENDPACKAGE CONTEXT PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE DOT UP UP_UP LEFT_PAR LEFT_BRK MINUS_GT }]
  [oclExpression ::= (*) oclExpression IMPLIES oclExpression , {EOF ENDPACKAGE CONTEXT PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE DOT UP UP_UP LEFT_PAR LEFT_BRK MINUS_GT }]
  [oclExpression ::= (*) oclExpression LT oclExpression , {EOF ENDPACKAGE CONTEXT PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE DOT UP UP_UP LEFT_PAR LEFT_BRK MINUS_GT }]
  [oclExpression ::= (*) oclExpression MINUS_GT ITERATE LEFT_PAR variableDeclaration SEMICOLON variableDeclaration BAR oclExpression RIGHT_PAR , {EOF ENDPACKAGE CONTEXT PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE DOT UP UP_UP LEFT_PAR LEFT_BRK MINUS_GT }]
  [tupleLiteralExp ::= (*) TUPLE LEFT_BRA variableDeclarationList RIGHT_BRA , {EOF ENDPACKAGE CONTEXT PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE DOT UP UP_UP LEFT_PAR LEFT_BRK MINUS_GT }]
  [collectionKind ::= (*) SET , {LEFT_BRA }]
  [oclExpression ::= (*) oclExpression UP simpleName LEFT_PAR RIGHT_PAR , {EOF ENDPACKAGE CONTEXT PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE DOT UP UP_UP LEFT_PAR LEFT_BRK MINUS_GT }]
  [oclExpression ::= (*) oclExpression NE oclExpression , {EOF ENDPACKAGE CONTEXT PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE DOT UP UP_UP LEFT_PAR LEFT_BRK MINUS_GT }]
  [oclExpression ::= (*) oclExpression DIVIDE oclExpression , {EOF ENDPACKAGE CONTEXT PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE DOT UP UP_UP LEFT_PAR LEFT_BRK MINUS_GT }]
  [oclExpression ::= (*) oclExpression LEFT_PAR arguments RIGHT_PAR , {EOF ENDPACKAGE CONTEXT PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE DOT UP UP_UP LEFT_PAR LEFT_BRK MINUS_GT }]
  [primitiveLiteralExp ::= (*) FALSE , {EOF ENDPACKAGE CONTEXT PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE DOT UP UP_UP LEFT_PAR LEFT_BRK MINUS_GT }]
  [literalExp ::= (*) primitiveLiteralExp , {EOF ENDPACKAGE CONTEXT PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE DOT UP UP_UP LEFT_PAR LEFT_BRK MINUS_GT }]
  [oclExpression ::= (*) LET variableDeclarationList IN oclExpression , {EOF ENDPACKAGE CONTEXT PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE DOT UP UP_UP LEFT_PAR LEFT_BRK MINUS_GT }]
  [oclExpression ::= (*) oclExpression GT oclExpression , {EOF ENDPACKAGE CONTEXT PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE DOT UP UP_UP LEFT_PAR LEFT_BRK MINUS_GT }]
  [oclExpression ::= (*) oclExpression MINUS_GT ITERATE LEFT_PAR variableDeclaration BAR oclExpression RIGHT_PAR , {EOF ENDPACKAGE CONTEXT PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE DOT UP UP_UP LEFT_PAR LEFT_BRK MINUS_GT }]
  [oclExpression ::= (*) literalExp , {EOF ENDPACKAGE CONTEXT PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE DOT UP UP_UP LEFT_PAR LEFT_BRK MINUS_GT }]
  [primitiveLiteralExp ::= (*) INTEGER , {EOF ENDPACKAGE CONTEXT PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE DOT UP UP_UP LEFT_PAR LEFT_BRK MINUS_GT }]
  [collectionKind ::= (*) BAG , {LEFT_BRA }]
  [oclExpression ::= (*) oclExpression AND oclExpression , {EOF ENDPACKAGE CONTEXT PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE DOT UP UP_UP LEFT_PAR LEFT_BRK MINUS_GT }]
  [oclExpression ::= (*) oclExpression PLUS oclExpression , {EOF ENDPACKAGE CONTEXT PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE DOT UP UP_UP LEFT_PAR LEFT_BRK MINUS_GT }]
  [oclExpression ::= (*) oclExpression LEFT_PAR variableDeclaration BAR oclExpression RIGHT_PAR , {EOF ENDPACKAGE CONTEXT PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE DOT UP UP_UP LEFT_PAR LEFT_BRK MINUS_GT }]
  [pathName ::= (*) simpleName , {EOF ENDPACKAGE CONTEXT PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE DOT UP AT COLON_COLON UP_UP LEFT_PAR LEFT_BRK MINUS_GT }]
  [oclExpression ::= (*) oclExpression UP_UP simpleName LEFT_PAR oclMessageArgumentList RIGHT_PAR , {EOF ENDPACKAGE CONTEXT PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE DOT UP UP_UP LEFT_PAR LEFT_BRK MINUS_GT }]
  [oclExpression ::= (*) oclExpression LE oclExpression , {EOF ENDPACKAGE CONTEXT PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE DOT UP UP_UP LEFT_PAR LEFT_BRK MINUS_GT }]
  [oclExpression ::= (*) NOT oclExpression , {EOF ENDPACKAGE CONTEXT PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE DOT UP UP_UP LEFT_PAR LEFT_BRK MINUS_GT }]
  [oclExpression ::= (*) LEFT_PAR oclExpression RIGHT_PAR , {EOF ENDPACKAGE CONTEXT PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE DOT UP UP_UP LEFT_PAR LEFT_BRK MINUS_GT }]
  [primitiveLiteralExp ::= (*) REAL , {EOF ENDPACKAGE CONTEXT PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE DOT UP UP_UP LEFT_PAR LEFT_BRK MINUS_GT }]
  [collectionKind ::= (*) SEQUENCE , {LEFT_BRA }]
  [oclExpression ::= (*) oclExpression OR oclExpression , {EOF ENDPACKAGE CONTEXT PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE DOT UP UP_UP LEFT_PAR LEFT_BRK MINUS_GT }]
  [oclExpression ::= (*) oclExpression MINUS oclExpression , {EOF ENDPACKAGE CONTEXT PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE DOT UP UP_UP LEFT_PAR LEFT_BRK MINUS_GT }]
  [oclExpression ::= (*) oclExpression LEFT_BRK argumentList RIGHT_BRK isMarkedPre , {EOF ENDPACKAGE CONTEXT PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE DOT UP UP_UP LEFT_PAR LEFT_BRK MINUS_GT }]
  [pathName ::= (*) pathName COLON_COLON simpleName , {EOF ENDPACKAGE CONTEXT PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE DOT UP AT COLON_COLON UP_UP LEFT_PAR LEFT_BRK MINUS_GT }]
  [collectionLiteralExp ::= (*) collectionKind LEFT_BRA collectionLiteralParts RIGHT_BRA , {EOF ENDPACKAGE CONTEXT PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE DOT UP UP_UP LEFT_PAR LEFT_BRK MINUS_GT }]
  [oclExpression ::= (*) oclExpression UP_UP simpleName LEFT_PAR RIGHT_PAR , {EOF ENDPACKAGE CONTEXT PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE DOT UP UP_UP LEFT_PAR LEFT_BRK MINUS_GT }]
  [oclExpression ::= (*) oclExpression GE oclExpression , {EOF ENDPACKAGE CONTEXT PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE DOT UP UP_UP LEFT_PAR LEFT_BRK MINUS_GT }]
  [oclExpression ::= (*) MINUS oclExpression , {EOF ENDPACKAGE CONTEXT PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE DOT UP UP_UP LEFT_PAR LEFT_BRK MINUS_GT }]
  [oclExpression ::= (*) pathName isMarkedPre , {EOF ENDPACKAGE CONTEXT PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE DOT UP UP_UP LEFT_PAR LEFT_BRK MINUS_GT }]
  [primitiveLiteralExp ::= (*) STRING , {EOF ENDPACKAGE CONTEXT PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE DOT UP UP_UP LEFT_PAR LEFT_BRK MINUS_GT }]
  [collectionKind ::= (*) COLLECTION , {LEFT_BRA }]
  [literalExp ::= (*) collectionLiteralExp , {EOF ENDPACKAGE CONTEXT PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE DOT UP UP_UP LEFT_PAR LEFT_BRK MINUS_GT }]
  [oclExpression ::= (*) oclExpression XOR oclExpression , {EOF ENDPACKAGE CONTEXT PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE DOT UP UP_UP LEFT_PAR LEFT_BRK MINUS_GT }]
  [oclExpression ::= (*) IF oclExpression THEN oclExpression ELSE oclExpression ENDIF , {EOF ENDPACKAGE CONTEXT PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE DOT UP UP_UP LEFT_PAR LEFT_BRK MINUS_GT }]
  [prePostOrBodyDecl ::= prePostOrBodyDecl BODY COLON (*) oclExpression , {EOF ENDPACKAGE CONTEXT PRE POST BODY }]
  [oclExpression ::= (*) oclExpression MINUS_GT simpleName , {EOF ENDPACKAGE CONTEXT PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE DOT UP UP_UP LEFT_PAR LEFT_BRK MINUS_GT }]
  [simpleName ::= (*) SIMPLE_NAME , {EOF ENDPACKAGE CONTEXT PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE DOT UP AT COLON_COLON UP_UP LEFT_PAR LEFT_BRK MINUS_GT }]
  [collectionLiteralExp ::= (*) collectionKind LEFT_BRA RIGHT_BRA , {EOF ENDPACKAGE CONTEXT PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE DOT UP UP_UP LEFT_PAR LEFT_BRK MINUS_GT }]
}
transition on tupleLiteralExp to state [54]
transition on oclExpression to state [255]
transition on REAL to state [52]
transition on INTEGER to state [51]
transition on pathName to state [50]
transition on SIMPLE_NAME to state [12]
transition on LET to state [49]
transition on FALSE to state [48]
transition on MINUS to state [47]
transition on COLLECTION to state [28]
transition on SET to state [20]
transition on simpleName to state [26]
transition on collectionLiteralExp to state [46]
transition on LEFT_PAR to state [45]
transition on STRING to state [44]
transition on IF to state [43]
transition on TRUE to state [42]
transition on collectionKind to state [41]
transition on NOT to state [40]
transition on primitiveLiteralExp to state [39]
transition on TUPLE to state [38]
transition on literalExp to state [37]
transition on BAG to state [25]
transition on SEQUENCE to state [22]

-------------------
lalr_state [252]: {
  [prePostOrBodyDecl ::= prePostOrBodyDecl BODY simpleName (*) COLON oclExpression , {EOF ENDPACKAGE CONTEXT PRE POST BODY }]
}
transition on COLON to state [253]

-------------------
lalr_state [253]: {
  [oclExpression ::= (*) oclExpression UP simpleName LEFT_PAR oclMessageArgumentList RIGHT_PAR , {EOF ENDPACKAGE CONTEXT PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE DOT UP UP_UP LEFT_PAR LEFT_BRK MINUS_GT }]
  [oclExpression ::= (*) oclExpression EQ oclExpression , {EOF ENDPACKAGE CONTEXT PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE DOT UP UP_UP LEFT_PAR LEFT_BRK MINUS_GT }]
  [oclExpression ::= (*) oclExpression TIMES oclExpression , {EOF ENDPACKAGE CONTEXT PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE DOT UP UP_UP LEFT_PAR LEFT_BRK MINUS_GT }]
  [oclExpression ::= (*) oclExpression DOT simpleName isMarkedPre , {EOF ENDPACKAGE CONTEXT PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE DOT UP UP_UP LEFT_PAR LEFT_BRK MINUS_GT }]
  [primitiveLiteralExp ::= (*) TRUE , {EOF ENDPACKAGE CONTEXT PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE DOT UP UP_UP LEFT_PAR LEFT_BRK MINUS_GT }]
  [literalExp ::= (*) tupleLiteralExp , {EOF ENDPACKAGE CONTEXT PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE DOT UP UP_UP LEFT_PAR LEFT_BRK MINUS_GT }]
  [oclExpression ::= (*) oclExpression IMPLIES oclExpression , {EOF ENDPACKAGE CONTEXT PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE DOT UP UP_UP LEFT_PAR LEFT_BRK MINUS_GT }]
  [oclExpression ::= (*) oclExpression LT oclExpression , {EOF ENDPACKAGE CONTEXT PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE DOT UP UP_UP LEFT_PAR LEFT_BRK MINUS_GT }]
  [oclExpression ::= (*) oclExpression MINUS_GT ITERATE LEFT_PAR variableDeclaration SEMICOLON variableDeclaration BAR oclExpression RIGHT_PAR , {EOF ENDPACKAGE CONTEXT PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE DOT UP UP_UP LEFT_PAR LEFT_BRK MINUS_GT }]
  [tupleLiteralExp ::= (*) TUPLE LEFT_BRA variableDeclarationList RIGHT_BRA , {EOF ENDPACKAGE CONTEXT PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE DOT UP UP_UP LEFT_PAR LEFT_BRK MINUS_GT }]
  [collectionKind ::= (*) SET , {LEFT_BRA }]
  [oclExpression ::= (*) oclExpression UP simpleName LEFT_PAR RIGHT_PAR , {EOF ENDPACKAGE CONTEXT PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE DOT UP UP_UP LEFT_PAR LEFT_BRK MINUS_GT }]
  [oclExpression ::= (*) oclExpression NE oclExpression , {EOF ENDPACKAGE CONTEXT PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE DOT UP UP_UP LEFT_PAR LEFT_BRK MINUS_GT }]
  [oclExpression ::= (*) oclExpression DIVIDE oclExpression , {EOF ENDPACKAGE CONTEXT PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE DOT UP UP_UP LEFT_PAR LEFT_BRK MINUS_GT }]
  [oclExpression ::= (*) oclExpression LEFT_PAR arguments RIGHT_PAR , {EOF ENDPACKAGE CONTEXT PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE DOT UP UP_UP LEFT_PAR LEFT_BRK MINUS_GT }]
  [primitiveLiteralExp ::= (*) FALSE , {EOF ENDPACKAGE CONTEXT PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE DOT UP UP_UP LEFT_PAR LEFT_BRK MINUS_GT }]
  [literalExp ::= (*) primitiveLiteralExp , {EOF ENDPACKAGE CONTEXT PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE DOT UP UP_UP LEFT_PAR LEFT_BRK MINUS_GT }]
  [oclExpression ::= (*) LET variableDeclarationList IN oclExpression , {EOF ENDPACKAGE CONTEXT PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE DOT UP UP_UP LEFT_PAR LEFT_BRK MINUS_GT }]
  [oclExpression ::= (*) oclExpression GT oclExpression , {EOF ENDPACKAGE CONTEXT PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE DOT UP UP_UP LEFT_PAR LEFT_BRK MINUS_GT }]
  [oclExpression ::= (*) oclExpression MINUS_GT ITERATE LEFT_PAR variableDeclaration BAR oclExpression RIGHT_PAR , {EOF ENDPACKAGE CONTEXT PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE DOT UP UP_UP LEFT_PAR LEFT_BRK MINUS_GT }]
  [oclExpression ::= (*) literalExp , {EOF ENDPACKAGE CONTEXT PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE DOT UP UP_UP LEFT_PAR LEFT_BRK MINUS_GT }]
  [primitiveLiteralExp ::= (*) INTEGER , {EOF ENDPACKAGE CONTEXT PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE DOT UP UP_UP LEFT_PAR LEFT_BRK MINUS_GT }]
  [collectionKind ::= (*) BAG , {LEFT_BRA }]
  [oclExpression ::= (*) oclExpression AND oclExpression , {EOF ENDPACKAGE CONTEXT PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE DOT UP UP_UP LEFT_PAR LEFT_BRK MINUS_GT }]
  [oclExpression ::= (*) oclExpression PLUS oclExpression , {EOF ENDPACKAGE CONTEXT PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE DOT UP UP_UP LEFT_PAR LEFT_BRK MINUS_GT }]
  [oclExpression ::= (*) oclExpression LEFT_PAR variableDeclaration BAR oclExpression RIGHT_PAR , {EOF ENDPACKAGE CONTEXT PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE DOT UP UP_UP LEFT_PAR LEFT_BRK MINUS_GT }]
  [pathName ::= (*) simpleName , {EOF ENDPACKAGE CONTEXT PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE DOT UP AT COLON_COLON UP_UP LEFT_PAR LEFT_BRK MINUS_GT }]
  [oclExpression ::= (*) oclExpression UP_UP simpleName LEFT_PAR oclMessageArgumentList RIGHT_PAR , {EOF ENDPACKAGE CONTEXT PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE DOT UP UP_UP LEFT_PAR LEFT_BRK MINUS_GT }]
  [oclExpression ::= (*) oclExpression LE oclExpression , {EOF ENDPACKAGE CONTEXT PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE DOT UP UP_UP LEFT_PAR LEFT_BRK MINUS_GT }]
  [oclExpression ::= (*) NOT oclExpression , {EOF ENDPACKAGE CONTEXT PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE DOT UP UP_UP LEFT_PAR LEFT_BRK MINUS_GT }]
  [oclExpression ::= (*) LEFT_PAR oclExpression RIGHT_PAR , {EOF ENDPACKAGE CONTEXT PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE DOT UP UP_UP LEFT_PAR LEFT_BRK MINUS_GT }]
  [primitiveLiteralExp ::= (*) REAL , {EOF ENDPACKAGE CONTEXT PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE DOT UP UP_UP LEFT_PAR LEFT_BRK MINUS_GT }]
  [collectionKind ::= (*) SEQUENCE , {LEFT_BRA }]
  [oclExpression ::= (*) oclExpression OR oclExpression , {EOF ENDPACKAGE CONTEXT PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE DOT UP UP_UP LEFT_PAR LEFT_BRK MINUS_GT }]
  [oclExpression ::= (*) oclExpression MINUS oclExpression , {EOF ENDPACKAGE CONTEXT PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE DOT UP UP_UP LEFT_PAR LEFT_BRK MINUS_GT }]
  [prePostOrBodyDecl ::= prePostOrBodyDecl BODY simpleName COLON (*) oclExpression , {EOF ENDPACKAGE CONTEXT PRE POST BODY }]
  [oclExpression ::= (*) oclExpression LEFT_BRK argumentList RIGHT_BRK isMarkedPre , {EOF ENDPACKAGE CONTEXT PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE DOT UP UP_UP LEFT_PAR LEFT_BRK MINUS_GT }]
  [pathName ::= (*) pathName COLON_COLON simpleName , {EOF ENDPACKAGE CONTEXT PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE DOT UP AT COLON_COLON UP_UP LEFT_PAR LEFT_BRK MINUS_GT }]
  [collectionLiteralExp ::= (*) collectionKind LEFT_BRA collectionLiteralParts RIGHT_BRA , {EOF ENDPACKAGE CONTEXT PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE DOT UP UP_UP LEFT_PAR LEFT_BRK MINUS_GT }]
  [oclExpression ::= (*) oclExpression UP_UP simpleName LEFT_PAR RIGHT_PAR , {EOF ENDPACKAGE CONTEXT PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE DOT UP UP_UP LEFT_PAR LEFT_BRK MINUS_GT }]
  [oclExpression ::= (*) oclExpression GE oclExpression , {EOF ENDPACKAGE CONTEXT PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE DOT UP UP_UP LEFT_PAR LEFT_BRK MINUS_GT }]
  [oclExpression ::= (*) MINUS oclExpression , {EOF ENDPACKAGE CONTEXT PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE DOT UP UP_UP LEFT_PAR LEFT_BRK MINUS_GT }]
  [oclExpression ::= (*) pathName isMarkedPre , {EOF ENDPACKAGE CONTEXT PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE DOT UP UP_UP LEFT_PAR LEFT_BRK MINUS_GT }]
  [primitiveLiteralExp ::= (*) STRING , {EOF ENDPACKAGE CONTEXT PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE DOT UP UP_UP LEFT_PAR LEFT_BRK MINUS_GT }]
  [collectionKind ::= (*) COLLECTION , {LEFT_BRA }]
  [literalExp ::= (*) collectionLiteralExp , {EOF ENDPACKAGE CONTEXT PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE DOT UP UP_UP LEFT_PAR LEFT_BRK MINUS_GT }]
  [oclExpression ::= (*) oclExpression XOR oclExpression , {EOF ENDPACKAGE CONTEXT PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE DOT UP UP_UP LEFT_PAR LEFT_BRK MINUS_GT }]
  [oclExpression ::= (*) IF oclExpression THEN oclExpression ELSE oclExpression ENDIF , {EOF ENDPACKAGE CONTEXT PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE DOT UP UP_UP LEFT_PAR LEFT_BRK MINUS_GT }]
  [oclExpression ::= (*) oclExpression MINUS_GT simpleName , {EOF ENDPACKAGE CONTEXT PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE DOT UP UP_UP LEFT_PAR LEFT_BRK MINUS_GT }]
  [simpleName ::= (*) SIMPLE_NAME , {EOF ENDPACKAGE CONTEXT PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE DOT UP AT COLON_COLON UP_UP LEFT_PAR LEFT_BRK MINUS_GT }]
  [collectionLiteralExp ::= (*) collectionKind LEFT_BRA RIGHT_BRA , {EOF ENDPACKAGE CONTEXT PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE DOT UP UP_UP LEFT_PAR LEFT_BRK MINUS_GT }]
}
transition on tupleLiteralExp to state [54]
transition on oclExpression to state [254]
transition on REAL to state [52]
transition on INTEGER to state [51]
transition on pathName to state [50]
transition on SIMPLE_NAME to state [12]
transition on LET to state [49]
transition on FALSE to state [48]
transition on MINUS to state [47]
transition on COLLECTION to state [28]
transition on SET to state [20]
transition on simpleName to state [26]
transition on collectionLiteralExp to state [46]
transition on LEFT_PAR to state [45]
transition on STRING to state [44]
transition on IF to state [43]
transition on TRUE to state [42]
transition on collectionKind to state [41]
transition on NOT to state [40]
transition on primitiveLiteralExp to state [39]
transition on TUPLE to state [38]
transition on literalExp to state [37]
transition on BAG to state [25]
transition on SEQUENCE to state [22]

-------------------
lalr_state [254]: {
  [oclExpression ::= oclExpression (*) LEFT_BRK argumentList RIGHT_BRK isMarkedPre , {EOF ENDPACKAGE CONTEXT PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE DOT UP UP_UP LEFT_PAR LEFT_BRK MINUS_GT }]
  [prePostOrBodyDecl ::= prePostOrBodyDecl BODY simpleName COLON oclExpression (*) , {EOF ENDPACKAGE CONTEXT PRE POST BODY }]
  [oclExpression ::= oclExpression (*) EQ oclExpression , {EOF ENDPACKAGE CONTEXT PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE DOT UP UP_UP LEFT_PAR LEFT_BRK MINUS_GT }]
  [oclExpression ::= oclExpression (*) IMPLIES oclExpression , {EOF ENDPACKAGE CONTEXT PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE DOT UP UP_UP LEFT_PAR LEFT_BRK MINUS_GT }]
  [oclExpression ::= oclExpression (*) UP simpleName LEFT_PAR RIGHT_PAR , {EOF ENDPACKAGE CONTEXT PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE DOT UP UP_UP LEFT_PAR LEFT_BRK MINUS_GT }]
  [oclExpression ::= oclExpression (*) LEFT_PAR arguments RIGHT_PAR , {EOF ENDPACKAGE CONTEXT PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE DOT UP UP_UP LEFT_PAR LEFT_BRK MINUS_GT }]
  [oclExpression ::= oclExpression (*) MINUS_GT ITERATE LEFT_PAR variableDeclaration BAR oclExpression RIGHT_PAR , {EOF ENDPACKAGE CONTEXT PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE DOT UP UP_UP LEFT_PAR LEFT_BRK MINUS_GT }]
  [oclExpression ::= oclExpression (*) PLUS oclExpression , {EOF ENDPACKAGE CONTEXT PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE DOT UP UP_UP LEFT_PAR LEFT_BRK MINUS_GT }]
  [oclExpression ::= oclExpression (*) LE oclExpression , {EOF ENDPACKAGE CONTEXT PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE DOT UP UP_UP LEFT_PAR LEFT_BRK MINUS_GT }]
  [oclExpression ::= oclExpression (*) OR oclExpression , {EOF ENDPACKAGE CONTEXT PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE DOT UP UP_UP LEFT_PAR LEFT_BRK MINUS_GT }]
  [oclExpression ::= oclExpression (*) UP_UP simpleName LEFT_PAR RIGHT_PAR , {EOF ENDPACKAGE CONTEXT PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE DOT UP UP_UP LEFT_PAR LEFT_BRK MINUS_GT }]
  [oclExpression ::= oclExpression (*) MINUS_GT simpleName , {EOF ENDPACKAGE CONTEXT PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE DOT UP UP_UP LEFT_PAR LEFT_BRK MINUS_GT }]
  [oclExpression ::= oclExpression (*) TIMES oclExpression , {EOF ENDPACKAGE CONTEXT PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE DOT UP UP_UP LEFT_PAR LEFT_BRK MINUS_GT }]
  [oclExpression ::= oclExpression (*) LT oclExpression , {EOF ENDPACKAGE CONTEXT PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE DOT UP UP_UP LEFT_PAR LEFT_BRK MINUS_GT }]
  [oclExpression ::= oclExpression (*) NE oclExpression , {EOF ENDPACKAGE CONTEXT PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE DOT UP UP_UP LEFT_PAR LEFT_BRK MINUS_GT }]
  [oclExpression ::= oclExpression (*) LEFT_PAR variableDeclaration BAR oclExpression RIGHT_PAR , {EOF ENDPACKAGE CONTEXT PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE DOT UP UP_UP LEFT_PAR LEFT_BRK MINUS_GT }]
  [oclExpression ::= oclExpression (*) MINUS oclExpression , {EOF ENDPACKAGE CONTEXT PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE DOT UP UP_UP LEFT_PAR LEFT_BRK MINUS_GT }]
  [oclExpression ::= oclExpression (*) GE oclExpression , {EOF ENDPACKAGE CONTEXT PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE DOT UP UP_UP LEFT_PAR LEFT_BRK MINUS_GT }]
  [oclExpression ::= oclExpression (*) XOR oclExpression , {EOF ENDPACKAGE CONTEXT PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE DOT UP UP_UP LEFT_PAR LEFT_BRK MINUS_GT }]
  [oclExpression ::= oclExpression (*) UP simpleName LEFT_PAR oclMessageArgumentList RIGHT_PAR , {EOF ENDPACKAGE CONTEXT PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE DOT UP UP_UP LEFT_PAR LEFT_BRK MINUS_GT }]
  [oclExpression ::= oclExpression (*) DOT simpleName isMarkedPre , {EOF ENDPACKAGE CONTEXT PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE DOT UP UP_UP LEFT_PAR LEFT_BRK MINUS_GT }]
  [oclExpression ::= oclExpression (*) MINUS_GT ITERATE LEFT_PAR variableDeclaration SEMICOLON variableDeclaration BAR oclExpression RIGHT_PAR , {EOF ENDPACKAGE CONTEXT PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE DOT UP UP_UP LEFT_PAR LEFT_BRK MINUS_GT }]
  [oclExpression ::= oclExpression (*) DIVIDE oclExpression , {EOF ENDPACKAGE CONTEXT PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE DOT UP UP_UP LEFT_PAR LEFT_BRK MINUS_GT }]
  [oclExpression ::= oclExpression (*) GT oclExpression , {EOF ENDPACKAGE CONTEXT PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE DOT UP UP_UP LEFT_PAR LEFT_BRK MINUS_GT }]
  [oclExpression ::= oclExpression (*) AND oclExpression , {EOF ENDPACKAGE CONTEXT PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE DOT UP UP_UP LEFT_PAR LEFT_BRK MINUS_GT }]
  [oclExpression ::= oclExpression (*) UP_UP simpleName LEFT_PAR oclMessageArgumentList RIGHT_PAR , {EOF ENDPACKAGE CONTEXT PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE DOT UP UP_UP LEFT_PAR LEFT_BRK MINUS_GT }]
}
transition on XOR to state [74]
transition on EQ to state [73]
transition on DOT to state [72]
transition on MINUS to state [71]
transition on GE to state [70]
transition on LEFT_BRK to state [69]
transition on DIVIDE to state [68]
transition on LEFT_PAR to state [67]
transition on MINUS_GT to state [66]
transition on LE to state [65]
transition on GT to state [64]
transition on IMPLIES to state [63]
transition on UP to state [62]
transition on UP_UP to state [61]
transition on OR to state [60]
transition on PLUS to state [59]
transition on NE to state [58]
transition on LT to state [57]
transition on AND to state [56]
transition on TIMES to state [55]

-------------------
lalr_state [255]: {
  [oclExpression ::= oclExpression (*) LEFT_BRK argumentList RIGHT_BRK isMarkedPre , {EOF ENDPACKAGE CONTEXT PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE DOT UP UP_UP LEFT_PAR LEFT_BRK MINUS_GT }]
  [oclExpression ::= oclExpression (*) EQ oclExpression , {EOF ENDPACKAGE CONTEXT PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE DOT UP UP_UP LEFT_PAR LEFT_BRK MINUS_GT }]
  [oclExpression ::= oclExpression (*) IMPLIES oclExpression , {EOF ENDPACKAGE CONTEXT PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE DOT UP UP_UP LEFT_PAR LEFT_BRK MINUS_GT }]
  [oclExpression ::= oclExpression (*) UP simpleName LEFT_PAR RIGHT_PAR , {EOF ENDPACKAGE CONTEXT PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE DOT UP UP_UP LEFT_PAR LEFT_BRK MINUS_GT }]
  [oclExpression ::= oclExpression (*) LEFT_PAR arguments RIGHT_PAR , {EOF ENDPACKAGE CONTEXT PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE DOT UP UP_UP LEFT_PAR LEFT_BRK MINUS_GT }]
  [oclExpression ::= oclExpression (*) MINUS_GT ITERATE LEFT_PAR variableDeclaration BAR oclExpression RIGHT_PAR , {EOF ENDPACKAGE CONTEXT PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE DOT UP UP_UP LEFT_PAR LEFT_BRK MINUS_GT }]
  [oclExpression ::= oclExpression (*) PLUS oclExpression , {EOF ENDPACKAGE CONTEXT PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE DOT UP UP_UP LEFT_PAR LEFT_BRK MINUS_GT }]
  [oclExpression ::= oclExpression (*) LE oclExpression , {EOF ENDPACKAGE CONTEXT PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE DOT UP UP_UP LEFT_PAR LEFT_BRK MINUS_GT }]
  [oclExpression ::= oclExpression (*) OR oclExpression , {EOF ENDPACKAGE CONTEXT PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE DOT UP UP_UP LEFT_PAR LEFT_BRK MINUS_GT }]
  [oclExpression ::= oclExpression (*) UP_UP simpleName LEFT_PAR RIGHT_PAR , {EOF ENDPACKAGE CONTEXT PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE DOT UP UP_UP LEFT_PAR LEFT_BRK MINUS_GT }]
  [oclExpression ::= oclExpression (*) MINUS_GT simpleName , {EOF ENDPACKAGE CONTEXT PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE DOT UP UP_UP LEFT_PAR LEFT_BRK MINUS_GT }]
  [prePostOrBodyDecl ::= prePostOrBodyDecl BODY COLON oclExpression (*) , {EOF ENDPACKAGE CONTEXT PRE POST BODY }]
  [oclExpression ::= oclExpression (*) TIMES oclExpression , {EOF ENDPACKAGE CONTEXT PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE DOT UP UP_UP LEFT_PAR LEFT_BRK MINUS_GT }]
  [oclExpression ::= oclExpression (*) LT oclExpression , {EOF ENDPACKAGE CONTEXT PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE DOT UP UP_UP LEFT_PAR LEFT_BRK MINUS_GT }]
  [oclExpression ::= oclExpression (*) NE oclExpression , {EOF ENDPACKAGE CONTEXT PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE DOT UP UP_UP LEFT_PAR LEFT_BRK MINUS_GT }]
  [oclExpression ::= oclExpression (*) LEFT_PAR variableDeclaration BAR oclExpression RIGHT_PAR , {EOF ENDPACKAGE CONTEXT PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE DOT UP UP_UP LEFT_PAR LEFT_BRK MINUS_GT }]
  [oclExpression ::= oclExpression (*) MINUS oclExpression , {EOF ENDPACKAGE CONTEXT PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE DOT UP UP_UP LEFT_PAR LEFT_BRK MINUS_GT }]
  [oclExpression ::= oclExpression (*) GE oclExpression , {EOF ENDPACKAGE CONTEXT PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE DOT UP UP_UP LEFT_PAR LEFT_BRK MINUS_GT }]
  [oclExpression ::= oclExpression (*) XOR oclExpression , {EOF ENDPACKAGE CONTEXT PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE DOT UP UP_UP LEFT_PAR LEFT_BRK MINUS_GT }]
  [oclExpression ::= oclExpression (*) UP simpleName LEFT_PAR oclMessageArgumentList RIGHT_PAR , {EOF ENDPACKAGE CONTEXT PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE DOT UP UP_UP LEFT_PAR LEFT_BRK MINUS_GT }]
  [oclExpression ::= oclExpression (*) DOT simpleName isMarkedPre , {EOF ENDPACKAGE CONTEXT PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE DOT UP UP_UP LEFT_PAR LEFT_BRK MINUS_GT }]
  [oclExpression ::= oclExpression (*) MINUS_GT ITERATE LEFT_PAR variableDeclaration SEMICOLON variableDeclaration BAR oclExpression RIGHT_PAR , {EOF ENDPACKAGE CONTEXT PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE DOT UP UP_UP LEFT_PAR LEFT_BRK MINUS_GT }]
  [oclExpression ::= oclExpression (*) DIVIDE oclExpression , {EOF ENDPACKAGE CONTEXT PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE DOT UP UP_UP LEFT_PAR LEFT_BRK MINUS_GT }]
  [oclExpression ::= oclExpression (*) GT oclExpression , {EOF ENDPACKAGE CONTEXT PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE DOT UP UP_UP LEFT_PAR LEFT_BRK MINUS_GT }]
  [oclExpression ::= oclExpression (*) AND oclExpression , {EOF ENDPACKAGE CONTEXT PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE DOT UP UP_UP LEFT_PAR LEFT_BRK MINUS_GT }]
  [oclExpression ::= oclExpression (*) UP_UP simpleName LEFT_PAR oclMessageArgumentList RIGHT_PAR , {EOF ENDPACKAGE CONTEXT PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE DOT UP UP_UP LEFT_PAR LEFT_BRK MINUS_GT }]
}
transition on XOR to state [74]
transition on EQ to state [73]
transition on DOT to state [72]
transition on MINUS to state [71]
transition on GE to state [70]
transition on LEFT_BRK to state [69]
transition on DIVIDE to state [68]
transition on LEFT_PAR to state [67]
transition on MINUS_GT to state [66]
transition on LE to state [65]
transition on GT to state [64]
transition on IMPLIES to state [63]
transition on UP to state [62]
transition on UP_UP to state [61]
transition on OR to state [60]
transition on PLUS to state [59]
transition on NE to state [58]
transition on LT to state [57]
transition on AND to state [56]
transition on TIMES to state [55]

-------------------
lalr_state [256]: {
  [prePostOrBodyDecl ::= prePostOrBodyDecl PRE simpleName (*) COLON oclExpression , {EOF ENDPACKAGE CONTEXT PRE POST BODY }]
}
transition on COLON to state [259]

-------------------
lalr_state [257]: {
  [oclExpression ::= (*) oclExpression UP simpleName LEFT_PAR oclMessageArgumentList RIGHT_PAR , {EOF ENDPACKAGE CONTEXT PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE DOT UP UP_UP LEFT_PAR LEFT_BRK MINUS_GT }]
  [oclExpression ::= (*) oclExpression EQ oclExpression , {EOF ENDPACKAGE CONTEXT PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE DOT UP UP_UP LEFT_PAR LEFT_BRK MINUS_GT }]
  [oclExpression ::= (*) oclExpression TIMES oclExpression , {EOF ENDPACKAGE CONTEXT PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE DOT UP UP_UP LEFT_PAR LEFT_BRK MINUS_GT }]
  [prePostOrBodyDecl ::= prePostOrBodyDecl PRE COLON (*) oclExpression , {EOF ENDPACKAGE CONTEXT PRE POST BODY }]
  [oclExpression ::= (*) oclExpression DOT simpleName isMarkedPre , {EOF ENDPACKAGE CONTEXT PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE DOT UP UP_UP LEFT_PAR LEFT_BRK MINUS_GT }]
  [primitiveLiteralExp ::= (*) TRUE , {EOF ENDPACKAGE CONTEXT PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE DOT UP UP_UP LEFT_PAR LEFT_BRK MINUS_GT }]
  [literalExp ::= (*) tupleLiteralExp , {EOF ENDPACKAGE CONTEXT PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE DOT UP UP_UP LEFT_PAR LEFT_BRK MINUS_GT }]
  [oclExpression ::= (*) oclExpression IMPLIES oclExpression , {EOF ENDPACKAGE CONTEXT PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE DOT UP UP_UP LEFT_PAR LEFT_BRK MINUS_GT }]
  [oclExpression ::= (*) oclExpression LT oclExpression , {EOF ENDPACKAGE CONTEXT PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE DOT UP UP_UP LEFT_PAR LEFT_BRK MINUS_GT }]
  [oclExpression ::= (*) oclExpression MINUS_GT ITERATE LEFT_PAR variableDeclaration SEMICOLON variableDeclaration BAR oclExpression RIGHT_PAR , {EOF ENDPACKAGE CONTEXT PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE DOT UP UP_UP LEFT_PAR LEFT_BRK MINUS_GT }]
  [tupleLiteralExp ::= (*) TUPLE LEFT_BRA variableDeclarationList RIGHT_BRA , {EOF ENDPACKAGE CONTEXT PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE DOT UP UP_UP LEFT_PAR LEFT_BRK MINUS_GT }]
  [collectionKind ::= (*) SET , {LEFT_BRA }]
  [oclExpression ::= (*) oclExpression UP simpleName LEFT_PAR RIGHT_PAR , {EOF ENDPACKAGE CONTEXT PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE DOT UP UP_UP LEFT_PAR LEFT_BRK MINUS_GT }]
  [oclExpression ::= (*) oclExpression NE oclExpression , {EOF ENDPACKAGE CONTEXT PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE DOT UP UP_UP LEFT_PAR LEFT_BRK MINUS_GT }]
  [oclExpression ::= (*) oclExpression DIVIDE oclExpression , {EOF ENDPACKAGE CONTEXT PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE DOT UP UP_UP LEFT_PAR LEFT_BRK MINUS_GT }]
  [oclExpression ::= (*) oclExpression LEFT_PAR arguments RIGHT_PAR , {EOF ENDPACKAGE CONTEXT PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE DOT UP UP_UP LEFT_PAR LEFT_BRK MINUS_GT }]
  [primitiveLiteralExp ::= (*) FALSE , {EOF ENDPACKAGE CONTEXT PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE DOT UP UP_UP LEFT_PAR LEFT_BRK MINUS_GT }]
  [literalExp ::= (*) primitiveLiteralExp , {EOF ENDPACKAGE CONTEXT PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE DOT UP UP_UP LEFT_PAR LEFT_BRK MINUS_GT }]
  [oclExpression ::= (*) LET variableDeclarationList IN oclExpression , {EOF ENDPACKAGE CONTEXT PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE DOT UP UP_UP LEFT_PAR LEFT_BRK MINUS_GT }]
  [oclExpression ::= (*) oclExpression GT oclExpression , {EOF ENDPACKAGE CONTEXT PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE DOT UP UP_UP LEFT_PAR LEFT_BRK MINUS_GT }]
  [oclExpression ::= (*) oclExpression MINUS_GT ITERATE LEFT_PAR variableDeclaration BAR oclExpression RIGHT_PAR , {EOF ENDPACKAGE CONTEXT PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE DOT UP UP_UP LEFT_PAR LEFT_BRK MINUS_GT }]
  [oclExpression ::= (*) literalExp , {EOF ENDPACKAGE CONTEXT PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE DOT UP UP_UP LEFT_PAR LEFT_BRK MINUS_GT }]
  [primitiveLiteralExp ::= (*) INTEGER , {EOF ENDPACKAGE CONTEXT PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE DOT UP UP_UP LEFT_PAR LEFT_BRK MINUS_GT }]
  [collectionKind ::= (*) BAG , {LEFT_BRA }]
  [oclExpression ::= (*) oclExpression AND oclExpression , {EOF ENDPACKAGE CONTEXT PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE DOT UP UP_UP LEFT_PAR LEFT_BRK MINUS_GT }]
  [oclExpression ::= (*) oclExpression PLUS oclExpression , {EOF ENDPACKAGE CONTEXT PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE DOT UP UP_UP LEFT_PAR LEFT_BRK MINUS_GT }]
  [oclExpression ::= (*) oclExpression LEFT_PAR variableDeclaration BAR oclExpression RIGHT_PAR , {EOF ENDPACKAGE CONTEXT PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE DOT UP UP_UP LEFT_PAR LEFT_BRK MINUS_GT }]
  [pathName ::= (*) simpleName , {EOF ENDPACKAGE CONTEXT PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE DOT UP AT COLON_COLON UP_UP LEFT_PAR LEFT_BRK MINUS_GT }]
  [oclExpression ::= (*) oclExpression UP_UP simpleName LEFT_PAR oclMessageArgumentList RIGHT_PAR , {EOF ENDPACKAGE CONTEXT PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE DOT UP UP_UP LEFT_PAR LEFT_BRK MINUS_GT }]
  [oclExpression ::= (*) oclExpression LE oclExpression , {EOF ENDPACKAGE CONTEXT PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE DOT UP UP_UP LEFT_PAR LEFT_BRK MINUS_GT }]
  [oclExpression ::= (*) NOT oclExpression , {EOF ENDPACKAGE CONTEXT PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE DOT UP UP_UP LEFT_PAR LEFT_BRK MINUS_GT }]
  [oclExpression ::= (*) LEFT_PAR oclExpression RIGHT_PAR , {EOF ENDPACKAGE CONTEXT PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE DOT UP UP_UP LEFT_PAR LEFT_BRK MINUS_GT }]
  [primitiveLiteralExp ::= (*) REAL , {EOF ENDPACKAGE CONTEXT PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE DOT UP UP_UP LEFT_PAR LEFT_BRK MINUS_GT }]
  [collectionKind ::= (*) SEQUENCE , {LEFT_BRA }]
  [oclExpression ::= (*) oclExpression OR oclExpression , {EOF ENDPACKAGE CONTEXT PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE DOT UP UP_UP LEFT_PAR LEFT_BRK MINUS_GT }]
  [oclExpression ::= (*) oclExpression MINUS oclExpression , {EOF ENDPACKAGE CONTEXT PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE DOT UP UP_UP LEFT_PAR LEFT_BRK MINUS_GT }]
  [oclExpression ::= (*) oclExpression LEFT_BRK argumentList RIGHT_BRK isMarkedPre , {EOF ENDPACKAGE CONTEXT PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE DOT UP UP_UP LEFT_PAR LEFT_BRK MINUS_GT }]
  [pathName ::= (*) pathName COLON_COLON simpleName , {EOF ENDPACKAGE CONTEXT PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE DOT UP AT COLON_COLON UP_UP LEFT_PAR LEFT_BRK MINUS_GT }]
  [collectionLiteralExp ::= (*) collectionKind LEFT_BRA collectionLiteralParts RIGHT_BRA , {EOF ENDPACKAGE CONTEXT PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE DOT UP UP_UP LEFT_PAR LEFT_BRK MINUS_GT }]
  [oclExpression ::= (*) oclExpression UP_UP simpleName LEFT_PAR RIGHT_PAR , {EOF ENDPACKAGE CONTEXT PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE DOT UP UP_UP LEFT_PAR LEFT_BRK MINUS_GT }]
  [oclExpression ::= (*) oclExpression GE oclExpression , {EOF ENDPACKAGE CONTEXT PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE DOT UP UP_UP LEFT_PAR LEFT_BRK MINUS_GT }]
  [oclExpression ::= (*) MINUS oclExpression , {EOF ENDPACKAGE CONTEXT PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE DOT UP UP_UP LEFT_PAR LEFT_BRK MINUS_GT }]
  [oclExpression ::= (*) pathName isMarkedPre , {EOF ENDPACKAGE CONTEXT PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE DOT UP UP_UP LEFT_PAR LEFT_BRK MINUS_GT }]
  [primitiveLiteralExp ::= (*) STRING , {EOF ENDPACKAGE CONTEXT PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE DOT UP UP_UP LEFT_PAR LEFT_BRK MINUS_GT }]
  [collectionKind ::= (*) COLLECTION , {LEFT_BRA }]
  [literalExp ::= (*) collectionLiteralExp , {EOF ENDPACKAGE CONTEXT PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE DOT UP UP_UP LEFT_PAR LEFT_BRK MINUS_GT }]
  [oclExpression ::= (*) oclExpression XOR oclExpression , {EOF ENDPACKAGE CONTEXT PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE DOT UP UP_UP LEFT_PAR LEFT_BRK MINUS_GT }]
  [oclExpression ::= (*) IF oclExpression THEN oclExpression ELSE oclExpression ENDIF , {EOF ENDPACKAGE CONTEXT PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE DOT UP UP_UP LEFT_PAR LEFT_BRK MINUS_GT }]
  [oclExpression ::= (*) oclExpression MINUS_GT simpleName , {EOF ENDPACKAGE CONTEXT PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE DOT UP UP_UP LEFT_PAR LEFT_BRK MINUS_GT }]
  [simpleName ::= (*) SIMPLE_NAME , {EOF ENDPACKAGE CONTEXT PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE DOT UP AT COLON_COLON UP_UP LEFT_PAR LEFT_BRK MINUS_GT }]
  [collectionLiteralExp ::= (*) collectionKind LEFT_BRA RIGHT_BRA , {EOF ENDPACKAGE CONTEXT PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE DOT UP UP_UP LEFT_PAR LEFT_BRK MINUS_GT }]
}
transition on tupleLiteralExp to state [54]
transition on oclExpression to state [258]
transition on REAL to state [52]
transition on INTEGER to state [51]
transition on pathName to state [50]
transition on SIMPLE_NAME to state [12]
transition on LET to state [49]
transition on FALSE to state [48]
transition on MINUS to state [47]
transition on COLLECTION to state [28]
transition on SET to state [20]
transition on simpleName to state [26]
transition on collectionLiteralExp to state [46]
transition on LEFT_PAR to state [45]
transition on STRING to state [44]
transition on IF to state [43]
transition on TRUE to state [42]
transition on collectionKind to state [41]
transition on NOT to state [40]
transition on primitiveLiteralExp to state [39]
transition on TUPLE to state [38]
transition on literalExp to state [37]
transition on BAG to state [25]
transition on SEQUENCE to state [22]

-------------------
lalr_state [258]: {
  [oclExpression ::= oclExpression (*) LEFT_BRK argumentList RIGHT_BRK isMarkedPre , {EOF ENDPACKAGE CONTEXT PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE DOT UP UP_UP LEFT_PAR LEFT_BRK MINUS_GT }]
  [oclExpression ::= oclExpression (*) EQ oclExpression , {EOF ENDPACKAGE CONTEXT PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE DOT UP UP_UP LEFT_PAR LEFT_BRK MINUS_GT }]
  [oclExpression ::= oclExpression (*) IMPLIES oclExpression , {EOF ENDPACKAGE CONTEXT PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE DOT UP UP_UP LEFT_PAR LEFT_BRK MINUS_GT }]
  [oclExpression ::= oclExpression (*) UP simpleName LEFT_PAR RIGHT_PAR , {EOF ENDPACKAGE CONTEXT PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE DOT UP UP_UP LEFT_PAR LEFT_BRK MINUS_GT }]
  [oclExpression ::= oclExpression (*) LEFT_PAR arguments RIGHT_PAR , {EOF ENDPACKAGE CONTEXT PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE DOT UP UP_UP LEFT_PAR LEFT_BRK MINUS_GT }]
  [oclExpression ::= oclExpression (*) MINUS_GT ITERATE LEFT_PAR variableDeclaration BAR oclExpression RIGHT_PAR , {EOF ENDPACKAGE CONTEXT PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE DOT UP UP_UP LEFT_PAR LEFT_BRK MINUS_GT }]
  [oclExpression ::= oclExpression (*) PLUS oclExpression , {EOF ENDPACKAGE CONTEXT PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE DOT UP UP_UP LEFT_PAR LEFT_BRK MINUS_GT }]
  [oclExpression ::= oclExpression (*) LE oclExpression , {EOF ENDPACKAGE CONTEXT PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE DOT UP UP_UP LEFT_PAR LEFT_BRK MINUS_GT }]
  [oclExpression ::= oclExpression (*) OR oclExpression , {EOF ENDPACKAGE CONTEXT PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE DOT UP UP_UP LEFT_PAR LEFT_BRK MINUS_GT }]
  [oclExpression ::= oclExpression (*) UP_UP simpleName LEFT_PAR RIGHT_PAR , {EOF ENDPACKAGE CONTEXT PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE DOT UP UP_UP LEFT_PAR LEFT_BRK MINUS_GT }]
  [oclExpression ::= oclExpression (*) MINUS_GT simpleName , {EOF ENDPACKAGE CONTEXT PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE DOT UP UP_UP LEFT_PAR LEFT_BRK MINUS_GT }]
  [oclExpression ::= oclExpression (*) TIMES oclExpression , {EOF ENDPACKAGE CONTEXT PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE DOT UP UP_UP LEFT_PAR LEFT_BRK MINUS_GT }]
  [oclExpression ::= oclExpression (*) LT oclExpression , {EOF ENDPACKAGE CONTEXT PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE DOT UP UP_UP LEFT_PAR LEFT_BRK MINUS_GT }]
  [oclExpression ::= oclExpression (*) NE oclExpression , {EOF ENDPACKAGE CONTEXT PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE DOT UP UP_UP LEFT_PAR LEFT_BRK MINUS_GT }]
  [oclExpression ::= oclExpression (*) LEFT_PAR variableDeclaration BAR oclExpression RIGHT_PAR , {EOF ENDPACKAGE CONTEXT PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE DOT UP UP_UP LEFT_PAR LEFT_BRK MINUS_GT }]
  [oclExpression ::= oclExpression (*) MINUS oclExpression , {EOF ENDPACKAGE CONTEXT PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE DOT UP UP_UP LEFT_PAR LEFT_BRK MINUS_GT }]
  [oclExpression ::= oclExpression (*) GE oclExpression , {EOF ENDPACKAGE CONTEXT PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE DOT UP UP_UP LEFT_PAR LEFT_BRK MINUS_GT }]
  [oclExpression ::= oclExpression (*) XOR oclExpression , {EOF ENDPACKAGE CONTEXT PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE DOT UP UP_UP LEFT_PAR LEFT_BRK MINUS_GT }]
  [oclExpression ::= oclExpression (*) UP simpleName LEFT_PAR oclMessageArgumentList RIGHT_PAR , {EOF ENDPACKAGE CONTEXT PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE DOT UP UP_UP LEFT_PAR LEFT_BRK MINUS_GT }]
  [oclExpression ::= oclExpression (*) DOT simpleName isMarkedPre , {EOF ENDPACKAGE CONTEXT PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE DOT UP UP_UP LEFT_PAR LEFT_BRK MINUS_GT }]
  [oclExpression ::= oclExpression (*) MINUS_GT ITERATE LEFT_PAR variableDeclaration SEMICOLON variableDeclaration BAR oclExpression RIGHT_PAR , {EOF ENDPACKAGE CONTEXT PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE DOT UP UP_UP LEFT_PAR LEFT_BRK MINUS_GT }]
  [prePostOrBodyDecl ::= prePostOrBodyDecl PRE COLON oclExpression (*) , {EOF ENDPACKAGE CONTEXT PRE POST BODY }]
  [oclExpression ::= oclExpression (*) DIVIDE oclExpression , {EOF ENDPACKAGE CONTEXT PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE DOT UP UP_UP LEFT_PAR LEFT_BRK MINUS_GT }]
  [oclExpression ::= oclExpression (*) GT oclExpression , {EOF ENDPACKAGE CONTEXT PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE DOT UP UP_UP LEFT_PAR LEFT_BRK MINUS_GT }]
  [oclExpression ::= oclExpression (*) AND oclExpression , {EOF ENDPACKAGE CONTEXT PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE DOT UP UP_UP LEFT_PAR LEFT_BRK MINUS_GT }]
  [oclExpression ::= oclExpression (*) UP_UP simpleName LEFT_PAR oclMessageArgumentList RIGHT_PAR , {EOF ENDPACKAGE CONTEXT PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE DOT UP UP_UP LEFT_PAR LEFT_BRK MINUS_GT }]
}
transition on XOR to state [74]
transition on EQ to state [73]
transition on DOT to state [72]
transition on MINUS to state [71]
transition on GE to state [70]
transition on LEFT_BRK to state [69]
transition on DIVIDE to state [68]
transition on LEFT_PAR to state [67]
transition on MINUS_GT to state [66]
transition on LE to state [65]
transition on GT to state [64]
transition on IMPLIES to state [63]
transition on UP to state [62]
transition on UP_UP to state [61]
transition on OR to state [60]
transition on PLUS to state [59]
transition on NE to state [58]
transition on LT to state [57]
transition on AND to state [56]
transition on TIMES to state [55]

-------------------
lalr_state [259]: {
  [oclExpression ::= (*) oclExpression UP simpleName LEFT_PAR oclMessageArgumentList RIGHT_PAR , {EOF ENDPACKAGE CONTEXT PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE DOT UP UP_UP LEFT_PAR LEFT_BRK MINUS_GT }]
  [oclExpression ::= (*) oclExpression EQ oclExpression , {EOF ENDPACKAGE CONTEXT PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE DOT UP UP_UP LEFT_PAR LEFT_BRK MINUS_GT }]
  [oclExpression ::= (*) oclExpression TIMES oclExpression , {EOF ENDPACKAGE CONTEXT PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE DOT UP UP_UP LEFT_PAR LEFT_BRK MINUS_GT }]
  [oclExpression ::= (*) oclExpression DOT simpleName isMarkedPre , {EOF ENDPACKAGE CONTEXT PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE DOT UP UP_UP LEFT_PAR LEFT_BRK MINUS_GT }]
  [primitiveLiteralExp ::= (*) TRUE , {EOF ENDPACKAGE CONTEXT PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE DOT UP UP_UP LEFT_PAR LEFT_BRK MINUS_GT }]
  [literalExp ::= (*) tupleLiteralExp , {EOF ENDPACKAGE CONTEXT PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE DOT UP UP_UP LEFT_PAR LEFT_BRK MINUS_GT }]
  [oclExpression ::= (*) oclExpression IMPLIES oclExpression , {EOF ENDPACKAGE CONTEXT PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE DOT UP UP_UP LEFT_PAR LEFT_BRK MINUS_GT }]
  [oclExpression ::= (*) oclExpression LT oclExpression , {EOF ENDPACKAGE CONTEXT PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE DOT UP UP_UP LEFT_PAR LEFT_BRK MINUS_GT }]
  [oclExpression ::= (*) oclExpression MINUS_GT ITERATE LEFT_PAR variableDeclaration SEMICOLON variableDeclaration BAR oclExpression RIGHT_PAR , {EOF ENDPACKAGE CONTEXT PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE DOT UP UP_UP LEFT_PAR LEFT_BRK MINUS_GT }]
  [tupleLiteralExp ::= (*) TUPLE LEFT_BRA variableDeclarationList RIGHT_BRA , {EOF ENDPACKAGE CONTEXT PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE DOT UP UP_UP LEFT_PAR LEFT_BRK MINUS_GT }]
  [collectionKind ::= (*) SET , {LEFT_BRA }]
  [oclExpression ::= (*) oclExpression UP simpleName LEFT_PAR RIGHT_PAR , {EOF ENDPACKAGE CONTEXT PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE DOT UP UP_UP LEFT_PAR LEFT_BRK MINUS_GT }]
  [oclExpression ::= (*) oclExpression NE oclExpression , {EOF ENDPACKAGE CONTEXT PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE DOT UP UP_UP LEFT_PAR LEFT_BRK MINUS_GT }]
  [oclExpression ::= (*) oclExpression DIVIDE oclExpression , {EOF ENDPACKAGE CONTEXT PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE DOT UP UP_UP LEFT_PAR LEFT_BRK MINUS_GT }]
  [oclExpression ::= (*) oclExpression LEFT_PAR arguments RIGHT_PAR , {EOF ENDPACKAGE CONTEXT PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE DOT UP UP_UP LEFT_PAR LEFT_BRK MINUS_GT }]
  [primitiveLiteralExp ::= (*) FALSE , {EOF ENDPACKAGE CONTEXT PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE DOT UP UP_UP LEFT_PAR LEFT_BRK MINUS_GT }]
  [literalExp ::= (*) primitiveLiteralExp , {EOF ENDPACKAGE CONTEXT PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE DOT UP UP_UP LEFT_PAR LEFT_BRK MINUS_GT }]
  [oclExpression ::= (*) LET variableDeclarationList IN oclExpression , {EOF ENDPACKAGE CONTEXT PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE DOT UP UP_UP LEFT_PAR LEFT_BRK MINUS_GT }]
  [oclExpression ::= (*) oclExpression GT oclExpression , {EOF ENDPACKAGE CONTEXT PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE DOT UP UP_UP LEFT_PAR LEFT_BRK MINUS_GT }]
  [oclExpression ::= (*) oclExpression MINUS_GT ITERATE LEFT_PAR variableDeclaration BAR oclExpression RIGHT_PAR , {EOF ENDPACKAGE CONTEXT PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE DOT UP UP_UP LEFT_PAR LEFT_BRK MINUS_GT }]
  [oclExpression ::= (*) literalExp , {EOF ENDPACKAGE CONTEXT PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE DOT UP UP_UP LEFT_PAR LEFT_BRK MINUS_GT }]
  [primitiveLiteralExp ::= (*) INTEGER , {EOF ENDPACKAGE CONTEXT PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE DOT UP UP_UP LEFT_PAR LEFT_BRK MINUS_GT }]
  [collectionKind ::= (*) BAG , {LEFT_BRA }]
  [oclExpression ::= (*) oclExpression AND oclExpression , {EOF ENDPACKAGE CONTEXT PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE DOT UP UP_UP LEFT_PAR LEFT_BRK MINUS_GT }]
  [oclExpression ::= (*) oclExpression PLUS oclExpression , {EOF ENDPACKAGE CONTEXT PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE DOT UP UP_UP LEFT_PAR LEFT_BRK MINUS_GT }]
  [oclExpression ::= (*) oclExpression LEFT_PAR variableDeclaration BAR oclExpression RIGHT_PAR , {EOF ENDPACKAGE CONTEXT PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE DOT UP UP_UP LEFT_PAR LEFT_BRK MINUS_GT }]
  [pathName ::= (*) simpleName , {EOF ENDPACKAGE CONTEXT PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE DOT UP AT COLON_COLON UP_UP LEFT_PAR LEFT_BRK MINUS_GT }]
  [oclExpression ::= (*) oclExpression UP_UP simpleName LEFT_PAR oclMessageArgumentList RIGHT_PAR , {EOF ENDPACKAGE CONTEXT PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE DOT UP UP_UP LEFT_PAR LEFT_BRK MINUS_GT }]
  [oclExpression ::= (*) oclExpression LE oclExpression , {EOF ENDPACKAGE CONTEXT PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE DOT UP UP_UP LEFT_PAR LEFT_BRK MINUS_GT }]
  [oclExpression ::= (*) NOT oclExpression , {EOF ENDPACKAGE CONTEXT PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE DOT UP UP_UP LEFT_PAR LEFT_BRK MINUS_GT }]
  [oclExpression ::= (*) LEFT_PAR oclExpression RIGHT_PAR , {EOF ENDPACKAGE CONTEXT PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE DOT UP UP_UP LEFT_PAR LEFT_BRK MINUS_GT }]
  [primitiveLiteralExp ::= (*) REAL , {EOF ENDPACKAGE CONTEXT PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE DOT UP UP_UP LEFT_PAR LEFT_BRK MINUS_GT }]
  [collectionKind ::= (*) SEQUENCE , {LEFT_BRA }]
  [oclExpression ::= (*) oclExpression OR oclExpression , {EOF ENDPACKAGE CONTEXT PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE DOT UP UP_UP LEFT_PAR LEFT_BRK MINUS_GT }]
  [oclExpression ::= (*) oclExpression MINUS oclExpression , {EOF ENDPACKAGE CONTEXT PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE DOT UP UP_UP LEFT_PAR LEFT_BRK MINUS_GT }]
  [oclExpression ::= (*) oclExpression LEFT_BRK argumentList RIGHT_BRK isMarkedPre , {EOF ENDPACKAGE CONTEXT PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE DOT UP UP_UP LEFT_PAR LEFT_BRK MINUS_GT }]
  [pathName ::= (*) pathName COLON_COLON simpleName , {EOF ENDPACKAGE CONTEXT PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE DOT UP AT COLON_COLON UP_UP LEFT_PAR LEFT_BRK MINUS_GT }]
  [collectionLiteralExp ::= (*) collectionKind LEFT_BRA collectionLiteralParts RIGHT_BRA , {EOF ENDPACKAGE CONTEXT PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE DOT UP UP_UP LEFT_PAR LEFT_BRK MINUS_GT }]
  [oclExpression ::= (*) oclExpression UP_UP simpleName LEFT_PAR RIGHT_PAR , {EOF ENDPACKAGE CONTEXT PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE DOT UP UP_UP LEFT_PAR LEFT_BRK MINUS_GT }]
  [oclExpression ::= (*) oclExpression GE oclExpression , {EOF ENDPACKAGE CONTEXT PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE DOT UP UP_UP LEFT_PAR LEFT_BRK MINUS_GT }]
  [prePostOrBodyDecl ::= prePostOrBodyDecl PRE simpleName COLON (*) oclExpression , {EOF ENDPACKAGE CONTEXT PRE POST BODY }]
  [oclExpression ::= (*) MINUS oclExpression , {EOF ENDPACKAGE CONTEXT PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE DOT UP UP_UP LEFT_PAR LEFT_BRK MINUS_GT }]
  [oclExpression ::= (*) pathName isMarkedPre , {EOF ENDPACKAGE CONTEXT PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE DOT UP UP_UP LEFT_PAR LEFT_BRK MINUS_GT }]
  [primitiveLiteralExp ::= (*) STRING , {EOF ENDPACKAGE CONTEXT PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE DOT UP UP_UP LEFT_PAR LEFT_BRK MINUS_GT }]
  [collectionKind ::= (*) COLLECTION , {LEFT_BRA }]
  [literalExp ::= (*) collectionLiteralExp , {EOF ENDPACKAGE CONTEXT PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE DOT UP UP_UP LEFT_PAR LEFT_BRK MINUS_GT }]
  [oclExpression ::= (*) oclExpression XOR oclExpression , {EOF ENDPACKAGE CONTEXT PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE DOT UP UP_UP LEFT_PAR LEFT_BRK MINUS_GT }]
  [oclExpression ::= (*) IF oclExpression THEN oclExpression ELSE oclExpression ENDIF , {EOF ENDPACKAGE CONTEXT PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE DOT UP UP_UP LEFT_PAR LEFT_BRK MINUS_GT }]
  [oclExpression ::= (*) oclExpression MINUS_GT simpleName , {EOF ENDPACKAGE CONTEXT PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE DOT UP UP_UP LEFT_PAR LEFT_BRK MINUS_GT }]
  [simpleName ::= (*) SIMPLE_NAME , {EOF ENDPACKAGE CONTEXT PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE DOT UP AT COLON_COLON UP_UP LEFT_PAR LEFT_BRK MINUS_GT }]
  [collectionLiteralExp ::= (*) collectionKind LEFT_BRA RIGHT_BRA , {EOF ENDPACKAGE CONTEXT PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE DOT UP UP_UP LEFT_PAR LEFT_BRK MINUS_GT }]
}
transition on tupleLiteralExp to state [54]
transition on oclExpression to state [260]
transition on REAL to state [52]
transition on INTEGER to state [51]
transition on pathName to state [50]
transition on SIMPLE_NAME to state [12]
transition on LET to state [49]
transition on FALSE to state [48]
transition on MINUS to state [47]
transition on COLLECTION to state [28]
transition on SET to state [20]
transition on simpleName to state [26]
transition on collectionLiteralExp to state [46]
transition on LEFT_PAR to state [45]
transition on STRING to state [44]
transition on IF to state [43]
transition on TRUE to state [42]
transition on collectionKind to state [41]
transition on NOT to state [40]
transition on primitiveLiteralExp to state [39]
transition on TUPLE to state [38]
transition on literalExp to state [37]
transition on BAG to state [25]
transition on SEQUENCE to state [22]

-------------------
lalr_state [260]: {
  [oclExpression ::= oclExpression (*) LEFT_BRK argumentList RIGHT_BRK isMarkedPre , {EOF ENDPACKAGE CONTEXT PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE DOT UP UP_UP LEFT_PAR LEFT_BRK MINUS_GT }]
  [oclExpression ::= oclExpression (*) EQ oclExpression , {EOF ENDPACKAGE CONTEXT PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE DOT UP UP_UP LEFT_PAR LEFT_BRK MINUS_GT }]
  [oclExpression ::= oclExpression (*) IMPLIES oclExpression , {EOF ENDPACKAGE CONTEXT PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE DOT UP UP_UP LEFT_PAR LEFT_BRK MINUS_GT }]
  [oclExpression ::= oclExpression (*) UP simpleName LEFT_PAR RIGHT_PAR , {EOF ENDPACKAGE CONTEXT PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE DOT UP UP_UP LEFT_PAR LEFT_BRK MINUS_GT }]
  [oclExpression ::= oclExpression (*) LEFT_PAR arguments RIGHT_PAR , {EOF ENDPACKAGE CONTEXT PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE DOT UP UP_UP LEFT_PAR LEFT_BRK MINUS_GT }]
  [oclExpression ::= oclExpression (*) MINUS_GT ITERATE LEFT_PAR variableDeclaration BAR oclExpression RIGHT_PAR , {EOF ENDPACKAGE CONTEXT PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE DOT UP UP_UP LEFT_PAR LEFT_BRK MINUS_GT }]
  [oclExpression ::= oclExpression (*) PLUS oclExpression , {EOF ENDPACKAGE CONTEXT PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE DOT UP UP_UP LEFT_PAR LEFT_BRK MINUS_GT }]
  [oclExpression ::= oclExpression (*) LE oclExpression , {EOF ENDPACKAGE CONTEXT PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE DOT UP UP_UP LEFT_PAR LEFT_BRK MINUS_GT }]
  [oclExpression ::= oclExpression (*) OR oclExpression , {EOF ENDPACKAGE CONTEXT PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE DOT UP UP_UP LEFT_PAR LEFT_BRK MINUS_GT }]
  [oclExpression ::= oclExpression (*) UP_UP simpleName LEFT_PAR RIGHT_PAR , {EOF ENDPACKAGE CONTEXT PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE DOT UP UP_UP LEFT_PAR LEFT_BRK MINUS_GT }]
  [prePostOrBodyDecl ::= prePostOrBodyDecl PRE simpleName COLON oclExpression (*) , {EOF ENDPACKAGE CONTEXT PRE POST BODY }]
  [oclExpression ::= oclExpression (*) MINUS_GT simpleName , {EOF ENDPACKAGE CONTEXT PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE DOT UP UP_UP LEFT_PAR LEFT_BRK MINUS_GT }]
  [oclExpression ::= oclExpression (*) TIMES oclExpression , {EOF ENDPACKAGE CONTEXT PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE DOT UP UP_UP LEFT_PAR LEFT_BRK MINUS_GT }]
  [oclExpression ::= oclExpression (*) LT oclExpression , {EOF ENDPACKAGE CONTEXT PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE DOT UP UP_UP LEFT_PAR LEFT_BRK MINUS_GT }]
  [oclExpression ::= oclExpression (*) NE oclExpression , {EOF ENDPACKAGE CONTEXT PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE DOT UP UP_UP LEFT_PAR LEFT_BRK MINUS_GT }]
  [oclExpression ::= oclExpression (*) LEFT_PAR variableDeclaration BAR oclExpression RIGHT_PAR , {EOF ENDPACKAGE CONTEXT PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE DOT UP UP_UP LEFT_PAR LEFT_BRK MINUS_GT }]
  [oclExpression ::= oclExpression (*) MINUS oclExpression , {EOF ENDPACKAGE CONTEXT PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE DOT UP UP_UP LEFT_PAR LEFT_BRK MINUS_GT }]
  [oclExpression ::= oclExpression (*) GE oclExpression , {EOF ENDPACKAGE CONTEXT PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE DOT UP UP_UP LEFT_PAR LEFT_BRK MINUS_GT }]
  [oclExpression ::= oclExpression (*) XOR oclExpression , {EOF ENDPACKAGE CONTEXT PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE DOT UP UP_UP LEFT_PAR LEFT_BRK MINUS_GT }]
  [oclExpression ::= oclExpression (*) UP simpleName LEFT_PAR oclMessageArgumentList RIGHT_PAR , {EOF ENDPACKAGE CONTEXT PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE DOT UP UP_UP LEFT_PAR LEFT_BRK MINUS_GT }]
  [oclExpression ::= oclExpression (*) DOT simpleName isMarkedPre , {EOF ENDPACKAGE CONTEXT PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE DOT UP UP_UP LEFT_PAR LEFT_BRK MINUS_GT }]
  [oclExpression ::= oclExpression (*) MINUS_GT ITERATE LEFT_PAR variableDeclaration SEMICOLON variableDeclaration BAR oclExpression RIGHT_PAR , {EOF ENDPACKAGE CONTEXT PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE DOT UP UP_UP LEFT_PAR LEFT_BRK MINUS_GT }]
  [oclExpression ::= oclExpression (*) DIVIDE oclExpression , {EOF ENDPACKAGE CONTEXT PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE DOT UP UP_UP LEFT_PAR LEFT_BRK MINUS_GT }]
  [oclExpression ::= oclExpression (*) GT oclExpression , {EOF ENDPACKAGE CONTEXT PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE DOT UP UP_UP LEFT_PAR LEFT_BRK MINUS_GT }]
  [oclExpression ::= oclExpression (*) AND oclExpression , {EOF ENDPACKAGE CONTEXT PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE DOT UP UP_UP LEFT_PAR LEFT_BRK MINUS_GT }]
  [oclExpression ::= oclExpression (*) UP_UP simpleName LEFT_PAR oclMessageArgumentList RIGHT_PAR , {EOF ENDPACKAGE CONTEXT PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE DOT UP UP_UP LEFT_PAR LEFT_BRK MINUS_GT }]
}
transition on XOR to state [74]
transition on EQ to state [73]
transition on DOT to state [72]
transition on MINUS to state [71]
transition on GE to state [70]
transition on LEFT_BRK to state [69]
transition on DIVIDE to state [68]
transition on LEFT_PAR to state [67]
transition on MINUS_GT to state [66]
transition on LE to state [65]
transition on GT to state [64]
transition on IMPLIES to state [63]
transition on UP to state [62]
transition on UP_UP to state [61]
transition on OR to state [60]
transition on PLUS to state [59]
transition on NE to state [58]
transition on LT to state [57]
transition on AND to state [56]
transition on TIMES to state [55]

-------------------
lalr_state [261]: {
  [prePostOrBodyDecl ::= PRE simpleName (*) COLON oclExpression , {EOF ENDPACKAGE CONTEXT PRE POST BODY }]
}
transition on COLON to state [264]

-------------------
lalr_state [262]: {
  [oclExpression ::= (*) oclExpression UP simpleName LEFT_PAR oclMessageArgumentList RIGHT_PAR , {EOF ENDPACKAGE CONTEXT PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE DOT UP UP_UP LEFT_PAR LEFT_BRK MINUS_GT }]
  [oclExpression ::= (*) oclExpression EQ oclExpression , {EOF ENDPACKAGE CONTEXT PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE DOT UP UP_UP LEFT_PAR LEFT_BRK MINUS_GT }]
  [oclExpression ::= (*) oclExpression TIMES oclExpression , {EOF ENDPACKAGE CONTEXT PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE DOT UP UP_UP LEFT_PAR LEFT_BRK MINUS_GT }]
  [oclExpression ::= (*) oclExpression DOT simpleName isMarkedPre , {EOF ENDPACKAGE CONTEXT PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE DOT UP UP_UP LEFT_PAR LEFT_BRK MINUS_GT }]
  [primitiveLiteralExp ::= (*) TRUE , {EOF ENDPACKAGE CONTEXT PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE DOT UP UP_UP LEFT_PAR LEFT_BRK MINUS_GT }]
  [literalExp ::= (*) tupleLiteralExp , {EOF ENDPACKAGE CONTEXT PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE DOT UP UP_UP LEFT_PAR LEFT_BRK MINUS_GT }]
  [oclExpression ::= (*) oclExpression IMPLIES oclExpression , {EOF ENDPACKAGE CONTEXT PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE DOT UP UP_UP LEFT_PAR LEFT_BRK MINUS_GT }]
  [oclExpression ::= (*) oclExpression LT oclExpression , {EOF ENDPACKAGE CONTEXT PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE DOT UP UP_UP LEFT_PAR LEFT_BRK MINUS_GT }]
  [oclExpression ::= (*) oclExpression MINUS_GT ITERATE LEFT_PAR variableDeclaration SEMICOLON variableDeclaration BAR oclExpression RIGHT_PAR , {EOF ENDPACKAGE CONTEXT PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE DOT UP UP_UP LEFT_PAR LEFT_BRK MINUS_GT }]
  [tupleLiteralExp ::= (*) TUPLE LEFT_BRA variableDeclarationList RIGHT_BRA , {EOF ENDPACKAGE CONTEXT PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE DOT UP UP_UP LEFT_PAR LEFT_BRK MINUS_GT }]
  [collectionKind ::= (*) SET , {LEFT_BRA }]
  [oclExpression ::= (*) oclExpression UP simpleName LEFT_PAR RIGHT_PAR , {EOF ENDPACKAGE CONTEXT PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE DOT UP UP_UP LEFT_PAR LEFT_BRK MINUS_GT }]
  [oclExpression ::= (*) oclExpression NE oclExpression , {EOF ENDPACKAGE CONTEXT PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE DOT UP UP_UP LEFT_PAR LEFT_BRK MINUS_GT }]
  [oclExpression ::= (*) oclExpression DIVIDE oclExpression , {EOF ENDPACKAGE CONTEXT PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE DOT UP UP_UP LEFT_PAR LEFT_BRK MINUS_GT }]
  [oclExpression ::= (*) oclExpression LEFT_PAR arguments RIGHT_PAR , {EOF ENDPACKAGE CONTEXT PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE DOT UP UP_UP LEFT_PAR LEFT_BRK MINUS_GT }]
  [primitiveLiteralExp ::= (*) FALSE , {EOF ENDPACKAGE CONTEXT PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE DOT UP UP_UP LEFT_PAR LEFT_BRK MINUS_GT }]
  [literalExp ::= (*) primitiveLiteralExp , {EOF ENDPACKAGE CONTEXT PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE DOT UP UP_UP LEFT_PAR LEFT_BRK MINUS_GT }]
  [oclExpression ::= (*) LET variableDeclarationList IN oclExpression , {EOF ENDPACKAGE CONTEXT PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE DOT UP UP_UP LEFT_PAR LEFT_BRK MINUS_GT }]
  [oclExpression ::= (*) oclExpression GT oclExpression , {EOF ENDPACKAGE CONTEXT PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE DOT UP UP_UP LEFT_PAR LEFT_BRK MINUS_GT }]
  [oclExpression ::= (*) oclExpression MINUS_GT ITERATE LEFT_PAR variableDeclaration BAR oclExpression RIGHT_PAR , {EOF ENDPACKAGE CONTEXT PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE DOT UP UP_UP LEFT_PAR LEFT_BRK MINUS_GT }]
  [oclExpression ::= (*) literalExp , {EOF ENDPACKAGE CONTEXT PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE DOT UP UP_UP LEFT_PAR LEFT_BRK MINUS_GT }]
  [primitiveLiteralExp ::= (*) INTEGER , {EOF ENDPACKAGE CONTEXT PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE DOT UP UP_UP LEFT_PAR LEFT_BRK MINUS_GT }]
  [collectionKind ::= (*) BAG , {LEFT_BRA }]
  [oclExpression ::= (*) oclExpression AND oclExpression , {EOF ENDPACKAGE CONTEXT PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE DOT UP UP_UP LEFT_PAR LEFT_BRK MINUS_GT }]
  [oclExpression ::= (*) oclExpression PLUS oclExpression , {EOF ENDPACKAGE CONTEXT PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE DOT UP UP_UP LEFT_PAR LEFT_BRK MINUS_GT }]
  [oclExpression ::= (*) oclExpression LEFT_PAR variableDeclaration BAR oclExpression RIGHT_PAR , {EOF ENDPACKAGE CONTEXT PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE DOT UP UP_UP LEFT_PAR LEFT_BRK MINUS_GT }]
  [pathName ::= (*) simpleName , {EOF ENDPACKAGE CONTEXT PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE DOT UP AT COLON_COLON UP_UP LEFT_PAR LEFT_BRK MINUS_GT }]
  [oclExpression ::= (*) oclExpression UP_UP simpleName LEFT_PAR oclMessageArgumentList RIGHT_PAR , {EOF ENDPACKAGE CONTEXT PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE DOT UP UP_UP LEFT_PAR LEFT_BRK MINUS_GT }]
  [oclExpression ::= (*) oclExpression LE oclExpression , {EOF ENDPACKAGE CONTEXT PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE DOT UP UP_UP LEFT_PAR LEFT_BRK MINUS_GT }]
  [oclExpression ::= (*) NOT oclExpression , {EOF ENDPACKAGE CONTEXT PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE DOT UP UP_UP LEFT_PAR LEFT_BRK MINUS_GT }]
  [oclExpression ::= (*) LEFT_PAR oclExpression RIGHT_PAR , {EOF ENDPACKAGE CONTEXT PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE DOT UP UP_UP LEFT_PAR LEFT_BRK MINUS_GT }]
  [primitiveLiteralExp ::= (*) REAL , {EOF ENDPACKAGE CONTEXT PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE DOT UP UP_UP LEFT_PAR LEFT_BRK MINUS_GT }]
  [collectionKind ::= (*) SEQUENCE , {LEFT_BRA }]
  [oclExpression ::= (*) oclExpression OR oclExpression , {EOF ENDPACKAGE CONTEXT PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE DOT UP UP_UP LEFT_PAR LEFT_BRK MINUS_GT }]
  [oclExpression ::= (*) oclExpression MINUS oclExpression , {EOF ENDPACKAGE CONTEXT PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE DOT UP UP_UP LEFT_PAR LEFT_BRK MINUS_GT }]
  [oclExpression ::= (*) oclExpression LEFT_BRK argumentList RIGHT_BRK isMarkedPre , {EOF ENDPACKAGE CONTEXT PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE DOT UP UP_UP LEFT_PAR LEFT_BRK MINUS_GT }]
  [prePostOrBodyDecl ::= PRE COLON (*) oclExpression , {EOF ENDPACKAGE CONTEXT PRE POST BODY }]
  [pathName ::= (*) pathName COLON_COLON simpleName , {EOF ENDPACKAGE CONTEXT PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE DOT UP AT COLON_COLON UP_UP LEFT_PAR LEFT_BRK MINUS_GT }]
  [collectionLiteralExp ::= (*) collectionKind LEFT_BRA collectionLiteralParts RIGHT_BRA , {EOF ENDPACKAGE CONTEXT PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE DOT UP UP_UP LEFT_PAR LEFT_BRK MINUS_GT }]
  [oclExpression ::= (*) oclExpression UP_UP simpleName LEFT_PAR RIGHT_PAR , {EOF ENDPACKAGE CONTEXT PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE DOT UP UP_UP LEFT_PAR LEFT_BRK MINUS_GT }]
  [oclExpression ::= (*) oclExpression GE oclExpression , {EOF ENDPACKAGE CONTEXT PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE DOT UP UP_UP LEFT_PAR LEFT_BRK MINUS_GT }]
  [oclExpression ::= (*) MINUS oclExpression , {EOF ENDPACKAGE CONTEXT PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE DOT UP UP_UP LEFT_PAR LEFT_BRK MINUS_GT }]
  [oclExpression ::= (*) pathName isMarkedPre , {EOF ENDPACKAGE CONTEXT PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE DOT UP UP_UP LEFT_PAR LEFT_BRK MINUS_GT }]
  [primitiveLiteralExp ::= (*) STRING , {EOF ENDPACKAGE CONTEXT PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE DOT UP UP_UP LEFT_PAR LEFT_BRK MINUS_GT }]
  [collectionKind ::= (*) COLLECTION , {LEFT_BRA }]
  [literalExp ::= (*) collectionLiteralExp , {EOF ENDPACKAGE CONTEXT PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE DOT UP UP_UP LEFT_PAR LEFT_BRK MINUS_GT }]
  [oclExpression ::= (*) oclExpression XOR oclExpression , {EOF ENDPACKAGE CONTEXT PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE DOT UP UP_UP LEFT_PAR LEFT_BRK MINUS_GT }]
  [oclExpression ::= (*) IF oclExpression THEN oclExpression ELSE oclExpression ENDIF , {EOF ENDPACKAGE CONTEXT PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE DOT UP UP_UP LEFT_PAR LEFT_BRK MINUS_GT }]
  [oclExpression ::= (*) oclExpression MINUS_GT simpleName , {EOF ENDPACKAGE CONTEXT PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE DOT UP UP_UP LEFT_PAR LEFT_BRK MINUS_GT }]
  [simpleName ::= (*) SIMPLE_NAME , {EOF ENDPACKAGE CONTEXT PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE DOT UP AT COLON_COLON UP_UP LEFT_PAR LEFT_BRK MINUS_GT }]
  [collectionLiteralExp ::= (*) collectionKind LEFT_BRA RIGHT_BRA , {EOF ENDPACKAGE CONTEXT PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE DOT UP UP_UP LEFT_PAR LEFT_BRK MINUS_GT }]
}
transition on tupleLiteralExp to state [54]
transition on oclExpression to state [263]
transition on REAL to state [52]
transition on INTEGER to state [51]
transition on pathName to state [50]
transition on SIMPLE_NAME to state [12]
transition on LET to state [49]
transition on FALSE to state [48]
transition on MINUS to state [47]
transition on COLLECTION to state [28]
transition on SET to state [20]
transition on simpleName to state [26]
transition on collectionLiteralExp to state [46]
transition on LEFT_PAR to state [45]
transition on STRING to state [44]
transition on IF to state [43]
transition on TRUE to state [42]
transition on collectionKind to state [41]
transition on NOT to state [40]
transition on primitiveLiteralExp to state [39]
transition on TUPLE to state [38]
transition on literalExp to state [37]
transition on BAG to state [25]
transition on SEQUENCE to state [22]

-------------------
lalr_state [263]: {
  [oclExpression ::= oclExpression (*) LEFT_BRK argumentList RIGHT_BRK isMarkedPre , {EOF ENDPACKAGE CONTEXT PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE DOT UP UP_UP LEFT_PAR LEFT_BRK MINUS_GT }]
  [oclExpression ::= oclExpression (*) EQ oclExpression , {EOF ENDPACKAGE CONTEXT PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE DOT UP UP_UP LEFT_PAR LEFT_BRK MINUS_GT }]
  [oclExpression ::= oclExpression (*) IMPLIES oclExpression , {EOF ENDPACKAGE CONTEXT PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE DOT UP UP_UP LEFT_PAR LEFT_BRK MINUS_GT }]
  [oclExpression ::= oclExpression (*) UP simpleName LEFT_PAR RIGHT_PAR , {EOF ENDPACKAGE CONTEXT PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE DOT UP UP_UP LEFT_PAR LEFT_BRK MINUS_GT }]
  [oclExpression ::= oclExpression (*) LEFT_PAR arguments RIGHT_PAR , {EOF ENDPACKAGE CONTEXT PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE DOT UP UP_UP LEFT_PAR LEFT_BRK MINUS_GT }]
  [oclExpression ::= oclExpression (*) MINUS_GT ITERATE LEFT_PAR variableDeclaration BAR oclExpression RIGHT_PAR , {EOF ENDPACKAGE CONTEXT PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE DOT UP UP_UP LEFT_PAR LEFT_BRK MINUS_GT }]
  [oclExpression ::= oclExpression (*) PLUS oclExpression , {EOF ENDPACKAGE CONTEXT PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE DOT UP UP_UP LEFT_PAR LEFT_BRK MINUS_GT }]
  [oclExpression ::= oclExpression (*) LE oclExpression , {EOF ENDPACKAGE CONTEXT PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE DOT UP UP_UP LEFT_PAR LEFT_BRK MINUS_GT }]
  [oclExpression ::= oclExpression (*) OR oclExpression , {EOF ENDPACKAGE CONTEXT PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE DOT UP UP_UP LEFT_PAR LEFT_BRK MINUS_GT }]
  [oclExpression ::= oclExpression (*) UP_UP simpleName LEFT_PAR RIGHT_PAR , {EOF ENDPACKAGE CONTEXT PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE DOT UP UP_UP LEFT_PAR LEFT_BRK MINUS_GT }]
  [oclExpression ::= oclExpression (*) MINUS_GT simpleName , {EOF ENDPACKAGE CONTEXT PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE DOT UP UP_UP LEFT_PAR LEFT_BRK MINUS_GT }]
  [prePostOrBodyDecl ::= PRE COLON oclExpression (*) , {EOF ENDPACKAGE CONTEXT PRE POST BODY }]
  [oclExpression ::= oclExpression (*) TIMES oclExpression , {EOF ENDPACKAGE CONTEXT PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE DOT UP UP_UP LEFT_PAR LEFT_BRK MINUS_GT }]
  [oclExpression ::= oclExpression (*) LT oclExpression , {EOF ENDPACKAGE CONTEXT PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE DOT UP UP_UP LEFT_PAR LEFT_BRK MINUS_GT }]
  [oclExpression ::= oclExpression (*) NE oclExpression , {EOF ENDPACKAGE CONTEXT PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE DOT UP UP_UP LEFT_PAR LEFT_BRK MINUS_GT }]
  [oclExpression ::= oclExpression (*) LEFT_PAR variableDeclaration BAR oclExpression RIGHT_PAR , {EOF ENDPACKAGE CONTEXT PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE DOT UP UP_UP LEFT_PAR LEFT_BRK MINUS_GT }]
  [oclExpression ::= oclExpression (*) MINUS oclExpression , {EOF ENDPACKAGE CONTEXT PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE DOT UP UP_UP LEFT_PAR LEFT_BRK MINUS_GT }]
  [oclExpression ::= oclExpression (*) GE oclExpression , {EOF ENDPACKAGE CONTEXT PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE DOT UP UP_UP LEFT_PAR LEFT_BRK MINUS_GT }]
  [oclExpression ::= oclExpression (*) XOR oclExpression , {EOF ENDPACKAGE CONTEXT PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE DOT UP UP_UP LEFT_PAR LEFT_BRK MINUS_GT }]
  [oclExpression ::= oclExpression (*) UP simpleName LEFT_PAR oclMessageArgumentList RIGHT_PAR , {EOF ENDPACKAGE CONTEXT PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE DOT UP UP_UP LEFT_PAR LEFT_BRK MINUS_GT }]
  [oclExpression ::= oclExpression (*) DOT simpleName isMarkedPre , {EOF ENDPACKAGE CONTEXT PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE DOT UP UP_UP LEFT_PAR LEFT_BRK MINUS_GT }]
  [oclExpression ::= oclExpression (*) MINUS_GT ITERATE LEFT_PAR variableDeclaration SEMICOLON variableDeclaration BAR oclExpression RIGHT_PAR , {EOF ENDPACKAGE CONTEXT PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE DOT UP UP_UP LEFT_PAR LEFT_BRK MINUS_GT }]
  [oclExpression ::= oclExpression (*) DIVIDE oclExpression , {EOF ENDPACKAGE CONTEXT PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE DOT UP UP_UP LEFT_PAR LEFT_BRK MINUS_GT }]
  [oclExpression ::= oclExpression (*) GT oclExpression , {EOF ENDPACKAGE CONTEXT PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE DOT UP UP_UP LEFT_PAR LEFT_BRK MINUS_GT }]
  [oclExpression ::= oclExpression (*) AND oclExpression , {EOF ENDPACKAGE CONTEXT PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE DOT UP UP_UP LEFT_PAR LEFT_BRK MINUS_GT }]
  [oclExpression ::= oclExpression (*) UP_UP simpleName LEFT_PAR oclMessageArgumentList RIGHT_PAR , {EOF ENDPACKAGE CONTEXT PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE DOT UP UP_UP LEFT_PAR LEFT_BRK MINUS_GT }]
}
transition on XOR to state [74]
transition on EQ to state [73]
transition on DOT to state [72]
transition on MINUS to state [71]
transition on GE to state [70]
transition on LEFT_BRK to state [69]
transition on DIVIDE to state [68]
transition on LEFT_PAR to state [67]
transition on MINUS_GT to state [66]
transition on LE to state [65]
transition on GT to state [64]
transition on IMPLIES to state [63]
transition on UP to state [62]
transition on UP_UP to state [61]
transition on OR to state [60]
transition on PLUS to state [59]
transition on NE to state [58]
transition on LT to state [57]
transition on AND to state [56]
transition on TIMES to state [55]

-------------------
lalr_state [264]: {
  [oclExpression ::= (*) oclExpression UP simpleName LEFT_PAR oclMessageArgumentList RIGHT_PAR , {EOF ENDPACKAGE CONTEXT PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE DOT UP UP_UP LEFT_PAR LEFT_BRK MINUS_GT }]
  [oclExpression ::= (*) oclExpression EQ oclExpression , {EOF ENDPACKAGE CONTEXT PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE DOT UP UP_UP LEFT_PAR LEFT_BRK MINUS_GT }]
  [oclExpression ::= (*) oclExpression TIMES oclExpression , {EOF ENDPACKAGE CONTEXT PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE DOT UP UP_UP LEFT_PAR LEFT_BRK MINUS_GT }]
  [oclExpression ::= (*) oclExpression DOT simpleName isMarkedPre , {EOF ENDPACKAGE CONTEXT PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE DOT UP UP_UP LEFT_PAR LEFT_BRK MINUS_GT }]
  [primitiveLiteralExp ::= (*) TRUE , {EOF ENDPACKAGE CONTEXT PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE DOT UP UP_UP LEFT_PAR LEFT_BRK MINUS_GT }]
  [literalExp ::= (*) tupleLiteralExp , {EOF ENDPACKAGE CONTEXT PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE DOT UP UP_UP LEFT_PAR LEFT_BRK MINUS_GT }]
  [oclExpression ::= (*) oclExpression IMPLIES oclExpression , {EOF ENDPACKAGE CONTEXT PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE DOT UP UP_UP LEFT_PAR LEFT_BRK MINUS_GT }]
  [oclExpression ::= (*) oclExpression LT oclExpression , {EOF ENDPACKAGE CONTEXT PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE DOT UP UP_UP LEFT_PAR LEFT_BRK MINUS_GT }]
  [oclExpression ::= (*) oclExpression MINUS_GT ITERATE LEFT_PAR variableDeclaration SEMICOLON variableDeclaration BAR oclExpression RIGHT_PAR , {EOF ENDPACKAGE CONTEXT PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE DOT UP UP_UP LEFT_PAR LEFT_BRK MINUS_GT }]
  [tupleLiteralExp ::= (*) TUPLE LEFT_BRA variableDeclarationList RIGHT_BRA , {EOF ENDPACKAGE CONTEXT PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE DOT UP UP_UP LEFT_PAR LEFT_BRK MINUS_GT }]
  [collectionKind ::= (*) SET , {LEFT_BRA }]
  [oclExpression ::= (*) oclExpression UP simpleName LEFT_PAR RIGHT_PAR , {EOF ENDPACKAGE CONTEXT PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE DOT UP UP_UP LEFT_PAR LEFT_BRK MINUS_GT }]
  [oclExpression ::= (*) oclExpression NE oclExpression , {EOF ENDPACKAGE CONTEXT PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE DOT UP UP_UP LEFT_PAR LEFT_BRK MINUS_GT }]
  [oclExpression ::= (*) oclExpression DIVIDE oclExpression , {EOF ENDPACKAGE CONTEXT PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE DOT UP UP_UP LEFT_PAR LEFT_BRK MINUS_GT }]
  [oclExpression ::= (*) oclExpression LEFT_PAR arguments RIGHT_PAR , {EOF ENDPACKAGE CONTEXT PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE DOT UP UP_UP LEFT_PAR LEFT_BRK MINUS_GT }]
  [primitiveLiteralExp ::= (*) FALSE , {EOF ENDPACKAGE CONTEXT PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE DOT UP UP_UP LEFT_PAR LEFT_BRK MINUS_GT }]
  [literalExp ::= (*) primitiveLiteralExp , {EOF ENDPACKAGE CONTEXT PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE DOT UP UP_UP LEFT_PAR LEFT_BRK MINUS_GT }]
  [oclExpression ::= (*) LET variableDeclarationList IN oclExpression , {EOF ENDPACKAGE CONTEXT PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE DOT UP UP_UP LEFT_PAR LEFT_BRK MINUS_GT }]
  [oclExpression ::= (*) oclExpression GT oclExpression , {EOF ENDPACKAGE CONTEXT PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE DOT UP UP_UP LEFT_PAR LEFT_BRK MINUS_GT }]
  [oclExpression ::= (*) oclExpression MINUS_GT ITERATE LEFT_PAR variableDeclaration BAR oclExpression RIGHT_PAR , {EOF ENDPACKAGE CONTEXT PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE DOT UP UP_UP LEFT_PAR LEFT_BRK MINUS_GT }]
  [oclExpression ::= (*) literalExp , {EOF ENDPACKAGE CONTEXT PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE DOT UP UP_UP LEFT_PAR LEFT_BRK MINUS_GT }]
  [primitiveLiteralExp ::= (*) INTEGER , {EOF ENDPACKAGE CONTEXT PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE DOT UP UP_UP LEFT_PAR LEFT_BRK MINUS_GT }]
  [collectionKind ::= (*) BAG , {LEFT_BRA }]
  [oclExpression ::= (*) oclExpression AND oclExpression , {EOF ENDPACKAGE CONTEXT PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE DOT UP UP_UP LEFT_PAR LEFT_BRK MINUS_GT }]
  [oclExpression ::= (*) oclExpression PLUS oclExpression , {EOF ENDPACKAGE CONTEXT PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE DOT UP UP_UP LEFT_PAR LEFT_BRK MINUS_GT }]
  [oclExpression ::= (*) oclExpression LEFT_PAR variableDeclaration BAR oclExpression RIGHT_PAR , {EOF ENDPACKAGE CONTEXT PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE DOT UP UP_UP LEFT_PAR LEFT_BRK MINUS_GT }]
  [prePostOrBodyDecl ::= PRE simpleName COLON (*) oclExpression , {EOF ENDPACKAGE CONTEXT PRE POST BODY }]
  [pathName ::= (*) simpleName , {EOF ENDPACKAGE CONTEXT PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE DOT UP AT COLON_COLON UP_UP LEFT_PAR LEFT_BRK MINUS_GT }]
  [oclExpression ::= (*) oclExpression UP_UP simpleName LEFT_PAR oclMessageArgumentList RIGHT_PAR , {EOF ENDPACKAGE CONTEXT PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE DOT UP UP_UP LEFT_PAR LEFT_BRK MINUS_GT }]
  [oclExpression ::= (*) oclExpression LE oclExpression , {EOF ENDPACKAGE CONTEXT PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE DOT UP UP_UP LEFT_PAR LEFT_BRK MINUS_GT }]
  [oclExpression ::= (*) NOT oclExpression , {EOF ENDPACKAGE CONTEXT PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE DOT UP UP_UP LEFT_PAR LEFT_BRK MINUS_GT }]
  [oclExpression ::= (*) LEFT_PAR oclExpression RIGHT_PAR , {EOF ENDPACKAGE CONTEXT PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE DOT UP UP_UP LEFT_PAR LEFT_BRK MINUS_GT }]
  [primitiveLiteralExp ::= (*) REAL , {EOF ENDPACKAGE CONTEXT PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE DOT UP UP_UP LEFT_PAR LEFT_BRK MINUS_GT }]
  [collectionKind ::= (*) SEQUENCE , {LEFT_BRA }]
  [oclExpression ::= (*) oclExpression OR oclExpression , {EOF ENDPACKAGE CONTEXT PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE DOT UP UP_UP LEFT_PAR LEFT_BRK MINUS_GT }]
  [oclExpression ::= (*) oclExpression MINUS oclExpression , {EOF ENDPACKAGE CONTEXT PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE DOT UP UP_UP LEFT_PAR LEFT_BRK MINUS_GT }]
  [oclExpression ::= (*) oclExpression LEFT_BRK argumentList RIGHT_BRK isMarkedPre , {EOF ENDPACKAGE CONTEXT PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE DOT UP UP_UP LEFT_PAR LEFT_BRK MINUS_GT }]
  [pathName ::= (*) pathName COLON_COLON simpleName , {EOF ENDPACKAGE CONTEXT PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE DOT UP AT COLON_COLON UP_UP LEFT_PAR LEFT_BRK MINUS_GT }]
  [collectionLiteralExp ::= (*) collectionKind LEFT_BRA collectionLiteralParts RIGHT_BRA , {EOF ENDPACKAGE CONTEXT PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE DOT UP UP_UP LEFT_PAR LEFT_BRK MINUS_GT }]
  [oclExpression ::= (*) oclExpression UP_UP simpleName LEFT_PAR RIGHT_PAR , {EOF ENDPACKAGE CONTEXT PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE DOT UP UP_UP LEFT_PAR LEFT_BRK MINUS_GT }]
  [oclExpression ::= (*) oclExpression GE oclExpression , {EOF ENDPACKAGE CONTEXT PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE DOT UP UP_UP LEFT_PAR LEFT_BRK MINUS_GT }]
  [oclExpression ::= (*) MINUS oclExpression , {EOF ENDPACKAGE CONTEXT PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE DOT UP UP_UP LEFT_PAR LEFT_BRK MINUS_GT }]
  [oclExpression ::= (*) pathName isMarkedPre , {EOF ENDPACKAGE CONTEXT PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE DOT UP UP_UP LEFT_PAR LEFT_BRK MINUS_GT }]
  [primitiveLiteralExp ::= (*) STRING , {EOF ENDPACKAGE CONTEXT PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE DOT UP UP_UP LEFT_PAR LEFT_BRK MINUS_GT }]
  [collectionKind ::= (*) COLLECTION , {LEFT_BRA }]
  [literalExp ::= (*) collectionLiteralExp , {EOF ENDPACKAGE CONTEXT PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE DOT UP UP_UP LEFT_PAR LEFT_BRK MINUS_GT }]
  [oclExpression ::= (*) oclExpression XOR oclExpression , {EOF ENDPACKAGE CONTEXT PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE DOT UP UP_UP LEFT_PAR LEFT_BRK MINUS_GT }]
  [oclExpression ::= (*) IF oclExpression THEN oclExpression ELSE oclExpression ENDIF , {EOF ENDPACKAGE CONTEXT PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE DOT UP UP_UP LEFT_PAR LEFT_BRK MINUS_GT }]
  [oclExpression ::= (*) oclExpression MINUS_GT simpleName , {EOF ENDPACKAGE CONTEXT PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE DOT UP UP_UP LEFT_PAR LEFT_BRK MINUS_GT }]
  [simpleName ::= (*) SIMPLE_NAME , {EOF ENDPACKAGE CONTEXT PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE DOT UP AT COLON_COLON UP_UP LEFT_PAR LEFT_BRK MINUS_GT }]
  [collectionLiteralExp ::= (*) collectionKind LEFT_BRA RIGHT_BRA , {EOF ENDPACKAGE CONTEXT PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE DOT UP UP_UP LEFT_PAR LEFT_BRK MINUS_GT }]
}
transition on tupleLiteralExp to state [54]
transition on oclExpression to state [265]
transition on REAL to state [52]
transition on INTEGER to state [51]
transition on pathName to state [50]
transition on SIMPLE_NAME to state [12]
transition on LET to state [49]
transition on FALSE to state [48]
transition on MINUS to state [47]
transition on COLLECTION to state [28]
transition on SET to state [20]
transition on simpleName to state [26]
transition on collectionLiteralExp to state [46]
transition on LEFT_PAR to state [45]
transition on STRING to state [44]
transition on IF to state [43]
transition on TRUE to state [42]
transition on collectionKind to state [41]
transition on NOT to state [40]
transition on primitiveLiteralExp to state [39]
transition on TUPLE to state [38]
transition on literalExp to state [37]
transition on BAG to state [25]
transition on SEQUENCE to state [22]

-------------------
lalr_state [265]: {
  [prePostOrBodyDecl ::= PRE simpleName COLON oclExpression (*) , {EOF ENDPACKAGE CONTEXT PRE POST BODY }]
  [oclExpression ::= oclExpression (*) LEFT_BRK argumentList RIGHT_BRK isMarkedPre , {EOF ENDPACKAGE CONTEXT PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE DOT UP UP_UP LEFT_PAR LEFT_BRK MINUS_GT }]
  [oclExpression ::= oclExpression (*) EQ oclExpression , {EOF ENDPACKAGE CONTEXT PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE DOT UP UP_UP LEFT_PAR LEFT_BRK MINUS_GT }]
  [oclExpression ::= oclExpression (*) IMPLIES oclExpression , {EOF ENDPACKAGE CONTEXT PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE DOT UP UP_UP LEFT_PAR LEFT_BRK MINUS_GT }]
  [oclExpression ::= oclExpression (*) UP simpleName LEFT_PAR RIGHT_PAR , {EOF ENDPACKAGE CONTEXT PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE DOT UP UP_UP LEFT_PAR LEFT_BRK MINUS_GT }]
  [oclExpression ::= oclExpression (*) LEFT_PAR arguments RIGHT_PAR , {EOF ENDPACKAGE CONTEXT PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE DOT UP UP_UP LEFT_PAR LEFT_BRK MINUS_GT }]
  [oclExpression ::= oclExpression (*) MINUS_GT ITERATE LEFT_PAR variableDeclaration BAR oclExpression RIGHT_PAR , {EOF ENDPACKAGE CONTEXT PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE DOT UP UP_UP LEFT_PAR LEFT_BRK MINUS_GT }]
  [oclExpression ::= oclExpression (*) PLUS oclExpression , {EOF ENDPACKAGE CONTEXT PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE DOT UP UP_UP LEFT_PAR LEFT_BRK MINUS_GT }]
  [oclExpression ::= oclExpression (*) LE oclExpression , {EOF ENDPACKAGE CONTEXT PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE DOT UP UP_UP LEFT_PAR LEFT_BRK MINUS_GT }]
  [oclExpression ::= oclExpression (*) OR oclExpression , {EOF ENDPACKAGE CONTEXT PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE DOT UP UP_UP LEFT_PAR LEFT_BRK MINUS_GT }]
  [oclExpression ::= oclExpression (*) UP_UP simpleName LEFT_PAR RIGHT_PAR , {EOF ENDPACKAGE CONTEXT PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE DOT UP UP_UP LEFT_PAR LEFT_BRK MINUS_GT }]
  [oclExpression ::= oclExpression (*) MINUS_GT simpleName , {EOF ENDPACKAGE CONTEXT PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE DOT UP UP_UP LEFT_PAR LEFT_BRK MINUS_GT }]
  [oclExpression ::= oclExpression (*) TIMES oclExpression , {EOF ENDPACKAGE CONTEXT PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE DOT UP UP_UP LEFT_PAR LEFT_BRK MINUS_GT }]
  [oclExpression ::= oclExpression (*) LT oclExpression , {EOF ENDPACKAGE CONTEXT PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE DOT UP UP_UP LEFT_PAR LEFT_BRK MINUS_GT }]
  [oclExpression ::= oclExpression (*) NE oclExpression , {EOF ENDPACKAGE CONTEXT PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE DOT UP UP_UP LEFT_PAR LEFT_BRK MINUS_GT }]
  [oclExpression ::= oclExpression (*) LEFT_PAR variableDeclaration BAR oclExpression RIGHT_PAR , {EOF ENDPACKAGE CONTEXT PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE DOT UP UP_UP LEFT_PAR LEFT_BRK MINUS_GT }]
  [oclExpression ::= oclExpression (*) MINUS oclExpression , {EOF ENDPACKAGE CONTEXT PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE DOT UP UP_UP LEFT_PAR LEFT_BRK MINUS_GT }]
  [oclExpression ::= oclExpression (*) GE oclExpression , {EOF ENDPACKAGE CONTEXT PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE DOT UP UP_UP LEFT_PAR LEFT_BRK MINUS_GT }]
  [oclExpression ::= oclExpression (*) XOR oclExpression , {EOF ENDPACKAGE CONTEXT PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE DOT UP UP_UP LEFT_PAR LEFT_BRK MINUS_GT }]
  [oclExpression ::= oclExpression (*) UP simpleName LEFT_PAR oclMessageArgumentList RIGHT_PAR , {EOF ENDPACKAGE CONTEXT PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE DOT UP UP_UP LEFT_PAR LEFT_BRK MINUS_GT }]
  [oclExpression ::= oclExpression (*) DOT simpleName isMarkedPre , {EOF ENDPACKAGE CONTEXT PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE DOT UP UP_UP LEFT_PAR LEFT_BRK MINUS_GT }]
  [oclExpression ::= oclExpression (*) MINUS_GT ITERATE LEFT_PAR variableDeclaration SEMICOLON variableDeclaration BAR oclExpression RIGHT_PAR , {EOF ENDPACKAGE CONTEXT PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE DOT UP UP_UP LEFT_PAR LEFT_BRK MINUS_GT }]
  [oclExpression ::= oclExpression (*) DIVIDE oclExpression , {EOF ENDPACKAGE CONTEXT PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE DOT UP UP_UP LEFT_PAR LEFT_BRK MINUS_GT }]
  [oclExpression ::= oclExpression (*) GT oclExpression , {EOF ENDPACKAGE CONTEXT PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE DOT UP UP_UP LEFT_PAR LEFT_BRK MINUS_GT }]
  [oclExpression ::= oclExpression (*) AND oclExpression , {EOF ENDPACKAGE CONTEXT PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE DOT UP UP_UP LEFT_PAR LEFT_BRK MINUS_GT }]
  [oclExpression ::= oclExpression (*) UP_UP simpleName LEFT_PAR oclMessageArgumentList RIGHT_PAR , {EOF ENDPACKAGE CONTEXT PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE DOT UP UP_UP LEFT_PAR LEFT_BRK MINUS_GT }]
}
transition on XOR to state [74]
transition on EQ to state [73]
transition on DOT to state [72]
transition on MINUS to state [71]
transition on GE to state [70]
transition on LEFT_BRK to state [69]
transition on DIVIDE to state [68]
transition on LEFT_PAR to state [67]
transition on MINUS_GT to state [66]
transition on LE to state [65]
transition on GT to state [64]
transition on IMPLIES to state [63]
transition on UP to state [62]
transition on UP_UP to state [61]
transition on OR to state [60]
transition on PLUS to state [59]
transition on NE to state [58]
transition on LT to state [57]
transition on AND to state [56]
transition on TIMES to state [55]

-------------------
lalr_state [266]: {
  [oclExpression ::= (*) oclExpression UP simpleName LEFT_PAR oclMessageArgumentList RIGHT_PAR , {EOF ENDPACKAGE CONTEXT PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE DOT UP UP_UP LEFT_PAR LEFT_BRK MINUS_GT }]
  [oclExpression ::= (*) oclExpression EQ oclExpression , {EOF ENDPACKAGE CONTEXT PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE DOT UP UP_UP LEFT_PAR LEFT_BRK MINUS_GT }]
  [oclExpression ::= (*) oclExpression TIMES oclExpression , {EOF ENDPACKAGE CONTEXT PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE DOT UP UP_UP LEFT_PAR LEFT_BRK MINUS_GT }]
  [oclExpression ::= (*) oclExpression DOT simpleName isMarkedPre , {EOF ENDPACKAGE CONTEXT PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE DOT UP UP_UP LEFT_PAR LEFT_BRK MINUS_GT }]
  [primitiveLiteralExp ::= (*) TRUE , {EOF ENDPACKAGE CONTEXT PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE DOT UP UP_UP LEFT_PAR LEFT_BRK MINUS_GT }]
  [literalExp ::= (*) tupleLiteralExp , {EOF ENDPACKAGE CONTEXT PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE DOT UP UP_UP LEFT_PAR LEFT_BRK MINUS_GT }]
  [oclExpression ::= (*) oclExpression IMPLIES oclExpression , {EOF ENDPACKAGE CONTEXT PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE DOT UP UP_UP LEFT_PAR LEFT_BRK MINUS_GT }]
  [oclExpression ::= (*) oclExpression LT oclExpression , {EOF ENDPACKAGE CONTEXT PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE DOT UP UP_UP LEFT_PAR LEFT_BRK MINUS_GT }]
  [oclExpression ::= (*) oclExpression MINUS_GT ITERATE LEFT_PAR variableDeclaration SEMICOLON variableDeclaration BAR oclExpression RIGHT_PAR , {EOF ENDPACKAGE CONTEXT PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE DOT UP UP_UP LEFT_PAR LEFT_BRK MINUS_GT }]
  [tupleLiteralExp ::= (*) TUPLE LEFT_BRA variableDeclarationList RIGHT_BRA , {EOF ENDPACKAGE CONTEXT PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE DOT UP UP_UP LEFT_PAR LEFT_BRK MINUS_GT }]
  [collectionKind ::= (*) SET , {LEFT_BRA }]
  [oclExpression ::= (*) oclExpression UP simpleName LEFT_PAR RIGHT_PAR , {EOF ENDPACKAGE CONTEXT PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE DOT UP UP_UP LEFT_PAR LEFT_BRK MINUS_GT }]
  [oclExpression ::= (*) oclExpression NE oclExpression , {EOF ENDPACKAGE CONTEXT PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE DOT UP UP_UP LEFT_PAR LEFT_BRK MINUS_GT }]
  [oclExpression ::= (*) oclExpression DIVIDE oclExpression , {EOF ENDPACKAGE CONTEXT PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE DOT UP UP_UP LEFT_PAR LEFT_BRK MINUS_GT }]
  [oclExpression ::= (*) oclExpression LEFT_PAR arguments RIGHT_PAR , {EOF ENDPACKAGE CONTEXT PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE DOT UP UP_UP LEFT_PAR LEFT_BRK MINUS_GT }]
  [primitiveLiteralExp ::= (*) FALSE , {EOF ENDPACKAGE CONTEXT PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE DOT UP UP_UP LEFT_PAR LEFT_BRK MINUS_GT }]
  [literalExp ::= (*) primitiveLiteralExp , {EOF ENDPACKAGE CONTEXT PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE DOT UP UP_UP LEFT_PAR LEFT_BRK MINUS_GT }]
  [oclExpression ::= (*) LET variableDeclarationList IN oclExpression , {EOF ENDPACKAGE CONTEXT PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE DOT UP UP_UP LEFT_PAR LEFT_BRK MINUS_GT }]
  [oclExpression ::= (*) oclExpression GT oclExpression , {EOF ENDPACKAGE CONTEXT PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE DOT UP UP_UP LEFT_PAR LEFT_BRK MINUS_GT }]
  [oclExpression ::= (*) oclExpression MINUS_GT ITERATE LEFT_PAR variableDeclaration BAR oclExpression RIGHT_PAR , {EOF ENDPACKAGE CONTEXT PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE DOT UP UP_UP LEFT_PAR LEFT_BRK MINUS_GT }]
  [oclExpression ::= (*) literalExp , {EOF ENDPACKAGE CONTEXT PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE DOT UP UP_UP LEFT_PAR LEFT_BRK MINUS_GT }]
  [primitiveLiteralExp ::= (*) INTEGER , {EOF ENDPACKAGE CONTEXT PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE DOT UP UP_UP LEFT_PAR LEFT_BRK MINUS_GT }]
  [collectionKind ::= (*) BAG , {LEFT_BRA }]
  [oclExpression ::= (*) oclExpression AND oclExpression , {EOF ENDPACKAGE CONTEXT PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE DOT UP UP_UP LEFT_PAR LEFT_BRK MINUS_GT }]
  [oclExpression ::= (*) oclExpression PLUS oclExpression , {EOF ENDPACKAGE CONTEXT PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE DOT UP UP_UP LEFT_PAR LEFT_BRK MINUS_GT }]
  [oclExpression ::= (*) oclExpression LEFT_PAR variableDeclaration BAR oclExpression RIGHT_PAR , {EOF ENDPACKAGE CONTEXT PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE DOT UP UP_UP LEFT_PAR LEFT_BRK MINUS_GT }]
  [pathName ::= (*) simpleName , {EOF ENDPACKAGE CONTEXT PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE DOT UP AT COLON_COLON UP_UP LEFT_PAR LEFT_BRK MINUS_GT }]
  [oclExpression ::= (*) oclExpression UP_UP simpleName LEFT_PAR oclMessageArgumentList RIGHT_PAR , {EOF ENDPACKAGE CONTEXT PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE DOT UP UP_UP LEFT_PAR LEFT_BRK MINUS_GT }]
  [oclExpression ::= (*) oclExpression LE oclExpression , {EOF ENDPACKAGE CONTEXT PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE DOT UP UP_UP LEFT_PAR LEFT_BRK MINUS_GT }]
  [oclExpression ::= (*) NOT oclExpression , {EOF ENDPACKAGE CONTEXT PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE DOT UP UP_UP LEFT_PAR LEFT_BRK MINUS_GT }]
  [oclExpression ::= (*) LEFT_PAR oclExpression RIGHT_PAR , {EOF ENDPACKAGE CONTEXT PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE DOT UP UP_UP LEFT_PAR LEFT_BRK MINUS_GT }]
  [prePostOrBodyDecl ::= BODY COLON (*) oclExpression , {EOF ENDPACKAGE CONTEXT PRE POST BODY }]
  [primitiveLiteralExp ::= (*) REAL , {EOF ENDPACKAGE CONTEXT PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE DOT UP UP_UP LEFT_PAR LEFT_BRK MINUS_GT }]
  [collectionKind ::= (*) SEQUENCE , {LEFT_BRA }]
  [oclExpression ::= (*) oclExpression OR oclExpression , {EOF ENDPACKAGE CONTEXT PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE DOT UP UP_UP LEFT_PAR LEFT_BRK MINUS_GT }]
  [oclExpression ::= (*) oclExpression MINUS oclExpression , {EOF ENDPACKAGE CONTEXT PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE DOT UP UP_UP LEFT_PAR LEFT_BRK MINUS_GT }]
  [oclExpression ::= (*) oclExpression LEFT_BRK argumentList RIGHT_BRK isMarkedPre , {EOF ENDPACKAGE CONTEXT PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE DOT UP UP_UP LEFT_PAR LEFT_BRK MINUS_GT }]
  [pathName ::= (*) pathName COLON_COLON simpleName , {EOF ENDPACKAGE CONTEXT PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE DOT UP AT COLON_COLON UP_UP LEFT_PAR LEFT_BRK MINUS_GT }]
  [collectionLiteralExp ::= (*) collectionKind LEFT_BRA collectionLiteralParts RIGHT_BRA , {EOF ENDPACKAGE CONTEXT PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE DOT UP UP_UP LEFT_PAR LEFT_BRK MINUS_GT }]
  [oclExpression ::= (*) oclExpression UP_UP simpleName LEFT_PAR RIGHT_PAR , {EOF ENDPACKAGE CONTEXT PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE DOT UP UP_UP LEFT_PAR LEFT_BRK MINUS_GT }]
  [oclExpression ::= (*) oclExpression GE oclExpression , {EOF ENDPACKAGE CONTEXT PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE DOT UP UP_UP LEFT_PAR LEFT_BRK MINUS_GT }]
  [oclExpression ::= (*) MINUS oclExpression , {EOF ENDPACKAGE CONTEXT PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE DOT UP UP_UP LEFT_PAR LEFT_BRK MINUS_GT }]
  [oclExpression ::= (*) pathName isMarkedPre , {EOF ENDPACKAGE CONTEXT PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE DOT UP UP_UP LEFT_PAR LEFT_BRK MINUS_GT }]
  [primitiveLiteralExp ::= (*) STRING , {EOF ENDPACKAGE CONTEXT PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE DOT UP UP_UP LEFT_PAR LEFT_BRK MINUS_GT }]
  [collectionKind ::= (*) COLLECTION , {LEFT_BRA }]
  [literalExp ::= (*) collectionLiteralExp , {EOF ENDPACKAGE CONTEXT PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE DOT UP UP_UP LEFT_PAR LEFT_BRK MINUS_GT }]
  [oclExpression ::= (*) oclExpression XOR oclExpression , {EOF ENDPACKAGE CONTEXT PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE DOT UP UP_UP LEFT_PAR LEFT_BRK MINUS_GT }]
  [oclExpression ::= (*) IF oclExpression THEN oclExpression ELSE oclExpression ENDIF , {EOF ENDPACKAGE CONTEXT PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE DOT UP UP_UP LEFT_PAR LEFT_BRK MINUS_GT }]
  [oclExpression ::= (*) oclExpression MINUS_GT simpleName , {EOF ENDPACKAGE CONTEXT PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE DOT UP UP_UP LEFT_PAR LEFT_BRK MINUS_GT }]
  [simpleName ::= (*) SIMPLE_NAME , {EOF ENDPACKAGE CONTEXT PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE DOT UP AT COLON_COLON UP_UP LEFT_PAR LEFT_BRK MINUS_GT }]
  [collectionLiteralExp ::= (*) collectionKind LEFT_BRA RIGHT_BRA , {EOF ENDPACKAGE CONTEXT PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE DOT UP UP_UP LEFT_PAR LEFT_BRK MINUS_GT }]
}
transition on tupleLiteralExp to state [54]
transition on oclExpression to state [270]
transition on REAL to state [52]
transition on INTEGER to state [51]
transition on pathName to state [50]
transition on SIMPLE_NAME to state [12]
transition on LET to state [49]
transition on FALSE to state [48]
transition on MINUS to state [47]
transition on COLLECTION to state [28]
transition on SET to state [20]
transition on simpleName to state [26]
transition on collectionLiteralExp to state [46]
transition on LEFT_PAR to state [45]
transition on STRING to state [44]
transition on IF to state [43]
transition on TRUE to state [42]
transition on collectionKind to state [41]
transition on NOT to state [40]
transition on primitiveLiteralExp to state [39]
transition on TUPLE to state [38]
transition on literalExp to state [37]
transition on BAG to state [25]
transition on SEQUENCE to state [22]

-------------------
lalr_state [267]: {
  [prePostOrBodyDecl ::= BODY simpleName (*) COLON oclExpression , {EOF ENDPACKAGE CONTEXT PRE POST BODY }]
}
transition on COLON to state [268]

-------------------
lalr_state [268]: {
  [oclExpression ::= (*) oclExpression UP simpleName LEFT_PAR oclMessageArgumentList RIGHT_PAR , {EOF ENDPACKAGE CONTEXT PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE DOT UP UP_UP LEFT_PAR LEFT_BRK MINUS_GT }]
  [oclExpression ::= (*) oclExpression EQ oclExpression , {EOF ENDPACKAGE CONTEXT PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE DOT UP UP_UP LEFT_PAR LEFT_BRK MINUS_GT }]
  [oclExpression ::= (*) oclExpression TIMES oclExpression , {EOF ENDPACKAGE CONTEXT PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE DOT UP UP_UP LEFT_PAR LEFT_BRK MINUS_GT }]
  [oclExpression ::= (*) oclExpression DOT simpleName isMarkedPre , {EOF ENDPACKAGE CONTEXT PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE DOT UP UP_UP LEFT_PAR LEFT_BRK MINUS_GT }]
  [primitiveLiteralExp ::= (*) TRUE , {EOF ENDPACKAGE CONTEXT PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE DOT UP UP_UP LEFT_PAR LEFT_BRK MINUS_GT }]
  [literalExp ::= (*) tupleLiteralExp , {EOF ENDPACKAGE CONTEXT PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE DOT UP UP_UP LEFT_PAR LEFT_BRK MINUS_GT }]
  [oclExpression ::= (*) oclExpression IMPLIES oclExpression , {EOF ENDPACKAGE CONTEXT PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE DOT UP UP_UP LEFT_PAR LEFT_BRK MINUS_GT }]
  [oclExpression ::= (*) oclExpression LT oclExpression , {EOF ENDPACKAGE CONTEXT PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE DOT UP UP_UP LEFT_PAR LEFT_BRK MINUS_GT }]
  [oclExpression ::= (*) oclExpression MINUS_GT ITERATE LEFT_PAR variableDeclaration SEMICOLON variableDeclaration BAR oclExpression RIGHT_PAR , {EOF ENDPACKAGE CONTEXT PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE DOT UP UP_UP LEFT_PAR LEFT_BRK MINUS_GT }]
  [tupleLiteralExp ::= (*) TUPLE LEFT_BRA variableDeclarationList RIGHT_BRA , {EOF ENDPACKAGE CONTEXT PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE DOT UP UP_UP LEFT_PAR LEFT_BRK MINUS_GT }]
  [collectionKind ::= (*) SET , {LEFT_BRA }]
  [oclExpression ::= (*) oclExpression UP simpleName LEFT_PAR RIGHT_PAR , {EOF ENDPACKAGE CONTEXT PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE DOT UP UP_UP LEFT_PAR LEFT_BRK MINUS_GT }]
  [oclExpression ::= (*) oclExpression NE oclExpression , {EOF ENDPACKAGE CONTEXT PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE DOT UP UP_UP LEFT_PAR LEFT_BRK MINUS_GT }]
  [oclExpression ::= (*) oclExpression DIVIDE oclExpression , {EOF ENDPACKAGE CONTEXT PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE DOT UP UP_UP LEFT_PAR LEFT_BRK MINUS_GT }]
  [oclExpression ::= (*) oclExpression LEFT_PAR arguments RIGHT_PAR , {EOF ENDPACKAGE CONTEXT PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE DOT UP UP_UP LEFT_PAR LEFT_BRK MINUS_GT }]
  [primitiveLiteralExp ::= (*) FALSE , {EOF ENDPACKAGE CONTEXT PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE DOT UP UP_UP LEFT_PAR LEFT_BRK MINUS_GT }]
  [literalExp ::= (*) primitiveLiteralExp , {EOF ENDPACKAGE CONTEXT PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE DOT UP UP_UP LEFT_PAR LEFT_BRK MINUS_GT }]
  [oclExpression ::= (*) LET variableDeclarationList IN oclExpression , {EOF ENDPACKAGE CONTEXT PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE DOT UP UP_UP LEFT_PAR LEFT_BRK MINUS_GT }]
  [oclExpression ::= (*) oclExpression GT oclExpression , {EOF ENDPACKAGE CONTEXT PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE DOT UP UP_UP LEFT_PAR LEFT_BRK MINUS_GT }]
  [oclExpression ::= (*) oclExpression MINUS_GT ITERATE LEFT_PAR variableDeclaration BAR oclExpression RIGHT_PAR , {EOF ENDPACKAGE CONTEXT PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE DOT UP UP_UP LEFT_PAR LEFT_BRK MINUS_GT }]
  [prePostOrBodyDecl ::= BODY simpleName COLON (*) oclExpression , {EOF ENDPACKAGE CONTEXT PRE POST BODY }]
  [oclExpression ::= (*) literalExp , {EOF ENDPACKAGE CONTEXT PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE DOT UP UP_UP LEFT_PAR LEFT_BRK MINUS_GT }]
  [primitiveLiteralExp ::= (*) INTEGER , {EOF ENDPACKAGE CONTEXT PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE DOT UP UP_UP LEFT_PAR LEFT_BRK MINUS_GT }]
  [collectionKind ::= (*) BAG , {LEFT_BRA }]
  [oclExpression ::= (*) oclExpression AND oclExpression , {EOF ENDPACKAGE CONTEXT PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE DOT UP UP_UP LEFT_PAR LEFT_BRK MINUS_GT }]
  [oclExpression ::= (*) oclExpression PLUS oclExpression , {EOF ENDPACKAGE CONTEXT PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE DOT UP UP_UP LEFT_PAR LEFT_BRK MINUS_GT }]
  [oclExpression ::= (*) oclExpression LEFT_PAR variableDeclaration BAR oclExpression RIGHT_PAR , {EOF ENDPACKAGE CONTEXT PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE DOT UP UP_UP LEFT_PAR LEFT_BRK MINUS_GT }]
  [pathName ::= (*) simpleName , {EOF ENDPACKAGE CONTEXT PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE DOT UP AT COLON_COLON UP_UP LEFT_PAR LEFT_BRK MINUS_GT }]
  [oclExpression ::= (*) oclExpression UP_UP simpleName LEFT_PAR oclMessageArgumentList RIGHT_PAR , {EOF ENDPACKAGE CONTEXT PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE DOT UP UP_UP LEFT_PAR LEFT_BRK MINUS_GT }]
  [oclExpression ::= (*) oclExpression LE oclExpression , {EOF ENDPACKAGE CONTEXT PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE DOT UP UP_UP LEFT_PAR LEFT_BRK MINUS_GT }]
  [oclExpression ::= (*) NOT oclExpression , {EOF ENDPACKAGE CONTEXT PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE DOT UP UP_UP LEFT_PAR LEFT_BRK MINUS_GT }]
  [oclExpression ::= (*) LEFT_PAR oclExpression RIGHT_PAR , {EOF ENDPACKAGE CONTEXT PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE DOT UP UP_UP LEFT_PAR LEFT_BRK MINUS_GT }]
  [primitiveLiteralExp ::= (*) REAL , {EOF ENDPACKAGE CONTEXT PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE DOT UP UP_UP LEFT_PAR LEFT_BRK MINUS_GT }]
  [collectionKind ::= (*) SEQUENCE , {LEFT_BRA }]
  [oclExpression ::= (*) oclExpression OR oclExpression , {EOF ENDPACKAGE CONTEXT PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE DOT UP UP_UP LEFT_PAR LEFT_BRK MINUS_GT }]
  [oclExpression ::= (*) oclExpression MINUS oclExpression , {EOF ENDPACKAGE CONTEXT PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE DOT UP UP_UP LEFT_PAR LEFT_BRK MINUS_GT }]
  [oclExpression ::= (*) oclExpression LEFT_BRK argumentList RIGHT_BRK isMarkedPre , {EOF ENDPACKAGE CONTEXT PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE DOT UP UP_UP LEFT_PAR LEFT_BRK MINUS_GT }]
  [pathName ::= (*) pathName COLON_COLON simpleName , {EOF ENDPACKAGE CONTEXT PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE DOT UP AT COLON_COLON UP_UP LEFT_PAR LEFT_BRK MINUS_GT }]
  [collectionLiteralExp ::= (*) collectionKind LEFT_BRA collectionLiteralParts RIGHT_BRA , {EOF ENDPACKAGE CONTEXT PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE DOT UP UP_UP LEFT_PAR LEFT_BRK MINUS_GT }]
  [oclExpression ::= (*) oclExpression UP_UP simpleName LEFT_PAR RIGHT_PAR , {EOF ENDPACKAGE CONTEXT PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE DOT UP UP_UP LEFT_PAR LEFT_BRK MINUS_GT }]
  [oclExpression ::= (*) oclExpression GE oclExpression , {EOF ENDPACKAGE CONTEXT PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE DOT UP UP_UP LEFT_PAR LEFT_BRK MINUS_GT }]
  [oclExpression ::= (*) MINUS oclExpression , {EOF ENDPACKAGE CONTEXT PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE DOT UP UP_UP LEFT_PAR LEFT_BRK MINUS_GT }]
  [oclExpression ::= (*) pathName isMarkedPre , {EOF ENDPACKAGE CONTEXT PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE DOT UP UP_UP LEFT_PAR LEFT_BRK MINUS_GT }]
  [primitiveLiteralExp ::= (*) STRING , {EOF ENDPACKAGE CONTEXT PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE DOT UP UP_UP LEFT_PAR LEFT_BRK MINUS_GT }]
  [collectionKind ::= (*) COLLECTION , {LEFT_BRA }]
  [literalExp ::= (*) collectionLiteralExp , {EOF ENDPACKAGE CONTEXT PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE DOT UP UP_UP LEFT_PAR LEFT_BRK MINUS_GT }]
  [oclExpression ::= (*) oclExpression XOR oclExpression , {EOF ENDPACKAGE CONTEXT PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE DOT UP UP_UP LEFT_PAR LEFT_BRK MINUS_GT }]
  [oclExpression ::= (*) IF oclExpression THEN oclExpression ELSE oclExpression ENDIF , {EOF ENDPACKAGE CONTEXT PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE DOT UP UP_UP LEFT_PAR LEFT_BRK MINUS_GT }]
  [oclExpression ::= (*) oclExpression MINUS_GT simpleName , {EOF ENDPACKAGE CONTEXT PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE DOT UP UP_UP LEFT_PAR LEFT_BRK MINUS_GT }]
  [simpleName ::= (*) SIMPLE_NAME , {EOF ENDPACKAGE CONTEXT PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE DOT UP AT COLON_COLON UP_UP LEFT_PAR LEFT_BRK MINUS_GT }]
  [collectionLiteralExp ::= (*) collectionKind LEFT_BRA RIGHT_BRA , {EOF ENDPACKAGE CONTEXT PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE DOT UP UP_UP LEFT_PAR LEFT_BRK MINUS_GT }]
}
transition on tupleLiteralExp to state [54]
transition on oclExpression to state [269]
transition on REAL to state [52]
transition on INTEGER to state [51]
transition on pathName to state [50]
transition on SIMPLE_NAME to state [12]
transition on LET to state [49]
transition on FALSE to state [48]
transition on MINUS to state [47]
transition on COLLECTION to state [28]
transition on SET to state [20]
transition on simpleName to state [26]
transition on collectionLiteralExp to state [46]
transition on LEFT_PAR to state [45]
transition on STRING to state [44]
transition on IF to state [43]
transition on TRUE to state [42]
transition on collectionKind to state [41]
transition on NOT to state [40]
transition on primitiveLiteralExp to state [39]
transition on TUPLE to state [38]
transition on literalExp to state [37]
transition on BAG to state [25]
transition on SEQUENCE to state [22]

-------------------
lalr_state [269]: {
  [oclExpression ::= oclExpression (*) LEFT_BRK argumentList RIGHT_BRK isMarkedPre , {EOF ENDPACKAGE CONTEXT PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE DOT UP UP_UP LEFT_PAR LEFT_BRK MINUS_GT }]
  [oclExpression ::= oclExpression (*) EQ oclExpression , {EOF ENDPACKAGE CONTEXT PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE DOT UP UP_UP LEFT_PAR LEFT_BRK MINUS_GT }]
  [oclExpression ::= oclExpression (*) IMPLIES oclExpression , {EOF ENDPACKAGE CONTEXT PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE DOT UP UP_UP LEFT_PAR LEFT_BRK MINUS_GT }]
  [oclExpression ::= oclExpression (*) UP simpleName LEFT_PAR RIGHT_PAR , {EOF ENDPACKAGE CONTEXT PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE DOT UP UP_UP LEFT_PAR LEFT_BRK MINUS_GT }]
  [oclExpression ::= oclExpression (*) LEFT_PAR arguments RIGHT_PAR , {EOF ENDPACKAGE CONTEXT PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE DOT UP UP_UP LEFT_PAR LEFT_BRK MINUS_GT }]
  [oclExpression ::= oclExpression (*) MINUS_GT ITERATE LEFT_PAR variableDeclaration BAR oclExpression RIGHT_PAR , {EOF ENDPACKAGE CONTEXT PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE DOT UP UP_UP LEFT_PAR LEFT_BRK MINUS_GT }]
  [oclExpression ::= oclExpression (*) PLUS oclExpression , {EOF ENDPACKAGE CONTEXT PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE DOT UP UP_UP LEFT_PAR LEFT_BRK MINUS_GT }]
  [oclExpression ::= oclExpression (*) LE oclExpression , {EOF ENDPACKAGE CONTEXT PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE DOT UP UP_UP LEFT_PAR LEFT_BRK MINUS_GT }]
  [oclExpression ::= oclExpression (*) OR oclExpression , {EOF ENDPACKAGE CONTEXT PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE DOT UP UP_UP LEFT_PAR LEFT_BRK MINUS_GT }]
  [oclExpression ::= oclExpression (*) UP_UP simpleName LEFT_PAR RIGHT_PAR , {EOF ENDPACKAGE CONTEXT PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE DOT UP UP_UP LEFT_PAR LEFT_BRK MINUS_GT }]
  [oclExpression ::= oclExpression (*) MINUS_GT simpleName , {EOF ENDPACKAGE CONTEXT PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE DOT UP UP_UP LEFT_PAR LEFT_BRK MINUS_GT }]
  [oclExpression ::= oclExpression (*) TIMES oclExpression , {EOF ENDPACKAGE CONTEXT PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE DOT UP UP_UP LEFT_PAR LEFT_BRK MINUS_GT }]
  [oclExpression ::= oclExpression (*) LT oclExpression , {EOF ENDPACKAGE CONTEXT PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE DOT UP UP_UP LEFT_PAR LEFT_BRK MINUS_GT }]
  [oclExpression ::= oclExpression (*) NE oclExpression , {EOF ENDPACKAGE CONTEXT PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE DOT UP UP_UP LEFT_PAR LEFT_BRK MINUS_GT }]
  [prePostOrBodyDecl ::= BODY simpleName COLON oclExpression (*) , {EOF ENDPACKAGE CONTEXT PRE POST BODY }]
  [oclExpression ::= oclExpression (*) LEFT_PAR variableDeclaration BAR oclExpression RIGHT_PAR , {EOF ENDPACKAGE CONTEXT PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE DOT UP UP_UP LEFT_PAR LEFT_BRK MINUS_GT }]
  [oclExpression ::= oclExpression (*) MINUS oclExpression , {EOF ENDPACKAGE CONTEXT PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE DOT UP UP_UP LEFT_PAR LEFT_BRK MINUS_GT }]
  [oclExpression ::= oclExpression (*) GE oclExpression , {EOF ENDPACKAGE CONTEXT PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE DOT UP UP_UP LEFT_PAR LEFT_BRK MINUS_GT }]
  [oclExpression ::= oclExpression (*) XOR oclExpression , {EOF ENDPACKAGE CONTEXT PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE DOT UP UP_UP LEFT_PAR LEFT_BRK MINUS_GT }]
  [oclExpression ::= oclExpression (*) UP simpleName LEFT_PAR oclMessageArgumentList RIGHT_PAR , {EOF ENDPACKAGE CONTEXT PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE DOT UP UP_UP LEFT_PAR LEFT_BRK MINUS_GT }]
  [oclExpression ::= oclExpression (*) DOT simpleName isMarkedPre , {EOF ENDPACKAGE CONTEXT PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE DOT UP UP_UP LEFT_PAR LEFT_BRK MINUS_GT }]
  [oclExpression ::= oclExpression (*) MINUS_GT ITERATE LEFT_PAR variableDeclaration SEMICOLON variableDeclaration BAR oclExpression RIGHT_PAR , {EOF ENDPACKAGE CONTEXT PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE DOT UP UP_UP LEFT_PAR LEFT_BRK MINUS_GT }]
  [oclExpression ::= oclExpression (*) DIVIDE oclExpression , {EOF ENDPACKAGE CONTEXT PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE DOT UP UP_UP LEFT_PAR LEFT_BRK MINUS_GT }]
  [oclExpression ::= oclExpression (*) GT oclExpression , {EOF ENDPACKAGE CONTEXT PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE DOT UP UP_UP LEFT_PAR LEFT_BRK MINUS_GT }]
  [oclExpression ::= oclExpression (*) AND oclExpression , {EOF ENDPACKAGE CONTEXT PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE DOT UP UP_UP LEFT_PAR LEFT_BRK MINUS_GT }]
  [oclExpression ::= oclExpression (*) UP_UP simpleName LEFT_PAR oclMessageArgumentList RIGHT_PAR , {EOF ENDPACKAGE CONTEXT PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE DOT UP UP_UP LEFT_PAR LEFT_BRK MINUS_GT }]
}
transition on XOR to state [74]
transition on EQ to state [73]
transition on DOT to state [72]
transition on MINUS to state [71]
transition on GE to state [70]
transition on LEFT_BRK to state [69]
transition on DIVIDE to state [68]
transition on LEFT_PAR to state [67]
transition on MINUS_GT to state [66]
transition on LE to state [65]
transition on GT to state [64]
transition on IMPLIES to state [63]
transition on UP to state [62]
transition on UP_UP to state [61]
transition on OR to state [60]
transition on PLUS to state [59]
transition on NE to state [58]
transition on LT to state [57]
transition on AND to state [56]
transition on TIMES to state [55]

-------------------
lalr_state [270]: {
  [oclExpression ::= oclExpression (*) LEFT_BRK argumentList RIGHT_BRK isMarkedPre , {EOF ENDPACKAGE CONTEXT PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE DOT UP UP_UP LEFT_PAR LEFT_BRK MINUS_GT }]
  [prePostOrBodyDecl ::= BODY COLON oclExpression (*) , {EOF ENDPACKAGE CONTEXT PRE POST BODY }]
  [oclExpression ::= oclExpression (*) EQ oclExpression , {EOF ENDPACKAGE CONTEXT PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE DOT UP UP_UP LEFT_PAR LEFT_BRK MINUS_GT }]
  [oclExpression ::= oclExpression (*) IMPLIES oclExpression , {EOF ENDPACKAGE CONTEXT PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE DOT UP UP_UP LEFT_PAR LEFT_BRK MINUS_GT }]
  [oclExpression ::= oclExpression (*) UP simpleName LEFT_PAR RIGHT_PAR , {EOF ENDPACKAGE CONTEXT PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE DOT UP UP_UP LEFT_PAR LEFT_BRK MINUS_GT }]
  [oclExpression ::= oclExpression (*) LEFT_PAR arguments RIGHT_PAR , {EOF ENDPACKAGE CONTEXT PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE DOT UP UP_UP LEFT_PAR LEFT_BRK MINUS_GT }]
  [oclExpression ::= oclExpression (*) MINUS_GT ITERATE LEFT_PAR variableDeclaration BAR oclExpression RIGHT_PAR , {EOF ENDPACKAGE CONTEXT PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE DOT UP UP_UP LEFT_PAR LEFT_BRK MINUS_GT }]
  [oclExpression ::= oclExpression (*) PLUS oclExpression , {EOF ENDPACKAGE CONTEXT PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE DOT UP UP_UP LEFT_PAR LEFT_BRK MINUS_GT }]
  [oclExpression ::= oclExpression (*) LE oclExpression , {EOF ENDPACKAGE CONTEXT PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE DOT UP UP_UP LEFT_PAR LEFT_BRK MINUS_GT }]
  [oclExpression ::= oclExpression (*) OR oclExpression , {EOF ENDPACKAGE CONTEXT PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE DOT UP UP_UP LEFT_PAR LEFT_BRK MINUS_GT }]
  [oclExpression ::= oclExpression (*) UP_UP simpleName LEFT_PAR RIGHT_PAR , {EOF ENDPACKAGE CONTEXT PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE DOT UP UP_UP LEFT_PAR LEFT_BRK MINUS_GT }]
  [oclExpression ::= oclExpression (*) MINUS_GT simpleName , {EOF ENDPACKAGE CONTEXT PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE DOT UP UP_UP LEFT_PAR LEFT_BRK MINUS_GT }]
  [oclExpression ::= oclExpression (*) TIMES oclExpression , {EOF ENDPACKAGE CONTEXT PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE DOT UP UP_UP LEFT_PAR LEFT_BRK MINUS_GT }]
  [oclExpression ::= oclExpression (*) LT oclExpression , {EOF ENDPACKAGE CONTEXT PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE DOT UP UP_UP LEFT_PAR LEFT_BRK MINUS_GT }]
  [oclExpression ::= oclExpression (*) NE oclExpression , {EOF ENDPACKAGE CONTEXT PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE DOT UP UP_UP LEFT_PAR LEFT_BRK MINUS_GT }]
  [oclExpression ::= oclExpression (*) LEFT_PAR variableDeclaration BAR oclExpression RIGHT_PAR , {EOF ENDPACKAGE CONTEXT PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE DOT UP UP_UP LEFT_PAR LEFT_BRK MINUS_GT }]
  [oclExpression ::= oclExpression (*) MINUS oclExpression , {EOF ENDPACKAGE CONTEXT PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE DOT UP UP_UP LEFT_PAR LEFT_BRK MINUS_GT }]
  [oclExpression ::= oclExpression (*) GE oclExpression , {EOF ENDPACKAGE CONTEXT PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE DOT UP UP_UP LEFT_PAR LEFT_BRK MINUS_GT }]
  [oclExpression ::= oclExpression (*) XOR oclExpression , {EOF ENDPACKAGE CONTEXT PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE DOT UP UP_UP LEFT_PAR LEFT_BRK MINUS_GT }]
  [oclExpression ::= oclExpression (*) UP simpleName LEFT_PAR oclMessageArgumentList RIGHT_PAR , {EOF ENDPACKAGE CONTEXT PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE DOT UP UP_UP LEFT_PAR LEFT_BRK MINUS_GT }]
  [oclExpression ::= oclExpression (*) DOT simpleName isMarkedPre , {EOF ENDPACKAGE CONTEXT PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE DOT UP UP_UP LEFT_PAR LEFT_BRK MINUS_GT }]
  [oclExpression ::= oclExpression (*) MINUS_GT ITERATE LEFT_PAR variableDeclaration SEMICOLON variableDeclaration BAR oclExpression RIGHT_PAR , {EOF ENDPACKAGE CONTEXT PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE DOT UP UP_UP LEFT_PAR LEFT_BRK MINUS_GT }]
  [oclExpression ::= oclExpression (*) DIVIDE oclExpression , {EOF ENDPACKAGE CONTEXT PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE DOT UP UP_UP LEFT_PAR LEFT_BRK MINUS_GT }]
  [oclExpression ::= oclExpression (*) GT oclExpression , {EOF ENDPACKAGE CONTEXT PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE DOT UP UP_UP LEFT_PAR LEFT_BRK MINUS_GT }]
  [oclExpression ::= oclExpression (*) AND oclExpression , {EOF ENDPACKAGE CONTEXT PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE DOT UP UP_UP LEFT_PAR LEFT_BRK MINUS_GT }]
  [oclExpression ::= oclExpression (*) UP_UP simpleName LEFT_PAR oclMessageArgumentList RIGHT_PAR , {EOF ENDPACKAGE CONTEXT PRE POST BODY IMPLIES AND OR XOR EQ NE LT GT LE GE PLUS MINUS TIMES DIVIDE DOT UP UP_UP LEFT_PAR LEFT_BRK MINUS_GT }]
}
transition on XOR to state [74]
transition on EQ to state [73]
transition on DOT to state [72]
transition on MINUS to state [71]
transition on GE to state [70]
transition on LEFT_BRK to state [69]
transition on DIVIDE to state [68]
transition on LEFT_PAR to state [67]
transition on MINUS_GT to state [66]
transition on LE to state [65]
transition on GT to state [64]
transition on IMPLIES to state [63]
transition on UP to state [62]
transition on UP_UP to state [61]
transition on OR to state [60]
transition on PLUS to state [59]
transition on NE to state [58]
transition on LT to state [57]
transition on AND to state [56]
transition on TIMES to state [55]

-------------------
lalr_state [271]: {
  [packageDeclaration ::= PACKAGE pathName (*) contextDeclList ENDPACKAGE , {EOF }]
  [contextDeclList ::= (*) contextDeclList contextDeclaration , {ENDPACKAGE CONTEXT }]
  [contextDeclList ::= (*) , {ENDPACKAGE CONTEXT }]
  [pathName ::= pathName (*) COLON_COLON simpleName , {ENDPACKAGE CONTEXT COLON_COLON }]
}
transition on contextDeclList to state [272]
transition on COLON_COLON to state [137]

-------------------
lalr_state [272]: {
  [propertyContextDecl ::= (*) CONTEXT pathName simpleName COLON type initOrDerValue , {ENDPACKAGE CONTEXT }]
  [contextDeclaration ::= (*) propertyContextDecl , {ENDPACKAGE CONTEXT }]
  [classifierContextDecl ::= (*) CONTEXT pathName invOrDef , {ENDPACKAGE CONTEXT }]
  [operationContextDecl ::= (*) CONTEXT operation prePostOrBodyDecl , {ENDPACKAGE CONTEXT }]
  [packageDeclaration ::= PACKAGE pathName contextDeclList (*) ENDPACKAGE , {EOF }]
  [contextDeclaration ::= (*) operationContextDecl , {ENDPACKAGE CONTEXT }]
  [contextDeclList ::= contextDeclList (*) contextDeclaration , {ENDPACKAGE CONTEXT }]
  [contextDeclaration ::= (*) classifierContextDecl , {ENDPACKAGE CONTEXT }]
}
transition on CONTEXT to state [8]
transition on ENDPACKAGE to state [273]
transition on operationContextDecl to state [7]
transition on classifierContextDecl to state [6]
transition on propertyContextDecl to state [5]
transition on contextDeclaration to state [4]

-------------------
lalr_state [273]: {
  [packageDeclaration ::= PACKAGE pathName contextDeclList ENDPACKAGE (*) , {EOF }]
}

-------------------
lalr_state [274]: {
  [$START ::= packageDeclaration EOF (*) , {EOF }]
}

-------------------
-------- ACTION_TABLE --------
From state #0
 [term 0:REDUCE(with prod 3)] [term 3:SHIFT(to state 2)]
 [term 5:REDUCE(with prod 3)]
From state #1
 [term 0:SHIFT(to state 274)]
From state #2
 [term 65:SHIFT(to state 12)]
From state #3
 [term 0:REDUCE(with prod 2)] [term 5:SHIFT(to state 8)]
From state #4
 [term 0:REDUCE(with prod 4)] [term 4:REDUCE(with prod 4)]
 [term 5:REDUCE(with prod 4)]
From state #5
 [term 0:REDUCE(with prod 5)] [term 4:REDUCE(with prod 5)]
 [term 5:REDUCE(with prod 5)]
From state #6
 [term 0:REDUCE(with prod 6)] [term 4:REDUCE(with prod 6)]
 [term 5:REDUCE(with prod 6)]
From state #7
 [term 0:REDUCE(with prod 7)] [term 4:REDUCE(with prod 7)]
 [term 5:REDUCE(with prod 7)]
From state #8
 [term 65:SHIFT(to state 12)]
From state #9
 [term 10:SHIFT(to state 235)] [term 11:SHIFT(to state 237)]
 [term 12:SHIFT(to state 234)]
From state #10
 [term 8:SHIFT(to state 178)] [term 9:SHIFT(to state 175)]
 [term 51:SHIFT(to state 179)] [term 65:SHIFT(to state 12)]
From state #11
 [term 8:REDUCE(with prod 120)] [term 9:REDUCE(with prod 120)]
 [term 51:REDUCE(with prod 120)] [term 53:SHIFT(to state 13)]
 [term 65:REDUCE(with prod 120)]
From state #12
 [term 0:REDUCE(with prod 122)] [term 4:REDUCE(with prod 122)]
 [term 5:REDUCE(with prod 122)] [term 6:REDUCE(with prod 122)]
 [term 7:REDUCE(with prod 122)] [term 8:REDUCE(with prod 122)]
 [term 9:REDUCE(with prod 122)] [term 10:REDUCE(with prod 122)]
 [term 11:REDUCE(with prod 122)] [term 12:REDUCE(with prod 122)]
 [term 20:REDUCE(with prod 122)] [term 21:REDUCE(with prod 122)]
 [term 22:REDUCE(with prod 122)] [term 23:REDUCE(with prod 122)]
 [term 24:REDUCE(with prod 122)] [term 25:REDUCE(with prod 122)]
 [term 26:REDUCE(with prod 122)] [term 27:REDUCE(with prod 122)]
 [term 28:REDUCE(with prod 122)] [term 29:REDUCE(with prod 122)]
 [term 30:REDUCE(with prod 122)] [term 31:REDUCE(with prod 122)]
 [term 33:REDUCE(with prod 122)] [term 34:REDUCE(with prod 122)]
 [term 37:REDUCE(with prod 122)] [term 39:REDUCE(with prod 122)]
 [term 40:REDUCE(with prod 122)] [term 41:REDUCE(with prod 122)]
 [term 42:REDUCE(with prod 122)] [term 43:REDUCE(with prod 122)]
 [term 44:REDUCE(with prod 122)] [term 45:REDUCE(with prod 122)]
 [term 46:REDUCE(with prod 122)] [term 47:REDUCE(with prod 122)]
 [term 48:REDUCE(with prod 122)] [term 50:REDUCE(with prod 122)]
 [term 51:REDUCE(with prod 122)] [term 52:REDUCE(with prod 122)]
 [term 53:REDUCE(with prod 122)] [term 54:REDUCE(with prod 122)]
 [term 56:REDUCE(with prod 122)] [term 57:REDUCE(with prod 122)]
 [term 58:REDUCE(with prod 122)] [term 59:REDUCE(with prod 122)]
 [term 65:REDUCE(with prod 122)]
From state #13
 [term 56:SHIFT(to state 15)] [term 65:SHIFT(to state 12)]
From state #14
 [term 42:SHIFT(to state 33)] [term 56:SHIFT(to state 172)]
From state #15
 [term 10:REDUCE(with prod 44)] [term 11:REDUCE(with prod 44)]
 [term 12:REDUCE(with prod 44)] [term 24:REDUCE(with prod 44)]
 [term 44:SHIFT(to state 170)]
From state #16
 [term 24:SHIFT(to state 18)] [term 37:REDUCE(with prod 50)]
 [term 42:REDUCE(with prod 50)] [term 44:SHIFT(to state 19)]
 [term 45:REDUCE(with prod 50)] [term 46:REDUCE(with prod 50)]
 [term 56:REDUCE(with prod 50)] [term 58:REDUCE(with prod 50)]
From state #17
 [term 37:REDUCE(with prod 45)] [term 42:REDUCE(with prod 45)]
 [term 56:REDUCE(with prod 45)] [term 58:REDUCE(with prod 45)]
From state #18
 [term 13:SHIFT(to state 20)] [term 14:SHIFT(to state 25)]
 [term 15:SHIFT(to state 22)] [term 16:SHIFT(to state 28)]
 [term 17:SHIFT(to state 38)] [term 31:SHIFT(to state 47)]
 [term 35:SHIFT(to state 40)] [term 36:SHIFT(to state 49)]
 [term 38:SHIFT(to state 43)] [term 53:SHIFT(to state 45)]
 [term 60:SHIFT(to state 51)] [term 61:SHIFT(to state 52)]
 [term 62:SHIFT(to state 44)] [term 63:SHIFT(to state 42)]
 [term 64:SHIFT(to state 48)] [term 65:SHIFT(to state 12)]
From state #19
 [term 13:SHIFT(to state 20)] [term 14:SHIFT(to state 25)]
 [term 15:SHIFT(to state 22)] [term 16:SHIFT(to state 28)]
 [term 18:SHIFT(to state 29)] [term 65:SHIFT(to state 12)]
From state #20
 [term 53:REDUCE(with prod 105)] [term 55:REDUCE(with prod 105)]
From state #21
 [term 6:REDUCE(with prod 53)] [term 7:REDUCE(with prod 53)]
 [term 10:REDUCE(with prod 53)] [term 11:REDUCE(with prod 53)]
 [term 12:REDUCE(with prod 53)] [term 24:REDUCE(with prod 53)]
 [term 37:REDUCE(with prod 53)] [term 42:REDUCE(with prod 53)]
 [term 45:REDUCE(with prod 53)] [term 46:REDUCE(with prod 53)]
 [term 56:REDUCE(with prod 53)] [term 58:REDUCE(with prod 53)]
From state #22
 [term 53:REDUCE(with prod 107)] [term 55:REDUCE(with prod 107)]
From state #23
 [term 6:REDUCE(with prod 51)] [term 7:REDUCE(with prod 51)]
 [term 10:REDUCE(with prod 51)] [term 11:REDUCE(with prod 51)]
 [term 12:REDUCE(with prod 51)] [term 24:REDUCE(with prod 51)]
 [term 37:REDUCE(with prod 51)] [term 42:REDUCE(with prod 51)]
 [term 45:REDUCE(with prod 51)] [term 46:REDUCE(with prod 51)]
 [term 51:SHIFT(to state 137)] [term 56:REDUCE(with prod 51)]
 [term 58:REDUCE(with prod 51)]
From state #24
 [term 53:SHIFT(to state 166)]
From state #25
 [term 53:REDUCE(with prod 106)] [term 55:REDUCE(with prod 106)]
From state #26
 [term 0:REDUCE(with prod 120)] [term 4:REDUCE(with prod 120)]
 [term 5:REDUCE(with prod 120)] [term 6:REDUCE(with prod 120)]
 [term 7:REDUCE(with prod 120)] [term 8:REDUCE(with prod 120)]
 [term 9:REDUCE(with prod 120)] [term 10:REDUCE(with prod 120)]
 [term 11:REDUCE(with prod 120)] [term 12:REDUCE(with prod 120)]
 [term 20:REDUCE(with prod 120)] [term 21:REDUCE(with prod 120)]
 [term 22:REDUCE(with prod 120)] [term 23:REDUCE(with prod 120)]
 [term 24:REDUCE(with prod 120)] [term 25:REDUCE(with prod 120)]
 [term 26:REDUCE(with prod 120)] [term 27:REDUCE(with prod 120)]
 [term 28:REDUCE(with prod 120)] [term 29:REDUCE(with prod 120)]
 [term 30:REDUCE(with prod 120)] [term 31:REDUCE(with prod 120)]
 [term 33:REDUCE(with prod 120)] [term 34:REDUCE(with prod 120)]
 [term 37:REDUCE(with prod 120)] [term 39:REDUCE(with prod 120)]
 [term 40:REDUCE(with prod 120)] [term 41:REDUCE(with prod 120)]
 [term 42:REDUCE(with prod 120)] [term 43:REDUCE(with prod 120)]
 [term 44:REDUCE(with prod 120)] [term 45:REDUCE(with prod 120)]
 [term 46:REDUCE(with prod 120)] [term 47:REDUCE(with prod 120)]
 [term 48:REDUCE(with prod 120)] [term 50:REDUCE(with prod 120)]
 [term 51:REDUCE(with prod 120)] [term 52:REDUCE(with prod 120)]
 [term 53:REDUCE(with prod 120)] [term 54:REDUCE(with prod 120)]
 [term 56:REDUCE(with prod 120)] [term 57:REDUCE(with prod 120)]
 [term 58:REDUCE(with prod 120)] [term 59:REDUCE(with prod 120)]
From state #27
 [term 24:REDUCE(with prod 48)] [term 37:REDUCE(with prod 48)]
 [term 42:REDUCE(with prod 48)] [term 45:REDUCE(with prod 48)]
 [term 46:REDUCE(with prod 48)] [term 56:REDUCE(with prod 48)]
 [term 58:REDUCE(with prod 48)]
From state #28
 [term 53:REDUCE(with prod 108)] [term 55:REDUCE(with prod 108)]
From state #29
 [term 53:SHIFT(to state 31)]
From state #30
 [term 6:REDUCE(with prod 52)] [term 7:REDUCE(with prod 52)]
 [term 10:REDUCE(with prod 52)] [term 11:REDUCE(with prod 52)]
 [term 12:REDUCE(with prod 52)] [term 24:REDUCE(with prod 52)]
 [term 37:REDUCE(with prod 52)] [term 42:REDUCE(with prod 52)]
 [term 45:REDUCE(with prod 52)] [term 46:REDUCE(with prod 52)]
 [term 56:REDUCE(with prod 52)] [term 58:REDUCE(with prod 52)]
From state #31
 [term 65:SHIFT(to state 12)]
From state #32
 [term 42:SHIFT(to state 33)] [term 56:SHIFT(to state 34)]
From state #33
 [term 65:SHIFT(to state 12)]
From state #34
 [term 6:REDUCE(with prod 55)] [term 7:REDUCE(with prod 55)]
 [term 10:REDUCE(with prod 55)] [term 11:REDUCE(with prod 55)]
 [term 12:REDUCE(with prod 55)] [term 24:REDUCE(with prod 55)]
 [term 37:REDUCE(with prod 55)] [term 42:REDUCE(with prod 55)]
 [term 45:REDUCE(with prod 55)] [term 46:REDUCE(with prod 55)]
 [term 56:REDUCE(with prod 55)] [term 58:REDUCE(with prod 55)]
From state #35
 [term 37:REDUCE(with prod 46)] [term 42:REDUCE(with prod 46)]
 [term 56:REDUCE(with prod 46)] [term 58:REDUCE(with prod 46)]
From state #36
 [term 13:SHIFT(to state 20)] [term 14:SHIFT(to state 25)]
 [term 15:SHIFT(to state 22)] [term 16:SHIFT(to state 28)]
 [term 17:SHIFT(to state 38)] [term 31:SHIFT(to state 47)]
 [term 35:SHIFT(to state 40)] [term 36:SHIFT(to state 49)]
 [term 38:SHIFT(to state 43)] [term 53:SHIFT(to state 45)]
 [term 60:SHIFT(to state 51)] [term 61:SHIFT(to state 52)]
 [term 62:SHIFT(to state 44)] [term 63:SHIFT(to state 42)]
 [term 64:SHIFT(to state 48)] [term 65:SHIFT(to state 12)]
From state #37
 [term 0:REDUCE(with prod 56)] [term 4:REDUCE(with prod 56)]
 [term 5:REDUCE(with prod 56)] [term 6:REDUCE(with prod 56)]
 [term 7:REDUCE(with prod 56)] [term 8:REDUCE(with prod 56)]
 [term 9:REDUCE(with prod 56)] [term 10:REDUCE(with prod 56)]
 [term 11:REDUCE(with prod 56)] [term 12:REDUCE(with prod 56)]
 [term 20:REDUCE(with prod 56)] [term 21:REDUCE(with prod 56)]
 [term 22:REDUCE(with prod 56)] [term 23:REDUCE(with prod 56)]
 [term 24:REDUCE(with prod 56)] [term 25:REDUCE(with prod 56)]
 [term 26:REDUCE(with prod 56)] [term 27:REDUCE(with prod 56)]
 [term 28:REDUCE(with prod 56)] [term 29:REDUCE(with prod 56)]
 [term 30:REDUCE(with prod 56)] [term 31:REDUCE(with prod 56)]
 [term 33:REDUCE(with prod 56)] [term 34:REDUCE(with prod 56)]
 [term 37:REDUCE(with prod 56)] [term 39:REDUCE(with prod 56)]
 [term 40:REDUCE(with prod 56)] [term 41:REDUCE(with prod 56)]
 [term 42:REDUCE(with prod 56)] [term 43:REDUCE(with prod 56)]
 [term 44:REDUCE(with prod 56)] [term 45:REDUCE(with prod 56)]
 [term 46:REDUCE(with prod 56)] [term 47:REDUCE(with prod 56)]
 [term 50:REDUCE(with prod 56)] [term 52:REDUCE(with prod 56)]
 [term 53:REDUCE(with prod 56)] [term 54:REDUCE(with prod 56)]
 [term 56:REDUCE(with prod 56)] [term 57:REDUCE(with prod 56)]
 [term 58:REDUCE(with prod 56)] [term 59:REDUCE(with prod 56)]
From state #38
 [term 55:SHIFT(to state 163)]
From state #39
 [term 0:REDUCE(with prod 101)] [term 4:REDUCE(with prod 101)]
 [term 5:REDUCE(with prod 101)] [term 6:REDUCE(with prod 101)]
 [term 7:REDUCE(with prod 101)] [term 8:REDUCE(with prod 101)]
 [term 9:REDUCE(with prod 101)] [term 10:REDUCE(with prod 101)]
 [term 11:REDUCE(with prod 101)] [term 12:REDUCE(with prod 101)]
 [term 20:REDUCE(with prod 101)] [term 21:REDUCE(with prod 101)]
 [term 22:REDUCE(with prod 101)] [term 23:REDUCE(with prod 101)]
 [term 24:REDUCE(with prod 101)] [term 25:REDUCE(with prod 101)]
 [term 26:REDUCE(with prod 101)] [term 27:REDUCE(with prod 101)]
 [term 28:REDUCE(with prod 101)] [term 29:REDUCE(with prod 101)]
 [term 30:REDUCE(with prod 101)] [term 31:REDUCE(with prod 101)]
 [term 33:REDUCE(with prod 101)] [term 34:REDUCE(with prod 101)]
 [term 37:REDUCE(with prod 101)] [term 39:REDUCE(with prod 101)]
 [term 40:REDUCE(with prod 101)] [term 41:REDUCE(with prod 101)]
 [term 42:REDUCE(with prod 101)] [term 43:REDUCE(with prod 101)]
 [term 44:REDUCE(with prod 101)] [term 45:REDUCE(with prod 101)]
 [term 46:REDUCE(with prod 101)] [term 47:REDUCE(with prod 101)]
 [term 50:REDUCE(with prod 101)] [term 52:REDUCE(with prod 101)]
 [term 53:REDUCE(with prod 101)] [term 54:REDUCE(with prod 101)]
 [term 56:REDUCE(with prod 101)] [term 57:REDUCE(with prod 101)]
 [term 58:REDUCE(with prod 101)] [term 59:REDUCE(with prod 101)]
From state #40
 [term 13:SHIFT(to state 20)] [term 14:SHIFT(to state 25)]
 [term 15:SHIFT(to state 22)] [term 16:SHIFT(to state 28)]
 [term 17:SHIFT(to state 38)] [term 31:SHIFT(to state 47)]
 [term 35:SHIFT(to state 40)] [term 36:SHIFT(to state 49)]
 [term 38:SHIFT(to state 43)] [term 53:SHIFT(to state 45)]
 [term 60:SHIFT(to state 51)] [term 61:SHIFT(to state 52)]
 [term 62:SHIFT(to state 44)] [term 63:SHIFT(to state 42)]
 [term 64:SHIFT(to state 48)] [term 65:SHIFT(to state 12)]
From state #41
 [term 55:SHIFT(to state 151)]
From state #42
 [term 0:REDUCE(with prod 118)] [term 4:REDUCE(with prod 118)]
 [term 5:REDUCE(with prod 118)] [term 6:REDUCE(with prod 118)]
 [term 7:REDUCE(with prod 118)] [term 8:REDUCE(with prod 118)]
 [term 9:REDUCE(with prod 118)] [term 10:REDUCE(with prod 118)]
 [term 11:REDUCE(with prod 118)] [term 12:REDUCE(with prod 118)]
 [term 20:REDUCE(with prod 118)] [term 21:REDUCE(with prod 118)]
 [term 22:REDUCE(with prod 118)] [term 23:REDUCE(with prod 118)]
 [term 24:REDUCE(with prod 118)] [term 25:REDUCE(with prod 118)]
 [term 26:REDUCE(with prod 118)] [term 27:REDUCE(with prod 118)]
 [term 28:REDUCE(with prod 118)] [term 29:REDUCE(with prod 118)]
 [term 30:REDUCE(with prod 118)] [term 31:REDUCE(with prod 118)]
 [term 33:REDUCE(with prod 118)] [term 34:REDUCE(with prod 118)]
 [term 37:REDUCE(with prod 118)] [term 39:REDUCE(with prod 118)]
 [term 40:REDUCE(with prod 118)] [term 41:REDUCE(with prod 118)]
 [term 42:REDUCE(with prod 118)] [term 43:REDUCE(with prod 118)]
 [term 44:REDUCE(with prod 118)] [term 45:REDUCE(with prod 118)]
 [term 46:REDUCE(with prod 118)] [term 47:REDUCE(with prod 118)]
 [term 50:REDUCE(with prod 118)] [term 52:REDUCE(with prod 118)]
 [term 53:REDUCE(with prod 118)] [term 54:REDUCE(with prod 118)]
 [term 56:REDUCE(with prod 118)] [term 57:REDUCE(with prod 118)]
 [term 58:REDUCE(with prod 118)] [term 59:REDUCE(with prod 118)]
From state #43
 [term 13:SHIFT(to state 20)] [term 14:SHIFT(to state 25)]
 [term 15:SHIFT(to state 22)] [term 16:SHIFT(to state 28)]
 [term 17:SHIFT(to state 38)] [term 31:SHIFT(to state 47)]
 [term 35:SHIFT(to state 40)] [term 36:SHIFT(to state 49)]
 [term 38:SHIFT(to state 43)] [term 53:SHIFT(to state 45)]
 [term 60:SHIFT(to state 51)] [term 61:SHIFT(to state 52)]
 [term 62:SHIFT(to state 44)] [term 63:SHIFT(to state 42)]
 [term 64:SHIFT(to state 48)] [term 65:SHIFT(to state 12)]
From state #44
 [term 0:REDUCE(with prod 117)] [term 4:REDUCE(with prod 117)]
 [term 5:REDUCE(with prod 117)] [term 6:REDUCE(with prod 117)]
 [term 7:REDUCE(with prod 117)] [term 8:REDUCE(with prod 117)]
 [term 9:REDUCE(with prod 117)] [term 10:REDUCE(with prod 117)]
 [term 11:REDUCE(with prod 117)] [term 12:REDUCE(with prod 117)]
 [term 20:REDUCE(with prod 117)] [term 21:REDUCE(with prod 117)]
 [term 22:REDUCE(with prod 117)] [term 23:REDUCE(with prod 117)]
 [term 24:REDUCE(with prod 117)] [term 25:REDUCE(with prod 117)]
 [term 26:REDUCE(with prod 117)] [term 27:REDUCE(with prod 117)]
 [term 28:REDUCE(with prod 117)] [term 29:REDUCE(with prod 117)]
 [term 30:REDUCE(with prod 117)] [term 31:REDUCE(with prod 117)]
 [term 33:REDUCE(with prod 117)] [term 34:REDUCE(with prod 117)]
 [term 37:REDUCE(with prod 117)] [term 39:REDUCE(with prod 117)]
 [term 40:REDUCE(with prod 117)] [term 41:REDUCE(with prod 117)]
 [term 42:REDUCE(with prod 117)] [term 43:REDUCE(with prod 117)]
 [term 44:REDUCE(with prod 117)] [term 45:REDUCE(with prod 117)]
 [term 46:REDUCE(with prod 117)] [term 47:REDUCE(with prod 117)]
 [term 50:REDUCE(with prod 117)] [term 52:REDUCE(with prod 117)]
 [term 53:REDUCE(with prod 117)] [term 54:REDUCE(with prod 117)]
 [term 56:REDUCE(with prod 117)] [term 57:REDUCE(with prod 117)]
 [term 58:REDUCE(with prod 117)] [term 59:REDUCE(with prod 117)]
From state #45
 [term 13:SHIFT(to state 20)] [term 14:SHIFT(to state 25)]
 [term 15:SHIFT(to state 22)] [term 16:SHIFT(to state 28)]
 [term 17:SHIFT(to state 38)] [term 31:SHIFT(to state 47)]
 [term 35:SHIFT(to state 40)] [term 36:SHIFT(to state 49)]
 [term 38:SHIFT(to state 43)] [term 53:SHIFT(to state 45)]
 [term 60:SHIFT(to state 51)] [term 61:SHIFT(to state 52)]
 [term 62:SHIFT(to state 44)] [term 63:SHIFT(to state 42)]
 [term 64:SHIFT(to state 48)] [term 65:SHIFT(to state 12)]
From state #46
 [term 0:REDUCE(with prod 99)] [term 4:REDUCE(with prod 99)]
 [term 5:REDUCE(with prod 99)] [term 6:REDUCE(with prod 99)]
 [term 7:REDUCE(with prod 99)] [term 8:REDUCE(with prod 99)]
 [term 9:REDUCE(with prod 99)] [term 10:REDUCE(with prod 99)]
 [term 11:REDUCE(with prod 99)] [term 12:REDUCE(with prod 99)]
 [term 20:REDUCE(with prod 99)] [term 21:REDUCE(with prod 99)]
 [term 22:REDUCE(with prod 99)] [term 23:REDUCE(with prod 99)]
 [term 24:REDUCE(with prod 99)] [term 25:REDUCE(with prod 99)]
 [term 26:REDUCE(with prod 99)] [term 27:REDUCE(with prod 99)]
 [term 28:REDUCE(with prod 99)] [term 29:REDUCE(with prod 99)]
 [term 30:REDUCE(with prod 99)] [term 31:REDUCE(with prod 99)]
 [term 33:REDUCE(with prod 99)] [term 34:REDUCE(with prod 99)]
 [term 37:REDUCE(with prod 99)] [term 39:REDUCE(with prod 99)]
 [term 40:REDUCE(with prod 99)] [term 41:REDUCE(with prod 99)]
 [term 42:REDUCE(with prod 99)] [term 43:REDUCE(with prod 99)]
 [term 44:REDUCE(with prod 99)] [term 45:REDUCE(with prod 99)]
 [term 46:REDUCE(with prod 99)] [term 47:REDUCE(with prod 99)]
 [term 50:REDUCE(with prod 99)] [term 52:REDUCE(with prod 99)]
 [term 53:REDUCE(with prod 99)] [term 54:REDUCE(with prod 99)]
 [term 56:REDUCE(with prod 99)] [term 57:REDUCE(with prod 99)]
 [term 58:REDUCE(with prod 99)] [term 59:REDUCE(with prod 99)]
From state #47
 [term 13:SHIFT(to state 20)] [term 14:SHIFT(to state 25)]
 [term 15:SHIFT(to state 22)] [term 16:SHIFT(to state 28)]
 [term 17:SHIFT(to state 38)] [term 31:SHIFT(to state 47)]
 [term 35:SHIFT(to state 40)] [term 36:SHIFT(to state 49)]
 [term 38:SHIFT(to state 43)] [term 53:SHIFT(to state 45)]
 [term 60:SHIFT(to state 51)] [term 61:SHIFT(to state 52)]
 [term 62:SHIFT(to state 44)] [term 63:SHIFT(to state 42)]
 [term 64:SHIFT(to state 48)] [term 65:SHIFT(to state 12)]
From state #48
 [term 0:REDUCE(with prod 119)] [term 4:REDUCE(with prod 119)]
 [term 5:REDUCE(with prod 119)] [term 6:REDUCE(with prod 119)]
 [term 7:REDUCE(with prod 119)] [term 8:REDUCE(with prod 119)]
 [term 9:REDUCE(with prod 119)] [term 10:REDUCE(with prod 119)]
 [term 11:REDUCE(with prod 119)] [term 12:REDUCE(with prod 119)]
 [term 20:REDUCE(with prod 119)] [term 21:REDUCE(with prod 119)]
 [term 22:REDUCE(with prod 119)] [term 23:REDUCE(with prod 119)]
 [term 24:REDUCE(with prod 119)] [term 25:REDUCE(with prod 119)]
 [term 26:REDUCE(with prod 119)] [term 27:REDUCE(with prod 119)]
 [term 28:REDUCE(with prod 119)] [term 29:REDUCE(with prod 119)]
 [term 30:REDUCE(with prod 119)] [term 31:REDUCE(with prod 119)]
 [term 33:REDUCE(with prod 119)] [term 34:REDUCE(with prod 119)]
 [term 37:REDUCE(with prod 119)] [term 39:REDUCE(with prod 119)]
 [term 40:REDUCE(with prod 119)] [term 41:REDUCE(with prod 119)]
 [term 42:REDUCE(with prod 119)] [term 43:REDUCE(with prod 119)]
 [term 44:REDUCE(with prod 119)] [term 45:REDUCE(with prod 119)]
 [term 46:REDUCE(with prod 119)] [term 47:REDUCE(with prod 119)]
 [term 50:REDUCE(with prod 119)] [term 52:REDUCE(with prod 119)]
 [term 53:REDUCE(with prod 119)] [term 54:REDUCE(with prod 119)]
 [term 56:REDUCE(with prod 119)] [term 57:REDUCE(with prod 119)]
 [term 58:REDUCE(with prod 119)] [term 59:REDUCE(with prod 119)]
From state #49
 [term 65:SHIFT(to state 12)]
From state #50
 [term 0:REDUCE(with prod 97)] [term 4:REDUCE(with prod 97)]
 [term 5:REDUCE(with prod 97)] [term 6:REDUCE(with prod 97)]
 [term 7:REDUCE(with prod 97)] [term 8:REDUCE(with prod 97)]
 [term 9:REDUCE(with prod 97)] [term 10:REDUCE(with prod 97)]
 [term 11:REDUCE(with prod 97)] [term 12:REDUCE(with prod 97)]
 [term 20:REDUCE(with prod 97)] [term 21:REDUCE(with prod 97)]
 [term 22:REDUCE(with prod 97)] [term 23:REDUCE(with prod 97)]
 [term 24:REDUCE(with prod 97)] [term 25:REDUCE(with prod 97)]
 [term 26:REDUCE(with prod 97)] [term 27:REDUCE(with prod 97)]
 [term 28:REDUCE(with prod 97)] [term 29:REDUCE(with prod 97)]
 [term 30:REDUCE(with prod 97)] [term 31:REDUCE(with prod 97)]
 [term 33:REDUCE(with prod 97)] [term 34:REDUCE(with prod 97)]
 [term 37:REDUCE(with prod 97)] [term 39:REDUCE(with prod 97)]
 [term 40:REDUCE(with prod 97)] [term 41:REDUCE(with prod 97)]
 [term 42:REDUCE(with prod 97)] [term 43:REDUCE(with prod 97)]
 [term 44:REDUCE(with prod 97)] [term 45:REDUCE(with prod 97)]
 [term 46:REDUCE(with prod 97)] [term 47:REDUCE(with prod 97)]
 [term 48:SHIFT(to state 78)] [term 50:REDUCE(with prod 97)]
 [term 51:SHIFT(to state 137)] [term 52:REDUCE(with prod 97)]
 [term 53:REDUCE(with prod 97)] [term 54:REDUCE(with prod 97)]
 [term 56:REDUCE(with prod 97)] [term 57:REDUCE(with prod 97)]
 [term 58:REDUCE(with prod 97)] [term 59:REDUCE(with prod 97)]
From state #51
 [term 0:REDUCE(with prod 115)] [term 4:REDUCE(with prod 115)]
 [term 5:REDUCE(with prod 115)] [term 6:REDUCE(with prod 115)]
 [term 7:REDUCE(with prod 115)] [term 8:REDUCE(with prod 115)]
 [term 9:REDUCE(with prod 115)] [term 10:REDUCE(with prod 115)]
 [term 11:REDUCE(with prod 115)] [term 12:REDUCE(with prod 115)]
 [term 20:REDUCE(with prod 115)] [term 21:REDUCE(with prod 115)]
 [term 22:REDUCE(with prod 115)] [term 23:REDUCE(with prod 115)]
 [term 24:REDUCE(with prod 115)] [term 25:REDUCE(with prod 115)]
 [term 26:REDUCE(with prod 115)] [term 27:REDUCE(with prod 115)]
 [term 28:REDUCE(with prod 115)] [term 29:REDUCE(with prod 115)]
 [term 30:REDUCE(with prod 115)] [term 31:REDUCE(with prod 115)]
 [term 33:REDUCE(with prod 115)] [term 34:REDUCE(with prod 115)]
 [term 37:REDUCE(with prod 115)] [term 39:REDUCE(with prod 115)]
 [term 40:REDUCE(with prod 115)] [term 41:REDUCE(with prod 115)]
 [term 42:REDUCE(with prod 115)] [term 43:REDUCE(with prod 115)]
 [term 44:REDUCE(with prod 115)] [term 45:REDUCE(with prod 115)]
 [term 46:REDUCE(with prod 115)] [term 47:REDUCE(with prod 115)]
 [term 50:REDUCE(with prod 115)] [term 52:REDUCE(with prod 115)]
 [term 53:REDUCE(with prod 115)] [term 54:REDUCE(with prod 115)]
 [term 56:REDUCE(with prod 115)] [term 57:REDUCE(with prod 115)]
 [term 58:REDUCE(with prod 115)] [term 59:REDUCE(with prod 115)]
From state #52
 [term 0:REDUCE(with prod 116)] [term 4:REDUCE(with prod 116)]
 [term 5:REDUCE(with prod 116)] [term 6:REDUCE(with prod 116)]
 [term 7:REDUCE(with prod 116)] [term 8:REDUCE(with prod 116)]
 [term 9:REDUCE(with prod 116)] [term 10:REDUCE(with prod 116)]
 [term 11:REDUCE(with prod 116)] [term 12:REDUCE(with prod 116)]
 [term 20:REDUCE(with prod 116)] [term 21:REDUCE(with prod 116)]
 [term 22:REDUCE(with prod 116)] [term 23:REDUCE(with prod 116)]
 [term 24:REDUCE(with prod 116)] [term 25:REDUCE(with prod 116)]
 [term 26:REDUCE(with prod 116)] [term 27:REDUCE(with prod 116)]
 [term 28:REDUCE(with prod 116)] [term 29:REDUCE(with prod 116)]
 [term 30:REDUCE(with prod 116)] [term 31:REDUCE(with prod 116)]
 [term 33:REDUCE(with prod 116)] [term 34:REDUCE(with prod 116)]
 [term 37:REDUCE(with prod 116)] [term 39:REDUCE(with prod 116)]
 [term 40:REDUCE(with prod 116)] [term 41:REDUCE(with prod 116)]
 [term 42:REDUCE(with prod 116)] [term 43:REDUCE(with prod 116)]
 [term 44:REDUCE(with prod 116)] [term 45:REDUCE(with prod 116)]
 [term 46:REDUCE(with prod 116)] [term 47:REDUCE(with prod 116)]
 [term 50:REDUCE(with prod 116)] [term 52:REDUCE(with prod 116)]
 [term 53:REDUCE(with prod 116)] [term 54:REDUCE(with prod 116)]
 [term 56:REDUCE(with prod 116)] [term 57:REDUCE(with prod 116)]
 [term 58:REDUCE(with prod 116)] [term 59:REDUCE(with prod 116)]
From state #53
 [term 20:SHIFT(to state 63)] [term 21:SHIFT(to state 56)]
 [term 22:SHIFT(to state 60)] [term 23:SHIFT(to state 74)]
 [term 24:REDUCE(with prod 47)] [term 25:SHIFT(to state 58)]
 [term 26:SHIFT(to state 57)] [term 27:SHIFT(to state 64)]
 [term 28:SHIFT(to state 65)] [term 29:SHIFT(to state 70)]
 [term 30:SHIFT(to state 59)] [term 31:SHIFT(to state 71)]
 [term 33:SHIFT(to state 55)] [term 34:SHIFT(to state 68)]
 [term 37:REDUCE(with prod 47)] [term 42:REDUCE(with prod 47)]
 [term 43:SHIFT(to state 72)] [term 45:REDUCE(with prod 47)]
 [term 46:REDUCE(with prod 47)] [term 47:SHIFT(to state 62)]
 [term 52:SHIFT(to state 61)] [term 53:SHIFT(to state 67)]
 [term 54:SHIFT(to state 69)] [term 56:REDUCE(with prod 47)]
 [term 58:REDUCE(with prod 47)] [term 59:SHIFT(to state 66)]
From state #54
 [term 0:REDUCE(with prod 100)] [term 4:REDUCE(with prod 100)]
 [term 5:REDUCE(with prod 100)] [term 6:REDUCE(with prod 100)]
 [term 7:REDUCE(with prod 100)] [term 8:REDUCE(with prod 100)]
 [term 9:REDUCE(with prod 100)] [term 10:REDUCE(with prod 100)]
 [term 11:REDUCE(with prod 100)] [term 12:REDUCE(with prod 100)]
 [term 20:REDUCE(with prod 100)] [term 21:REDUCE(with prod 100)]
 [term 22:REDUCE(with prod 100)] [term 23:REDUCE(with prod 100)]
 [term 24:REDUCE(with prod 100)] [term 25:REDUCE(with prod 100)]
 [term 26:REDUCE(with prod 100)] [term 27:REDUCE(with prod 100)]
 [term 28:REDUCE(with prod 100)] [term 29:REDUCE(with prod 100)]
 [term 30:REDUCE(with prod 100)] [term 31:REDUCE(with prod 100)]
 [term 33:REDUCE(with prod 100)] [term 34:REDUCE(with prod 100)]
 [term 37:REDUCE(with prod 100)] [term 39:REDUCE(with prod 100)]
 [term 40:REDUCE(with prod 100)] [term 41:REDUCE(with prod 100)]
 [term 42:REDUCE(with prod 100)] [term 43:REDUCE(with prod 100)]
 [term 44:REDUCE(with prod 100)] [term 45:REDUCE(with prod 100)]
 [term 46:REDUCE(with prod 100)] [term 47:REDUCE(with prod 100)]
 [term 50:REDUCE(with prod 100)] [term 52:REDUCE(with prod 100)]
 [term 53:REDUCE(with prod 100)] [term 54:REDUCE(with prod 100)]
 [term 56:REDUCE(with prod 100)] [term 57:REDUCE(with prod 100)]
 [term 58:REDUCE(with prod 100)] [term 59:REDUCE(with prod 100)]
From state #55
 [term 13:SHIFT(to state 20)] [term 14:SHIFT(to state 25)]
 [term 15:SHIFT(to state 22)] [term 16:SHIFT(to state 28)]
 [term 17:SHIFT(to state 38)] [term 31:SHIFT(to state 47)]
 [term 35:SHIFT(to state 40)] [term 36:SHIFT(to state 49)]
 [term 38:SHIFT(to state 43)] [term 53:SHIFT(to state 45)]
 [term 60:SHIFT(to state 51)] [term 61:SHIFT(to state 52)]
 [term 62:SHIFT(to state 44)] [term 63:SHIFT(to state 42)]
 [term 64:SHIFT(to state 48)] [term 65:SHIFT(to state 12)]
From state #56
 [term 13:SHIFT(to state 20)] [term 14:SHIFT(to state 25)]
 [term 15:SHIFT(to state 22)] [term 16:SHIFT(to state 28)]
 [term 17:SHIFT(to state 38)] [term 31:SHIFT(to state 47)]
 [term 35:SHIFT(to state 40)] [term 36:SHIFT(to state 49)]
 [term 38:SHIFT(to state 43)] [term 53:SHIFT(to state 45)]
 [term 60:SHIFT(to state 51)] [term 61:SHIFT(to state 52)]
 [term 62:SHIFT(to state 44)] [term 63:SHIFT(to state 42)]
 [term 64:SHIFT(to state 48)] [term 65:SHIFT(to state 12)]
From state #57
 [term 13:SHIFT(to state 20)] [term 14:SHIFT(to state 25)]
 [term 15:SHIFT(to state 22)] [term 16:SHIFT(to state 28)]
 [term 17:SHIFT(to state 38)] [term 31:SHIFT(to state 47)]
 [term 35:SHIFT(to state 40)] [term 36:SHIFT(to state 49)]
 [term 38:SHIFT(to state 43)] [term 53:SHIFT(to state 45)]
 [term 60:SHIFT(to state 51)] [term 61:SHIFT(to state 52)]
 [term 62:SHIFT(to state 44)] [term 63:SHIFT(to state 42)]
 [term 64:SHIFT(to state 48)] [term 65:SHIFT(to state 12)]
From state #58
 [term 13:SHIFT(to state 20)] [term 14:SHIFT(to state 25)]
 [term 15:SHIFT(to state 22)] [term 16:SHIFT(to state 28)]
 [term 17:SHIFT(to state 38)] [term 31:SHIFT(to state 47)]
 [term 35:SHIFT(to state 40)] [term 36:SHIFT(to state 49)]
 [term 38:SHIFT(to state 43)] [term 53:SHIFT(to state 45)]
 [term 60:SHIFT(to state 51)] [term 61:SHIFT(to state 52)]
 [term 62:SHIFT(to state 44)] [term 63:SHIFT(to state 42)]
 [term 64:SHIFT(to state 48)] [term 65:SHIFT(to state 12)]
From state #59
 [term 13:SHIFT(to state 20)] [term 14:SHIFT(to state 25)]
 [term 15:SHIFT(to state 22)] [term 16:SHIFT(to state 28)]
 [term 17:SHIFT(to state 38)] [term 31:SHIFT(to state 47)]
 [term 35:SHIFT(to state 40)] [term 36:SHIFT(to state 49)]
 [term 38:SHIFT(to state 43)] [term 53:SHIFT(to state 45)]
 [term 60:SHIFT(to state 51)] [term 61:SHIFT(to state 52)]
 [term 62:SHIFT(to state 44)] [term 63:SHIFT(to state 42)]
 [term 64:SHIFT(to state 48)] [term 65:SHIFT(to state 12)]
From state #60
 [term 13:SHIFT(to state 20)] [term 14:SHIFT(to state 25)]
 [term 15:SHIFT(to state 22)] [term 16:SHIFT(to state 28)]
 [term 17:SHIFT(to state 38)] [term 31:SHIFT(to state 47)]
 [term 35:SHIFT(to state 40)] [term 36:SHIFT(to state 49)]
 [term 38:SHIFT(to state 43)] [term 53:SHIFT(to state 45)]
 [term 60:SHIFT(to state 51)] [term 61:SHIFT(to state 52)]
 [term 62:SHIFT(to state 44)] [term 63:SHIFT(to state 42)]
 [term 64:SHIFT(to state 48)] [term 65:SHIFT(to state 12)]
From state #61
 [term 65:SHIFT(to state 12)]
From state #62
 [term 65:SHIFT(to state 12)]
From state #63
 [term 13:SHIFT(to state 20)] [term 14:SHIFT(to state 25)]
 [term 15:SHIFT(to state 22)] [term 16:SHIFT(to state 28)]
 [term 17:SHIFT(to state 38)] [term 31:SHIFT(to state 47)]
 [term 35:SHIFT(to state 40)] [term 36:SHIFT(to state 49)]
 [term 38:SHIFT(to state 43)] [term 53:SHIFT(to state 45)]
 [term 60:SHIFT(to state 51)] [term 61:SHIFT(to state 52)]
 [term 62:SHIFT(to state 44)] [term 63:SHIFT(to state 42)]
 [term 64:SHIFT(to state 48)] [term 65:SHIFT(to state 12)]
From state #64
 [term 13:SHIFT(to state 20)] [term 14:SHIFT(to state 25)]
 [term 15:SHIFT(to state 22)] [term 16:SHIFT(to state 28)]
 [term 17:SHIFT(to state 38)] [term 31:SHIFT(to state 47)]
 [term 35:SHIFT(to state 40)] [term 36:SHIFT(to state 49)]
 [term 38:SHIFT(to state 43)] [term 53:SHIFT(to state 45)]
 [term 60:SHIFT(to state 51)] [term 61:SHIFT(to state 52)]
 [term 62:SHIFT(to state 44)] [term 63:SHIFT(to state 42)]
 [term 64:SHIFT(to state 48)] [term 65:SHIFT(to state 12)]
From state #65
 [term 13:SHIFT(to state 20)] [term 14:SHIFT(to state 25)]
 [term 15:SHIFT(to state 22)] [term 16:SHIFT(to state 28)]
 [term 17:SHIFT(to state 38)] [term 31:SHIFT(to state 47)]
 [term 35:SHIFT(to state 40)] [term 36:SHIFT(to state 49)]
 [term 38:SHIFT(to state 43)] [term 53:SHIFT(to state 45)]
 [term 60:SHIFT(to state 51)] [term 61:SHIFT(to state 52)]
 [term 62:SHIFT(to state 44)] [term 63:SHIFT(to state 42)]
 [term 64:SHIFT(to state 48)] [term 65:SHIFT(to state 12)]
From state #66
 [term 19:SHIFT(to state 99)] [term 65:SHIFT(to state 12)]
From state #67
 [term 13:SHIFT(to state 20)] [term 14:SHIFT(to state 25)]
 [term 15:SHIFT(to state 22)] [term 16:SHIFT(to state 28)]
 [term 17:SHIFT(to state 38)] [term 31:SHIFT(to state 47)]
 [term 35:SHIFT(to state 40)] [term 36:SHIFT(to state 49)]
 [term 38:SHIFT(to state 43)] [term 53:SHIFT(to state 45)]
 [term 56:REDUCE(with prod 88)] [term 60:SHIFT(to state 51)]
 [term 61:SHIFT(to state 52)] [term 62:SHIFT(to state 44)]
 [term 63:SHIFT(to state 42)] [term 64:SHIFT(to state 48)]
 [term 65:SHIFT(to state 12)]
From state #68
 [term 13:SHIFT(to state 20)] [term 14:SHIFT(to state 25)]
 [term 15:SHIFT(to state 22)] [term 16:SHIFT(to state 28)]
 [term 17:SHIFT(to state 38)] [term 31:SHIFT(to state 47)]
 [term 35:SHIFT(to state 40)] [term 36:SHIFT(to state 49)]
 [term 38:SHIFT(to state 43)] [term 53:SHIFT(to state 45)]
 [term 60:SHIFT(to state 51)] [term 61:SHIFT(to state 52)]
 [term 62:SHIFT(to state 44)] [term 63:SHIFT(to state 42)]
 [term 64:SHIFT(to state 48)] [term 65:SHIFT(to state 12)]
From state #69
 [term 13:SHIFT(to state 20)] [term 14:SHIFT(to state 25)]
 [term 15:SHIFT(to state 22)] [term 16:SHIFT(to state 28)]
 [term 17:SHIFT(to state 38)] [term 31:SHIFT(to state 47)]
 [term 35:SHIFT(to state 40)] [term 36:SHIFT(to state 49)]
 [term 38:SHIFT(to state 43)] [term 53:SHIFT(to state 45)]
 [term 60:SHIFT(to state 51)] [term 61:SHIFT(to state 52)]
 [term 62:SHIFT(to state 44)] [term 63:SHIFT(to state 42)]
 [term 64:SHIFT(to state 48)] [term 65:SHIFT(to state 12)]
From state #70
 [term 13:SHIFT(to state 20)] [term 14:SHIFT(to state 25)]
 [term 15:SHIFT(to state 22)] [term 16:SHIFT(to state 28)]
 [term 17:SHIFT(to state 38)] [term 31:SHIFT(to state 47)]
 [term 35:SHIFT(to state 40)] [term 36:SHIFT(to state 49)]
 [term 38:SHIFT(to state 43)] [term 53:SHIFT(to state 45)]
 [term 60:SHIFT(to state 51)] [term 61:SHIFT(to state 52)]
 [term 62:SHIFT(to state 44)] [term 63:SHIFT(to state 42)]
 [term 64:SHIFT(to state 48)] [term 65:SHIFT(to state 12)]
From state #71
 [term 13:SHIFT(to state 20)] [term 14:SHIFT(to state 25)]
 [term 15:SHIFT(to state 22)] [term 16:SHIFT(to state 28)]
 [term 17:SHIFT(to state 38)] [term 31:SHIFT(to state 47)]
 [term 35:SHIFT(to state 40)] [term 36:SHIFT(to state 49)]
 [term 38:SHIFT(to state 43)] [term 53:SHIFT(to state 45)]
 [term 60:SHIFT(to state 51)] [term 61:SHIFT(to state 52)]
 [term 62:SHIFT(to state 44)] [term 63:SHIFT(to state 42)]
 [term 64:SHIFT(to state 48)] [term 65:SHIFT(to state 12)]
From state #72
 [term 65:SHIFT(to state 12)]
From state #73
 [term 13:SHIFT(to state 20)] [term 14:SHIFT(to state 25)]
 [term 15:SHIFT(to state 22)] [term 16:SHIFT(to state 28)]
 [term 17:SHIFT(to state 38)] [term 31:SHIFT(to state 47)]
 [term 35:SHIFT(to state 40)] [term 36:SHIFT(to state 49)]
 [term 38:SHIFT(to state 43)] [term 53:SHIFT(to state 45)]
 [term 60:SHIFT(to state 51)] [term 61:SHIFT(to state 52)]
 [term 62:SHIFT(to state 44)] [term 63:SHIFT(to state 42)]
 [term 64:SHIFT(to state 48)] [term 65:SHIFT(to state 12)]
From state #74
 [term 13:SHIFT(to state 20)] [term 14:SHIFT(to state 25)]
 [term 15:SHIFT(to state 22)] [term 16:SHIFT(to state 28)]
 [term 17:SHIFT(to state 38)] [term 31:SHIFT(to state 47)]
 [term 35:SHIFT(to state 40)] [term 36:SHIFT(to state 49)]
 [term 38:SHIFT(to state 43)] [term 53:SHIFT(to state 45)]
 [term 60:SHIFT(to state 51)] [term 61:SHIFT(to state 52)]
 [term 62:SHIFT(to state 44)] [term 63:SHIFT(to state 42)]
 [term 64:SHIFT(to state 48)] [term 65:SHIFT(to state 12)]
From state #75
 [term 0:REDUCE(with prod 81)] [term 4:REDUCE(with prod 81)]
 [term 5:REDUCE(with prod 81)] [term 6:REDUCE(with prod 81)]
 [term 7:REDUCE(with prod 81)] [term 8:REDUCE(with prod 81)]
 [term 9:REDUCE(with prod 81)] [term 10:REDUCE(with prod 81)]
 [term 11:REDUCE(with prod 81)] [term 12:REDUCE(with prod 81)]
 [term 20:REDUCE(with prod 81)] [term 21:REDUCE(with prod 81)]
 [term 22:REDUCE(with prod 81)] [term 23:REDUCE(with prod 81)]
 [term 24:SHIFT(to state 73)] [term 25:SHIFT(to state 58)]
 [term 26:SHIFT(to state 57)] [term 27:SHIFT(to state 64)]
 [term 28:SHIFT(to state 65)] [term 29:SHIFT(to state 70)]
 [term 30:SHIFT(to state 59)] [term 31:SHIFT(to state 71)]
 [term 33:SHIFT(to state 55)] [term 34:SHIFT(to state 68)]
 [term 37:REDUCE(with prod 81)] [term 39:REDUCE(with prod 81)]
 [term 40:REDUCE(with prod 81)] [term 41:REDUCE(with prod 81)]
 [term 42:REDUCE(with prod 81)] [term 43:SHIFT(to state 72)]
 [term 44:REDUCE(with prod 81)] [term 45:REDUCE(with prod 81)]
 [term 46:REDUCE(with prod 81)] [term 47:REDUCE(with prod 81)]
 [term 50:REDUCE(with prod 81)] [term 52:REDUCE(with prod 81)]
 [term 53:SHIFT(to state 67)] [term 54:SHIFT(to state 69)]
 [term 56:REDUCE(with prod 81)] [term 57:REDUCE(with prod 81)]
 [term 58:REDUCE(with prod 81)] [term 59:SHIFT(to state 66)]
From state #76
 [term 0:REDUCE(with prod 77)] [term 4:REDUCE(with prod 77)]
 [term 5:REDUCE(with prod 77)] [term 6:REDUCE(with prod 77)]
 [term 7:REDUCE(with prod 77)] [term 8:REDUCE(with prod 77)]
 [term 9:REDUCE(with prod 77)] [term 10:REDUCE(with prod 77)]
 [term 11:REDUCE(with prod 77)] [term 12:REDUCE(with prod 77)]
 [term 20:REDUCE(with prod 77)] [term 21:REDUCE(with prod 77)]
 [term 22:REDUCE(with prod 77)] [term 23:REDUCE(with prod 77)]
 [term 24:REDUCE(with prod 77)] [term 25:REDUCE(with prod 77)]
 [term 26:SHIFT(to state 57)] [term 27:SHIFT(to state 64)]
 [term 28:SHIFT(to state 65)] [term 29:SHIFT(to state 70)]
 [term 30:SHIFT(to state 59)] [term 31:SHIFT(to state 71)]
 [term 33:SHIFT(to state 55)] [term 34:SHIFT(to state 68)]
 [term 37:REDUCE(with prod 77)] [term 39:REDUCE(with prod 77)]
 [term 40:REDUCE(with prod 77)] [term 41:REDUCE(with prod 77)]
 [term 42:REDUCE(with prod 77)] [term 43:SHIFT(to state 72)]
 [term 44:REDUCE(with prod 77)] [term 45:REDUCE(with prod 77)]
 [term 46:REDUCE(with prod 77)] [term 47:REDUCE(with prod 77)]
 [term 50:REDUCE(with prod 77)] [term 52:REDUCE(with prod 77)]
 [term 53:SHIFT(to state 67)] [term 54:SHIFT(to state 69)]
 [term 56:REDUCE(with prod 77)] [term 57:REDUCE(with prod 77)]
 [term 58:REDUCE(with prod 77)] [term 59:SHIFT(to state 66)]
From state #77
 [term 0:REDUCE(with prod 97)] [term 4:REDUCE(with prod 97)]
 [term 5:REDUCE(with prod 97)] [term 6:REDUCE(with prod 97)]
 [term 7:REDUCE(with prod 97)] [term 8:REDUCE(with prod 97)]
 [term 9:REDUCE(with prod 97)] [term 10:REDUCE(with prod 97)]
 [term 11:REDUCE(with prod 97)] [term 12:REDUCE(with prod 97)]
 [term 20:REDUCE(with prod 97)] [term 21:REDUCE(with prod 97)]
 [term 22:REDUCE(with prod 97)] [term 23:REDUCE(with prod 97)]
 [term 24:REDUCE(with prod 97)] [term 25:REDUCE(with prod 97)]
 [term 26:REDUCE(with prod 97)] [term 27:REDUCE(with prod 97)]
 [term 28:REDUCE(with prod 97)] [term 29:REDUCE(with prod 97)]
 [term 30:REDUCE(with prod 97)] [term 31:REDUCE(with prod 97)]
 [term 33:REDUCE(with prod 97)] [term 34:REDUCE(with prod 97)]
 [term 37:REDUCE(with prod 97)] [term 39:REDUCE(with prod 97)]
 [term 40:REDUCE(with prod 97)] [term 41:REDUCE(with prod 97)]
 [term 42:REDUCE(with prod 97)] [term 43:REDUCE(with prod 97)]
 [term 44:REDUCE(with prod 97)] [term 45:REDUCE(with prod 97)]
 [term 46:REDUCE(with prod 97)] [term 47:REDUCE(with prod 97)]
 [term 48:SHIFT(to state 78)] [term 50:REDUCE(with prod 97)]
 [term 52:REDUCE(with prod 97)] [term 53:REDUCE(with prod 97)]
 [term 54:REDUCE(with prod 97)] [term 56:REDUCE(with prod 97)]
 [term 57:REDUCE(with prod 97)] [term 58:REDUCE(with prod 97)]
 [term 59:REDUCE(with prod 97)]
From state #78
 [term 10:SHIFT(to state 80)]
From state #79
 [term 0:REDUCE(with prod 59)] [term 4:REDUCE(with prod 59)]
 [term 5:REDUCE(with prod 59)] [term 6:REDUCE(with prod 59)]
 [term 7:REDUCE(with prod 59)] [term 8:REDUCE(with prod 59)]
 [term 9:REDUCE(with prod 59)] [term 10:REDUCE(with prod 59)]
 [term 11:REDUCE(with prod 59)] [term 12:REDUCE(with prod 59)]
 [term 20:REDUCE(with prod 59)] [term 21:REDUCE(with prod 59)]
 [term 22:REDUCE(with prod 59)] [term 23:REDUCE(with prod 59)]
 [term 24:REDUCE(with prod 59)] [term 25:REDUCE(with prod 59)]
 [term 26:REDUCE(with prod 59)] [term 27:REDUCE(with prod 59)]
 [term 28:REDUCE(with prod 59)] [term 29:REDUCE(with prod 59)]
 [term 30:REDUCE(with prod 59)] [term 31:REDUCE(with prod 59)]
 [term 33:REDUCE(with prod 59)] [term 34:REDUCE(with prod 59)]
 [term 37:REDUCE(with prod 59)] [term 39:REDUCE(with prod 59)]
 [term 40:REDUCE(with prod 59)] [term 41:REDUCE(with prod 59)]
 [term 42:REDUCE(with prod 59)] [term 43:REDUCE(with prod 59)]
 [term 44:REDUCE(with prod 59)] [term 45:REDUCE(with prod 59)]
 [term 46:REDUCE(with prod 59)] [term 47:REDUCE(with prod 59)]
 [term 50:REDUCE(with prod 59)] [term 52:REDUCE(with prod 59)]
 [term 53:REDUCE(with prod 59)] [term 54:REDUCE(with prod 59)]
 [term 56:REDUCE(with prod 59)] [term 57:REDUCE(with prod 59)]
 [term 58:REDUCE(with prod 59)] [term 59:REDUCE(with prod 59)]
From state #80
 [term 0:REDUCE(with prod 98)] [term 4:REDUCE(with prod 98)]
 [term 5:REDUCE(with prod 98)] [term 6:REDUCE(with prod 98)]
 [term 7:REDUCE(with prod 98)] [term 8:REDUCE(with prod 98)]
 [term 9:REDUCE(with prod 98)] [term 10:REDUCE(with prod 98)]
 [term 11:REDUCE(with prod 98)] [term 12:REDUCE(with prod 98)]
 [term 20:REDUCE(with prod 98)] [term 21:REDUCE(with prod 98)]
 [term 22:REDUCE(with prod 98)] [term 23:REDUCE(with prod 98)]
 [term 24:REDUCE(with prod 98)] [term 25:REDUCE(with prod 98)]
 [term 26:REDUCE(with prod 98)] [term 27:REDUCE(with prod 98)]
 [term 28:REDUCE(with prod 98)] [term 29:REDUCE(with prod 98)]
 [term 30:REDUCE(with prod 98)] [term 31:REDUCE(with prod 98)]
 [term 33:REDUCE(with prod 98)] [term 34:REDUCE(with prod 98)]
 [term 37:REDUCE(with prod 98)] [term 39:REDUCE(with prod 98)]
 [term 40:REDUCE(with prod 98)] [term 41:REDUCE(with prod 98)]
 [term 42:REDUCE(with prod 98)] [term 43:REDUCE(with prod 98)]
 [term 44:REDUCE(with prod 98)] [term 45:REDUCE(with prod 98)]
 [term 46:REDUCE(with prod 98)] [term 47:REDUCE(with prod 98)]
 [term 50:REDUCE(with prod 98)] [term 52:REDUCE(with prod 98)]
 [term 53:REDUCE(with prod 98)] [term 54:REDUCE(with prod 98)]
 [term 56:REDUCE(with prod 98)] [term 57:REDUCE(with prod 98)]
 [term 58:REDUCE(with prod 98)] [term 59:REDUCE(with prod 98)]
From state #81
 [term 0:REDUCE(with prod 71)] [term 4:REDUCE(with prod 71)]
 [term 5:REDUCE(with prod 71)] [term 6:REDUCE(with prod 71)]
 [term 7:REDUCE(with prod 71)] [term 8:REDUCE(with prod 71)]
 [term 9:REDUCE(with prod 71)] [term 10:REDUCE(with prod 71)]
 [term 11:REDUCE(with prod 71)] [term 12:REDUCE(with prod 71)]
 [term 20:REDUCE(with prod 71)] [term 21:REDUCE(with prod 71)]
 [term 22:REDUCE(with prod 71)] [term 23:REDUCE(with prod 71)]
 [term 24:REDUCE(with prod 71)] [term 25:REDUCE(with prod 71)]
 [term 26:REDUCE(with prod 71)] [term 27:REDUCE(with prod 71)]
 [term 28:REDUCE(with prod 71)] [term 29:REDUCE(with prod 71)]
 [term 30:REDUCE(with prod 71)] [term 31:REDUCE(with prod 71)]
 [term 33:SHIFT(to state 55)] [term 34:SHIFT(to state 68)]
 [term 37:REDUCE(with prod 71)] [term 39:REDUCE(with prod 71)]
 [term 40:REDUCE(with prod 71)] [term 41:REDUCE(with prod 71)]
 [term 42:REDUCE(with prod 71)] [term 43:SHIFT(to state 72)]
 [term 44:REDUCE(with prod 71)] [term 45:REDUCE(with prod 71)]
 [term 46:REDUCE(with prod 71)] [term 47:REDUCE(with prod 71)]
 [term 50:REDUCE(with prod 71)] [term 52:REDUCE(with prod 71)]
 [term 53:SHIFT(to state 67)] [term 54:SHIFT(to state 69)]
 [term 56:REDUCE(with prod 71)] [term 57:REDUCE(with prod 71)]
 [term 58:REDUCE(with prod 71)] [term 59:SHIFT(to state 66)]
From state #82
 [term 0:REDUCE(with prod 76)] [term 4:REDUCE(with prod 76)]
 [term 5:REDUCE(with prod 76)] [term 6:REDUCE(with prod 76)]
 [term 7:REDUCE(with prod 76)] [term 8:REDUCE(with prod 76)]
 [term 9:REDUCE(with prod 76)] [term 10:REDUCE(with prod 76)]
 [term 11:REDUCE(with prod 76)] [term 12:REDUCE(with prod 76)]
 [term 20:REDUCE(with prod 76)] [term 21:REDUCE(with prod 76)]
 [term 22:REDUCE(with prod 76)] [term 23:REDUCE(with prod 76)]
 [term 24:REDUCE(with prod 76)] [term 25:REDUCE(with prod 76)]
 [term 26:REDUCE(with prod 76)] [term 27:REDUCE(with prod 76)]
 [term 28:REDUCE(with prod 76)] [term 29:REDUCE(with prod 76)]
 [term 30:SHIFT(to state 59)] [term 31:SHIFT(to state 71)]
 [term 33:SHIFT(to state 55)] [term 34:SHIFT(to state 68)]
 [term 37:REDUCE(with prod 76)] [term 39:REDUCE(with prod 76)]
 [term 40:REDUCE(with prod 76)] [term 41:REDUCE(with prod 76)]
 [term 42:REDUCE(with prod 76)] [term 43:SHIFT(to state 72)]
 [term 44:REDUCE(with prod 76)] [term 45:REDUCE(with prod 76)]
 [term 46:REDUCE(with prod 76)] [term 47:REDUCE(with prod 76)]
 [term 50:REDUCE(with prod 76)] [term 52:REDUCE(with prod 76)]
 [term 53:SHIFT(to state 67)] [term 54:SHIFT(to state 69)]
 [term 56:REDUCE(with prod 76)] [term 57:REDUCE(with prod 76)]
 [term 58:REDUCE(with prod 76)] [term 59:SHIFT(to state 66)]
From state #83
 [term 20:SHIFT(to state 63)] [term 21:SHIFT(to state 56)]
 [term 22:SHIFT(to state 60)] [term 23:SHIFT(to state 74)]
 [term 24:SHIFT(to state 73)] [term 25:SHIFT(to state 58)]
 [term 26:SHIFT(to state 57)] [term 27:SHIFT(to state 64)]
 [term 28:SHIFT(to state 65)] [term 29:SHIFT(to state 70)]
 [term 30:SHIFT(to state 59)] [term 31:SHIFT(to state 71)]
 [term 33:SHIFT(to state 55)] [term 34:SHIFT(to state 68)]
 [term 42:REDUCE(with prod 90)] [term 43:SHIFT(to state 72)]
 [term 47:SHIFT(to state 62)] [term 52:SHIFT(to state 61)]
 [term 53:SHIFT(to state 67)] [term 54:SHIFT(to state 69)]
 [term 56:REDUCE(with prod 90)] [term 57:REDUCE(with prod 90)]
 [term 59:SHIFT(to state 66)]
From state #84
 [term 42:SHIFT(to state 85)] [term 57:SHIFT(to state 86)]
From state #85
 [term 13:SHIFT(to state 20)] [term 14:SHIFT(to state 25)]
 [term 15:SHIFT(to state 22)] [term 16:SHIFT(to state 28)]
 [term 17:SHIFT(to state 38)] [term 31:SHIFT(to state 47)]
 [term 35:SHIFT(to state 40)] [term 36:SHIFT(to state 49)]
 [term 38:SHIFT(to state 43)] [term 53:SHIFT(to state 45)]
 [term 60:SHIFT(to state 51)] [term 61:SHIFT(to state 52)]
 [term 62:SHIFT(to state 44)] [term 63:SHIFT(to state 42)]
 [term 64:SHIFT(to state 48)] [term 65:SHIFT(to state 12)]
From state #86
 [term 0:REDUCE(with prod 97)] [term 4:REDUCE(with prod 97)]
 [term 5:REDUCE(with prod 97)] [term 6:REDUCE(with prod 97)]
 [term 7:REDUCE(with prod 97)] [term 8:REDUCE(with prod 97)]
 [term 9:REDUCE(with prod 97)] [term 10:REDUCE(with prod 97)]
 [term 11:REDUCE(with prod 97)] [term 12:REDUCE(with prod 97)]
 [term 20:REDUCE(with prod 97)] [term 21:REDUCE(with prod 97)]
 [term 22:REDUCE(with prod 97)] [term 23:REDUCE(with prod 97)]
 [term 24:REDUCE(with prod 97)] [term 25:REDUCE(with prod 97)]
 [term 26:REDUCE(with prod 97)] [term 27:REDUCE(with prod 97)]
 [term 28:REDUCE(with prod 97)] [term 29:REDUCE(with prod 97)]
 [term 30:REDUCE(with prod 97)] [term 31:REDUCE(with prod 97)]
 [term 33:REDUCE(with prod 97)] [term 34:REDUCE(with prod 97)]
 [term 37:REDUCE(with prod 97)] [term 39:REDUCE(with prod 97)]
 [term 40:REDUCE(with prod 97)] [term 41:REDUCE(with prod 97)]
 [term 42:REDUCE(with prod 97)] [term 43:REDUCE(with prod 97)]
 [term 44:REDUCE(with prod 97)] [term 45:REDUCE(with prod 97)]
 [term 46:REDUCE(with prod 97)] [term 47:REDUCE(with prod 97)]
 [term 48:SHIFT(to state 78)] [term 50:REDUCE(with prod 97)]
 [term 52:REDUCE(with prod 97)] [term 53:REDUCE(with prod 97)]
 [term 54:REDUCE(with prod 97)] [term 56:REDUCE(with prod 97)]
 [term 57:REDUCE(with prod 97)] [term 58:REDUCE(with prod 97)]
 [term 59:REDUCE(with prod 97)]
From state #87
 [term 0:REDUCE(with prod 62)] [term 4:REDUCE(with prod 62)]
 [term 5:REDUCE(with prod 62)] [term 6:REDUCE(with prod 62)]
 [term 7:REDUCE(with prod 62)] [term 8:REDUCE(with prod 62)]
 [term 9:REDUCE(with prod 62)] [term 10:REDUCE(with prod 62)]
 [term 11:REDUCE(with prod 62)] [term 12:REDUCE(with prod 62)]
 [term 20:REDUCE(with prod 62)] [term 21:REDUCE(with prod 62)]
 [term 22:REDUCE(with prod 62)] [term 23:REDUCE(with prod 62)]
 [term 24:REDUCE(with prod 62)] [term 25:REDUCE(with prod 62)]
 [term 26:REDUCE(with prod 62)] [term 27:REDUCE(with prod 62)]
 [term 28:REDUCE(with prod 62)] [term 29:REDUCE(with prod 62)]
 [term 30:REDUCE(with prod 62)] [term 31:REDUCE(with prod 62)]
 [term 33:REDUCE(with prod 62)] [term 34:REDUCE(with prod 62)]
 [term 37:REDUCE(with prod 62)] [term 39:REDUCE(with prod 62)]
 [term 40:REDUCE(with prod 62)] [term 41:REDUCE(with prod 62)]
 [term 42:REDUCE(with prod 62)] [term 43:REDUCE(with prod 62)]
 [term 44:REDUCE(with prod 62)] [term 45:REDUCE(with prod 62)]
 [term 46:REDUCE(with prod 62)] [term 47:REDUCE(with prod 62)]
 [term 50:REDUCE(with prod 62)] [term 52:REDUCE(with prod 62)]
 [term 53:REDUCE(with prod 62)] [term 54:REDUCE(with prod 62)]
 [term 56:REDUCE(with prod 62)] [term 57:REDUCE(with prod 62)]
 [term 58:REDUCE(with prod 62)] [term 59:REDUCE(with prod 62)]
From state #88
 [term 20:SHIFT(to state 63)] [term 21:SHIFT(to state 56)]
 [term 22:SHIFT(to state 60)] [term 23:SHIFT(to state 74)]
 [term 24:SHIFT(to state 73)] [term 25:SHIFT(to state 58)]
 [term 26:SHIFT(to state 57)] [term 27:SHIFT(to state 64)]
 [term 28:SHIFT(to state 65)] [term 29:SHIFT(to state 70)]
 [term 30:SHIFT(to state 59)] [term 31:SHIFT(to state 71)]
 [term 33:SHIFT(to state 55)] [term 34:SHIFT(to state 68)]
 [term 42:REDUCE(with prod 91)] [term 43:SHIFT(to state 72)]
 [term 47:SHIFT(to state 62)] [term 52:SHIFT(to state 61)]
 [term 53:SHIFT(to state 67)] [term 54:SHIFT(to state 69)]
 [term 56:REDUCE(with prod 91)] [term 57:REDUCE(with prod 91)]
 [term 59:SHIFT(to state 66)]
From state #89
 [term 0:REDUCE(with prod 69)] [term 4:REDUCE(with prod 69)]
 [term 5:REDUCE(with prod 69)] [term 6:REDUCE(with prod 69)]
 [term 7:REDUCE(with prod 69)] [term 8:REDUCE(with prod 69)]
 [term 9:REDUCE(with prod 69)] [term 10:REDUCE(with prod 69)]
 [term 11:REDUCE(with prod 69)] [term 12:REDUCE(with prod 69)]
 [term 20:REDUCE(with prod 69)] [term 21:REDUCE(with prod 69)]
 [term 22:REDUCE(with prod 69)] [term 23:REDUCE(with prod 69)]
 [term 24:REDUCE(with prod 69)] [term 25:REDUCE(with prod 69)]
 [term 26:REDUCE(with prod 69)] [term 27:REDUCE(with prod 69)]
 [term 28:REDUCE(with prod 69)] [term 29:REDUCE(with prod 69)]
 [term 30:REDUCE(with prod 69)] [term 31:REDUCE(with prod 69)]
 [term 33:REDUCE(with prod 69)] [term 34:REDUCE(with prod 69)]
 [term 37:REDUCE(with prod 69)] [term 39:REDUCE(with prod 69)]
 [term 40:REDUCE(with prod 69)] [term 41:REDUCE(with prod 69)]
 [term 42:REDUCE(with prod 69)] [term 43:SHIFT(to state 72)]
 [term 44:REDUCE(with prod 69)] [term 45:REDUCE(with prod 69)]
 [term 46:REDUCE(with prod 69)] [term 47:REDUCE(with prod 69)]
 [term 50:REDUCE(with prod 69)] [term 52:REDUCE(with prod 69)]
 [term 53:SHIFT(to state 67)] [term 54:SHIFT(to state 69)]
 [term 56:REDUCE(with prod 69)] [term 57:REDUCE(with prod 69)]
 [term 58:REDUCE(with prod 69)] [term 59:SHIFT(to state 66)]
From state #90
 [term 46:SHIFT(to state 95)]
From state #91
 [term 20:REDUCE(with prod 120)] [term 21:REDUCE(with prod 120)]
 [term 22:REDUCE(with prod 120)] [term 23:REDUCE(with prod 120)]
 [term 24:SHIFT(to state 18)] [term 25:REDUCE(with prod 120)]
 [term 26:REDUCE(with prod 120)] [term 27:REDUCE(with prod 120)]
 [term 28:REDUCE(with prod 120)] [term 29:REDUCE(with prod 120)]
 [term 30:REDUCE(with prod 120)] [term 31:REDUCE(with prod 120)]
 [term 33:REDUCE(with prod 120)] [term 34:REDUCE(with prod 120)]
 [term 42:REDUCE(with prod 120)] [term 43:REDUCE(with prod 120)]
 [term 44:SHIFT(to state 19)] [term 46:REDUCE(with prod 50)]
 [term 47:REDUCE(with prod 120)] [term 48:REDUCE(with prod 120)]
 [term 51:REDUCE(with prod 120)] [term 52:REDUCE(with prod 120)]
 [term 53:REDUCE(with prod 120)] [term 54:REDUCE(with prod 120)]
 [term 56:REDUCE(with prod 120)] [term 59:REDUCE(with prod 120)]
From state #92
 [term 56:SHIFT(to state 94)]
From state #93
 [term 42:SHIFT(to state 85)] [term 56:REDUCE(with prod 89)]
From state #94
 [term 0:REDUCE(with prod 60)] [term 4:REDUCE(with prod 60)]
 [term 5:REDUCE(with prod 60)] [term 6:REDUCE(with prod 60)]
 [term 7:REDUCE(with prod 60)] [term 8:REDUCE(with prod 60)]
 [term 9:REDUCE(with prod 60)] [term 10:REDUCE(with prod 60)]
 [term 11:REDUCE(with prod 60)] [term 12:REDUCE(with prod 60)]
 [term 20:REDUCE(with prod 60)] [term 21:REDUCE(with prod 60)]
 [term 22:REDUCE(with prod 60)] [term 23:REDUCE(with prod 60)]
 [term 24:REDUCE(with prod 60)] [term 25:REDUCE(with prod 60)]
 [term 26:REDUCE(with prod 60)] [term 27:REDUCE(with prod 60)]
 [term 28:REDUCE(with prod 60)] [term 29:REDUCE(with prod 60)]
 [term 30:REDUCE(with prod 60)] [term 31:REDUCE(with prod 60)]
 [term 33:REDUCE(with prod 60)] [term 34:REDUCE(with prod 60)]
 [term 37:REDUCE(with prod 60)] [term 39:REDUCE(with prod 60)]
 [term 40:REDUCE(with prod 60)] [term 41:REDUCE(with prod 60)]
 [term 42:REDUCE(with prod 60)] [term 43:REDUCE(with prod 60)]
 [term 44:REDUCE(with prod 60)] [term 45:REDUCE(with prod 60)]
 [term 46:REDUCE(with prod 60)] [term 47:REDUCE(with prod 60)]
 [term 50:REDUCE(with prod 60)] [term 52:REDUCE(with prod 60)]
 [term 53:REDUCE(with prod 60)] [term 54:REDUCE(with prod 60)]
 [term 56:REDUCE(with prod 60)] [term 57:REDUCE(with prod 60)]
 [term 58:REDUCE(with prod 60)] [term 59:REDUCE(with prod 60)]
From state #95
 [term 13:SHIFT(to state 20)] [term 14:SHIFT(to state 25)]
 [term 15:SHIFT(to state 22)] [term 16:SHIFT(to state 28)]
 [term 17:SHIFT(to state 38)] [term 31:SHIFT(to state 47)]
 [term 35:SHIFT(to state 40)] [term 36:SHIFT(to state 49)]
 [term 38:SHIFT(to state 43)] [term 53:SHIFT(to state 45)]
 [term 60:SHIFT(to state 51)] [term 61:SHIFT(to state 52)]
 [term 62:SHIFT(to state 44)] [term 63:SHIFT(to state 42)]
 [term 64:SHIFT(to state 48)] [term 65:SHIFT(to state 12)]
From state #96
 [term 20:SHIFT(to state 63)] [term 21:SHIFT(to state 56)]
 [term 22:SHIFT(to state 60)] [term 23:SHIFT(to state 74)]
 [term 24:SHIFT(to state 73)] [term 25:SHIFT(to state 58)]
 [term 26:SHIFT(to state 57)] [term 27:SHIFT(to state 64)]
 [term 28:SHIFT(to state 65)] [term 29:SHIFT(to state 70)]
 [term 30:SHIFT(to state 59)] [term 31:SHIFT(to state 71)]
 [term 33:SHIFT(to state 55)] [term 34:SHIFT(to state 68)]
 [term 43:SHIFT(to state 72)] [term 47:SHIFT(to state 62)]
 [term 52:SHIFT(to state 61)] [term 53:SHIFT(to state 67)]
 [term 54:SHIFT(to state 69)] [term 56:SHIFT(to state 97)]
 [term 59:SHIFT(to state 66)]
From state #97
 [term 0:REDUCE(with prod 61)] [term 4:REDUCE(with prod 61)]
 [term 5:REDUCE(with prod 61)] [term 6:REDUCE(with prod 61)]
 [term 7:REDUCE(with prod 61)] [term 8:REDUCE(with prod 61)]
 [term 9:REDUCE(with prod 61)] [term 10:REDUCE(with prod 61)]
 [term 11:REDUCE(with prod 61)] [term 12:REDUCE(with prod 61)]
 [term 20:REDUCE(with prod 61)] [term 21:REDUCE(with prod 61)]
 [term 22:REDUCE(with prod 61)] [term 23:REDUCE(with prod 61)]
 [term 24:REDUCE(with prod 61)] [term 25:REDUCE(with prod 61)]
 [term 26:REDUCE(with prod 61)] [term 27:REDUCE(with prod 61)]
 [term 28:REDUCE(with prod 61)] [term 29:REDUCE(with prod 61)]
 [term 30:REDUCE(with prod 61)] [term 31:REDUCE(with prod 61)]
 [term 33:REDUCE(with prod 61)] [term 34:REDUCE(with prod 61)]
 [term 37:REDUCE(with prod 61)] [term 39:REDUCE(with prod 61)]
 [term 40:REDUCE(with prod 61)] [term 41:REDUCE(with prod 61)]
 [term 42:REDUCE(with prod 61)] [term 43:REDUCE(with prod 61)]
 [term 44:REDUCE(with prod 61)] [term 45:REDUCE(with prod 61)]
 [term 46:REDUCE(with prod 61)] [term 47:REDUCE(with prod 61)]
 [term 50:REDUCE(with prod 61)] [term 52:REDUCE(with prod 61)]
 [term 53:REDUCE(with prod 61)] [term 54:REDUCE(with prod 61)]
 [term 56:REDUCE(with prod 61)] [term 57:REDUCE(with prod 61)]
 [term 58:REDUCE(with prod 61)] [term 59:REDUCE(with prod 61)]
From state #98
 [term 0:REDUCE(with prod 63)] [term 4:REDUCE(with prod 63)]
 [term 5:REDUCE(with prod 63)] [term 6:REDUCE(with prod 63)]
 [term 7:REDUCE(with prod 63)] [term 8:REDUCE(with prod 63)]
 [term 9:REDUCE(with prod 63)] [term 10:REDUCE(with prod 63)]
 [term 11:REDUCE(with prod 63)] [term 12:REDUCE(with prod 63)]
 [term 20:REDUCE(with prod 63)] [term 21:REDUCE(with prod 63)]
 [term 22:REDUCE(with prod 63)] [term 23:REDUCE(with prod 63)]
 [term 24:REDUCE(with prod 63)] [term 25:REDUCE(with prod 63)]
 [term 26:REDUCE(with prod 63)] [term 27:REDUCE(with prod 63)]
 [term 28:REDUCE(with prod 63)] [term 29:REDUCE(with prod 63)]
 [term 30:REDUCE(with prod 63)] [term 31:REDUCE(with prod 63)]
 [term 33:REDUCE(with prod 63)] [term 34:REDUCE(with prod 63)]
 [term 37:REDUCE(with prod 63)] [term 39:REDUCE(with prod 63)]
 [term 40:REDUCE(with prod 63)] [term 41:REDUCE(with prod 63)]
 [term 42:REDUCE(with prod 63)] [term 43:REDUCE(with prod 63)]
 [term 44:REDUCE(with prod 63)] [term 45:REDUCE(with prod 63)]
 [term 46:REDUCE(with prod 63)] [term 47:REDUCE(with prod 63)]
 [term 50:REDUCE(with prod 63)] [term 52:REDUCE(with prod 63)]
 [term 53:REDUCE(with prod 63)] [term 54:REDUCE(with prod 63)]
 [term 56:REDUCE(with prod 63)] [term 57:REDUCE(with prod 63)]
 [term 58:REDUCE(with prod 63)] [term 59:REDUCE(with prod 63)]
From state #99
 [term 53:SHIFT(to state 100)]
From state #100
 [term 65:SHIFT(to state 12)]
From state #101
 [term 45:SHIFT(to state 102)] [term 46:SHIFT(to state 103)]
From state #102
 [term 65:SHIFT(to state 12)]
From state #103
 [term 13:SHIFT(to state 20)] [term 14:SHIFT(to state 25)]
 [term 15:SHIFT(to state 22)] [term 16:SHIFT(to state 28)]
 [term 17:SHIFT(to state 38)] [term 31:SHIFT(to state 47)]
 [term 35:SHIFT(to state 40)] [term 36:SHIFT(to state 49)]
 [term 38:SHIFT(to state 43)] [term 53:SHIFT(to state 45)]
 [term 60:SHIFT(to state 51)] [term 61:SHIFT(to state 52)]
 [term 62:SHIFT(to state 44)] [term 63:SHIFT(to state 42)]
 [term 64:SHIFT(to state 48)] [term 65:SHIFT(to state 12)]
From state #104
 [term 20:SHIFT(to state 63)] [term 21:SHIFT(to state 56)]
 [term 22:SHIFT(to state 60)] [term 23:SHIFT(to state 74)]
 [term 24:SHIFT(to state 73)] [term 25:SHIFT(to state 58)]
 [term 26:SHIFT(to state 57)] [term 27:SHIFT(to state 64)]
 [term 28:SHIFT(to state 65)] [term 29:SHIFT(to state 70)]
 [term 30:SHIFT(to state 59)] [term 31:SHIFT(to state 71)]
 [term 33:SHIFT(to state 55)] [term 34:SHIFT(to state 68)]
 [term 43:SHIFT(to state 72)] [term 47:SHIFT(to state 62)]
 [term 52:SHIFT(to state 61)] [term 53:SHIFT(to state 67)]
 [term 54:SHIFT(to state 69)] [term 56:SHIFT(to state 105)]
 [term 59:SHIFT(to state 66)]
From state #105
 [term 0:REDUCE(with prod 65)] [term 4:REDUCE(with prod 65)]
 [term 5:REDUCE(with prod 65)] [term 6:REDUCE(with prod 65)]
 [term 7:REDUCE(with prod 65)] [term 8:REDUCE(with prod 65)]
 [term 9:REDUCE(with prod 65)] [term 10:REDUCE(with prod 65)]
 [term 11:REDUCE(with prod 65)] [term 12:REDUCE(with prod 65)]
 [term 20:REDUCE(with prod 65)] [term 21:REDUCE(with prod 65)]
 [term 22:REDUCE(with prod 65)] [term 23:REDUCE(with prod 65)]
 [term 24:REDUCE(with prod 65)] [term 25:REDUCE(with prod 65)]
 [term 26:REDUCE(with prod 65)] [term 27:REDUCE(with prod 65)]
 [term 28:REDUCE(with prod 65)] [term 29:REDUCE(with prod 65)]
 [term 30:REDUCE(with prod 65)] [term 31:REDUCE(with prod 65)]
 [term 33:REDUCE(with prod 65)] [term 34:REDUCE(with prod 65)]
 [term 37:REDUCE(with prod 65)] [term 39:REDUCE(with prod 65)]
 [term 40:REDUCE(with prod 65)] [term 41:REDUCE(with prod 65)]
 [term 42:REDUCE(with prod 65)] [term 43:REDUCE(with prod 65)]
 [term 44:REDUCE(with prod 65)] [term 45:REDUCE(with prod 65)]
 [term 46:REDUCE(with prod 65)] [term 47:REDUCE(with prod 65)]
 [term 50:REDUCE(with prod 65)] [term 52:REDUCE(with prod 65)]
 [term 53:REDUCE(with prod 65)] [term 54:REDUCE(with prod 65)]
 [term 56:REDUCE(with prod 65)] [term 57:REDUCE(with prod 65)]
 [term 58:REDUCE(with prod 65)] [term 59:REDUCE(with prod 65)]
From state #106
 [term 46:SHIFT(to state 107)]
From state #107
 [term 13:SHIFT(to state 20)] [term 14:SHIFT(to state 25)]
 [term 15:SHIFT(to state 22)] [term 16:SHIFT(to state 28)]
 [term 17:SHIFT(to state 38)] [term 31:SHIFT(to state 47)]
 [term 35:SHIFT(to state 40)] [term 36:SHIFT(to state 49)]
 [term 38:SHIFT(to state 43)] [term 53:SHIFT(to state 45)]
 [term 60:SHIFT(to state 51)] [term 61:SHIFT(to state 52)]
 [term 62:SHIFT(to state 44)] [term 63:SHIFT(to state 42)]
 [term 64:SHIFT(to state 48)] [term 65:SHIFT(to state 12)]
From state #108
 [term 20:SHIFT(to state 63)] [term 21:SHIFT(to state 56)]
 [term 22:SHIFT(to state 60)] [term 23:SHIFT(to state 74)]
 [term 24:SHIFT(to state 73)] [term 25:SHIFT(to state 58)]
 [term 26:SHIFT(to state 57)] [term 27:SHIFT(to state 64)]
 [term 28:SHIFT(to state 65)] [term 29:SHIFT(to state 70)]
 [term 30:SHIFT(to state 59)] [term 31:SHIFT(to state 71)]
 [term 33:SHIFT(to state 55)] [term 34:SHIFT(to state 68)]
 [term 43:SHIFT(to state 72)] [term 47:SHIFT(to state 62)]
 [term 52:SHIFT(to state 61)] [term 53:SHIFT(to state 67)]
 [term 54:SHIFT(to state 69)] [term 56:SHIFT(to state 109)]
 [term 59:SHIFT(to state 66)]
From state #109
 [term 0:REDUCE(with prod 64)] [term 4:REDUCE(with prod 64)]
 [term 5:REDUCE(with prod 64)] [term 6:REDUCE(with prod 64)]
 [term 7:REDUCE(with prod 64)] [term 8:REDUCE(with prod 64)]
 [term 9:REDUCE(with prod 64)] [term 10:REDUCE(with prod 64)]
 [term 11:REDUCE(with prod 64)] [term 12:REDUCE(with prod 64)]
 [term 20:REDUCE(with prod 64)] [term 21:REDUCE(with prod 64)]
 [term 22:REDUCE(with prod 64)] [term 23:REDUCE(with prod 64)]
 [term 24:REDUCE(with prod 64)] [term 25:REDUCE(with prod 64)]
 [term 26:REDUCE(with prod 64)] [term 27:REDUCE(with prod 64)]
 [term 28:REDUCE(with prod 64)] [term 29:REDUCE(with prod 64)]
 [term 30:REDUCE(with prod 64)] [term 31:REDUCE(with prod 64)]
 [term 33:REDUCE(with prod 64)] [term 34:REDUCE(with prod 64)]
 [term 37:REDUCE(with prod 64)] [term 39:REDUCE(with prod 64)]
 [term 40:REDUCE(with prod 64)] [term 41:REDUCE(with prod 64)]
 [term 42:REDUCE(with prod 64)] [term 43:REDUCE(with prod 64)]
 [term 44:REDUCE(with prod 64)] [term 45:REDUCE(with prod 64)]
 [term 46:REDUCE(with prod 64)] [term 47:REDUCE(with prod 64)]
 [term 50:REDUCE(with prod 64)] [term 52:REDUCE(with prod 64)]
 [term 53:REDUCE(with prod 64)] [term 54:REDUCE(with prod 64)]
 [term 56:REDUCE(with prod 64)] [term 57:REDUCE(with prod 64)]
 [term 58:REDUCE(with prod 64)] [term 59:REDUCE(with prod 64)]
From state #110
 [term 0:REDUCE(with prod 75)] [term 4:REDUCE(with prod 75)]
 [term 5:REDUCE(with prod 75)] [term 6:REDUCE(with prod 75)]
 [term 7:REDUCE(with prod 75)] [term 8:REDUCE(with prod 75)]
 [term 9:REDUCE(with prod 75)] [term 10:REDUCE(with prod 75)]
 [term 11:REDUCE(with prod 75)] [term 12:REDUCE(with prod 75)]
 [term 20:REDUCE(with prod 75)] [term 21:REDUCE(with prod 75)]
 [term 22:REDUCE(with prod 75)] [term 23:REDUCE(with prod 75)]
 [term 24:REDUCE(with prod 75)] [term 25:REDUCE(with prod 75)]
 [term 26:REDUCE(with prod 75)] [term 27:REDUCE(with prod 75)]
 [term 28:REDUCE(with prod 75)] [term 29:REDUCE(with prod 75)]
 [term 30:SHIFT(to state 59)] [term 31:SHIFT(to state 71)]
 [term 33:SHIFT(to state 55)] [term 34:SHIFT(to state 68)]
 [term 37:REDUCE(with prod 75)] [term 39:REDUCE(with prod 75)]
 [term 40:REDUCE(with prod 75)] [term 41:REDUCE(with prod 75)]
 [term 42:REDUCE(with prod 75)] [term 43:SHIFT(to state 72)]
 [term 44:REDUCE(with prod 75)] [term 45:REDUCE(with prod 75)]
 [term 46:REDUCE(with prod 75)] [term 47:REDUCE(with prod 75)]
 [term 50:REDUCE(with prod 75)] [term 52:REDUCE(with prod 75)]
 [term 53:SHIFT(to state 67)] [term 54:SHIFT(to state 69)]
 [term 56:REDUCE(with prod 75)] [term 57:REDUCE(with prod 75)]
 [term 58:REDUCE(with prod 75)] [term 59:SHIFT(to state 66)]
From state #111
 [term 0:REDUCE(with prod 74)] [term 4:REDUCE(with prod 74)]
 [term 5:REDUCE(with prod 74)] [term 6:REDUCE(with prod 74)]
 [term 7:REDUCE(with prod 74)] [term 8:REDUCE(with prod 74)]
 [term 9:REDUCE(with prod 74)] [term 10:REDUCE(with prod 74)]
 [term 11:REDUCE(with prod 74)] [term 12:REDUCE(with prod 74)]
 [term 20:REDUCE(with prod 74)] [term 21:REDUCE(with prod 74)]
 [term 22:REDUCE(with prod 74)] [term 23:REDUCE(with prod 74)]
 [term 24:REDUCE(with prod 74)] [term 25:REDUCE(with prod 74)]
 [term 26:REDUCE(with prod 74)] [term 27:REDUCE(with prod 74)]
 [term 28:REDUCE(with prod 74)] [term 29:REDUCE(with prod 74)]
 [term 30:SHIFT(to state 59)] [term 31:SHIFT(to state 71)]
 [term 33:SHIFT(to state 55)] [term 34:SHIFT(to state 68)]
 [term 37:REDUCE(with prod 74)] [term 39:REDUCE(with prod 74)]
 [term 40:REDUCE(with prod 74)] [term 41:REDUCE(with prod 74)]
 [term 42:REDUCE(with prod 74)] [term 43:SHIFT(to state 72)]
 [term 44:REDUCE(with prod 74)] [term 45:REDUCE(with prod 74)]
 [term 46:REDUCE(with prod 74)] [term 47:REDUCE(with prod 74)]
 [term 50:REDUCE(with prod 74)] [term 52:REDUCE(with prod 74)]
 [term 53:SHIFT(to state 67)] [term 54:SHIFT(to state 69)]
 [term 56:REDUCE(with prod 74)] [term 57:REDUCE(with prod 74)]
 [term 58:REDUCE(with prod 74)] [term 59:SHIFT(to state 66)]
From state #112
 [term 0:REDUCE(with prod 82)] [term 4:REDUCE(with prod 82)]
 [term 5:REDUCE(with prod 82)] [term 6:REDUCE(with prod 82)]
 [term 7:REDUCE(with prod 82)] [term 8:REDUCE(with prod 82)]
 [term 9:REDUCE(with prod 82)] [term 10:REDUCE(with prod 82)]
 [term 11:REDUCE(with prod 82)] [term 12:REDUCE(with prod 82)]
 [term 20:REDUCE(with prod 82)] [term 21:SHIFT(to state 56)]
 [term 22:SHIFT(to state 60)] [term 23:SHIFT(to state 74)]
 [term 24:SHIFT(to state 73)] [term 25:SHIFT(to state 58)]
 [term 26:SHIFT(to state 57)] [term 27:SHIFT(to state 64)]
 [term 28:SHIFT(to state 65)] [term 29:SHIFT(to state 70)]
 [term 30:SHIFT(to state 59)] [term 31:SHIFT(to state 71)]
 [term 33:SHIFT(to state 55)] [term 34:SHIFT(to state 68)]
 [term 37:REDUCE(with prod 82)] [term 39:REDUCE(with prod 82)]
 [term 40:REDUCE(with prod 82)] [term 41:REDUCE(with prod 82)]
 [term 42:REDUCE(with prod 82)] [term 43:SHIFT(to state 72)]
 [term 44:REDUCE(with prod 82)] [term 45:REDUCE(with prod 82)]
 [term 46:REDUCE(with prod 82)] [term 47:REDUCE(with prod 82)]
 [term 50:REDUCE(with prod 82)] [term 52:REDUCE(with prod 82)]
 [term 53:SHIFT(to state 67)] [term 54:SHIFT(to state 69)]
 [term 56:REDUCE(with prod 82)] [term 57:REDUCE(with prod 82)]
 [term 58:REDUCE(with prod 82)] [term 59:SHIFT(to state 66)]
From state #113
 [term 53:SHIFT(to state 114)]
From state #114
 [term 13:SHIFT(to state 20)] [term 14:SHIFT(to state 25)]
 [term 15:SHIFT(to state 22)] [term 16:SHIFT(to state 28)]
 [term 17:SHIFT(to state 38)] [term 31:SHIFT(to state 47)]
 [term 35:SHIFT(to state 40)] [term 36:SHIFT(to state 49)]
 [term 38:SHIFT(to state 43)] [term 49:SHIFT(to state 115)]
 [term 53:SHIFT(to state 45)] [term 56:SHIFT(to state 117)]
 [term 60:SHIFT(to state 51)] [term 61:SHIFT(to state 52)]
 [term 62:SHIFT(to state 44)] [term 63:SHIFT(to state 42)]
 [term 64:SHIFT(to state 48)] [term 65:SHIFT(to state 12)]
From state #115
 [term 42:REDUCE(with prod 94)] [term 44:SHIFT(to state 123)]
 [term 56:REDUCE(with prod 94)]
From state #116
 [term 42:REDUCE(with prod 92)] [term 56:REDUCE(with prod 92)]
From state #117
 [term 0:REDUCE(with prod 87)] [term 4:REDUCE(with prod 87)]
 [term 5:REDUCE(with prod 87)] [term 6:REDUCE(with prod 87)]
 [term 7:REDUCE(with prod 87)] [term 8:REDUCE(with prod 87)]
 [term 9:REDUCE(with prod 87)] [term 10:REDUCE(with prod 87)]
 [term 11:REDUCE(with prod 87)] [term 12:REDUCE(with prod 87)]
 [term 20:REDUCE(with prod 87)] [term 21:REDUCE(with prod 87)]
 [term 22:REDUCE(with prod 87)] [term 23:REDUCE(with prod 87)]
 [term 24:REDUCE(with prod 87)] [term 25:REDUCE(with prod 87)]
 [term 26:REDUCE(with prod 87)] [term 27:REDUCE(with prod 87)]
 [term 28:REDUCE(with prod 87)] [term 29:REDUCE(with prod 87)]
 [term 30:REDUCE(with prod 87)] [term 31:REDUCE(with prod 87)]
 [term 33:REDUCE(with prod 87)] [term 34:REDUCE(with prod 87)]
 [term 37:REDUCE(with prod 87)] [term 39:REDUCE(with prod 87)]
 [term 40:REDUCE(with prod 87)] [term 41:REDUCE(with prod 87)]
 [term 42:REDUCE(with prod 87)] [term 43:REDUCE(with prod 87)]
 [term 44:REDUCE(with prod 87)] [term 45:REDUCE(with prod 87)]
 [term 46:REDUCE(with prod 87)] [term 47:REDUCE(with prod 87)]
 [term 50:REDUCE(with prod 87)] [term 52:REDUCE(with prod 87)]
 [term 53:REDUCE(with prod 87)] [term 54:REDUCE(with prod 87)]
 [term 56:REDUCE(with prod 87)] [term 57:REDUCE(with prod 87)]
 [term 58:REDUCE(with prod 87)] [term 59:REDUCE(with prod 87)]
From state #118
 [term 42:SHIFT(to state 120)] [term 56:SHIFT(to state 121)]
From state #119
 [term 20:SHIFT(to state 63)] [term 21:SHIFT(to state 56)]
 [term 22:SHIFT(to state 60)] [term 23:SHIFT(to state 74)]
 [term 24:SHIFT(to state 73)] [term 25:SHIFT(to state 58)]
 [term 26:SHIFT(to state 57)] [term 27:SHIFT(to state 64)]
 [term 28:SHIFT(to state 65)] [term 29:SHIFT(to state 70)]
 [term 30:SHIFT(to state 59)] [term 31:SHIFT(to state 71)]
 [term 33:SHIFT(to state 55)] [term 34:SHIFT(to state 68)]
 [term 42:REDUCE(with prod 96)] [term 43:SHIFT(to state 72)]
 [term 47:SHIFT(to state 62)] [term 52:SHIFT(to state 61)]
 [term 53:SHIFT(to state 67)] [term 54:SHIFT(to state 69)]
 [term 56:REDUCE(with prod 96)] [term 59:SHIFT(to state 66)]
From state #120
 [term 13:SHIFT(to state 20)] [term 14:SHIFT(to state 25)]
 [term 15:SHIFT(to state 22)] [term 16:SHIFT(to state 28)]
 [term 17:SHIFT(to state 38)] [term 31:SHIFT(to state 47)]
 [term 35:SHIFT(to state 40)] [term 36:SHIFT(to state 49)]
 [term 38:SHIFT(to state 43)] [term 49:SHIFT(to state 115)]
 [term 53:SHIFT(to state 45)] [term 60:SHIFT(to state 51)]
 [term 61:SHIFT(to state 52)] [term 62:SHIFT(to state 44)]
 [term 63:SHIFT(to state 42)] [term 64:SHIFT(to state 48)]
 [term 65:SHIFT(to state 12)]
From state #121
 [term 0:REDUCE(with prod 86)] [term 4:REDUCE(with prod 86)]
 [term 5:REDUCE(with prod 86)] [term 6:REDUCE(with prod 86)]
 [term 7:REDUCE(with prod 86)] [term 8:REDUCE(with prod 86)]
 [term 9:REDUCE(with prod 86)] [term 10:REDUCE(with prod 86)]
 [term 11:REDUCE(with prod 86)] [term 12:REDUCE(with prod 86)]
 [term 20:REDUCE(with prod 86)] [term 21:REDUCE(with prod 86)]
 [term 22:REDUCE(with prod 86)] [term 23:REDUCE(with prod 86)]
 [term 24:REDUCE(with prod 86)] [term 25:REDUCE(with prod 86)]
 [term 26:REDUCE(with prod 86)] [term 27:REDUCE(with prod 86)]
 [term 28:REDUCE(with prod 86)] [term 29:REDUCE(with prod 86)]
 [term 30:REDUCE(with prod 86)] [term 31:REDUCE(with prod 86)]
 [term 33:REDUCE(with prod 86)] [term 34:REDUCE(with prod 86)]
 [term 37:REDUCE(with prod 86)] [term 39:REDUCE(with prod 86)]
 [term 40:REDUCE(with prod 86)] [term 41:REDUCE(with prod 86)]
 [term 42:REDUCE(with prod 86)] [term 43:REDUCE(with prod 86)]
 [term 44:REDUCE(with prod 86)] [term 45:REDUCE(with prod 86)]
 [term 46:REDUCE(with prod 86)] [term 47:REDUCE(with prod 86)]
 [term 50:REDUCE(with prod 86)] [term 52:REDUCE(with prod 86)]
 [term 53:REDUCE(with prod 86)] [term 54:REDUCE(with prod 86)]
 [term 56:REDUCE(with prod 86)] [term 57:REDUCE(with prod 86)]
 [term 58:REDUCE(with prod 86)] [term 59:REDUCE(with prod 86)]
From state #122
 [term 42:REDUCE(with prod 93)] [term 56:REDUCE(with prod 93)]
From state #123
 [term 13:SHIFT(to state 20)] [term 14:SHIFT(to state 25)]
 [term 15:SHIFT(to state 22)] [term 16:SHIFT(to state 28)]
 [term 18:SHIFT(to state 29)] [term 65:SHIFT(to state 12)]
From state #124
 [term 42:REDUCE(with prod 95)] [term 56:REDUCE(with prod 95)]
From state #125
 [term 53:SHIFT(to state 126)]
From state #126
 [term 13:SHIFT(to state 20)] [term 14:SHIFT(to state 25)]
 [term 15:SHIFT(to state 22)] [term 16:SHIFT(to state 28)]
 [term 17:SHIFT(to state 38)] [term 31:SHIFT(to state 47)]
 [term 35:SHIFT(to state 40)] [term 36:SHIFT(to state 49)]
 [term 38:SHIFT(to state 43)] [term 49:SHIFT(to state 115)]
 [term 53:SHIFT(to state 45)] [term 56:SHIFT(to state 127)]
 [term 60:SHIFT(to state 51)] [term 61:SHIFT(to state 52)]
 [term 62:SHIFT(to state 44)] [term 63:SHIFT(to state 42)]
 [term 64:SHIFT(to state 48)] [term 65:SHIFT(to state 12)]
From state #127
 [term 0:REDUCE(with prod 85)] [term 4:REDUCE(with prod 85)]
 [term 5:REDUCE(with prod 85)] [term 6:REDUCE(with prod 85)]
 [term 7:REDUCE(with prod 85)] [term 8:REDUCE(with prod 85)]
 [term 9:REDUCE(with prod 85)] [term 10:REDUCE(with prod 85)]
 [term 11:REDUCE(with prod 85)] [term 12:REDUCE(with prod 85)]
 [term 20:REDUCE(with prod 85)] [term 21:REDUCE(with prod 85)]
 [term 22:REDUCE(with prod 85)] [term 23:REDUCE(with prod 85)]
 [term 24:REDUCE(with prod 85)] [term 25:REDUCE(with prod 85)]
 [term 26:REDUCE(with prod 85)] [term 27:REDUCE(with prod 85)]
 [term 28:REDUCE(with prod 85)] [term 29:REDUCE(with prod 85)]
 [term 30:REDUCE(with prod 85)] [term 31:REDUCE(with prod 85)]
 [term 33:REDUCE(with prod 85)] [term 34:REDUCE(with prod 85)]
 [term 37:REDUCE(with prod 85)] [term 39:REDUCE(with prod 85)]
 [term 40:REDUCE(with prod 85)] [term 41:REDUCE(with prod 85)]
 [term 42:REDUCE(with prod 85)] [term 43:REDUCE(with prod 85)]
 [term 44:REDUCE(with prod 85)] [term 45:REDUCE(with prod 85)]
 [term 46:REDUCE(with prod 85)] [term 47:REDUCE(with prod 85)]
 [term 50:REDUCE(with prod 85)] [term 52:REDUCE(with prod 85)]
 [term 53:REDUCE(with prod 85)] [term 54:REDUCE(with prod 85)]
 [term 56:REDUCE(with prod 85)] [term 57:REDUCE(with prod 85)]
 [term 58:REDUCE(with prod 85)] [term 59:REDUCE(with prod 85)]
From state #128
 [term 42:SHIFT(to state 120)] [term 56:SHIFT(to state 129)]
From state #129
 [term 0:REDUCE(with prod 84)] [term 4:REDUCE(with prod 84)]
 [term 5:REDUCE(with prod 84)] [term 6:REDUCE(with prod 84)]
 [term 7:REDUCE(with prod 84)] [term 8:REDUCE(with prod 84)]
 [term 9:REDUCE(with prod 84)] [term 10:REDUCE(with prod 84)]
 [term 11:REDUCE(with prod 84)] [term 12:REDUCE(with prod 84)]
 [term 20:REDUCE(with prod 84)] [term 21:REDUCE(with prod 84)]
 [term 22:REDUCE(with prod 84)] [term 23:REDUCE(with prod 84)]
 [term 24:REDUCE(with prod 84)] [term 25:REDUCE(with prod 84)]
 [term 26:REDUCE(with prod 84)] [term 27:REDUCE(with prod 84)]
 [term 28:REDUCE(with prod 84)] [term 29:REDUCE(with prod 84)]
 [term 30:REDUCE(with prod 84)] [term 31:REDUCE(with prod 84)]
 [term 33:REDUCE(with prod 84)] [term 34:REDUCE(with prod 84)]
 [term 37:REDUCE(with prod 84)] [term 39:REDUCE(with prod 84)]
 [term 40:REDUCE(with prod 84)] [term 41:REDUCE(with prod 84)]
 [term 42:REDUCE(with prod 84)] [term 43:REDUCE(with prod 84)]
 [term 44:REDUCE(with prod 84)] [term 45:REDUCE(with prod 84)]
 [term 46:REDUCE(with prod 84)] [term 47:REDUCE(with prod 84)]
 [term 50:REDUCE(with prod 84)] [term 52:REDUCE(with prod 84)]
 [term 53:REDUCE(with prod 84)] [term 54:REDUCE(with prod 84)]
 [term 56:REDUCE(with prod 84)] [term 57:REDUCE(with prod 84)]
 [term 58:REDUCE(with prod 84)] [term 59:REDUCE(with prod 84)]
From state #130
 [term 0:REDUCE(with prod 80)] [term 4:REDUCE(with prod 80)]
 [term 5:REDUCE(with prod 80)] [term 6:REDUCE(with prod 80)]
 [term 7:REDUCE(with prod 80)] [term 8:REDUCE(with prod 80)]
 [term 9:REDUCE(with prod 80)] [term 10:REDUCE(with prod 80)]
 [term 11:REDUCE(with prod 80)] [term 12:REDUCE(with prod 80)]
 [term 20:REDUCE(with prod 80)] [term 21:REDUCE(with prod 80)]
 [term 22:REDUCE(with prod 80)] [term 23:REDUCE(with prod 80)]
 [term 24:SHIFT(to state 73)] [term 25:SHIFT(to state 58)]
 [term 26:SHIFT(to state 57)] [term 27:SHIFT(to state 64)]
 [term 28:SHIFT(to state 65)] [term 29:SHIFT(to state 70)]
 [term 30:SHIFT(to state 59)] [term 31:SHIFT(to state 71)]
 [term 33:SHIFT(to state 55)] [term 34:SHIFT(to state 68)]
 [term 37:REDUCE(with prod 80)] [term 39:REDUCE(with prod 80)]
 [term 40:REDUCE(with prod 80)] [term 41:REDUCE(with prod 80)]
 [term 42:REDUCE(with prod 80)] [term 43:SHIFT(to state 72)]
 [term 44:REDUCE(with prod 80)] [term 45:REDUCE(with prod 80)]
 [term 46:REDUCE(with prod 80)] [term 47:REDUCE(with prod 80)]
 [term 50:REDUCE(with prod 80)] [term 52:REDUCE(with prod 80)]
 [term 53:SHIFT(to state 67)] [term 54:SHIFT(to state 69)]
 [term 56:REDUCE(with prod 80)] [term 57:REDUCE(with prod 80)]
 [term 58:REDUCE(with prod 80)] [term 59:SHIFT(to state 66)]
From state #131
 [term 0:REDUCE(with prod 70)] [term 4:REDUCE(with prod 70)]
 [term 5:REDUCE(with prod 70)] [term 6:REDUCE(with prod 70)]
 [term 7:REDUCE(with prod 70)] [term 8:REDUCE(with prod 70)]
 [term 9:REDUCE(with prod 70)] [term 10:REDUCE(with prod 70)]
 [term 11:REDUCE(with prod 70)] [term 12:REDUCE(with prod 70)]
 [term 20:REDUCE(with prod 70)] [term 21:REDUCE(with prod 70)]
 [term 22:REDUCE(with prod 70)] [term 23:REDUCE(with prod 70)]
 [term 24:REDUCE(with prod 70)] [term 25:REDUCE(with prod 70)]
 [term 26:REDUCE(with prod 70)] [term 27:REDUCE(with prod 70)]
 [term 28:REDUCE(with prod 70)] [term 29:REDUCE(with prod 70)]
 [term 30:REDUCE(with prod 70)] [term 31:REDUCE(with prod 70)]
 [term 33:SHIFT(to state 55)] [term 34:SHIFT(to state 68)]
 [term 37:REDUCE(with prod 70)] [term 39:REDUCE(with prod 70)]
 [term 40:REDUCE(with prod 70)] [term 41:REDUCE(with prod 70)]
 [term 42:REDUCE(with prod 70)] [term 43:SHIFT(to state 72)]
 [term 44:REDUCE(with prod 70)] [term 45:REDUCE(with prod 70)]
 [term 46:REDUCE(with prod 70)] [term 47:REDUCE(with prod 70)]
 [term 50:REDUCE(with prod 70)] [term 52:REDUCE(with prod 70)]
 [term 53:SHIFT(to state 67)] [term 54:SHIFT(to state 69)]
 [term 56:REDUCE(with prod 70)] [term 57:REDUCE(with prod 70)]
 [term 58:REDUCE(with prod 70)] [term 59:SHIFT(to state 66)]
From state #132
 [term 0:REDUCE(with prod 78)] [term 4:REDUCE(with prod 78)]
 [term 5:REDUCE(with prod 78)] [term 6:REDUCE(with prod 78)]
 [term 7:REDUCE(with prod 78)] [term 8:REDUCE(with prod 78)]
 [term 9:REDUCE(with prod 78)] [term 10:REDUCE(with prod 78)]
 [term 11:REDUCE(with prod 78)] [term 12:REDUCE(with prod 78)]
 [term 20:REDUCE(with prod 78)] [term 21:REDUCE(with prod 78)]
 [term 22:REDUCE(with prod 78)] [term 23:REDUCE(with prod 78)]
 [term 24:REDUCE(with prod 78)] [term 25:REDUCE(with prod 78)]
 [term 26:SHIFT(to state 57)] [term 27:SHIFT(to state 64)]
 [term 28:SHIFT(to state 65)] [term 29:SHIFT(to state 70)]
 [term 30:SHIFT(to state 59)] [term 31:SHIFT(to state 71)]
 [term 33:SHIFT(to state 55)] [term 34:SHIFT(to state 68)]
 [term 37:REDUCE(with prod 78)] [term 39:REDUCE(with prod 78)]
 [term 40:REDUCE(with prod 78)] [term 41:REDUCE(with prod 78)]
 [term 42:REDUCE(with prod 78)] [term 43:SHIFT(to state 72)]
 [term 44:REDUCE(with prod 78)] [term 45:REDUCE(with prod 78)]
 [term 46:REDUCE(with prod 78)] [term 47:REDUCE(with prod 78)]
 [term 50:REDUCE(with prod 78)] [term 52:REDUCE(with prod 78)]
 [term 53:SHIFT(to state 67)] [term 54:SHIFT(to state 69)]
 [term 56:REDUCE(with prod 78)] [term 57:REDUCE(with prod 78)]
 [term 58:REDUCE(with prod 78)] [term 59:SHIFT(to state 66)]
From state #133
 [term 0:REDUCE(with prod 73)] [term 4:REDUCE(with prod 73)]
 [term 5:REDUCE(with prod 73)] [term 6:REDUCE(with prod 73)]
 [term 7:REDUCE(with prod 73)] [term 8:REDUCE(with prod 73)]
 [term 9:REDUCE(with prod 73)] [term 10:REDUCE(with prod 73)]
 [term 11:REDUCE(with prod 73)] [term 12:REDUCE(with prod 73)]
 [term 20:REDUCE(with prod 73)] [term 21:REDUCE(with prod 73)]
 [term 22:REDUCE(with prod 73)] [term 23:REDUCE(with prod 73)]
 [term 24:REDUCE(with prod 73)] [term 25:REDUCE(with prod 73)]
 [term 26:REDUCE(with prod 73)] [term 27:REDUCE(with prod 73)]
 [term 28:REDUCE(with prod 73)] [term 29:REDUCE(with prod 73)]
 [term 30:SHIFT(to state 59)] [term 31:SHIFT(to state 71)]
 [term 33:SHIFT(to state 55)] [term 34:SHIFT(to state 68)]
 [term 37:REDUCE(with prod 73)] [term 39:REDUCE(with prod 73)]
 [term 40:REDUCE(with prod 73)] [term 41:REDUCE(with prod 73)]
 [term 42:REDUCE(with prod 73)] [term 43:SHIFT(to state 72)]
 [term 44:REDUCE(with prod 73)] [term 45:REDUCE(with prod 73)]
 [term 46:REDUCE(with prod 73)] [term 47:REDUCE(with prod 73)]
 [term 50:REDUCE(with prod 73)] [term 52:REDUCE(with prod 73)]
 [term 53:SHIFT(to state 67)] [term 54:SHIFT(to state 69)]
 [term 56:REDUCE(with prod 73)] [term 57:REDUCE(with prod 73)]
 [term 58:REDUCE(with prod 73)] [term 59:SHIFT(to state 66)]
From state #134
 [term 0:REDUCE(with prod 79)] [term 4:REDUCE(with prod 79)]
 [term 5:REDUCE(with prod 79)] [term 6:REDUCE(with prod 79)]
 [term 7:REDUCE(with prod 79)] [term 8:REDUCE(with prod 79)]
 [term 9:REDUCE(with prod 79)] [term 10:REDUCE(with prod 79)]
 [term 11:REDUCE(with prod 79)] [term 12:REDUCE(with prod 79)]
 [term 20:REDUCE(with prod 79)] [term 21:REDUCE(with prod 79)]
 [term 22:REDUCE(with prod 79)] [term 23:REDUCE(with prod 79)]
 [term 24:SHIFT(to state 73)] [term 25:SHIFT(to state 58)]
 [term 26:SHIFT(to state 57)] [term 27:SHIFT(to state 64)]
 [term 28:SHIFT(to state 65)] [term 29:SHIFT(to state 70)]
 [term 30:SHIFT(to state 59)] [term 31:SHIFT(to state 71)]
 [term 33:SHIFT(to state 55)] [term 34:SHIFT(to state 68)]
 [term 37:REDUCE(with prod 79)] [term 39:REDUCE(with prod 79)]
 [term 40:REDUCE(with prod 79)] [term 41:REDUCE(with prod 79)]
 [term 42:REDUCE(with prod 79)] [term 43:SHIFT(to state 72)]
 [term 44:REDUCE(with prod 79)] [term 45:REDUCE(with prod 79)]
 [term 46:REDUCE(with prod 79)] [term 47:REDUCE(with prod 79)]
 [term 50:REDUCE(with prod 79)] [term 52:REDUCE(with prod 79)]
 [term 53:SHIFT(to state 67)] [term 54:SHIFT(to state 69)]
 [term 56:REDUCE(with prod 79)] [term 57:REDUCE(with prod 79)]
 [term 58:REDUCE(with prod 79)] [term 59:SHIFT(to state 66)]
From state #135
 [term 0:REDUCE(with prod 68)] [term 4:REDUCE(with prod 68)]
 [term 5:REDUCE(with prod 68)] [term 6:REDUCE(with prod 68)]
 [term 7:REDUCE(with prod 68)] [term 8:REDUCE(with prod 68)]
 [term 9:REDUCE(with prod 68)] [term 10:REDUCE(with prod 68)]
 [term 11:REDUCE(with prod 68)] [term 12:REDUCE(with prod 68)]
 [term 20:REDUCE(with prod 68)] [term 21:REDUCE(with prod 68)]
 [term 22:REDUCE(with prod 68)] [term 23:REDUCE(with prod 68)]
 [term 24:REDUCE(with prod 68)] [term 25:REDUCE(with prod 68)]
 [term 26:REDUCE(with prod 68)] [term 27:REDUCE(with prod 68)]
 [term 28:REDUCE(with prod 68)] [term 29:REDUCE(with prod 68)]
 [term 30:REDUCE(with prod 68)] [term 31:REDUCE(with prod 68)]
 [term 33:REDUCE(with prod 68)] [term 34:REDUCE(with prod 68)]
 [term 37:REDUCE(with prod 68)] [term 39:REDUCE(with prod 68)]
 [term 40:REDUCE(with prod 68)] [term 41:REDUCE(with prod 68)]
 [term 42:REDUCE(with prod 68)] [term 43:SHIFT(to state 72)]
 [term 44:REDUCE(with prod 68)] [term 45:REDUCE(with prod 68)]
 [term 46:REDUCE(with prod 68)] [term 47:REDUCE(with prod 68)]
 [term 50:REDUCE(with prod 68)] [term 52:REDUCE(with prod 68)]
 [term 53:SHIFT(to state 67)] [term 54:SHIFT(to state 69)]
 [term 56:REDUCE(with prod 68)] [term 57:REDUCE(with prod 68)]
 [term 58:REDUCE(with prod 68)] [term 59:SHIFT(to state 66)]
From state #136
 [term 0:REDUCE(with prod 58)] [term 4:REDUCE(with prod 58)]
 [term 5:REDUCE(with prod 58)] [term 6:REDUCE(with prod 58)]
 [term 7:REDUCE(with prod 58)] [term 8:REDUCE(with prod 58)]
 [term 9:REDUCE(with prod 58)] [term 10:REDUCE(with prod 58)]
 [term 11:REDUCE(with prod 58)] [term 12:REDUCE(with prod 58)]
 [term 20:REDUCE(with prod 58)] [term 21:REDUCE(with prod 58)]
 [term 22:REDUCE(with prod 58)] [term 23:REDUCE(with prod 58)]
 [term 24:REDUCE(with prod 58)] [term 25:REDUCE(with prod 58)]
 [term 26:REDUCE(with prod 58)] [term 27:REDUCE(with prod 58)]
 [term 28:REDUCE(with prod 58)] [term 29:REDUCE(with prod 58)]
 [term 30:REDUCE(with prod 58)] [term 31:REDUCE(with prod 58)]
 [term 33:REDUCE(with prod 58)] [term 34:REDUCE(with prod 58)]
 [term 37:REDUCE(with prod 58)] [term 39:REDUCE(with prod 58)]
 [term 40:REDUCE(with prod 58)] [term 41:REDUCE(with prod 58)]
 [term 42:REDUCE(with prod 58)] [term 43:REDUCE(with prod 58)]
 [term 44:REDUCE(with prod 58)] [term 45:REDUCE(with prod 58)]
 [term 46:REDUCE(with prod 58)] [term 47:REDUCE(with prod 58)]
 [term 50:REDUCE(with prod 58)] [term 52:REDUCE(with prod 58)]
 [term 53:REDUCE(with prod 58)] [term 54:REDUCE(with prod 58)]
 [term 56:REDUCE(with prod 58)] [term 57:REDUCE(with prod 58)]
 [term 58:REDUCE(with prod 58)] [term 59:REDUCE(with prod 58)]
From state #137
 [term 65:SHIFT(to state 12)]
From state #138
 [term 0:REDUCE(with prod 121)] [term 4:REDUCE(with prod 121)]
 [term 5:REDUCE(with prod 121)] [term 6:REDUCE(with prod 121)]
 [term 7:REDUCE(with prod 121)] [term 8:REDUCE(with prod 121)]
 [term 9:REDUCE(with prod 121)] [term 10:REDUCE(with prod 121)]
 [term 11:REDUCE(with prod 121)] [term 12:REDUCE(with prod 121)]
 [term 20:REDUCE(with prod 121)] [term 21:REDUCE(with prod 121)]
 [term 22:REDUCE(with prod 121)] [term 23:REDUCE(with prod 121)]
 [term 24:REDUCE(with prod 121)] [term 25:REDUCE(with prod 121)]
 [term 26:REDUCE(with prod 121)] [term 27:REDUCE(with prod 121)]
 [term 28:REDUCE(with prod 121)] [term 29:REDUCE(with prod 121)]
 [term 30:REDUCE(with prod 121)] [term 31:REDUCE(with prod 121)]
 [term 33:REDUCE(with prod 121)] [term 34:REDUCE(with prod 121)]
 [term 37:REDUCE(with prod 121)] [term 39:REDUCE(with prod 121)]
 [term 40:REDUCE(with prod 121)] [term 41:REDUCE(with prod 121)]
 [term 42:REDUCE(with prod 121)] [term 43:REDUCE(with prod 121)]
 [term 44:REDUCE(with prod 121)] [term 45:REDUCE(with prod 121)]
 [term 46:REDUCE(with prod 121)] [term 47:REDUCE(with prod 121)]
 [term 48:REDUCE(with prod 121)] [term 50:REDUCE(with prod 121)]
 [term 51:REDUCE(with prod 121)] [term 52:REDUCE(with prod 121)]
 [term 53:REDUCE(with prod 121)] [term 54:REDUCE(with prod 121)]
 [term 56:REDUCE(with prod 121)] [term 57:REDUCE(with prod 121)]
 [term 58:REDUCE(with prod 121)] [term 59:REDUCE(with prod 121)]
From state #139
 [term 37:SHIFT(to state 140)] [term 42:SHIFT(to state 33)]
From state #140
 [term 13:SHIFT(to state 20)] [term 14:SHIFT(to state 25)]
 [term 15:SHIFT(to state 22)] [term 16:SHIFT(to state 28)]
 [term 17:SHIFT(to state 38)] [term 31:SHIFT(to state 47)]
 [term 35:SHIFT(to state 40)] [term 36:SHIFT(to state 49)]
 [term 38:SHIFT(to state 43)] [term 53:SHIFT(to state 45)]
 [term 60:SHIFT(to state 51)] [term 61:SHIFT(to state 52)]
 [term 62:SHIFT(to state 44)] [term 63:SHIFT(to state 42)]
 [term 64:SHIFT(to state 48)] [term 65:SHIFT(to state 12)]
From state #141
 [term 0:REDUCE(with prod 83)] [term 4:REDUCE(with prod 83)]
 [term 5:REDUCE(with prod 83)] [term 6:REDUCE(with prod 83)]
 [term 7:REDUCE(with prod 83)] [term 8:REDUCE(with prod 83)]
 [term 9:REDUCE(with prod 83)] [term 10:REDUCE(with prod 83)]
 [term 11:REDUCE(with prod 83)] [term 12:REDUCE(with prod 83)]
 [term 20:REDUCE(with prod 83)] [term 21:REDUCE(with prod 83)]
 [term 22:REDUCE(with prod 83)] [term 23:REDUCE(with prod 83)]
 [term 24:REDUCE(with prod 83)] [term 25:REDUCE(with prod 83)]
 [term 26:REDUCE(with prod 83)] [term 27:REDUCE(with prod 83)]
 [term 28:REDUCE(with prod 83)] [term 29:REDUCE(with prod 83)]
 [term 30:REDUCE(with prod 83)] [term 31:REDUCE(with prod 83)]
 [term 33:REDUCE(with prod 83)] [term 34:REDUCE(with prod 83)]
 [term 37:REDUCE(with prod 83)] [term 39:REDUCE(with prod 83)]
 [term 40:REDUCE(with prod 83)] [term 41:REDUCE(with prod 83)]
 [term 42:REDUCE(with prod 83)] [term 43:REDUCE(with prod 83)]
 [term 44:REDUCE(with prod 83)] [term 45:REDUCE(with prod 83)]
 [term 46:REDUCE(with prod 83)] [term 47:REDUCE(with prod 83)]
 [term 50:REDUCE(with prod 83)] [term 52:REDUCE(with prod 83)]
 [term 53:SHIFT(to state 67)] [term 54:SHIFT(to state 69)]
 [term 56:REDUCE(with prod 83)] [term 57:REDUCE(with prod 83)]
 [term 58:REDUCE(with prod 83)] [term 59:REDUCE(with prod 83)]
From state #142
 [term 0:REDUCE(with prod 67)] [term 4:REDUCE(with prod 67)]
 [term 5:REDUCE(with prod 67)] [term 6:REDUCE(with prod 67)]
 [term 7:REDUCE(with prod 67)] [term 8:REDUCE(with prod 67)]
 [term 9:REDUCE(with prod 67)] [term 10:REDUCE(with prod 67)]
 [term 11:REDUCE(with prod 67)] [term 12:REDUCE(with prod 67)]
 [term 20:REDUCE(with prod 67)] [term 21:REDUCE(with prod 67)]
 [term 22:REDUCE(with prod 67)] [term 23:REDUCE(with prod 67)]
 [term 24:REDUCE(with prod 67)] [term 25:REDUCE(with prod 67)]
 [term 26:REDUCE(with prod 67)] [term 27:REDUCE(with prod 67)]
 [term 28:REDUCE(with prod 67)] [term 29:REDUCE(with prod 67)]
 [term 30:REDUCE(with prod 67)] [term 31:REDUCE(with prod 67)]
 [term 33:REDUCE(with prod 67)] [term 34:REDUCE(with prod 67)]
 [term 37:REDUCE(with prod 67)] [term 39:REDUCE(with prod 67)]
 [term 40:REDUCE(with prod 67)] [term 41:REDUCE(with prod 67)]
 [term 42:REDUCE(with prod 67)] [term 43:SHIFT(to state 72)]
 [term 44:REDUCE(with prod 67)] [term 45:REDUCE(with prod 67)]
 [term 46:REDUCE(with prod 67)] [term 47:REDUCE(with prod 67)]
 [term 50:REDUCE(with prod 67)] [term 52:REDUCE(with prod 67)]
 [term 53:SHIFT(to state 67)] [term 54:SHIFT(to state 69)]
 [term 56:REDUCE(with prod 67)] [term 57:REDUCE(with prod 67)]
 [term 58:REDUCE(with prod 67)] [term 59:SHIFT(to state 66)]
From state #143
 [term 20:SHIFT(to state 63)] [term 21:SHIFT(to state 56)]
 [term 22:SHIFT(to state 60)] [term 23:SHIFT(to state 74)]
 [term 24:SHIFT(to state 73)] [term 25:SHIFT(to state 58)]
 [term 26:SHIFT(to state 57)] [term 27:SHIFT(to state 64)]
 [term 28:SHIFT(to state 65)] [term 29:SHIFT(to state 70)]
 [term 30:SHIFT(to state 59)] [term 31:SHIFT(to state 71)]
 [term 33:SHIFT(to state 55)] [term 34:SHIFT(to state 68)]
 [term 43:SHIFT(to state 72)] [term 47:SHIFT(to state 62)]
 [term 52:SHIFT(to state 61)] [term 53:SHIFT(to state 67)]
 [term 54:SHIFT(to state 69)] [term 56:SHIFT(to state 144)]
 [term 59:SHIFT(to state 66)]
From state #144
 [term 0:REDUCE(with prod 57)] [term 4:REDUCE(with prod 57)]
 [term 5:REDUCE(with prod 57)] [term 6:REDUCE(with prod 57)]
 [term 7:REDUCE(with prod 57)] [term 8:REDUCE(with prod 57)]
 [term 9:REDUCE(with prod 57)] [term 10:REDUCE(with prod 57)]
 [term 11:REDUCE(with prod 57)] [term 12:REDUCE(with prod 57)]
 [term 20:REDUCE(with prod 57)] [term 21:REDUCE(with prod 57)]
 [term 22:REDUCE(with prod 57)] [term 23:REDUCE(with prod 57)]
 [term 24:REDUCE(with prod 57)] [term 25:REDUCE(with prod 57)]
 [term 26:REDUCE(with prod 57)] [term 27:REDUCE(with prod 57)]
 [term 28:REDUCE(with prod 57)] [term 29:REDUCE(with prod 57)]
 [term 30:REDUCE(with prod 57)] [term 31:REDUCE(with prod 57)]
 [term 33:REDUCE(with prod 57)] [term 34:REDUCE(with prod 57)]
 [term 37:REDUCE(with prod 57)] [term 39:REDUCE(with prod 57)]
 [term 40:REDUCE(with prod 57)] [term 41:REDUCE(with prod 57)]
 [term 42:REDUCE(with prod 57)] [term 43:REDUCE(with prod 57)]
 [term 44:REDUCE(with prod 57)] [term 45:REDUCE(with prod 57)]
 [term 46:REDUCE(with prod 57)] [term 47:REDUCE(with prod 57)]
 [term 50:REDUCE(with prod 57)] [term 52:REDUCE(with prod 57)]
 [term 53:REDUCE(with prod 57)] [term 54:REDUCE(with prod 57)]
 [term 56:REDUCE(with prod 57)] [term 57:REDUCE(with prod 57)]
 [term 58:REDUCE(with prod 57)] [term 59:REDUCE(with prod 57)]
From state #145
 [term 20:SHIFT(to state 63)] [term 21:SHIFT(to state 56)]
 [term 22:SHIFT(to state 60)] [term 23:SHIFT(to state 74)]
 [term 24:SHIFT(to state 73)] [term 25:SHIFT(to state 58)]
 [term 26:SHIFT(to state 57)] [term 27:SHIFT(to state 64)]
 [term 28:SHIFT(to state 65)] [term 29:SHIFT(to state 70)]
 [term 30:SHIFT(to state 59)] [term 31:SHIFT(to state 71)]
 [term 33:SHIFT(to state 55)] [term 34:SHIFT(to state 68)]
 [term 39:SHIFT(to state 146)] [term 43:SHIFT(to state 72)]
 [term 47:SHIFT(to state 62)] [term 52:SHIFT(to state 61)]
 [term 53:SHIFT(to state 67)] [term 54:SHIFT(to state 69)]
 [term 59:SHIFT(to state 66)]
From state #146
 [term 13:SHIFT(to state 20)] [term 14:SHIFT(to state 25)]
 [term 15:SHIFT(to state 22)] [term 16:SHIFT(to state 28)]
 [term 17:SHIFT(to state 38)] [term 31:SHIFT(to state 47)]
 [term 35:SHIFT(to state 40)] [term 36:SHIFT(to state 49)]
 [term 38:SHIFT(to state 43)] [term 53:SHIFT(to state 45)]
 [term 60:SHIFT(to state 51)] [term 61:SHIFT(to state 52)]
 [term 62:SHIFT(to state 44)] [term 63:SHIFT(to state 42)]
 [term 64:SHIFT(to state 48)] [term 65:SHIFT(to state 12)]
From state #147
 [term 20:SHIFT(to state 63)] [term 21:SHIFT(to state 56)]
 [term 22:SHIFT(to state 60)] [term 23:SHIFT(to state 74)]
 [term 24:SHIFT(to state 73)] [term 25:SHIFT(to state 58)]
 [term 26:SHIFT(to state 57)] [term 27:SHIFT(to state 64)]
 [term 28:SHIFT(to state 65)] [term 29:SHIFT(to state 70)]
 [term 30:SHIFT(to state 59)] [term 31:SHIFT(to state 71)]
 [term 33:SHIFT(to state 55)] [term 34:SHIFT(to state 68)]
 [term 40:SHIFT(to state 148)] [term 43:SHIFT(to state 72)]
 [term 47:SHIFT(to state 62)] [term 52:SHIFT(to state 61)]
 [term 53:SHIFT(to state 67)] [term 54:SHIFT(to state 69)]
 [term 59:SHIFT(to state 66)]
From state #148
 [term 13:SHIFT(to state 20)] [term 14:SHIFT(to state 25)]
 [term 15:SHIFT(to state 22)] [term 16:SHIFT(to state 28)]
 [term 17:SHIFT(to state 38)] [term 31:SHIFT(to state 47)]
 [term 35:SHIFT(to state 40)] [term 36:SHIFT(to state 49)]
 [term 38:SHIFT(to state 43)] [term 53:SHIFT(to state 45)]
 [term 60:SHIFT(to state 51)] [term 61:SHIFT(to state 52)]
 [term 62:SHIFT(to state 44)] [term 63:SHIFT(to state 42)]
 [term 64:SHIFT(to state 48)] [term 65:SHIFT(to state 12)]
From state #149
 [term 20:SHIFT(to state 63)] [term 21:SHIFT(to state 56)]
 [term 22:SHIFT(to state 60)] [term 23:SHIFT(to state 74)]
 [term 24:SHIFT(to state 73)] [term 25:SHIFT(to state 58)]
 [term 26:SHIFT(to state 57)] [term 27:SHIFT(to state 64)]
 [term 28:SHIFT(to state 65)] [term 29:SHIFT(to state 70)]
 [term 30:SHIFT(to state 59)] [term 31:SHIFT(to state 71)]
 [term 33:SHIFT(to state 55)] [term 34:SHIFT(to state 68)]
 [term 41:SHIFT(to state 150)] [term 43:SHIFT(to state 72)]
 [term 47:SHIFT(to state 62)] [term 52:SHIFT(to state 61)]
 [term 53:SHIFT(to state 67)] [term 54:SHIFT(to state 69)]
 [term 59:SHIFT(to state 66)]
From state #150
 [term 0:REDUCE(with prod 72)] [term 4:REDUCE(with prod 72)]
 [term 5:REDUCE(with prod 72)] [term 6:REDUCE(with prod 72)]
 [term 7:REDUCE(with prod 72)] [term 8:REDUCE(with prod 72)]
 [term 9:REDUCE(with prod 72)] [term 10:REDUCE(with prod 72)]
 [term 11:REDUCE(with prod 72)] [term 12:REDUCE(with prod 72)]
 [term 20:REDUCE(with prod 72)] [term 21:REDUCE(with prod 72)]
 [term 22:REDUCE(with prod 72)] [term 23:REDUCE(with prod 72)]
 [term 24:REDUCE(with prod 72)] [term 25:REDUCE(with prod 72)]
 [term 26:REDUCE(with prod 72)] [term 27:REDUCE(with prod 72)]
 [term 28:REDUCE(with prod 72)] [term 29:REDUCE(with prod 72)]
 [term 30:REDUCE(with prod 72)] [term 31:REDUCE(with prod 72)]
 [term 33:REDUCE(with prod 72)] [term 34:REDUCE(with prod 72)]
 [term 37:REDUCE(with prod 72)] [term 39:REDUCE(with prod 72)]
 [term 40:REDUCE(with prod 72)] [term 41:REDUCE(with prod 72)]
 [term 42:REDUCE(with prod 72)] [term 43:REDUCE(with prod 72)]
 [term 44:REDUCE(with prod 72)] [term 45:REDUCE(with prod 72)]
 [term 46:REDUCE(with prod 72)] [term 47:REDUCE(with prod 72)]
 [term 50:REDUCE(with prod 72)] [term 52:REDUCE(with prod 72)]
 [term 53:REDUCE(with prod 72)] [term 54:REDUCE(with prod 72)]
 [term 56:REDUCE(with prod 72)] [term 57:REDUCE(with prod 72)]
 [term 58:REDUCE(with prod 72)] [term 59:REDUCE(with prod 72)]
From state #151
 [term 13:SHIFT(to state 20)] [term 14:SHIFT(to state 25)]
 [term 15:SHIFT(to state 22)] [term 16:SHIFT(to state 28)]
 [term 17:SHIFT(to state 38)] [term 31:SHIFT(to state 47)]
 [term 35:SHIFT(to state 40)] [term 36:SHIFT(to state 49)]
 [term 38:SHIFT(to state 43)] [term 53:SHIFT(to state 45)]
 [term 58:SHIFT(to state 156)] [term 60:SHIFT(to state 51)]
 [term 61:SHIFT(to state 52)] [term 62:SHIFT(to state 44)]
 [term 63:SHIFT(to state 42)] [term 64:SHIFT(to state 48)]
 [term 65:SHIFT(to state 12)]
From state #152
 [term 42:REDUCE(with prod 112)] [term 58:REDUCE(with prod 112)]
From state #153
 [term 42:REDUCE(with prod 109)] [term 58:REDUCE(with prod 109)]
From state #154
 [term 42:SHIFT(to state 159)] [term 58:SHIFT(to state 160)]
From state #155
 [term 20:SHIFT(to state 63)] [term 21:SHIFT(to state 56)]
 [term 22:SHIFT(to state 60)] [term 23:SHIFT(to state 74)]
 [term 24:SHIFT(to state 73)] [term 25:SHIFT(to state 58)]
 [term 26:SHIFT(to state 57)] [term 27:SHIFT(to state 64)]
 [term 28:SHIFT(to state 65)] [term 29:SHIFT(to state 70)]
 [term 30:SHIFT(to state 59)] [term 31:SHIFT(to state 71)]
 [term 33:SHIFT(to state 55)] [term 34:SHIFT(to state 68)]
 [term 42:REDUCE(with prod 111)] [term 43:SHIFT(to state 72)]
 [term 47:SHIFT(to state 62)] [term 50:SHIFT(to state 157)]
 [term 52:SHIFT(to state 61)] [term 53:SHIFT(to state 67)]
 [term 54:SHIFT(to state 69)] [term 58:REDUCE(with prod 111)]
 [term 59:SHIFT(to state 66)]
From state #156
 [term 0:REDUCE(with prod 104)] [term 4:REDUCE(with prod 104)]
 [term 5:REDUCE(with prod 104)] [term 6:REDUCE(with prod 104)]
 [term 7:REDUCE(with prod 104)] [term 8:REDUCE(with prod 104)]
 [term 9:REDUCE(with prod 104)] [term 10:REDUCE(with prod 104)]
 [term 11:REDUCE(with prod 104)] [term 12:REDUCE(with prod 104)]
 [term 20:REDUCE(with prod 104)] [term 21:REDUCE(with prod 104)]
 [term 22:REDUCE(with prod 104)] [term 23:REDUCE(with prod 104)]
 [term 24:REDUCE(with prod 104)] [term 25:REDUCE(with prod 104)]
 [term 26:REDUCE(with prod 104)] [term 27:REDUCE(with prod 104)]
 [term 28:REDUCE(with prod 104)] [term 29:REDUCE(with prod 104)]
 [term 30:REDUCE(with prod 104)] [term 31:REDUCE(with prod 104)]
 [term 33:REDUCE(with prod 104)] [term 34:REDUCE(with prod 104)]
 [term 37:REDUCE(with prod 104)] [term 39:REDUCE(with prod 104)]
 [term 40:REDUCE(with prod 104)] [term 41:REDUCE(with prod 104)]
 [term 42:REDUCE(with prod 104)] [term 43:REDUCE(with prod 104)]
 [term 44:REDUCE(with prod 104)] [term 45:REDUCE(with prod 104)]
 [term 46:REDUCE(with prod 104)] [term 47:REDUCE(with prod 104)]
 [term 50:REDUCE(with prod 104)] [term 52:REDUCE(with prod 104)]
 [term 53:REDUCE(with prod 104)] [term 54:REDUCE(with prod 104)]
 [term 56:REDUCE(with prod 104)] [term 57:REDUCE(with prod 104)]
 [term 58:REDUCE(with prod 104)] [term 59:REDUCE(with prod 104)]
From state #157
 [term 13:SHIFT(to state 20)] [term 14:SHIFT(to state 25)]
 [term 15:SHIFT(to state 22)] [term 16:SHIFT(to state 28)]
 [term 17:SHIFT(to state 38)] [term 31:SHIFT(to state 47)]
 [term 35:SHIFT(to state 40)] [term 36:SHIFT(to state 49)]
 [term 38:SHIFT(to state 43)] [term 53:SHIFT(to state 45)]
 [term 60:SHIFT(to state 51)] [term 61:SHIFT(to state 52)]
 [term 62:SHIFT(to state 44)] [term 63:SHIFT(to state 42)]
 [term 64:SHIFT(to state 48)] [term 65:SHIFT(to state 12)]
From state #158
 [term 20:SHIFT(to state 63)] [term 21:SHIFT(to state 56)]
 [term 22:SHIFT(to state 60)] [term 23:SHIFT(to state 74)]
 [term 24:SHIFT(to state 73)] [term 25:SHIFT(to state 58)]
 [term 26:SHIFT(to state 57)] [term 27:SHIFT(to state 64)]
 [term 28:SHIFT(to state 65)] [term 29:SHIFT(to state 70)]
 [term 30:SHIFT(to state 59)] [term 31:SHIFT(to state 71)]
 [term 33:SHIFT(to state 55)] [term 34:SHIFT(to state 68)]
 [term 42:REDUCE(with prod 113)] [term 43:SHIFT(to state 72)]
 [term 47:SHIFT(to state 62)] [term 52:SHIFT(to state 61)]
 [term 53:SHIFT(to state 67)] [term 54:SHIFT(to state 69)]
 [term 58:REDUCE(with prod 113)] [term 59:SHIFT(to state 66)]
From state #159
 [term 13:SHIFT(to state 20)] [term 14:SHIFT(to state 25)]
 [term 15:SHIFT(to state 22)] [term 16:SHIFT(to state 28)]
 [term 17:SHIFT(to state 38)] [term 31:SHIFT(to state 47)]
 [term 35:SHIFT(to state 40)] [term 36:SHIFT(to state 49)]
 [term 38:SHIFT(to state 43)] [term 53:SHIFT(to state 45)]
 [term 60:SHIFT(to state 51)] [term 61:SHIFT(to state 52)]
 [term 62:SHIFT(to state 44)] [term 63:SHIFT(to state 42)]
 [term 64:SHIFT(to state 48)] [term 65:SHIFT(to state 12)]
From state #160
 [term 0:REDUCE(with prod 103)] [term 4:REDUCE(with prod 103)]
 [term 5:REDUCE(with prod 103)] [term 6:REDUCE(with prod 103)]
 [term 7:REDUCE(with prod 103)] [term 8:REDUCE(with prod 103)]
 [term 9:REDUCE(with prod 103)] [term 10:REDUCE(with prod 103)]
 [term 11:REDUCE(with prod 103)] [term 12:REDUCE(with prod 103)]
 [term 20:REDUCE(with prod 103)] [term 21:REDUCE(with prod 103)]
 [term 22:REDUCE(with prod 103)] [term 23:REDUCE(with prod 103)]
 [term 24:REDUCE(with prod 103)] [term 25:REDUCE(with prod 103)]
 [term 26:REDUCE(with prod 103)] [term 27:REDUCE(with prod 103)]
 [term 28:REDUCE(with prod 103)] [term 29:REDUCE(with prod 103)]
 [term 30:REDUCE(with prod 103)] [term 31:REDUCE(with prod 103)]
 [term 33:REDUCE(with prod 103)] [term 34:REDUCE(with prod 103)]
 [term 37:REDUCE(with prod 103)] [term 39:REDUCE(with prod 103)]
 [term 40:REDUCE(with prod 103)] [term 41:REDUCE(with prod 103)]
 [term 42:REDUCE(with prod 103)] [term 43:REDUCE(with prod 103)]
 [term 44:REDUCE(with prod 103)] [term 45:REDUCE(with prod 103)]
 [term 46:REDUCE(with prod 103)] [term 47:REDUCE(with prod 103)]
 [term 50:REDUCE(with prod 103)] [term 52:REDUCE(with prod 103)]
 [term 53:REDUCE(with prod 103)] [term 54:REDUCE(with prod 103)]
 [term 56:REDUCE(with prod 103)] [term 57:REDUCE(with prod 103)]
 [term 58:REDUCE(with prod 103)] [term 59:REDUCE(with prod 103)]
From state #161
 [term 42:REDUCE(with prod 110)] [term 58:REDUCE(with prod 110)]
From state #162
 [term 0:REDUCE(with prod 66)] [term 4:REDUCE(with prod 66)]
 [term 5:REDUCE(with prod 66)] [term 6:REDUCE(with prod 66)]
 [term 7:REDUCE(with prod 66)] [term 8:REDUCE(with prod 66)]
 [term 9:REDUCE(with prod 66)] [term 10:REDUCE(with prod 66)]
 [term 11:REDUCE(with prod 66)] [term 12:REDUCE(with prod 66)]
 [term 20:REDUCE(with prod 66)] [term 21:REDUCE(with prod 66)]
 [term 22:REDUCE(with prod 66)] [term 23:REDUCE(with prod 66)]
 [term 24:REDUCE(with prod 66)] [term 25:REDUCE(with prod 66)]
 [term 26:REDUCE(with prod 66)] [term 27:REDUCE(with prod 66)]
 [term 28:REDUCE(with prod 66)] [term 29:REDUCE(with prod 66)]
 [term 30:REDUCE(with prod 66)] [term 31:REDUCE(with prod 66)]
 [term 33:REDUCE(with prod 66)] [term 34:REDUCE(with prod 66)]
 [term 37:REDUCE(with prod 66)] [term 39:REDUCE(with prod 66)]
 [term 40:REDUCE(with prod 66)] [term 41:REDUCE(with prod 66)]
 [term 42:REDUCE(with prod 66)] [term 43:SHIFT(to state 72)]
 [term 44:REDUCE(with prod 66)] [term 45:REDUCE(with prod 66)]
 [term 46:REDUCE(with prod 66)] [term 47:REDUCE(with prod 66)]
 [term 50:REDUCE(with prod 66)] [term 52:REDUCE(with prod 66)]
 [term 53:SHIFT(to state 67)] [term 54:SHIFT(to state 69)]
 [term 56:REDUCE(with prod 66)] [term 57:REDUCE(with prod 66)]
 [term 58:REDUCE(with prod 66)] [term 59:SHIFT(to state 66)]
From state #163
 [term 65:SHIFT(to state 12)]
From state #164
 [term 42:SHIFT(to state 33)] [term 58:SHIFT(to state 165)]
From state #165
 [term 0:REDUCE(with prod 114)] [term 4:REDUCE(with prod 114)]
 [term 5:REDUCE(with prod 114)] [term 6:REDUCE(with prod 114)]
 [term 7:REDUCE(with prod 114)] [term 8:REDUCE(with prod 114)]
 [term 9:REDUCE(with prod 114)] [term 10:REDUCE(with prod 114)]
 [term 11:REDUCE(with prod 114)] [term 12:REDUCE(with prod 114)]
 [term 20:REDUCE(with prod 114)] [term 21:REDUCE(with prod 114)]
 [term 22:REDUCE(with prod 114)] [term 23:REDUCE(with prod 114)]
 [term 24:REDUCE(with prod 114)] [term 25:REDUCE(with prod 114)]
 [term 26:REDUCE(with prod 114)] [term 27:REDUCE(with prod 114)]
 [term 28:REDUCE(with prod 114)] [term 29:REDUCE(with prod 114)]
 [term 30:REDUCE(with prod 114)] [term 31:REDUCE(with prod 114)]
 [term 33:REDUCE(with prod 114)] [term 34:REDUCE(with prod 114)]
 [term 37:REDUCE(with prod 114)] [term 39:REDUCE(with prod 114)]
 [term 40:REDUCE(with prod 114)] [term 41:REDUCE(with prod 114)]
 [term 42:REDUCE(with prod 114)] [term 43:REDUCE(with prod 114)]
 [term 44:REDUCE(with prod 114)] [term 45:REDUCE(with prod 114)]
 [term 46:REDUCE(with prod 114)] [term 47:REDUCE(with prod 114)]
 [term 50:REDUCE(with prod 114)] [term 52:REDUCE(with prod 114)]
 [term 53:REDUCE(with prod 114)] [term 54:REDUCE(with prod 114)]
 [term 56:REDUCE(with prod 114)] [term 57:REDUCE(with prod 114)]
 [term 58:REDUCE(with prod 114)] [term 59:REDUCE(with prod 114)]
From state #166
 [term 13:SHIFT(to state 20)] [term 14:SHIFT(to state 25)]
 [term 15:SHIFT(to state 22)] [term 16:SHIFT(to state 28)]
 [term 18:SHIFT(to state 29)] [term 65:SHIFT(to state 12)]
From state #167
 [term 56:SHIFT(to state 168)]
From state #168
 [term 6:REDUCE(with prod 54)] [term 7:REDUCE(with prod 54)]
 [term 10:REDUCE(with prod 54)] [term 11:REDUCE(with prod 54)]
 [term 12:REDUCE(with prod 54)] [term 24:REDUCE(with prod 54)]
 [term 37:REDUCE(with prod 54)] [term 42:REDUCE(with prod 54)]
 [term 45:REDUCE(with prod 54)] [term 46:REDUCE(with prod 54)]
 [term 56:REDUCE(with prod 54)] [term 58:REDUCE(with prod 54)]
From state #169
 [term 20:SHIFT(to state 63)] [term 21:SHIFT(to state 56)]
 [term 22:SHIFT(to state 60)] [term 23:SHIFT(to state 74)]
 [term 24:REDUCE(with prod 49)] [term 25:SHIFT(to state 58)]
 [term 26:SHIFT(to state 57)] [term 27:SHIFT(to state 64)]
 [term 28:SHIFT(to state 65)] [term 29:SHIFT(to state 70)]
 [term 30:SHIFT(to state 59)] [term 31:SHIFT(to state 71)]
 [term 33:SHIFT(to state 55)] [term 34:SHIFT(to state 68)]
 [term 37:REDUCE(with prod 49)] [term 42:REDUCE(with prod 49)]
 [term 43:SHIFT(to state 72)] [term 45:REDUCE(with prod 49)]
 [term 46:REDUCE(with prod 49)] [term 47:SHIFT(to state 62)]
 [term 52:SHIFT(to state 61)] [term 53:SHIFT(to state 67)]
 [term 54:SHIFT(to state 69)] [term 56:REDUCE(with prod 49)]
 [term 58:REDUCE(with prod 49)] [term 59:SHIFT(to state 66)]
From state #170
 [term 13:SHIFT(to state 20)] [term 14:SHIFT(to state 25)]
 [term 15:SHIFT(to state 22)] [term 16:SHIFT(to state 28)]
 [term 18:SHIFT(to state 29)] [term 65:SHIFT(to state 12)]
From state #171
 [term 10:REDUCE(with prod 43)] [term 11:REDUCE(with prod 43)]
 [term 12:REDUCE(with prod 43)] [term 24:REDUCE(with prod 43)]
From state #172
 [term 10:REDUCE(with prod 42)] [term 11:REDUCE(with prod 42)]
 [term 12:REDUCE(with prod 42)] [term 24:REDUCE(with prod 42)]
 [term 44:SHIFT(to state 173)]
From state #173
 [term 13:SHIFT(to state 20)] [term 14:SHIFT(to state 25)]
 [term 15:SHIFT(to state 22)] [term 16:SHIFT(to state 28)]
 [term 18:SHIFT(to state 29)] [term 65:SHIFT(to state 12)]
From state #174
 [term 10:REDUCE(with prod 41)] [term 11:REDUCE(with prod 41)]
 [term 12:REDUCE(with prod 41)] [term 24:REDUCE(with prod 41)]
From state #175
 [term 44:SHIFT(to state 229)] [term 65:SHIFT(to state 12)]
From state #176
 [term 0:REDUCE(with prod 13)] [term 4:REDUCE(with prod 13)]
 [term 5:REDUCE(with prod 13)] [term 8:SHIFT(to state 211)]
 [term 9:SHIFT(to state 209)] [term 44:SHIFT(to state 210)]
From state #177
 [term 44:SHIFT(to state 194)]
From state #178
 [term 44:SHIFT(to state 190)] [term 65:SHIFT(to state 12)]
From state #179
 [term 65:SHIFT(to state 12)]
From state #180
 [term 8:REDUCE(with prod 121)] [term 9:REDUCE(with prod 121)]
 [term 51:REDUCE(with prod 121)] [term 53:SHIFT(to state 181)]
 [term 65:REDUCE(with prod 121)]
From state #181
 [term 56:SHIFT(to state 183)] [term 65:SHIFT(to state 12)]
From state #182
 [term 42:SHIFT(to state 33)] [term 56:SHIFT(to state 186)]
From state #183
 [term 10:REDUCE(with prod 40)] [term 11:REDUCE(with prod 40)]
 [term 12:REDUCE(with prod 40)] [term 24:REDUCE(with prod 40)]
 [term 44:SHIFT(to state 184)]
From state #184
 [term 13:SHIFT(to state 20)] [term 14:SHIFT(to state 25)]
 [term 15:SHIFT(to state 22)] [term 16:SHIFT(to state 28)]
 [term 18:SHIFT(to state 29)] [term 65:SHIFT(to state 12)]
From state #185
 [term 10:REDUCE(with prod 39)] [term 11:REDUCE(with prod 39)]
 [term 12:REDUCE(with prod 39)] [term 24:REDUCE(with prod 39)]
From state #186
 [term 10:REDUCE(with prod 38)] [term 11:REDUCE(with prod 38)]
 [term 12:REDUCE(with prod 38)] [term 24:REDUCE(with prod 38)]
 [term 44:SHIFT(to state 187)]
From state #187
 [term 13:SHIFT(to state 20)] [term 14:SHIFT(to state 25)]
 [term 15:SHIFT(to state 22)] [term 16:SHIFT(to state 28)]
 [term 18:SHIFT(to state 29)] [term 65:SHIFT(to state 12)]
From state #188
 [term 10:REDUCE(with prod 37)] [term 11:REDUCE(with prod 37)]
 [term 12:REDUCE(with prod 37)] [term 24:REDUCE(with prod 37)]
From state #189
 [term 44:SHIFT(to state 192)]
From state #190
 [term 13:SHIFT(to state 20)] [term 14:SHIFT(to state 25)]
 [term 15:SHIFT(to state 22)] [term 16:SHIFT(to state 28)]
 [term 17:SHIFT(to state 38)] [term 31:SHIFT(to state 47)]
 [term 35:SHIFT(to state 40)] [term 36:SHIFT(to state 49)]
 [term 38:SHIFT(to state 43)] [term 53:SHIFT(to state 45)]
 [term 60:SHIFT(to state 51)] [term 61:SHIFT(to state 52)]
 [term 62:SHIFT(to state 44)] [term 63:SHIFT(to state 42)]
 [term 64:SHIFT(to state 48)] [term 65:SHIFT(to state 12)]
From state #191
 [term 0:REDUCE(with prod 15)] [term 4:REDUCE(with prod 15)]
 [term 5:REDUCE(with prod 15)] [term 8:REDUCE(with prod 15)]
 [term 9:REDUCE(with prod 15)] [term 20:SHIFT(to state 63)]
 [term 21:SHIFT(to state 56)] [term 22:SHIFT(to state 60)]
 [term 23:SHIFT(to state 74)] [term 24:SHIFT(to state 73)]
 [term 25:SHIFT(to state 58)] [term 26:SHIFT(to state 57)]
 [term 27:SHIFT(to state 64)] [term 28:SHIFT(to state 65)]
 [term 29:SHIFT(to state 70)] [term 30:SHIFT(to state 59)]
 [term 31:SHIFT(to state 71)] [term 33:SHIFT(to state 55)]
 [term 34:SHIFT(to state 68)] [term 43:SHIFT(to state 72)]
 [term 44:REDUCE(with prod 15)] [term 47:SHIFT(to state 62)]
 [term 52:SHIFT(to state 61)] [term 53:SHIFT(to state 67)]
 [term 54:SHIFT(to state 69)] [term 59:SHIFT(to state 66)]
From state #192
 [term 13:SHIFT(to state 20)] [term 14:SHIFT(to state 25)]
 [term 15:SHIFT(to state 22)] [term 16:SHIFT(to state 28)]
 [term 17:SHIFT(to state 38)] [term 31:SHIFT(to state 47)]
 [term 35:SHIFT(to state 40)] [term 36:SHIFT(to state 49)]
 [term 38:SHIFT(to state 43)] [term 53:SHIFT(to state 45)]
 [term 60:SHIFT(to state 51)] [term 61:SHIFT(to state 52)]
 [term 62:SHIFT(to state 44)] [term 63:SHIFT(to state 42)]
 [term 64:SHIFT(to state 48)] [term 65:SHIFT(to state 12)]
From state #193
 [term 0:REDUCE(with prod 14)] [term 4:REDUCE(with prod 14)]
 [term 5:REDUCE(with prod 14)] [term 8:REDUCE(with prod 14)]
 [term 9:REDUCE(with prod 14)] [term 20:SHIFT(to state 63)]
 [term 21:SHIFT(to state 56)] [term 22:SHIFT(to state 60)]
 [term 23:SHIFT(to state 74)] [term 24:SHIFT(to state 73)]
 [term 25:SHIFT(to state 58)] [term 26:SHIFT(to state 57)]
 [term 27:SHIFT(to state 64)] [term 28:SHIFT(to state 65)]
 [term 29:SHIFT(to state 70)] [term 30:SHIFT(to state 59)]
 [term 31:SHIFT(to state 71)] [term 33:SHIFT(to state 55)]
 [term 34:SHIFT(to state 68)] [term 43:SHIFT(to state 72)]
 [term 44:REDUCE(with prod 14)] [term 47:SHIFT(to state 62)]
 [term 52:SHIFT(to state 61)] [term 53:SHIFT(to state 67)]
 [term 54:SHIFT(to state 69)] [term 59:SHIFT(to state 66)]
From state #194
 [term 13:SHIFT(to state 20)] [term 14:SHIFT(to state 25)]
 [term 15:SHIFT(to state 22)] [term 16:SHIFT(to state 28)]
 [term 18:SHIFT(to state 29)] [term 65:SHIFT(to state 12)]
From state #195
 [term 6:SHIFT(to state 196)] [term 7:SHIFT(to state 198)]
From state #196
 [term 44:SHIFT(to state 207)]
From state #197
 [term 0:REDUCE(with prod 8)] [term 4:REDUCE(with prod 8)]
 [term 5:REDUCE(with prod 8)] [term 6:SHIFT(to state 201)]
 [term 7:SHIFT(to state 202)]
From state #198
 [term 44:SHIFT(to state 199)]
From state #199
 [term 13:SHIFT(to state 20)] [term 14:SHIFT(to state 25)]
 [term 15:SHIFT(to state 22)] [term 16:SHIFT(to state 28)]
 [term 17:SHIFT(to state 38)] [term 31:SHIFT(to state 47)]
 [term 35:SHIFT(to state 40)] [term 36:SHIFT(to state 49)]
 [term 38:SHIFT(to state 43)] [term 53:SHIFT(to state 45)]
 [term 60:SHIFT(to state 51)] [term 61:SHIFT(to state 52)]
 [term 62:SHIFT(to state 44)] [term 63:SHIFT(to state 42)]
 [term 64:SHIFT(to state 48)] [term 65:SHIFT(to state 12)]
From state #200
 [term 0:REDUCE(with prod 10)] [term 4:REDUCE(with prod 10)]
 [term 5:REDUCE(with prod 10)] [term 6:REDUCE(with prod 10)]
 [term 7:REDUCE(with prod 10)] [term 20:SHIFT(to state 63)]
 [term 21:SHIFT(to state 56)] [term 22:SHIFT(to state 60)]
 [term 23:SHIFT(to state 74)] [term 24:SHIFT(to state 73)]
 [term 25:SHIFT(to state 58)] [term 26:SHIFT(to state 57)]
 [term 27:SHIFT(to state 64)] [term 28:SHIFT(to state 65)]
 [term 29:SHIFT(to state 70)] [term 30:SHIFT(to state 59)]
 [term 31:SHIFT(to state 71)] [term 33:SHIFT(to state 55)]
 [term 34:SHIFT(to state 68)] [term 43:SHIFT(to state 72)]
 [term 47:SHIFT(to state 62)] [term 52:SHIFT(to state 61)]
 [term 53:SHIFT(to state 67)] [term 54:SHIFT(to state 69)]
 [term 59:SHIFT(to state 66)]
From state #201
 [term 44:SHIFT(to state 205)]
From state #202
 [term 44:SHIFT(to state 203)]
From state #203
 [term 13:SHIFT(to state 20)] [term 14:SHIFT(to state 25)]
 [term 15:SHIFT(to state 22)] [term 16:SHIFT(to state 28)]
 [term 17:SHIFT(to state 38)] [term 31:SHIFT(to state 47)]
 [term 35:SHIFT(to state 40)] [term 36:SHIFT(to state 49)]
 [term 38:SHIFT(to state 43)] [term 53:SHIFT(to state 45)]
 [term 60:SHIFT(to state 51)] [term 61:SHIFT(to state 52)]
 [term 62:SHIFT(to state 44)] [term 63:SHIFT(to state 42)]
 [term 64:SHIFT(to state 48)] [term 65:SHIFT(to state 12)]
From state #204
 [term 0:REDUCE(with prod 12)] [term 4:REDUCE(with prod 12)]
 [term 5:REDUCE(with prod 12)] [term 6:REDUCE(with prod 12)]
 [term 7:REDUCE(with prod 12)] [term 20:SHIFT(to state 63)]
 [term 21:SHIFT(to state 56)] [term 22:SHIFT(to state 60)]
 [term 23:SHIFT(to state 74)] [term 24:SHIFT(to state 73)]
 [term 25:SHIFT(to state 58)] [term 26:SHIFT(to state 57)]
 [term 27:SHIFT(to state 64)] [term 28:SHIFT(to state 65)]
 [term 29:SHIFT(to state 70)] [term 30:SHIFT(to state 59)]
 [term 31:SHIFT(to state 71)] [term 33:SHIFT(to state 55)]
 [term 34:SHIFT(to state 68)] [term 43:SHIFT(to state 72)]
 [term 47:SHIFT(to state 62)] [term 52:SHIFT(to state 61)]
 [term 53:SHIFT(to state 67)] [term 54:SHIFT(to state 69)]
 [term 59:SHIFT(to state 66)]
From state #205
 [term 13:SHIFT(to state 20)] [term 14:SHIFT(to state 25)]
 [term 15:SHIFT(to state 22)] [term 16:SHIFT(to state 28)]
 [term 17:SHIFT(to state 38)] [term 31:SHIFT(to state 47)]
 [term 35:SHIFT(to state 40)] [term 36:SHIFT(to state 49)]
 [term 38:SHIFT(to state 43)] [term 53:SHIFT(to state 45)]
 [term 60:SHIFT(to state 51)] [term 61:SHIFT(to state 52)]
 [term 62:SHIFT(to state 44)] [term 63:SHIFT(to state 42)]
 [term 64:SHIFT(to state 48)] [term 65:SHIFT(to state 12)]
From state #206
 [term 0:REDUCE(with prod 11)] [term 4:REDUCE(with prod 11)]
 [term 5:REDUCE(with prod 11)] [term 6:REDUCE(with prod 11)]
 [term 7:REDUCE(with prod 11)] [term 20:SHIFT(to state 63)]
 [term 21:SHIFT(to state 56)] [term 22:SHIFT(to state 60)]
 [term 23:SHIFT(to state 74)] [term 24:SHIFT(to state 73)]
 [term 25:SHIFT(to state 58)] [term 26:SHIFT(to state 57)]
 [term 27:SHIFT(to state 64)] [term 28:SHIFT(to state 65)]
 [term 29:SHIFT(to state 70)] [term 30:SHIFT(to state 59)]
 [term 31:SHIFT(to state 71)] [term 33:SHIFT(to state 55)]
 [term 34:SHIFT(to state 68)] [term 43:SHIFT(to state 72)]
 [term 47:SHIFT(to state 62)] [term 52:SHIFT(to state 61)]
 [term 53:SHIFT(to state 67)] [term 54:SHIFT(to state 69)]
 [term 59:SHIFT(to state 66)]
From state #207
 [term 13:SHIFT(to state 20)] [term 14:SHIFT(to state 25)]
 [term 15:SHIFT(to state 22)] [term 16:SHIFT(to state 28)]
 [term 17:SHIFT(to state 38)] [term 31:SHIFT(to state 47)]
 [term 35:SHIFT(to state 40)] [term 36:SHIFT(to state 49)]
 [term 38:SHIFT(to state 43)] [term 53:SHIFT(to state 45)]
 [term 60:SHIFT(to state 51)] [term 61:SHIFT(to state 52)]
 [term 62:SHIFT(to state 44)] [term 63:SHIFT(to state 42)]
 [term 64:SHIFT(to state 48)] [term 65:SHIFT(to state 12)]
From state #208
 [term 0:REDUCE(with prod 9)] [term 4:REDUCE(with prod 9)]
 [term 5:REDUCE(with prod 9)] [term 6:REDUCE(with prod 9)]
 [term 7:REDUCE(with prod 9)] [term 20:SHIFT(to state 63)]
 [term 21:SHIFT(to state 56)] [term 22:SHIFT(to state 60)]
 [term 23:SHIFT(to state 74)] [term 24:SHIFT(to state 73)]
 [term 25:SHIFT(to state 58)] [term 26:SHIFT(to state 57)]
 [term 27:SHIFT(to state 64)] [term 28:SHIFT(to state 65)]
 [term 29:SHIFT(to state 70)] [term 30:SHIFT(to state 59)]
 [term 31:SHIFT(to state 71)] [term 33:SHIFT(to state 55)]
 [term 34:SHIFT(to state 68)] [term 43:SHIFT(to state 72)]
 [term 47:SHIFT(to state 62)] [term 52:SHIFT(to state 61)]
 [term 53:SHIFT(to state 67)] [term 54:SHIFT(to state 69)]
 [term 59:SHIFT(to state 66)]
From state #209
 [term 65:SHIFT(to state 12)]
From state #210
 [term 65:SHIFT(to state 12)]
From state #211
 [term 44:SHIFT(to state 212)] [term 65:SHIFT(to state 12)]
From state #212
 [term 13:SHIFT(to state 20)] [term 14:SHIFT(to state 25)]
 [term 15:SHIFT(to state 22)] [term 16:SHIFT(to state 28)]
 [term 17:SHIFT(to state 38)] [term 31:SHIFT(to state 47)]
 [term 35:SHIFT(to state 40)] [term 36:SHIFT(to state 49)]
 [term 38:SHIFT(to state 43)] [term 53:SHIFT(to state 45)]
 [term 60:SHIFT(to state 51)] [term 61:SHIFT(to state 52)]
 [term 62:SHIFT(to state 44)] [term 63:SHIFT(to state 42)]
 [term 64:SHIFT(to state 48)] [term 65:SHIFT(to state 12)]
From state #213
 [term 44:SHIFT(to state 214)]
From state #214
 [term 13:SHIFT(to state 20)] [term 14:SHIFT(to state 25)]
 [term 15:SHIFT(to state 22)] [term 16:SHIFT(to state 28)]
 [term 17:SHIFT(to state 38)] [term 31:SHIFT(to state 47)]
 [term 35:SHIFT(to state 40)] [term 36:SHIFT(to state 49)]
 [term 38:SHIFT(to state 43)] [term 53:SHIFT(to state 45)]
 [term 60:SHIFT(to state 51)] [term 61:SHIFT(to state 52)]
 [term 62:SHIFT(to state 44)] [term 63:SHIFT(to state 42)]
 [term 64:SHIFT(to state 48)] [term 65:SHIFT(to state 12)]
From state #215
 [term 0:REDUCE(with prod 18)] [term 4:REDUCE(with prod 18)]
 [term 5:REDUCE(with prod 18)] [term 8:REDUCE(with prod 18)]
 [term 9:REDUCE(with prod 18)] [term 20:SHIFT(to state 63)]
 [term 21:SHIFT(to state 56)] [term 22:SHIFT(to state 60)]
 [term 23:SHIFT(to state 74)] [term 24:SHIFT(to state 73)]
 [term 25:SHIFT(to state 58)] [term 26:SHIFT(to state 57)]
 [term 27:SHIFT(to state 64)] [term 28:SHIFT(to state 65)]
 [term 29:SHIFT(to state 70)] [term 30:SHIFT(to state 59)]
 [term 31:SHIFT(to state 71)] [term 33:SHIFT(to state 55)]
 [term 34:SHIFT(to state 68)] [term 43:SHIFT(to state 72)]
 [term 44:REDUCE(with prod 18)] [term 47:SHIFT(to state 62)]
 [term 52:SHIFT(to state 61)] [term 53:SHIFT(to state 67)]
 [term 54:SHIFT(to state 69)] [term 59:SHIFT(to state 66)]
From state #216
 [term 0:REDUCE(with prod 19)] [term 4:REDUCE(with prod 19)]
 [term 5:REDUCE(with prod 19)] [term 8:REDUCE(with prod 19)]
 [term 9:REDUCE(with prod 19)] [term 20:SHIFT(to state 63)]
 [term 21:SHIFT(to state 56)] [term 22:SHIFT(to state 60)]
 [term 23:SHIFT(to state 74)] [term 24:SHIFT(to state 73)]
 [term 25:SHIFT(to state 58)] [term 26:SHIFT(to state 57)]
 [term 27:SHIFT(to state 64)] [term 28:SHIFT(to state 65)]
 [term 29:SHIFT(to state 70)] [term 30:SHIFT(to state 59)]
 [term 31:SHIFT(to state 71)] [term 33:SHIFT(to state 55)]
 [term 34:SHIFT(to state 68)] [term 43:SHIFT(to state 72)]
 [term 44:REDUCE(with prod 19)] [term 47:SHIFT(to state 62)]
 [term 52:SHIFT(to state 61)] [term 53:SHIFT(to state 67)]
 [term 54:SHIFT(to state 69)] [term 59:SHIFT(to state 66)]
From state #217
 [term 24:SHIFT(to state 224)]
From state #218
 [term 0:REDUCE(with prod 21)] [term 4:REDUCE(with prod 21)]
 [term 5:REDUCE(with prod 21)] [term 8:REDUCE(with prod 21)]
 [term 9:REDUCE(with prod 21)] [term 44:REDUCE(with prod 21)]
From state #219
 [term 51:SHIFT(to state 179)]
From state #220
 [term 24:SHIFT(to state 18)] [term 44:SHIFT(to state 19)]
 [term 51:REDUCE(with prod 120)] [term 53:SHIFT(to state 13)]
From state #221
 [term 24:SHIFT(to state 222)]
From state #222
 [term 13:SHIFT(to state 20)] [term 14:SHIFT(to state 25)]
 [term 15:SHIFT(to state 22)] [term 16:SHIFT(to state 28)]
 [term 17:SHIFT(to state 38)] [term 31:SHIFT(to state 47)]
 [term 35:SHIFT(to state 40)] [term 36:SHIFT(to state 49)]
 [term 38:SHIFT(to state 43)] [term 53:SHIFT(to state 45)]
 [term 60:SHIFT(to state 51)] [term 61:SHIFT(to state 52)]
 [term 62:SHIFT(to state 44)] [term 63:SHIFT(to state 42)]
 [term 64:SHIFT(to state 48)] [term 65:SHIFT(to state 12)]
From state #223
 [term 0:REDUCE(with prod 22)] [term 4:REDUCE(with prod 22)]
 [term 5:REDUCE(with prod 22)] [term 8:REDUCE(with prod 22)]
 [term 9:REDUCE(with prod 22)] [term 20:SHIFT(to state 63)]
 [term 21:SHIFT(to state 56)] [term 22:SHIFT(to state 60)]
 [term 23:SHIFT(to state 74)] [term 24:SHIFT(to state 73)]
 [term 25:SHIFT(to state 58)] [term 26:SHIFT(to state 57)]
 [term 27:SHIFT(to state 64)] [term 28:SHIFT(to state 65)]
 [term 29:SHIFT(to state 70)] [term 30:SHIFT(to state 59)]
 [term 31:SHIFT(to state 71)] [term 33:SHIFT(to state 55)]
 [term 34:SHIFT(to state 68)] [term 43:SHIFT(to state 72)]
 [term 44:REDUCE(with prod 22)] [term 47:SHIFT(to state 62)]
 [term 52:SHIFT(to state 61)] [term 53:SHIFT(to state 67)]
 [term 54:SHIFT(to state 69)] [term 59:SHIFT(to state 66)]
From state #224
 [term 13:SHIFT(to state 20)] [term 14:SHIFT(to state 25)]
 [term 15:SHIFT(to state 22)] [term 16:SHIFT(to state 28)]
 [term 17:SHIFT(to state 38)] [term 31:SHIFT(to state 47)]
 [term 35:SHIFT(to state 40)] [term 36:SHIFT(to state 49)]
 [term 38:SHIFT(to state 43)] [term 53:SHIFT(to state 45)]
 [term 60:SHIFT(to state 51)] [term 61:SHIFT(to state 52)]
 [term 62:SHIFT(to state 44)] [term 63:SHIFT(to state 42)]
 [term 64:SHIFT(to state 48)] [term 65:SHIFT(to state 12)]
From state #225
 [term 0:REDUCE(with prod 23)] [term 4:REDUCE(with prod 23)]
 [term 5:REDUCE(with prod 23)] [term 8:REDUCE(with prod 23)]
 [term 9:REDUCE(with prod 23)] [term 20:SHIFT(to state 63)]
 [term 21:SHIFT(to state 56)] [term 22:SHIFT(to state 60)]
 [term 23:SHIFT(to state 74)] [term 24:SHIFT(to state 73)]
 [term 25:SHIFT(to state 58)] [term 26:SHIFT(to state 57)]
 [term 27:SHIFT(to state 64)] [term 28:SHIFT(to state 65)]
 [term 29:SHIFT(to state 70)] [term 30:SHIFT(to state 59)]
 [term 31:SHIFT(to state 71)] [term 33:SHIFT(to state 55)]
 [term 34:SHIFT(to state 68)] [term 43:SHIFT(to state 72)]
 [term 44:REDUCE(with prod 23)] [term 47:SHIFT(to state 62)]
 [term 52:SHIFT(to state 61)] [term 53:SHIFT(to state 67)]
 [term 54:SHIFT(to state 69)] [term 59:SHIFT(to state 66)]
From state #226
 [term 44:SHIFT(to state 227)]
From state #227
 [term 65:SHIFT(to state 12)]
From state #228
 [term 0:REDUCE(with prod 20)] [term 4:REDUCE(with prod 20)]
 [term 5:REDUCE(with prod 20)] [term 8:REDUCE(with prod 20)]
 [term 9:REDUCE(with prod 20)] [term 44:REDUCE(with prod 20)]
From state #229
 [term 65:SHIFT(to state 12)]
From state #230
 [term 44:SHIFT(to state 231)]
From state #231
 [term 65:SHIFT(to state 12)]
From state #232
 [term 0:REDUCE(with prod 16)] [term 4:REDUCE(with prod 16)]
 [term 5:REDUCE(with prod 16)] [term 8:REDUCE(with prod 16)]
 [term 9:REDUCE(with prod 16)] [term 44:REDUCE(with prod 16)]
From state #233
 [term 0:REDUCE(with prod 17)] [term 4:REDUCE(with prod 17)]
 [term 5:REDUCE(with prod 17)] [term 8:REDUCE(with prod 17)]
 [term 9:REDUCE(with prod 17)] [term 44:REDUCE(with prod 17)]
From state #234
 [term 44:SHIFT(to state 266)] [term 65:SHIFT(to state 12)]
From state #235
 [term 44:SHIFT(to state 262)] [term 65:SHIFT(to state 12)]
From state #236
 [term 0:REDUCE(with prod 24)] [term 4:REDUCE(with prod 24)]
 [term 5:REDUCE(with prod 24)] [term 10:SHIFT(to state 243)]
 [term 11:SHIFT(to state 245)] [term 12:SHIFT(to state 244)]
From state #237
 [term 44:SHIFT(to state 238)] [term 65:SHIFT(to state 12)]
From state #238
 [term 13:SHIFT(to state 20)] [term 14:SHIFT(to state 25)]
 [term 15:SHIFT(to state 22)] [term 16:SHIFT(to state 28)]
 [term 17:SHIFT(to state 38)] [term 31:SHIFT(to state 47)]
 [term 35:SHIFT(to state 40)] [term 36:SHIFT(to state 49)]
 [term 38:SHIFT(to state 43)] [term 53:SHIFT(to state 45)]
 [term 60:SHIFT(to state 51)] [term 61:SHIFT(to state 52)]
 [term 62:SHIFT(to state 44)] [term 63:SHIFT(to state 42)]
 [term 64:SHIFT(to state 48)] [term 65:SHIFT(to state 12)]
From state #239
 [term 44:SHIFT(to state 240)]
From state #240
 [term 13:SHIFT(to state 20)] [term 14:SHIFT(to state 25)]
 [term 15:SHIFT(to state 22)] [term 16:SHIFT(to state 28)]
 [term 17:SHIFT(to state 38)] [term 31:SHIFT(to state 47)]
 [term 35:SHIFT(to state 40)] [term 36:SHIFT(to state 49)]
 [term 38:SHIFT(to state 43)] [term 53:SHIFT(to state 45)]
 [term 60:SHIFT(to state 51)] [term 61:SHIFT(to state 52)]
 [term 62:SHIFT(to state 44)] [term 63:SHIFT(to state 42)]
 [term 64:SHIFT(to state 48)] [term 65:SHIFT(to state 12)]
From state #241
 [term 0:REDUCE(with prod 27)] [term 4:REDUCE(with prod 27)]
 [term 5:REDUCE(with prod 27)] [term 10:REDUCE(with prod 27)]
 [term 11:REDUCE(with prod 27)] [term 12:REDUCE(with prod 27)]
 [term 20:SHIFT(to state 63)] [term 21:SHIFT(to state 56)]
 [term 22:SHIFT(to state 60)] [term 23:SHIFT(to state 74)]
 [term 24:SHIFT(to state 73)] [term 25:SHIFT(to state 58)]
 [term 26:SHIFT(to state 57)] [term 27:SHIFT(to state 64)]
 [term 28:SHIFT(to state 65)] [term 29:SHIFT(to state 70)]
 [term 30:SHIFT(to state 59)] [term 31:SHIFT(to state 71)]
 [term 33:SHIFT(to state 55)] [term 34:SHIFT(to state 68)]
 [term 43:SHIFT(to state 72)] [term 47:SHIFT(to state 62)]
 [term 52:SHIFT(to state 61)] [term 53:SHIFT(to state 67)]
 [term 54:SHIFT(to state 69)] [term 59:SHIFT(to state 66)]
From state #242
 [term 0:REDUCE(with prod 28)] [term 4:REDUCE(with prod 28)]
 [term 5:REDUCE(with prod 28)] [term 10:REDUCE(with prod 28)]
 [term 11:REDUCE(with prod 28)] [term 12:REDUCE(with prod 28)]
 [term 20:SHIFT(to state 63)] [term 21:SHIFT(to state 56)]
 [term 22:SHIFT(to state 60)] [term 23:SHIFT(to state 74)]
 [term 24:SHIFT(to state 73)] [term 25:SHIFT(to state 58)]
 [term 26:SHIFT(to state 57)] [term 27:SHIFT(to state 64)]
 [term 28:SHIFT(to state 65)] [term 29:SHIFT(to state 70)]
 [term 30:SHIFT(to state 59)] [term 31:SHIFT(to state 71)]
 [term 33:SHIFT(to state 55)] [term 34:SHIFT(to state 68)]
 [term 43:SHIFT(to state 72)] [term 47:SHIFT(to state 62)]
 [term 52:SHIFT(to state 61)] [term 53:SHIFT(to state 67)]
 [term 54:SHIFT(to state 69)] [term 59:SHIFT(to state 66)]
From state #243
 [term 44:SHIFT(to state 257)] [term 65:SHIFT(to state 12)]
From state #244
 [term 44:SHIFT(to state 251)] [term 65:SHIFT(to state 12)]
From state #245
 [term 44:SHIFT(to state 247)] [term 65:SHIFT(to state 12)]
From state #246
 [term 44:SHIFT(to state 249)]
From state #247
 [term 13:SHIFT(to state 20)] [term 14:SHIFT(to state 25)]
 [term 15:SHIFT(to state 22)] [term 16:SHIFT(to state 28)]
 [term 17:SHIFT(to state 38)] [term 31:SHIFT(to state 47)]
 [term 35:SHIFT(to state 40)] [term 36:SHIFT(to state 49)]
 [term 38:SHIFT(to state 43)] [term 53:SHIFT(to state 45)]
 [term 60:SHIFT(to state 51)] [term 61:SHIFT(to state 52)]
 [term 62:SHIFT(to state 44)] [term 63:SHIFT(to state 42)]
 [term 64:SHIFT(to state 48)] [term 65:SHIFT(to state 12)]
From state #248
 [term 0:REDUCE(with prod 34)] [term 4:REDUCE(with prod 34)]
 [term 5:REDUCE(with prod 34)] [term 10:REDUCE(with prod 34)]
 [term 11:REDUCE(with prod 34)] [term 12:REDUCE(with prod 34)]
 [term 20:SHIFT(to state 63)] [term 21:SHIFT(to state 56)]
 [term 22:SHIFT(to state 60)] [term 23:SHIFT(to state 74)]
 [term 24:SHIFT(to state 73)] [term 25:SHIFT(to state 58)]
 [term 26:SHIFT(to state 57)] [term 27:SHIFT(to state 64)]
 [term 28:SHIFT(to state 65)] [term 29:SHIFT(to state 70)]
 [term 30:SHIFT(to state 59)] [term 31:SHIFT(to state 71)]
 [term 33:SHIFT(to state 55)] [term 34:SHIFT(to state 68)]
 [term 43:SHIFT(to state 72)] [term 47:SHIFT(to state 62)]
 [term 52:SHIFT(to state 61)] [term 53:SHIFT(to state 67)]
 [term 54:SHIFT(to state 69)] [term 59:SHIFT(to state 66)]
From state #249
 [term 13:SHIFT(to state 20)] [term 14:SHIFT(to state 25)]
 [term 15:SHIFT(to state 22)] [term 16:SHIFT(to state 28)]
 [term 17:SHIFT(to state 38)] [term 31:SHIFT(to state 47)]
 [term 35:SHIFT(to state 40)] [term 36:SHIFT(to state 49)]
 [term 38:SHIFT(to state 43)] [term 53:SHIFT(to state 45)]
 [term 60:SHIFT(to state 51)] [term 61:SHIFT(to state 52)]
 [term 62:SHIFT(to state 44)] [term 63:SHIFT(to state 42)]
 [term 64:SHIFT(to state 48)] [term 65:SHIFT(to state 12)]
From state #250
 [term 0:REDUCE(with prod 33)] [term 4:REDUCE(with prod 33)]
 [term 5:REDUCE(with prod 33)] [term 10:REDUCE(with prod 33)]
 [term 11:REDUCE(with prod 33)] [term 12:REDUCE(with prod 33)]
 [term 20:SHIFT(to state 63)] [term 21:SHIFT(to state 56)]
 [term 22:SHIFT(to state 60)] [term 23:SHIFT(to state 74)]
 [term 24:SHIFT(to state 73)] [term 25:SHIFT(to state 58)]
 [term 26:SHIFT(to state 57)] [term 27:SHIFT(to state 64)]
 [term 28:SHIFT(to state 65)] [term 29:SHIFT(to state 70)]
 [term 30:SHIFT(to state 59)] [term 31:SHIFT(to state 71)]
 [term 33:SHIFT(to state 55)] [term 34:SHIFT(to state 68)]
 [term 43:SHIFT(to state 72)] [term 47:SHIFT(to state 62)]
 [term 52:SHIFT(to state 61)] [term 53:SHIFT(to state 67)]
 [term 54:SHIFT(to state 69)] [term 59:SHIFT(to state 66)]
From state #251
 [term 13:SHIFT(to state 20)] [term 14:SHIFT(to state 25)]
 [term 15:SHIFT(to state 22)] [term 16:SHIFT(to state 28)]
 [term 17:SHIFT(to state 38)] [term 31:SHIFT(to state 47)]
 [term 35:SHIFT(to state 40)] [term 36:SHIFT(to state 49)]
 [term 38:SHIFT(to state 43)] [term 53:SHIFT(to state 45)]
 [term 60:SHIFT(to state 51)] [term 61:SHIFT(to state 52)]
 [term 62:SHIFT(to state 44)] [term 63:SHIFT(to state 42)]
 [term 64:SHIFT(to state 48)] [term 65:SHIFT(to state 12)]
From state #252
 [term 44:SHIFT(to state 253)]
From state #253
 [term 13:SHIFT(to state 20)] [term 14:SHIFT(to state 25)]
 [term 15:SHIFT(to state 22)] [term 16:SHIFT(to state 28)]
 [term 17:SHIFT(to state 38)] [term 31:SHIFT(to state 47)]
 [term 35:SHIFT(to state 40)] [term 36:SHIFT(to state 49)]
 [term 38:SHIFT(to state 43)] [term 53:SHIFT(to state 45)]
 [term 60:SHIFT(to state 51)] [term 61:SHIFT(to state 52)]
 [term 62:SHIFT(to state 44)] [term 63:SHIFT(to state 42)]
 [term 64:SHIFT(to state 48)] [term 65:SHIFT(to state 12)]
From state #254
 [term 0:REDUCE(with prod 35)] [term 4:REDUCE(with prod 35)]
 [term 5:REDUCE(with prod 35)] [term 10:REDUCE(with prod 35)]
 [term 11:REDUCE(with prod 35)] [term 12:REDUCE(with prod 35)]
 [term 20:SHIFT(to state 63)] [term 21:SHIFT(to state 56)]
 [term 22:SHIFT(to state 60)] [term 23:SHIFT(to state 74)]
 [term 24:SHIFT(to state 73)] [term 25:SHIFT(to state 58)]
 [term 26:SHIFT(to state 57)] [term 27:SHIFT(to state 64)]
 [term 28:SHIFT(to state 65)] [term 29:SHIFT(to state 70)]
 [term 30:SHIFT(to state 59)] [term 31:SHIFT(to state 71)]
 [term 33:SHIFT(to state 55)] [term 34:SHIFT(to state 68)]
 [term 43:SHIFT(to state 72)] [term 47:SHIFT(to state 62)]
 [term 52:SHIFT(to state 61)] [term 53:SHIFT(to state 67)]
 [term 54:SHIFT(to state 69)] [term 59:SHIFT(to state 66)]
From state #255
 [term 0:REDUCE(with prod 36)] [term 4:REDUCE(with prod 36)]
 [term 5:REDUCE(with prod 36)] [term 10:REDUCE(with prod 36)]
 [term 11:REDUCE(with prod 36)] [term 12:REDUCE(with prod 36)]
 [term 20:SHIFT(to state 63)] [term 21:SHIFT(to state 56)]
 [term 22:SHIFT(to state 60)] [term 23:SHIFT(to state 74)]
 [term 24:SHIFT(to state 73)] [term 25:SHIFT(to state 58)]
 [term 26:SHIFT(to state 57)] [term 27:SHIFT(to state 64)]
 [term 28:SHIFT(to state 65)] [term 29:SHIFT(to state 70)]
 [term 30:SHIFT(to state 59)] [term 31:SHIFT(to state 71)]
 [term 33:SHIFT(to state 55)] [term 34:SHIFT(to state 68)]
 [term 43:SHIFT(to state 72)] [term 47:SHIFT(to state 62)]
 [term 52:SHIFT(to state 61)] [term 53:SHIFT(to state 67)]
 [term 54:SHIFT(to state 69)] [term 59:SHIFT(to state 66)]
From state #256
 [term 44:SHIFT(to state 259)]
From state #257
 [term 13:SHIFT(to state 20)] [term 14:SHIFT(to state 25)]
 [term 15:SHIFT(to state 22)] [term 16:SHIFT(to state 28)]
 [term 17:SHIFT(to state 38)] [term 31:SHIFT(to state 47)]
 [term 35:SHIFT(to state 40)] [term 36:SHIFT(to state 49)]
 [term 38:SHIFT(to state 43)] [term 53:SHIFT(to state 45)]
 [term 60:SHIFT(to state 51)] [term 61:SHIFT(to state 52)]
 [term 62:SHIFT(to state 44)] [term 63:SHIFT(to state 42)]
 [term 64:SHIFT(to state 48)] [term 65:SHIFT(to state 12)]
From state #258
 [term 0:REDUCE(with prod 32)] [term 4:REDUCE(with prod 32)]
 [term 5:REDUCE(with prod 32)] [term 10:REDUCE(with prod 32)]
 [term 11:REDUCE(with prod 32)] [term 12:REDUCE(with prod 32)]
 [term 20:SHIFT(to state 63)] [term 21:SHIFT(to state 56)]
 [term 22:SHIFT(to state 60)] [term 23:SHIFT(to state 74)]
 [term 24:SHIFT(to state 73)] [term 25:SHIFT(to state 58)]
 [term 26:SHIFT(to state 57)] [term 27:SHIFT(to state 64)]
 [term 28:SHIFT(to state 65)] [term 29:SHIFT(to state 70)]
 [term 30:SHIFT(to state 59)] [term 31:SHIFT(to state 71)]
 [term 33:SHIFT(to state 55)] [term 34:SHIFT(to state 68)]
 [term 43:SHIFT(to state 72)] [term 47:SHIFT(to state 62)]
 [term 52:SHIFT(to state 61)] [term 53:SHIFT(to state 67)]
 [term 54:SHIFT(to state 69)] [term 59:SHIFT(to state 66)]
From state #259
 [term 13:SHIFT(to state 20)] [term 14:SHIFT(to state 25)]
 [term 15:SHIFT(to state 22)] [term 16:SHIFT(to state 28)]
 [term 17:SHIFT(to state 38)] [term 31:SHIFT(to state 47)]
 [term 35:SHIFT(to state 40)] [term 36:SHIFT(to state 49)]
 [term 38:SHIFT(to state 43)] [term 53:SHIFT(to state 45)]
 [term 60:SHIFT(to state 51)] [term 61:SHIFT(to state 52)]
 [term 62:SHIFT(to state 44)] [term 63:SHIFT(to state 42)]
 [term 64:SHIFT(to state 48)] [term 65:SHIFT(to state 12)]
From state #260
 [term 0:REDUCE(with prod 31)] [term 4:REDUCE(with prod 31)]
 [term 5:REDUCE(with prod 31)] [term 10:REDUCE(with prod 31)]
 [term 11:REDUCE(with prod 31)] [term 12:REDUCE(with prod 31)]
 [term 20:SHIFT(to state 63)] [term 21:SHIFT(to state 56)]
 [term 22:SHIFT(to state 60)] [term 23:SHIFT(to state 74)]
 [term 24:SHIFT(to state 73)] [term 25:SHIFT(to state 58)]
 [term 26:SHIFT(to state 57)] [term 27:SHIFT(to state 64)]
 [term 28:SHIFT(to state 65)] [term 29:SHIFT(to state 70)]
 [term 30:SHIFT(to state 59)] [term 31:SHIFT(to state 71)]
 [term 33:SHIFT(to state 55)] [term 34:SHIFT(to state 68)]
 [term 43:SHIFT(to state 72)] [term 47:SHIFT(to state 62)]
 [term 52:SHIFT(to state 61)] [term 53:SHIFT(to state 67)]
 [term 54:SHIFT(to state 69)] [term 59:SHIFT(to state 66)]
From state #261
 [term 44:SHIFT(to state 264)]
From state #262
 [term 13:SHIFT(to state 20)] [term 14:SHIFT(to state 25)]
 [term 15:SHIFT(to state 22)] [term 16:SHIFT(to state 28)]
 [term 17:SHIFT(to state 38)] [term 31:SHIFT(to state 47)]
 [term 35:SHIFT(to state 40)] [term 36:SHIFT(to state 49)]
 [term 38:SHIFT(to state 43)] [term 53:SHIFT(to state 45)]
 [term 60:SHIFT(to state 51)] [term 61:SHIFT(to state 52)]
 [term 62:SHIFT(to state 44)] [term 63:SHIFT(to state 42)]
 [term 64:SHIFT(to state 48)] [term 65:SHIFT(to state 12)]
From state #263
 [term 0:REDUCE(with prod 26)] [term 4:REDUCE(with prod 26)]
 [term 5:REDUCE(with prod 26)] [term 10:REDUCE(with prod 26)]
 [term 11:REDUCE(with prod 26)] [term 12:REDUCE(with prod 26)]
 [term 20:SHIFT(to state 63)] [term 21:SHIFT(to state 56)]
 [term 22:SHIFT(to state 60)] [term 23:SHIFT(to state 74)]
 [term 24:SHIFT(to state 73)] [term 25:SHIFT(to state 58)]
 [term 26:SHIFT(to state 57)] [term 27:SHIFT(to state 64)]
 [term 28:SHIFT(to state 65)] [term 29:SHIFT(to state 70)]
 [term 30:SHIFT(to state 59)] [term 31:SHIFT(to state 71)]
 [term 33:SHIFT(to state 55)] [term 34:SHIFT(to state 68)]
 [term 43:SHIFT(to state 72)] [term 47:SHIFT(to state 62)]
 [term 52:SHIFT(to state 61)] [term 53:SHIFT(to state 67)]
 [term 54:SHIFT(to state 69)] [term 59:SHIFT(to state 66)]
From state #264
 [term 13:SHIFT(to state 20)] [term 14:SHIFT(to state 25)]
 [term 15:SHIFT(to state 22)] [term 16:SHIFT(to state 28)]
 [term 17:SHIFT(to state 38)] [term 31:SHIFT(to state 47)]
 [term 35:SHIFT(to state 40)] [term 36:SHIFT(to state 49)]
 [term 38:SHIFT(to state 43)] [term 53:SHIFT(to state 45)]
 [term 60:SHIFT(to state 51)] [term 61:SHIFT(to state 52)]
 [term 62:SHIFT(to state 44)] [term 63:SHIFT(to state 42)]
 [term 64:SHIFT(to state 48)] [term 65:SHIFT(to state 12)]
From state #265
 [term 0:REDUCE(with prod 25)] [term 4:REDUCE(with prod 25)]
 [term 5:REDUCE(with prod 25)] [term 10:REDUCE(with prod 25)]
 [term 11:REDUCE(with prod 25)] [term 12:REDUCE(with prod 25)]
 [term 20:SHIFT(to state 63)] [term 21:SHIFT(to state 56)]
 [term 22:SHIFT(to state 60)] [term 23:SHIFT(to state 74)]
 [term 24:SHIFT(to state 73)] [term 25:SHIFT(to state 58)]
 [term 26:SHIFT(to state 57)] [term 27:SHIFT(to state 64)]
 [term 28:SHIFT(to state 65)] [term 29:SHIFT(to state 70)]
 [term 30:SHIFT(to state 59)] [term 31:SHIFT(to state 71)]
 [term 33:SHIFT(to state 55)] [term 34:SHIFT(to state 68)]
 [term 43:SHIFT(to state 72)] [term 47:SHIFT(to state 62)]
 [term 52:SHIFT(to state 61)] [term 53:SHIFT(to state 67)]
 [term 54:SHIFT(to state 69)] [term 59:SHIFT(to state 66)]
From state #266
 [term 13:SHIFT(to state 20)] [term 14:SHIFT(to state 25)]
 [term 15:SHIFT(to state 22)] [term 16:SHIFT(to state 28)]
 [term 17:SHIFT(to state 38)] [term 31:SHIFT(to state 47)]
 [term 35:SHIFT(to state 40)] [term 36:SHIFT(to state 49)]
 [term 38:SHIFT(to state 43)] [term 53:SHIFT(to state 45)]
 [term 60:SHIFT(to state 51)] [term 61:SHIFT(to state 52)]
 [term 62:SHIFT(to state 44)] [term 63:SHIFT(to state 42)]
 [term 64:SHIFT(to state 48)] [term 65:SHIFT(to state 12)]
From state #267
 [term 44:SHIFT(to state 268)]
From state #268
 [term 13:SHIFT(to state 20)] [term 14:SHIFT(to state 25)]
 [term 15:SHIFT(to state 22)] [term 16:SHIFT(to state 28)]
 [term 17:SHIFT(to state 38)] [term 31:SHIFT(to state 47)]
 [term 35:SHIFT(to state 40)] [term 36:SHIFT(to state 49)]
 [term 38:SHIFT(to state 43)] [term 53:SHIFT(to state 45)]
 [term 60:SHIFT(to state 51)] [term 61:SHIFT(to state 52)]
 [term 62:SHIFT(to state 44)] [term 63:SHIFT(to state 42)]
 [term 64:SHIFT(to state 48)] [term 65:SHIFT(to state 12)]
From state #269
 [term 0:REDUCE(with prod 29)] [term 4:REDUCE(with prod 29)]
 [term 5:REDUCE(with prod 29)] [term 10:REDUCE(with prod 29)]
 [term 11:REDUCE(with prod 29)] [term 12:REDUCE(with prod 29)]
 [term 20:SHIFT(to state 63)] [term 21:SHIFT(to state 56)]
 [term 22:SHIFT(to state 60)] [term 23:SHIFT(to state 74)]
 [term 24:SHIFT(to state 73)] [term 25:SHIFT(to state 58)]
 [term 26:SHIFT(to state 57)] [term 27:SHIFT(to state 64)]
 [term 28:SHIFT(to state 65)] [term 29:SHIFT(to state 70)]
 [term 30:SHIFT(to state 59)] [term 31:SHIFT(to state 71)]
 [term 33:SHIFT(to state 55)] [term 34:SHIFT(to state 68)]
 [term 43:SHIFT(to state 72)] [term 47:SHIFT(to state 62)]
 [term 52:SHIFT(to state 61)] [term 53:SHIFT(to state 67)]
 [term 54:SHIFT(to state 69)] [term 59:SHIFT(to state 66)]
From state #270
 [term 0:REDUCE(with prod 30)] [term 4:REDUCE(with prod 30)]
 [term 5:REDUCE(with prod 30)] [term 10:REDUCE(with prod 30)]
 [term 11:REDUCE(with prod 30)] [term 12:REDUCE(with prod 30)]
 [term 20:SHIFT(to state 63)] [term 21:SHIFT(to state 56)]
 [term 22:SHIFT(to state 60)] [term 23:SHIFT(to state 74)]
 [term 24:SHIFT(to state 73)] [term 25:SHIFT(to state 58)]
 [term 26:SHIFT(to state 57)] [term 27:SHIFT(to state 64)]
 [term 28:SHIFT(to state 65)] [term 29:SHIFT(to state 70)]
 [term 30:SHIFT(to state 59)] [term 31:SHIFT(to state 71)]
 [term 33:SHIFT(to state 55)] [term 34:SHIFT(to state 68)]
 [term 43:SHIFT(to state 72)] [term 47:SHIFT(to state 62)]
 [term 52:SHIFT(to state 61)] [term 53:SHIFT(to state 67)]
 [term 54:SHIFT(to state 69)] [term 59:SHIFT(to state 66)]
From state #271
 [term 4:REDUCE(with prod 3)] [term 5:REDUCE(with prod 3)]
 [term 51:SHIFT(to state 137)]
From state #272
 [term 4:SHIFT(to state 273)] [term 5:SHIFT(to state 8)]
From state #273
 [term 0:REDUCE(with prod 1)]
From state #274
 [term 0:REDUCE(with prod 0)]
------------------------------
-------- REDUCE_TABLE --------
From state #0
 [non term 1->state 1] [non term 2->state 3]
From state #1
From state #2
 [non term 32->state 271] [non term 33->state 26]
From state #3
 [non term 3->state 4] [non term 4->state 6] [non term 7->state 5]
 [non term 9->state 7]
From state #4
From state #5
From state #6
From state #7
From state #8
 [non term 10->state 9] [non term 32->state 10] [non term 33->state 11]
From state #9
 [non term 11->state 236]
From state #10
 [non term 5->state 176] [non term 33->state 177]
From state #11
From state #12
From state #13
 [non term 12->state 14] [non term 13->state 17] [non term 33->state 16]
From state #14
From state #15
From state #16
From state #17
From state #18
 [non term 16->state 41] [non term 18->state 169] [non term 24->state 37]
 [non term 26->state 46] [non term 30->state 54] [non term 31->state 39]
 [non term 32->state 50] [non term 33->state 26]
From state #19
 [non term 14->state 27] [non term 15->state 30] [non term 16->state 24]
 [non term 17->state 21] [non term 32->state 23] [non term 33->state 26]
From state #20
From state #21
From state #22
From state #23
From state #24
From state #25
From state #26
From state #27
From state #28
From state #29
From state #30
From state #31
 [non term 12->state 32] [non term 13->state 17] [non term 33->state 16]
From state #32
From state #33
 [non term 13->state 35] [non term 33->state 16]
From state #34
From state #35
From state #36
 [non term 16->state 41] [non term 18->state 53] [non term 24->state 37]
 [non term 26->state 46] [non term 30->state 54] [non term 31->state 39]
 [non term 32->state 50] [non term 33->state 26]
From state #37
From state #38
From state #39
From state #40
 [non term 16->state 41] [non term 18->state 162] [non term 24->state 37]
 [non term 26->state 46] [non term 30->state 54] [non term 31->state 39]
 [non term 32->state 50] [non term 33->state 26]
From state #41
From state #42
From state #43
 [non term 16->state 41] [non term 18->state 145] [non term 24->state 37]
 [non term 26->state 46] [non term 30->state 54] [non term 31->state 39]
 [non term 32->state 50] [non term 33->state 26]
From state #44
From state #45
 [non term 16->state 41] [non term 18->state 143] [non term 24->state 37]
 [non term 26->state 46] [non term 30->state 54] [non term 31->state 39]
 [non term 32->state 50] [non term 33->state 26]
From state #46
From state #47
 [non term 16->state 41] [non term 18->state 142] [non term 24->state 37]
 [non term 26->state 46] [non term 30->state 54] [non term 31->state 39]
 [non term 32->state 50] [non term 33->state 26]
From state #48
From state #49
 [non term 12->state 139] [non term 13->state 17] [non term 33->state 16]
From state #50
 [non term 23->state 136]
From state #51
From state #52
From state #53
From state #54
From state #55
 [non term 16->state 41] [non term 18->state 135] [non term 24->state 37]
 [non term 26->state 46] [non term 30->state 54] [non term 31->state 39]
 [non term 32->state 50] [non term 33->state 26]
From state #56
 [non term 16->state 41] [non term 18->state 134] [non term 24->state 37]
 [non term 26->state 46] [non term 30->state 54] [non term 31->state 39]
 [non term 32->state 50] [non term 33->state 26]
From state #57
 [non term 16->state 41] [non term 18->state 133] [non term 24->state 37]
 [non term 26->state 46] [non term 30->state 54] [non term 31->state 39]
 [non term 32->state 50] [non term 33->state 26]
From state #58
 [non term 16->state 41] [non term 18->state 132] [non term 24->state 37]
 [non term 26->state 46] [non term 30->state 54] [non term 31->state 39]
 [non term 32->state 50] [non term 33->state 26]
From state #59
 [non term 16->state 41] [non term 18->state 131] [non term 24->state 37]
 [non term 26->state 46] [non term 30->state 54] [non term 31->state 39]
 [non term 32->state 50] [non term 33->state 26]
From state #60
 [non term 16->state 41] [non term 18->state 130] [non term 24->state 37]
 [non term 26->state 46] [non term 30->state 54] [non term 31->state 39]
 [non term 32->state 50] [non term 33->state 26]
From state #61
 [non term 33->state 125]
From state #62
 [non term 33->state 113]
From state #63
 [non term 16->state 41] [non term 18->state 112] [non term 24->state 37]
 [non term 26->state 46] [non term 30->state 54] [non term 31->state 39]
 [non term 32->state 50] [non term 33->state 26]
From state #64
 [non term 16->state 41] [non term 18->state 111] [non term 24->state 37]
 [non term 26->state 46] [non term 30->state 54] [non term 31->state 39]
 [non term 32->state 50] [non term 33->state 26]
From state #65
 [non term 16->state 41] [non term 18->state 110] [non term 24->state 37]
 [non term 26->state 46] [non term 30->state 54] [non term 31->state 39]
 [non term 32->state 50] [non term 33->state 26]
From state #66
 [non term 33->state 98]
From state #67
 [non term 13->state 90] [non term 16->state 41] [non term 18->state 83]
 [non term 19->state 92] [non term 20->state 93] [non term 24->state 37]
 [non term 26->state 46] [non term 30->state 54] [non term 31->state 39]
 [non term 32->state 50] [non term 33->state 91]
From state #68
 [non term 16->state 41] [non term 18->state 89] [non term 24->state 37]
 [non term 26->state 46] [non term 30->state 54] [non term 31->state 39]
 [non term 32->state 50] [non term 33->state 26]
From state #69
 [non term 16->state 41] [non term 18->state 83] [non term 20->state 84]
 [non term 24->state 37] [non term 26->state 46] [non term 30->state 54]
 [non term 31->state 39] [non term 32->state 50] [non term 33->state 26]
From state #70
 [non term 16->state 41] [non term 18->state 82] [non term 24->state 37]
 [non term 26->state 46] [non term 30->state 54] [non term 31->state 39]
 [non term 32->state 50] [non term 33->state 26]
From state #71
 [non term 16->state 41] [non term 18->state 81] [non term 24->state 37]
 [non term 26->state 46] [non term 30->state 54] [non term 31->state 39]
 [non term 32->state 50] [non term 33->state 26]
From state #72
 [non term 33->state 77]
From state #73
 [non term 16->state 41] [non term 18->state 76] [non term 24->state 37]
 [non term 26->state 46] [non term 30->state 54] [non term 31->state 39]
 [non term 32->state 50] [non term 33->state 26]
From state #74
 [non term 16->state 41] [non term 18->state 75] [non term 24->state 37]
 [non term 26->state 46] [non term 30->state 54] [non term 31->state 39]
 [non term 32->state 50] [non term 33->state 26]
From state #75
From state #76
From state #77
 [non term 23->state 79]
From state #78
From state #79
From state #80
From state #81
From state #82
From state #83
From state #84
From state #85
 [non term 16->state 41] [non term 18->state 88] [non term 24->state 37]
 [non term 26->state 46] [non term 30->state 54] [non term 31->state 39]
 [non term 32->state 50] [non term 33->state 26]
From state #86
 [non term 23->state 87]
From state #87
From state #88
From state #89
From state #90
From state #91
From state #92
From state #93
From state #94
From state #95
 [non term 16->state 41] [non term 18->state 96] [non term 24->state 37]
 [non term 26->state 46] [non term 30->state 54] [non term 31->state 39]
 [non term 32->state 50] [non term 33->state 26]
From state #96
From state #97
From state #98
From state #99
From state #100
 [non term 13->state 101] [non term 33->state 16]
From state #101
From state #102
 [non term 13->state 106] [non term 33->state 16]
From state #103
 [non term 16->state 41] [non term 18->state 104] [non term 24->state 37]
 [non term 26->state 46] [non term 30->state 54] [non term 31->state 39]
 [non term 32->state 50] [non term 33->state 26]
From state #104
From state #105
From state #106
From state #107
 [non term 16->state 41] [non term 18->state 108] [non term 24->state 37]
 [non term 26->state 46] [non term 30->state 54] [non term 31->state 39]
 [non term 32->state 50] [non term 33->state 26]
From state #108
From state #109
From state #110
From state #111
From state #112
From state #113
From state #114
 [non term 16->state 41] [non term 18->state 119] [non term 21->state 118]
 [non term 22->state 116] [non term 24->state 37] [non term 26->state 46]
 [non term 30->state 54] [non term 31->state 39] [non term 32->state 50]
 [non term 33->state 26]
From state #115
From state #116
From state #117
From state #118
From state #119
From state #120
 [non term 16->state 41] [non term 18->state 119] [non term 22->state 122]
 [non term 24->state 37] [non term 26->state 46] [non term 30->state 54]
 [non term 31->state 39] [non term 32->state 50] [non term 33->state 26]
From state #121
From state #122
From state #123
 [non term 14->state 124] [non term 15->state 30] [non term 16->state 24]
 [non term 17->state 21] [non term 32->state 23] [non term 33->state 26]
From state #124
From state #125
From state #126
 [non term 16->state 41] [non term 18->state 119] [non term 21->state 128]
 [non term 22->state 116] [non term 24->state 37] [non term 26->state 46]
 [non term 30->state 54] [non term 31->state 39] [non term 32->state 50]
 [non term 33->state 26]
From state #127
From state #128
From state #129
From state #130
From state #131
From state #132
From state #133
From state #134
From state #135
From state #136
From state #137
 [non term 33->state 138]
From state #138
From state #139
From state #140
 [non term 16->state 41] [non term 18->state 141] [non term 24->state 37]
 [non term 26->state 46] [non term 30->state 54] [non term 31->state 39]
 [non term 32->state 50] [non term 33->state 26]
From state #141
From state #142
From state #143
From state #144
From state #145
From state #146
 [non term 16->state 41] [non term 18->state 147] [non term 24->state 37]
 [non term 26->state 46] [non term 30->state 54] [non term 31->state 39]
 [non term 32->state 50] [non term 33->state 26]
From state #147
From state #148
 [non term 16->state 41] [non term 18->state 149] [non term 24->state 37]
 [non term 26->state 46] [non term 30->state 54] [non term 31->state 39]
 [non term 32->state 50] [non term 33->state 26]
From state #149
From state #150
From state #151
 [non term 16->state 41] [non term 18->state 155] [non term 24->state 37]
 [non term 26->state 46] [non term 27->state 154] [non term 28->state 153]
 [non term 29->state 152] [non term 30->state 54] [non term 31->state 39]
 [non term 32->state 50] [non term 33->state 26]
From state #152
From state #153
From state #154
From state #155
From state #156
From state #157
 [non term 16->state 41] [non term 18->state 158] [non term 24->state 37]
 [non term 26->state 46] [non term 30->state 54] [non term 31->state 39]
 [non term 32->state 50] [non term 33->state 26]
From state #158
From state #159
 [non term 16->state 41] [non term 18->state 155] [non term 24->state 37]
 [non term 26->state 46] [non term 28->state 161] [non term 29->state 152]
 [non term 30->state 54] [non term 31->state 39] [non term 32->state 50]
 [non term 33->state 26]
From state #160
From state #161
From state #162
From state #163
 [non term 12->state 164] [non term 13->state 17] [non term 33->state 16]
From state #164
From state #165
From state #166
 [non term 14->state 167] [non term 15->state 30] [non term 16->state 24]
 [non term 17->state 21] [non term 32->state 23] [non term 33->state 26]
From state #167
From state #168
From state #169
From state #170
 [non term 14->state 171] [non term 15->state 30] [non term 16->state 24]
 [non term 17->state 21] [non term 32->state 23] [non term 33->state 26]
From state #171
From state #172
From state #173
 [non term 14->state 174] [non term 15->state 30] [non term 16->state 24]
 [non term 17->state 21] [non term 32->state 23] [non term 33->state 26]
From state #174
From state #175
 [non term 33->state 230]
From state #176
From state #177
From state #178
 [non term 33->state 189]
From state #179
 [non term 33->state 180]
From state #180
From state #181
 [non term 12->state 182] [non term 13->state 17] [non term 33->state 16]
From state #182
From state #183
From state #184
 [non term 14->state 185] [non term 15->state 30] [non term 16->state 24]
 [non term 17->state 21] [non term 32->state 23] [non term 33->state 26]
From state #185
From state #186
From state #187
 [non term 14->state 188] [non term 15->state 30] [non term 16->state 24]
 [non term 17->state 21] [non term 32->state 23] [non term 33->state 26]
From state #188
From state #189
From state #190
 [non term 16->state 41] [non term 18->state 191] [non term 24->state 37]
 [non term 26->state 46] [non term 30->state 54] [non term 31->state 39]
 [non term 32->state 50] [non term 33->state 26]
From state #191
From state #192
 [non term 16->state 41] [non term 18->state 193] [non term 24->state 37]
 [non term 26->state 46] [non term 30->state 54] [non term 31->state 39]
 [non term 32->state 50] [non term 33->state 26]
From state #193
From state #194
 [non term 14->state 195] [non term 15->state 30] [non term 16->state 24]
 [non term 17->state 21] [non term 32->state 23] [non term 33->state 26]
From state #195
 [non term 8->state 197]
From state #196
From state #197
From state #198
From state #199
 [non term 16->state 41] [non term 18->state 200] [non term 24->state 37]
 [non term 26->state 46] [non term 30->state 54] [non term 31->state 39]
 [non term 32->state 50] [non term 33->state 26]
From state #200
From state #201
From state #202
From state #203
 [non term 16->state 41] [non term 18->state 204] [non term 24->state 37]
 [non term 26->state 46] [non term 30->state 54] [non term 31->state 39]
 [non term 32->state 50] [non term 33->state 26]
From state #204
From state #205
 [non term 16->state 41] [non term 18->state 206] [non term 24->state 37]
 [non term 26->state 46] [non term 30->state 54] [non term 31->state 39]
 [non term 32->state 50] [non term 33->state 26]
From state #206
From state #207
 [non term 16->state 41] [non term 18->state 208] [non term 24->state 37]
 [non term 26->state 46] [non term 30->state 54] [non term 31->state 39]
 [non term 32->state 50] [non term 33->state 26]
From state #208
From state #209
 [non term 33->state 226]
From state #210
 [non term 6->state 218] [non term 10->state 217] [non term 13->state 221]
 [non term 32->state 219] [non term 33->state 220]
From state #211
 [non term 33->state 213]
From state #212
 [non term 16->state 41] [non term 18->state 216] [non term 24->state 37]
 [non term 26->state 46] [non term 30->state 54] [non term 31->state 39]
 [non term 32->state 50] [non term 33->state 26]
From state #213
From state #214
 [non term 16->state 41] [non term 18->state 215] [non term 24->state 37]
 [non term 26->state 46] [non term 30->state 54] [non term 31->state 39]
 [non term 32->state 50] [non term 33->state 26]
From state #215
From state #216
From state #217
From state #218
From state #219
From state #220
From state #221
From state #222
 [non term 16->state 41] [non term 18->state 223] [non term 24->state 37]
 [non term 26->state 46] [non term 30->state 54] [non term 31->state 39]
 [non term 32->state 50] [non term 33->state 26]
From state #223
From state #224
 [non term 16->state 41] [non term 18->state 225] [non term 24->state 37]
 [non term 26->state 46] [non term 30->state 54] [non term 31->state 39]
 [non term 32->state 50] [non term 33->state 26]
From state #225
From state #226
From state #227
 [non term 6->state 228] [non term 10->state 217] [non term 13->state 221]
 [non term 32->state 219] [non term 33->state 220]
From state #228
From state #229
 [non term 6->state 233] [non term 10->state 217] [non term 13->state 221]
 [non term 32->state 219] [non term 33->state 220]
From state #230
From state #231
 [non term 6->state 232] [non term 10->state 217] [non term 13->state 221]
 [non term 32->state 219] [non term 33->state 220]
From state #232
From state #233
From state #234
 [non term 33->state 267]
From state #235
 [non term 33->state 261]
From state #236
From state #237
 [non term 33->state 239]
From state #238
 [non term 16->state 41] [non term 18->state 242] [non term 24->state 37]
 [non term 26->state 46] [non term 30->state 54] [non term 31->state 39]
 [non term 32->state 50] [non term 33->state 26]
From state #239
From state #240
 [non term 16->state 41] [non term 18->state 241] [non term 24->state 37]
 [non term 26->state 46] [non term 30->state 54] [non term 31->state 39]
 [non term 32->state 50] [non term 33->state 26]
From state #241
From state #242
From state #243
 [non term 33->state 256]
From state #244
 [non term 33->state 252]
From state #245
 [non term 33->state 246]
From state #246
From state #247
 [non term 16->state 41] [non term 18->state 248] [non term 24->state 37]
 [non term 26->state 46] [non term 30->state 54] [non term 31->state 39]
 [non term 32->state 50] [non term 33->state 26]
From state #248
From state #249
 [non term 16->state 41] [non term 18->state 250] [non term 24->state 37]
 [non term 26->state 46] [non term 30->state 54] [non term 31->state 39]
 [non term 32->state 50] [non term 33->state 26]
From state #250
From state #251
 [non term 16->state 41] [non term 18->state 255] [non term 24->state 37]
 [non term 26->state 46] [non term 30->state 54] [non term 31->state 39]
 [non term 32->state 50] [non term 33->state 26]
From state #252
From state #253
 [non term 16->state 41] [non term 18->state 254] [non term 24->state 37]
 [non term 26->state 46] [non term 30->state 54] [non term 31->state 39]
 [non term 32->state 50] [non term 33->state 26]
From state #254
From state #255
From state #256
From state #257
 [non term 16->state 41] [non term 18->state 258] [non term 24->state 37]
 [non term 26->state 46] [non term 30->state 54] [non term 31->state 39]
 [non term 32->state 50] [non term 33->state 26]
From state #258
From state #259
 [non term 16->state 41] [non term 18->state 260] [non term 24->state 37]
 [non term 26->state 46] [non term 30->state 54] [non term 31->state 39]
 [non term 32->state 50] [non term 33->state 26]
From state #260
From state #261
From state #262
 [non term 16->state 41] [non term 18->state 263] [non term 24->state 37]
 [non term 26->state 46] [non term 30->state 54] [non term 31->state 39]
 [non term 32->state 50] [non term 33->state 26]
From state #263
From state #264
 [non term 16->state 41] [non term 18->state 265] [non term 24->state 37]
 [non term 26->state 46] [non term 30->state 54] [non term 31->state 39]
 [non term 32->state 50] [non term 33->state 26]
From state #265
From state #266
 [non term 16->state 41] [non term 18->state 270] [non term 24->state 37]
 [non term 26->state 46] [non term 30->state 54] [non term 31->state 39]
 [non term 32->state 50] [non term 33->state 26]
From state #267
From state #268
 [non term 16->state 41] [non term 18->state 269] [non term 24->state 37]
 [non term 26->state 46] [non term 30->state 54] [non term 31->state 39]
 [non term 32->state 50] [non term 33->state 26]
From state #269
From state #270
From state #271
 [non term 2->state 272]
From state #272
 [non term 3->state 4] [non term 4->state 6] [non term 7->state 5]
 [non term 9->state 7]
From state #273
From state #274
-----------------------------
Closing files...
------- CUP v0.10k Parser Generation Summary -------
  0 errors and 2 warnings
  66 terminals, 34 non-terminals, and 123 productions declared, 
  producing 275 unique parse states.
  1 terminal declared but not used.
  0 non-terminal declared but not used.
  0 productions never reduced.
  0 conflicts detected (0 expected).
  Code written to "Yyparse.java", and "sym.java".
---------------------------------------------------- (v0.10k)
