/**
 *
 *  Class EdocReaderAdapter$Class.java
 *
 *  Generated by KMFStudio at 09 March 2004 11:42:38
 *  Visit http://www.cs.ukc.ac.uk/kmf
 *
 */

package edoc.repository;

import java.util.*;
import java.lang.reflect.*;

import uk.ac.kent.cs.kmf.xmi.*;
import uk.ac.kent.cs.kmf.util.*;

/**
  * This class represents a reader modelImplAdapter that can be used to load XMI files into the repository
  */
public class EdocReaderAdapter$Class
	extends ReaderAdapter
	implements IReaderAdapter
{
	/** The repository */
	edoc.repository.EdocRepository rep;
	/** The log */
	ILog log;

	/** Abstract factory */
	public EdocReaderAdapter$Class(edoc.repository.EdocRepository rep, ILog log) {
		this.rep = rep;
		this.log = log;
	}

	/** 
	  * This method is called everytime a CreateObject event appears during 
	  * the XMI file parsing
	  */
	public java.lang.Object createObject(ObjectInfo info) {
		// References to other objects is the XMI framework responsability
		if (info.getIdref() != null) return null;
		// Use the repository to create object
		else {
			// Get a clean xmiName
			String objName = Naming.getCleanName(info.getXMIName());
			if (objName.equals("Collection_")) return new Vector();
			if (objName.equals("Set_")) return new HashSet();
			if (objName.equals("List_")) return new Vector();
			if (objName.equals("Boolean_")) return new Boolean(info.getLabel());
			if (objName.equals("Integer_")) return new Integer(info.getLabel());
			if (objName.equals("Double_")) return new Double(info.getLabel());
			if (objName.equals("String_")) return new String(info.getLabel());
			Object obj = rep.buildElement(objName);
			// Debug info
			if (obj == null) {
				log.reportMessage("Cannot create an instance of '"+objName+"'");
			} else {
//              log.reportMessage("Create an instance of '"+objName+"'");
			}
			return obj;
		}
	}

	/** 
	  * This method is called everytime a CreateProperty event appears
	  * during XMI parsing
	  */
	public java.lang.Object createProperty(FeatureInfo info) {
		// Get a clean xmiName
		String propertyName = Naming.getCleanName(info.getXMIName());
		if (propertyName.indexOf(".")!=-1)
			propertyName = propertyName.substring(propertyName.lastIndexOf(".")+1, propertyName.length());
		// Set the property
		if (info.getValue() == null) return propertyName;
		String message = "Create property '"+propertyName+"' into '"+info.getObject()+"' with value '"+info.getValue()+"'";
//        log.reportMessage(message);
		setPropertyValue(info.getObject(), propertyName, info.getValue());
		return null;
	}

	/** 
	  * This method is called everytime a ResolveValue event appears
	  * during XMI parsing
	  */
	public void resolveValue(java.lang.Object object, java.lang.Object property, java.lang.Object value) {
		// Set property
		String message = "Resolve property '"+property+"' from '"+object+"' to '"+value+"'";
//        log.reportMessage(message);
		setPropertyValue(object, (String)property, value);
	}

	/** 
	  * This method is called everytime a SetProperty event appears
	  * during XMI parsing
	  */
	public void setPropertyValue(Object object, String name, Object value) {
		String propertyName = name;
		if (propertyName.indexOf(".")!=-1)
			propertyName = propertyName.substring(propertyName.lastIndexOf(".")+1, propertyName.length());
		// Get the object's method corresponding to property
		// Get also return type
		String getterName = Naming.getGetter(propertyName);
		Class type = null;
		Method getterMethod = null;
		try {
			getterMethod  = object.getClass().getMethod(getterName, new Class[] {});
			type = getterMethod.getReturnType();
		} catch (Exception e) {
			log.reportMessage("Cannot find property '"+propertyName+"'");
			log.reportMessage(e.toString());
		}
		// Set the property to the specific value
		String setterName = Naming.getSetter(propertyName);
		try {
			// Get the set method
			Method setterMethod = object.getClass().getMethod(setterName, new Class[] {type});
			// Return type is Boolean
			if (type == Boolean.class) {
				setterMethod.invoke(object, new Object[]{Boolean.valueOf((String)value)});
			// Return type is Byte
			} else if (type == Byte.class) {
				setterMethod.invoke(object, new Object[]{Byte.valueOf((String)value)});
			// Return type is Character
			} else if (type == Character.class) {
				setterMethod.invoke(object, new Object[]{new Character(((String)value).charAt(0))});
			// Return type is Double
			} else if (type == Double.class) {
				setterMethod.invoke(object, new Object[]{Double.valueOf((String)value)});
			// Return type is Float
			} else if (type == Float.class) {
				setterMethod.invoke(object, new Object[]{Float.valueOf((String)value)});
			// Return type is Integer
			} else if (type == Integer.class) {
				setterMethod.invoke(object, new Object[]{Integer.valueOf((String)value)});
			// Return type is Long
			} else if (type == Long.class) {
				setterMethod.invoke(object, new Object[]{Long.valueOf((String)value)});
			// Return type is Short
			} else if (type == Short.class) {
				setterMethod.invoke(object, new Object[]{Short.valueOf((String)value)});
			// Return type is a String
			} else if (type == String.class) {
				setterMethod.invoke(object, new Object[]{new String((String)value)});
			// Return type is a StringBuffer
			} else if (type == StringBuffer.class) {
				setterMethod.invoke(object, new Object[]{new String((String)value)});
			// Collection
			} else if (Collection.class.isAssignableFrom(type)) {
				((Collection)getterMethod.invoke(object, new Object[]{})).add(value);
			// Other return type
			} else {
				setterMethod.invoke(object, new Object[]{value});
			}
		} catch (Exception e) {
			String message = "Cannot invoke mutator '"+getterName+"("+type+")'\n";
			message += "this = "+object+"\n";
			message += "argument = '"+value.getClass()+"("+value+")";
			log.reportMessage(message);
			log.reportMessage(e.toString());
		}
	}
}
